using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using Cinemachine;
using ECM2.Examples.ThirdPerson;
using JoshH.Extensions;
using KINEMATION.KAnimationCore.Runtime.Attributes;
using KINEMATION.KAnimationCore.Runtime.Core;
using KINEMATION.KAnimationCore.Runtime.Rig;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Animations;
using UnityEngine.EventSystems;
using UnityEngine.Experimental.Animations;
using UnityEngine.Playables;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.Serialization;
using UnityEngine.Splines;
using UnityEngine.UI;
using VLB;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class PreviewTerrainCreater : MonoBehaviour
{
	public float space = 10f;

	public int columns = 20;

	public GameObject targetObject;

	private GameObject tempObj;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void Create()
	{
	}
}
public class Demo : MonoBehaviour
{
	private GameObject[] animals;

	private int animalIndex;

	private List<string> animationList = new List<string>
	{
		"Attack", "Bounce", "Clicked", "Death", "Eat", "Fear", "Fly", "Hit", "Idle_A", "Idle_B",
		"Idle_C", "Jump", "Roll", "Run", "Sit", "Spin/Splash", "Swim", "Walk"
	};

	private List<string> shapekeyList = new List<string>
	{
		"Eyes_Annoyed", "Eyes_Blink", "Eyes_Cry", "Eyes_Dead", "Eyes_Excited", "Eyes_Happy", "Eyes_LookDown", "Eyes_LookIn", "Eyes_LookOut", "Eyes_LookUp",
		"Eyes_Rabid", "Eyes_Sad", "Eyes_Shrink", "Eyes_Sleep", "Eyes_Spin", "Eyes_Squint", "Eyes_Trauma", "Sweat_L", "Sweat_R", "Teardrop_L",
		"Teardrop_R"
	};

	[Space(10f)]
	private Transform animal_parent;

	private Dropdown dropdownAnimal;

	private Dropdown dropdownAnimation;

	private Dropdown dropdownShapekey;

	private void Start()
	{
		animal_parent = GameObject.Find("Animals").transform;
		Transform transform = GameObject.Find("Canvas").transform;
		dropdownAnimal = transform.Find("Animal").Find("Dropdown").GetComponent<Dropdown>();
		dropdownAnimation = transform.Find("Animation").Find("Dropdown").GetComponent<Dropdown>();
		dropdownShapekey = transform.Find("Shapekey").Find("Dropdown").GetComponent<Dropdown>();
		int childCount = animal_parent.childCount;
		animals = new GameObject[childCount];
		List<string> list = new List<string>();
		for (int i = 0; i < childCount; i++)
		{
			animals[i] = animal_parent.GetChild(i).gameObject;
			string item = animal_parent.GetChild(i).name;
			list.Add(item);
			if (i == 0)
			{
				animals[i].SetActive(value: true);
			}
			else
			{
				animals[i].SetActive(value: false);
			}
		}
		dropdownAnimal.AddOptions(list);
		dropdownAnimation.AddOptions(animationList);
		dropdownShapekey.AddOptions(shapekeyList);
		dropdownShapekey.value = 1;
		ChangeShapekey();
	}

	private void Update()
	{
		if (Input.GetKeyDown("up"))
		{
			PrevAnimal();
		}
		else if (Input.GetKeyDown("down"))
		{
			NextAnimal();
		}
		else if (Input.GetKeyDown("right") && (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)))
		{
			NextShapekey();
		}
		else if (Input.GetKeyDown("left") && (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)))
		{
			PrevShapekey();
		}
		else if (Input.GetKeyDown("right"))
		{
			NextAnimation();
		}
		else if (Input.GetKeyDown("left"))
		{
			PrevAnimation();
		}
	}

	public void NextAnimal()
	{
		if (dropdownAnimal.value >= dropdownAnimal.options.Count - 1)
		{
			dropdownAnimal.value = 0;
		}
		else
		{
			dropdownAnimal.value++;
		}
		ChangeAnimal();
	}

	public void PrevAnimal()
	{
		if (dropdownAnimal.value <= 0)
		{
			dropdownAnimal.value = dropdownAnimal.options.Count - 1;
		}
		else
		{
			dropdownAnimal.value--;
		}
		ChangeAnimal();
	}

	public void ChangeAnimal()
	{
		animals[animalIndex].SetActive(value: false);
		animals[dropdownAnimal.value].SetActive(value: true);
		animalIndex = dropdownAnimal.value;
		ChangeAnimation();
		ChangeShapekey();
	}

	public void NextAnimation()
	{
		if (dropdownAnimation.value >= dropdownAnimation.options.Count - 1)
		{
			dropdownAnimation.value = 0;
		}
		else
		{
			dropdownAnimation.value++;
		}
		ChangeAnimation();
	}

	public void PrevAnimation()
	{
		if (dropdownAnimation.value <= 0)
		{
			dropdownAnimation.value = dropdownAnimation.options.Count - 1;
		}
		else
		{
			dropdownAnimation.value--;
		}
		ChangeAnimation();
	}

	public void ChangeAnimation()
	{
		Animator component = animals[dropdownAnimal.value].GetComponent<Animator>();
		if (!(component != null))
		{
			return;
		}
		int value = dropdownAnimation.value;
		if (value == 15)
		{
			if (component.HasState(0, Animator.StringToHash("Spin")))
			{
				component.Play("Spin");
			}
			else if (component.HasState(0, Animator.StringToHash("Splash")))
			{
				component.Play("Splash");
			}
		}
		else
		{
			component.Play(dropdownAnimation.options[value].text);
		}
	}

	public void NextShapekey()
	{
		if (dropdownShapekey.value >= dropdownShapekey.options.Count - 1)
		{
			dropdownShapekey.value = 0;
		}
		else
		{
			dropdownShapekey.value++;
		}
		ChangeShapekey();
	}

	public void PrevShapekey()
	{
		if (dropdownShapekey.value <= 0)
		{
			dropdownShapekey.value = dropdownShapekey.options.Count - 1;
		}
		else
		{
			dropdownShapekey.value--;
		}
		ChangeShapekey();
	}

	public void ChangeShapekey()
	{
		Animator component = animals[dropdownAnimal.value].GetComponent<Animator>();
		if (component != null)
		{
			component.Play(dropdownShapekey.options[dropdownShapekey.value].text);
		}
	}

	public void GoToWebsite(string URL)
	{
		Application.OpenURL(URL);
	}
}
public class RotateOnScroll : MonoBehaviour
{
	public float rotationSpeed = 2000f;

	private void Update()
	{
		float axis = Input.GetAxis("Mouse ScrollWheel");
		if (axis != 0f)
		{
			float angle = axis * rotationSpeed * Time.deltaTime * 10f;
			base.transform.Rotate(Vector3.up, angle);
		}
	}
}
public class Readme : ScriptableObject
{
	[Serializable]
	public class Section
	{
		public string heading;

		public string text;

		public string linkText;

		public string url;
	}

	public Texture2D icon;

	public string title;

	public Section[] sections;

	public bool loadedLayout;
}
public static class EditorPrefsStrings
{
}
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[8754]
			{
				0, 0, 0, 1, 0, 0, 0, 55, 92, 65,
				115, 115, 101, 116, 115, 92, 65, 114, 116, 92,
				80, 102, 98, 115, 92, 84, 101, 114, 114, 97,
				105, 110, 86, 105, 115, 117, 97, 108, 92, 80,
				114, 101, 118, 105, 101, 119, 84, 101, 114, 114,
				97, 105, 110, 67, 114, 101, 97, 116, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				64, 92, 65, 115, 115, 101, 116, 115, 92, 69,
				67, 77, 50, 92, 69, 120, 97, 109, 112, 108,
				101, 115, 92, 70, 105, 114, 115, 116, 32, 80,
				101, 114, 115, 111, 110, 32, 70, 108, 121, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 73, 110, 112,
				117, 116, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 60, 92, 65, 115, 115, 101, 116, 115,
				92, 69, 67, 77, 50, 92, 69, 120, 97, 109,
				112, 108, 101, 115, 92, 70, 105, 114, 115, 116,
				32, 80, 101, 114, 115, 111, 110, 32, 70, 108,
				121, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				70, 108, 121, 65, 98, 105, 108, 105, 116, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				65, 92, 65, 115, 115, 101, 116, 115, 92, 69,
				67, 77, 50, 92, 69, 120, 97, 109, 112, 108,
				101, 115, 92, 70, 105, 114, 115, 116, 32, 80,
				101, 114, 115, 111, 110, 32, 83, 119, 105, 109,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 73, 110,
				112, 117, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 66, 92, 65, 115, 115, 101, 116,
				115, 92, 69, 67, 77, 50, 92, 69, 120, 97,
				109, 112, 108, 101, 115, 92, 70, 105, 114, 115,
				116, 32, 80, 101, 114, 115, 111, 110, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 70, 105, 114,
				115, 116, 80, 101, 114, 115, 111, 110, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 71, 92, 65,
				115, 115, 101, 116, 115, 92, 69, 67, 77, 50,
				92, 69, 120, 97, 109, 112, 108, 101, 115, 92,
				70, 105, 114, 115, 116, 32, 80, 101, 114, 115,
				111, 110, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 70, 105, 114, 115, 116, 80, 101, 114, 115,
				111, 110, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 73, 110, 112, 117, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 75, 92, 65, 115,
				115, 101, 116, 115, 92, 69, 67, 77, 50, 92,
				69, 120, 97, 109, 112, 108, 101, 115, 92, 70,
				105, 114, 115, 116, 32, 80, 101, 114, 115, 111,
				110, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				70, 105, 114, 115, 116, 80, 101, 114, 115, 111,
				110, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				76, 111, 111, 107, 73, 110, 112, 117, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 69, 67,
				77, 50, 92, 69, 120, 97, 109, 112, 108, 101,
				115, 92, 71, 108, 105, 100, 101, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 71, 108, 105, 100,
				101, 65, 98, 105, 108, 105, 116, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 55, 92,
				65, 115, 115, 101, 116, 115, 92, 69, 67, 77,
				50, 92, 69, 120, 97, 109, 112, 108, 101, 115,
				92, 71, 108, 105, 100, 101, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 80, 108, 97, 121, 101,
				114, 67, 111, 110, 116, 114, 111, 108, 108, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 52, 92, 65, 115, 115, 101, 116, 115, 92,
				69, 67, 77, 50, 92, 69, 120, 97, 109, 112,
				108, 101, 115, 92, 74, 117, 109, 112, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 73, 110, 112, 117,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 49, 92, 65, 115, 115, 101, 116, 115, 92,
				69, 67, 77, 50, 92, 69, 120, 97, 109, 112,
				108, 101, 115, 92, 74, 117, 109, 112, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 74, 117, 109,
				112, 65, 98, 105, 108, 105, 116, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 55, 92,
				65, 115, 115, 101, 116, 115, 92, 69, 67, 77,
				50, 92, 69, 120, 97, 109, 112, 108, 101, 115,
				92, 76, 97, 100, 100, 101, 114, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 73, 110, 112, 117,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 47, 92, 65, 115, 115, 101, 116, 115, 92,
				69, 67, 77, 50, 92, 69, 120, 97, 109, 112,
				108, 101, 115, 92, 76, 97, 100, 100, 101, 114,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				76, 97, 100, 100, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 59, 92, 65, 115,
				115, 101, 116, 115, 92, 69, 67, 77, 50, 92,
				69, 120, 97, 109, 112, 108, 101, 115, 92, 76,
				97, 100, 100, 101, 114, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 76, 97, 100, 100, 101,
				114, 67, 108, 105, 109, 98, 65, 98, 105, 108,
				105, 116, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 73, 92, 65, 115, 115, 101, 116,
				115, 92, 69, 67, 77, 50, 92, 69, 120, 97,
				109, 112, 108, 101, 115, 92, 79, 114, 105, 101,
				110, 116, 32, 116, 111, 32, 71, 114, 111, 117,
				110, 100, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				79, 114, 105, 101, 110, 116, 84, 111, 71, 114,
				111, 117, 110, 100, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 60, 92, 65, 115, 115, 101,
				116, 115, 92, 69, 67, 77, 50, 92, 69, 120,
				97, 109, 112, 108, 101, 115, 92, 80, 108, 97,
				110, 101, 116, 32, 87, 97, 108, 107, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 80, 108, 97,
				121, 101, 114, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 66, 92, 65, 115, 115, 101, 116, 115,
				92, 69, 67, 77, 50, 92, 69, 120, 97, 109,
				112, 108, 101, 115, 92, 80, 108, 97, 110, 101,
				116, 32, 87, 97, 108, 107, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 84, 104, 105, 114, 100,
				80, 101, 114, 115, 111, 110, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 70, 92, 65, 115,
				115, 101, 116, 115, 92, 69, 67, 77, 50, 92,
				69, 120, 97, 109, 112, 108, 101, 115, 92, 83,
				105, 100, 101, 32, 83, 99, 114, 111, 108, 108,
				105, 110, 103, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 83, 105, 100, 101, 83, 99, 114, 111,
				108, 108, 105, 110, 103, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 54, 92, 65, 115, 115, 101,
				116, 115, 92, 69, 67, 77, 50, 92, 69, 120,
				97, 109, 112, 108, 101, 115, 92, 83, 108, 105,
				100, 101, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 80, 108, 97, 121, 101, 114, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 65, 92, 65, 115,
				115, 101, 116, 115, 92, 69, 67, 77, 50, 92,
				69, 120, 97, 109, 112, 108, 101, 115, 92, 83,
				108, 111, 112, 101, 32, 83, 112, 101, 101, 100,
				32, 77, 111, 100, 105, 102, 105, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 77, 121,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 52,
				92, 65, 115, 115, 101, 116, 115, 92, 69, 67,
				77, 50, 92, 69, 120, 97, 109, 112, 108, 101,
				115, 92, 84, 101, 108, 101, 112, 111, 114, 116,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
				101, 108, 101, 112, 111, 114, 116, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 67,
				92, 65, 115, 115, 101, 116, 115, 92, 69, 67,
				77, 50, 92, 69, 120, 97, 109, 112, 108, 101,
				115, 92, 84, 104, 105, 114, 100, 32, 80, 101,
				114, 115, 111, 110, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 84, 104, 105, 114, 100, 80, 101,
				114, 115, 111, 110, 67, 111, 110, 116, 114, 111,
				108, 108, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 89, 92, 65, 115, 115, 101,
				116, 115, 92, 69, 67, 77, 50, 92, 69, 120,
				97, 109, 112, 108, 101, 115, 92, 84, 111, 103,
				103, 108, 101, 32, 71, 114, 97, 118, 105, 116,
				121, 32, 68, 105, 114, 101, 99, 116, 105, 111,
				110, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				84, 111, 103, 103, 108, 101, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 71, 114, 97, 118, 105,
				116, 121, 68, 105, 114, 101, 99, 116, 105, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 71, 92, 65, 115, 115, 101, 116, 115, 92,
				69, 67, 77, 50, 92, 69, 120, 97, 109, 112,
				108, 101, 115, 92, 84, 119, 105, 110, 45, 83,
				116, 105, 99, 107, 32, 77, 111, 118, 101, 109,
				101, 110, 116, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 84, 119, 105, 110, 83, 116, 105, 99,
				107, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				52, 92, 65, 115, 115, 101, 116, 115, 92, 69,
				67, 77, 50, 92, 83, 104, 97, 114, 101, 100,
				32, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 73, 110, 112, 117, 116,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				52, 92, 65, 115, 115, 101, 116, 115, 92, 69,
				67, 77, 50, 92, 83, 104, 97, 114, 101, 100,
				32, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 80, 97, 117, 115, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				60, 92, 65, 115, 115, 101, 116, 115, 92, 69,
				67, 77, 50, 92, 83, 104, 97, 114, 101, 100,
				32, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 105, 109, 112,
				108, 101, 67, 97, 109, 101, 114, 97, 67, 111,
				110, 116, 114, 111, 108, 108, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 102, 92,
				65, 115, 115, 101, 116, 115, 92, 69, 67, 77,
				50, 92, 87, 97, 108, 107, 116, 104, 114, 111,
				117, 103, 104, 92, 50, 32, 45, 32, 67, 111,
				110, 116, 114, 111, 108, 108, 105, 110, 103, 32,
				97, 32, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 92, 50, 46, 49, 32, 45, 32, 67, 117,
				115, 116, 111, 109, 32, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 80, 108, 97, 121, 101, 114, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 107, 92,
				65, 115, 115, 101, 116, 115, 92, 69, 67, 77,
				50, 92, 87, 97, 108, 107, 116, 104, 114, 111,
				117, 103, 104, 92, 50, 32, 45, 32, 67, 111,
				110, 116, 114, 111, 108, 108, 105, 110, 103, 32,
				97, 32, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 92, 50, 46, 50, 32, 45, 32, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 32, 67, 111,
				110, 116, 114, 111, 108, 108, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 80, 108, 97,
				121, 101, 114, 67, 111, 110, 116, 114, 111, 108,
				108, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 108, 92, 65, 115, 115, 101, 116,
				115, 92, 69, 67, 77, 50, 92, 87, 97, 108,
				107, 116, 104, 114, 111, 117, 103, 104, 92, 51,
				32, 45, 32, 65, 110, 105, 109, 97, 116, 105,
				110, 103, 32, 97, 32, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 92, 51, 46, 49, 32, 45,
				32, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				32, 67, 111, 110, 116, 114, 111, 108, 108, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 110, 105, 109, 97, 116, 105, 111, 110, 67,
				111, 110, 116, 114, 111, 108, 108, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 105,
				92, 65, 115, 115, 101, 116, 115, 92, 69, 67,
				77, 50, 92, 87, 97, 108, 107, 116, 104, 114,
				111, 117, 103, 104, 92, 51, 32, 45, 32, 65,
				110, 105, 109, 97, 116, 105, 110, 103, 32, 97,
				32, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				92, 51, 46, 49, 32, 45, 32, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 32, 67, 111, 110,
				116, 114, 111, 108, 108, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 80, 108, 97, 121,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 108,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 103, 92, 65, 115, 115, 101, 116, 115,
				92, 69, 67, 77, 50, 92, 87, 97, 108, 107,
				116, 104, 114, 111, 117, 103, 104, 92, 51, 32,
				45, 32, 65, 110, 105, 109, 97, 116, 105, 110,
				103, 32, 97, 32, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 92, 51, 46, 51, 32, 45, 32,
				82, 111, 111, 116, 32, 77, 111, 116, 105, 111,
				110, 32, 84, 111, 103, 103, 108, 101, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 82, 111, 111,
				116, 77, 111, 116, 105, 111, 110, 84, 111, 103,
				103, 108, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 104, 92, 65, 115, 115, 101, 116,
				115, 92, 69, 67, 77, 50, 92, 87, 97, 108,
				107, 116, 104, 114, 111, 117, 103, 104, 92, 52,
				32, 45, 32, 69, 120, 116, 101, 110, 100, 105,
				110, 103, 32, 97, 32, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 92, 52, 46, 49, 32, 45,
				32, 67, 117, 115, 116, 111, 109, 32, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 112, 114, 105,
				110, 116, 97, 98, 108, 101, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 105, 92, 65, 115, 115,
				101, 116, 115, 92, 69, 67, 77, 50, 92, 87,
				97, 108, 107, 116, 104, 114, 111, 117, 103, 104,
				92, 52, 32, 45, 32, 69, 120, 116, 101, 110,
				100, 105, 110, 103, 32, 97, 32, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 92, 52, 46, 50,
				32, 45, 32, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 32, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 80, 108, 97, 121, 101, 114, 67, 111,
				110, 116, 114, 111, 108, 108, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 102, 92,
				65, 115, 115, 101, 116, 115, 92, 69, 67, 77,
				50, 92, 87, 97, 108, 107, 116, 104, 114, 111,
				117, 103, 104, 92, 52, 32, 45, 32, 69, 120,
				116, 101, 110, 100, 105, 110, 103, 32, 97, 32,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 92,
				52, 46, 50, 32, 45, 32, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 32, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 83, 112, 114, 105, 110,
				116, 65, 98, 105, 108, 105, 116, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 105, 92,
				65, 115, 115, 101, 116, 115, 92, 69, 67, 77,
				50, 92, 87, 97, 108, 107, 116, 104, 114, 111,
				117, 103, 104, 92, 52, 32, 45, 32, 69, 120,
				116, 101, 110, 100, 105, 110, 103, 32, 97, 32,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 92,
				52, 46, 51, 32, 45, 32, 67, 117, 115, 116,
				111, 109, 32, 77, 111, 118, 101, 109, 101, 110,
				116, 32, 77, 111, 100, 101, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 68, 97, 115, 104, 105,
				110, 103, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 105, 92, 65, 115, 115, 101, 116, 115, 92,
				69, 67, 77, 50, 92, 87, 97, 108, 107, 116,
				104, 114, 111, 117, 103, 104, 92, 52, 32, 45,
				32, 69, 120, 116, 101, 110, 100, 105, 110, 103,
				32, 97, 32, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 92, 52, 46, 51, 32, 45, 32, 67,
				117, 115, 116, 111, 109, 32, 77, 111, 118, 101,
				109, 101, 110, 116, 32, 77, 111, 100, 101, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 80, 108,
				97, 121, 101, 114, 67, 111, 110, 116, 114, 111,
				108, 108, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 109, 92, 65, 115, 115, 101,
				116, 115, 92, 69, 67, 77, 50, 92, 87, 97,
				108, 107, 116, 104, 114, 111, 117, 103, 104, 92,
				53, 32, 45, 32, 67, 111, 108, 108, 105, 115,
				105, 111, 110, 32, 68, 101, 116, 101, 99, 116,
				105, 111, 110, 32, 97, 110, 100, 32, 69, 118,
				101, 110, 116, 115, 92, 53, 46, 49, 32, 45,
				32, 67, 117, 115, 116, 111, 109, 32, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 80, 108, 97, 121,
				101, 114, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 117, 92, 65, 115, 115, 101, 116, 115, 92,
				69, 67, 77, 50, 92, 87, 97, 108, 107, 116,
				104, 114, 111, 117, 103, 104, 92, 53, 32, 45,
				32, 67, 111, 108, 108, 105, 115, 105, 111, 110,
				32, 68, 101, 116, 101, 99, 116, 105, 111, 110,
				32, 97, 110, 100, 32, 69, 118, 101, 110, 116,
				115, 92, 53, 46, 50, 32, 45, 32, 76, 105,
				115, 116, 101, 110, 32, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 32, 69, 118, 101, 110, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				80, 108, 97, 121, 101, 114, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 68, 92, 65, 115,
				115, 101, 116, 115, 92, 69, 67, 77, 50, 92,
				87, 97, 108, 107, 116, 104, 114, 111, 117, 103,
				104, 92, 54, 32, 45, 32, 80, 104, 121, 115,
				105, 99, 115, 92, 54, 46, 49, 32, 45, 32,
				70, 111, 114, 99, 101, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 66, 111, 117, 110, 99,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 70, 92, 65, 115, 115, 101, 116, 115,
				92, 69, 67, 77, 50, 92, 87, 97, 108, 107,
				116, 104, 114, 111, 117, 103, 104, 92, 54, 32,
				45, 32, 80, 104, 121, 115, 105, 99, 115, 92,
				54, 46, 49, 32, 45, 32, 70, 111, 114, 99,
				101, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 70, 111, 114, 99, 101, 90, 111, 110, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				92, 92, 65, 115, 115, 101, 116, 115, 92, 69,
				67, 77, 50, 92, 87, 97, 108, 107, 116, 104,
				114, 111, 117, 103, 104, 92, 54, 32, 45, 32,
				80, 104, 121, 115, 105, 99, 115, 92, 54, 46,
				50, 32, 45, 32, 80, 104, 121, 115, 105, 99,
				115, 32, 73, 110, 116, 101, 114, 97, 99, 116,
				105, 111, 110, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 112, 112, 108, 121, 76, 97,
				110, 100, 105, 110, 103, 70, 111, 114, 99, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				88, 92, 65, 115, 115, 101, 116, 115, 92, 69,
				67, 77, 50, 92, 87, 97, 108, 107, 116, 104,
				114, 111, 117, 103, 104, 92, 55, 32, 45, 32,
				80, 108, 97, 116, 102, 111, 114, 109, 115, 92,
				55, 46, 49, 32, 45, 32, 83, 99, 114, 105,
				112, 116, 101, 100, 32, 80, 108, 97, 116, 102,
				111, 114, 109, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 75, 105, 110, 101, 109, 97, 116,
				105, 99, 77, 111, 118, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 90, 92, 65, 115,
				115, 101, 116, 115, 92, 69, 67, 77, 50, 92,
				87, 97, 108, 107, 116, 104, 114, 111, 117, 103,
				104, 92, 55, 32, 45, 32, 80, 108, 97, 116,
				102, 111, 114, 109, 115, 92, 55, 46, 49, 32,
				45, 32, 83, 99, 114, 105, 112, 116, 101, 100,
				32, 80, 108, 97, 116, 102, 111, 114, 109, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 75,
				105, 110, 101, 109, 97, 116, 105, 99, 82, 111,
				116, 97, 116, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 88, 92, 65, 115, 115, 101,
				116, 115, 92, 69, 67, 77, 50, 92, 87, 97,
				108, 107, 116, 104, 114, 111, 117, 103, 104, 92,
				55, 32, 45, 32, 80, 108, 97, 116, 102, 111,
				114, 109, 115, 92, 55, 46, 52, 32, 45, 32,
				79, 110, 101, 45, 87, 97, 121, 32, 80, 108,
				97, 116, 102, 111, 114, 109, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 79, 110, 101, 87,
				97, 121, 80, 108, 97, 116, 102, 111, 114, 109,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				73, 92, 65, 115, 115, 101, 116, 115, 92, 69,
				67, 77, 50, 92, 87, 97, 108, 107, 116, 104,
				114, 111, 117, 103, 104, 92, 55, 32, 45, 32,
				80, 108, 97, 116, 102, 111, 114, 109, 115, 92,
				83, 104, 97, 114, 101, 100, 32, 83, 99, 114,
				105, 112, 116, 115, 92, 80, 108, 97, 121, 101,
				114, 67, 111, 110, 116, 114, 111, 108, 108, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 85, 92, 65, 115, 115, 101, 116, 115, 92,
				69, 67, 77, 50, 92, 87, 97, 108, 107, 116,
				104, 114, 111, 117, 103, 104, 92, 56, 32, 45,
				32, 65, 73, 32, 78, 97, 118, 105, 103, 97,
				116, 105, 111, 110, 92, 56, 46, 49, 32, 45,
				32, 67, 108, 105, 99, 107, 32, 84, 111, 32,
				77, 111, 118, 101, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 108, 105, 99, 107, 84, 111,
				77, 111, 118, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 113, 92, 65, 115, 115, 101,
				116, 115, 92, 69, 67, 77, 50, 92, 87, 97,
				108, 107, 116, 104, 114, 111, 117, 103, 104, 92,
				57, 32, 45, 32, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 92, 57, 46, 49, 32,
				45, 32, 70, 105, 114, 115, 116, 32, 80, 101,
				114, 115, 111, 110, 32, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 32, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 70, 105, 114, 115, 116, 80,
				101, 114, 115, 111, 110, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 111, 92, 65, 115, 115,
				101, 116, 115, 92, 69, 67, 77, 50, 92, 87,
				97, 108, 107, 116, 104, 114, 111, 117, 103, 104,
				92, 57, 32, 45, 32, 67, 105, 110, 101, 109,
				97, 99, 104, 105, 110, 101, 92, 57, 46, 50,
				32, 45, 32, 84, 104, 105, 114, 100, 32, 80,
				101, 114, 115, 111, 110, 32, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 32, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 67, 111, 110, 116, 114, 111,
				108, 108, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 113, 92, 65, 115, 115, 101,
				116, 115, 92, 69, 67, 77, 50, 92, 87, 97,
				108, 107, 116, 104, 114, 111, 117, 103, 104, 92,
				57, 32, 45, 32, 67, 105, 110, 101, 109, 97,
				99, 104, 105, 110, 101, 92, 57, 46, 50, 32,
				45, 32, 84, 104, 105, 114, 100, 32, 80, 101,
				114, 115, 111, 110, 32, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 32, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 84, 104, 105, 114, 100, 80,
				101, 114, 115, 111, 110, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 49, 92, 65, 115, 115,
				101, 116, 115, 92, 70, 111, 103, 79, 102, 87,
				97, 114, 92, 68, 101, 109, 111, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 66, 108, 105, 110,
				107, 105, 110, 103, 82, 101, 118, 101, 97, 108,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 49, 92, 65, 115, 115, 101, 116, 115,
				92, 70, 111, 103, 79, 102, 87, 97, 114, 92,
				68, 101, 109, 111, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 70, 111, 119, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 68, 101, 109, 111, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 42,
				92, 65, 115, 115, 101, 116, 115, 92, 70, 111,
				103, 79, 102, 87, 97, 114, 92, 68, 101, 109,
				111, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				84, 101, 97, 109, 115, 68, 101, 109, 111, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 72, 97,
				114, 100, 32, 83, 108, 97, 115, 104, 101, 115,
				32, 86, 111, 108, 49, 92, 68, 101, 109, 111,
				32, 83, 99, 101, 110, 101, 92, 68, 101, 109,
				111, 77, 97, 110, 97, 103, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 41, 92,
				65, 115, 115, 101, 116, 115, 92, 72, 97, 114,
				100, 32, 83, 108, 97, 115, 104, 101, 115, 32,
				86, 111, 108, 49, 92, 83, 101, 108, 102, 68,
				101, 115, 116, 114, 117, 99, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 56, 92, 65,
				115, 115, 101, 116, 115, 92, 75, 73, 78, 69,
				77, 65, 84, 73, 79, 78, 92, 77, 97, 103,
				105, 99, 66, 108, 101, 110, 100, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 77, 97, 103, 105,
				99, 66, 108, 101, 110, 100, 65, 115, 115, 101,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 54, 92, 65, 115, 115, 101, 116, 115, 92,
				75, 73, 78, 69, 77, 65, 84, 73, 79, 78,
				92, 77, 97, 103, 105, 99, 66, 108, 101, 110,
				100, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				77, 97, 103, 105, 99, 66, 108, 101, 110, 100,
				105, 110, 103, 46, 99, 115, 0, 0, 0, 3,
				0, 0, 0, 55, 92, 65, 115, 115, 101, 116,
				115, 92, 75, 73, 78, 69, 77, 65, 84, 73,
				79, 78, 92, 77, 97, 103, 105, 99, 66, 108,
				101, 110, 100, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 77, 97, 103, 105, 99, 66, 108, 101,
				110, 100, 74, 111, 98, 115, 46, 99, 115, 0,
				0, 0, 4, 0, 0, 0, 58, 92, 65, 115,
				115, 101, 116, 115, 92, 75, 73, 78, 69, 77,
				65, 84, 73, 79, 78, 92, 77, 97, 103, 105,
				99, 66, 108, 101, 110, 100, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 77, 97, 103, 105, 99,
				66, 108, 101, 110, 100, 76, 105, 98, 114, 97,
				114, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 56, 92, 65, 115, 115, 101, 116, 115,
				92, 75, 73, 78, 69, 77, 65, 84, 73, 79,
				78, 92, 77, 97, 103, 105, 99, 66, 108, 101,
				110, 100, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 77, 97, 103, 105, 99, 66, 108, 101, 110,
				100, 83, 116, 97, 116, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 60, 92, 65, 115,
				115, 101, 116, 115, 92, 81, 117, 105, 114, 107,
				121, 32, 83, 101, 114, 105, 101, 115, 32, 85,
				108, 116, 105, 109, 97, 116, 101, 92, 66, 105,
				114, 100, 115, 32, 66, 117, 110, 100, 108, 101,
				92, 95, 83, 99, 114, 105, 112, 116, 115, 92,
				68, 101, 109, 111, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 70, 92, 65, 115, 115, 101,
				116, 115, 92, 81, 117, 105, 114, 107, 121, 32,
				83, 101, 114, 105, 101, 115, 32, 85, 108, 116,
				105, 109, 97, 116, 101, 92, 66, 105, 114, 100,
				115, 32, 66, 117, 110, 100, 108, 101, 92, 95,
				83, 99, 114, 105, 112, 116, 115, 92, 82, 111,
				116, 97, 116, 101, 79, 110, 83, 99, 114, 111,
				108, 108, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 38, 92, 65, 115, 115, 101, 116, 115,
				92, 84, 117, 116, 111, 114, 105, 97, 108, 73,
				110, 102, 111, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 82, 101, 97, 100, 109, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 73, 92,
				65, 115, 115, 101, 116, 115, 92, 85, 73, 32,
				83, 112, 108, 105, 110, 101, 32, 82, 101, 110,
				100, 101, 114, 101, 114, 92, 69, 120, 97, 109,
				112, 108, 101, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 68, 114, 97, 103, 103, 97, 98, 108,
				101, 83, 112, 108, 105, 110, 101, 80, 111, 105,
				110, 116, 69, 120, 97, 109, 112, 108, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 61,
				92, 65, 115, 115, 101, 116, 115, 92, 85, 73,
				32, 83, 112, 108, 105, 110, 101, 32, 82, 101,
				110, 100, 101, 114, 101, 114, 92, 69, 120, 97,
				109, 112, 108, 101, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 114, 97, 103, 80, 111, 114,
				116, 69, 120, 97, 109, 112, 108, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 69, 92,
				65, 115, 115, 101, 116, 115, 92, 85, 73, 32,
				83, 112, 108, 105, 110, 101, 32, 82, 101, 110,
				100, 101, 114, 101, 114, 92, 69, 120, 97, 109,
				112, 108, 101, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 83, 112, 108, 105, 110, 101,
				82, 101, 110, 100, 101, 114, 101, 114, 69, 120,
				97, 109, 112, 108, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 40, 92, 65, 115, 115,
				101, 116, 115, 92, 85, 73, 71, 114, 97, 100,
				105, 101, 110, 116, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 71, 114, 97, 100, 105,
				101, 110, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 46, 92, 65, 115, 115, 101, 116,
				115, 92, 85, 73, 71, 114, 97, 100, 105, 101,
				110, 116, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 86, 101, 99, 116, 111, 114, 50, 69, 120,
				116, 101, 110, 115, 105, 111, 110, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 73, 92, 65,
				115, 115, 101, 116, 115, 92, 86, 111, 108, 117,
				109, 101, 116, 114, 105, 99, 76, 105, 103, 104,
				116, 66, 101, 97, 109, 92, 83, 97, 109, 112,
				108, 101, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 67, 97, 109, 101, 114, 97, 84, 111,
				103, 103, 108, 101, 66, 101, 97, 109, 86, 105,
				115, 105, 98, 105, 108, 105, 116, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 64, 92,
				65, 115, 115, 101, 116, 115, 92, 86, 111, 108,
				117, 109, 101, 116, 114, 105, 99, 76, 105, 103,
				104, 116, 66, 101, 97, 109, 92, 83, 97, 109,
				112, 108, 101, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 101, 99, 107, 73, 102,
				73, 110, 115, 105, 100, 101, 66, 101, 97, 109,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				74, 92, 65, 115, 115, 101, 116, 115, 92, 86,
				111, 108, 117, 109, 101, 116, 114, 105, 99, 76,
				105, 103, 104, 116, 66, 101, 97, 109, 92, 83,
				97, 109, 112, 108, 101, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 70, 101, 97, 116, 117,
				114, 101, 115, 78, 111, 116, 83, 117, 112, 112,
				111, 114, 116, 101, 100, 77, 101, 115, 115, 97,
				103, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 67, 92, 65, 115, 115, 101, 116, 115,
				92, 86, 111, 108, 117, 109, 101, 116, 114, 105,
				99, 76, 105, 103, 104, 116, 66, 101, 97, 109,
				92, 83, 97, 109, 112, 108, 101, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 70, 114, 101,
				101, 67, 97, 109, 101, 114, 97, 67, 111, 110,
				116, 114, 111, 108, 108, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 61, 92, 65,
				115, 115, 101, 116, 115, 92, 86, 111, 108, 117,
				109, 101, 116, 114, 105, 99, 76, 105, 103, 104,
				116, 66, 101, 97, 109, 92, 83, 97, 109, 112,
				108, 101, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 76, 105, 103, 104, 116, 71, 101, 110,
				101, 114, 97, 116, 111, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 54, 92, 65, 115,
				115, 101, 116, 115, 92, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 92, 83, 97, 109, 112, 108,
				101, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 82, 111, 116, 97, 116, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
				65, 115, 115, 101, 116, 115, 92, 86, 111, 108,
				117, 109, 101, 116, 114, 105, 99, 76, 105, 103,
				104, 116, 66, 101, 97, 109, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 66, 97, 116, 99, 104,
				105, 110, 103, 72, 101, 108, 112, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 63,
				92, 65, 115, 115, 101, 116, 115, 92, 86, 111,
				108, 117, 109, 101, 116, 114, 105, 99, 76, 105,
				103, 104, 116, 66, 101, 97, 109, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 66, 101, 97, 109,
				71, 101, 111, 109, 101, 116, 114, 121, 65, 98,
				115, 116, 114, 97, 99, 116, 66, 97, 115, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				45, 92, 65, 115, 115, 101, 116, 115, 92, 86,
				111, 108, 117, 109, 101, 116, 114, 105, 99, 76,
				105, 103, 104, 116, 66, 101, 97, 109, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 111, 110,
				102, 105, 103, 46, 99, 115, 0, 0, 0, 15,
				0, 0, 0, 45, 92, 65, 115, 115, 101, 116,
				115, 92, 86, 111, 108, 117, 109, 101, 116, 114,
				105, 99, 76, 105, 103, 104, 116, 66, 101, 97,
				109, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				67, 111, 110, 115, 116, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 52, 92, 65, 115,
				115, 101, 116, 115, 92, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 117, 109, 109, 121, 77, 97,
				116, 101, 114, 105, 97, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 57, 92, 65, 115,
				115, 101, 116, 115, 92, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 100, 105, 116, 111, 114, 80,
				114, 101, 102, 115, 83, 116, 114, 105, 110, 103,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 57, 92, 65, 115, 115, 101, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 102,
				102, 101, 99, 116, 65, 98, 115, 116, 114, 97,
				99, 116, 66, 97, 115, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 52, 92, 65, 115,
				115, 101, 116, 115, 92, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 102, 102, 101, 99, 116, 70,
				108, 105, 99, 107, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 56, 92, 65, 115,
				115, 101, 116, 115, 92, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 102, 102, 101, 99, 116, 70,
				114, 111, 109, 80, 114, 111, 102, 105, 108, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				50, 92, 65, 115, 115, 101, 116, 115, 92, 86,
				111, 108, 117, 109, 101, 116, 114, 105, 99, 76,
				105, 103, 104, 116, 66, 101, 97, 109, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 69, 102, 102,
				101, 99, 116, 80, 117, 108, 115, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 56, 92,
				65, 115, 115, 101, 116, 115, 92, 86, 111, 108,
				117, 109, 101, 116, 114, 105, 99, 76, 105, 103,
				104, 116, 66, 101, 97, 109, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 72, 68, 92, 66, 101,
				97, 109, 71, 101, 111, 109, 101, 116, 114, 121,
				72, 68, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 54, 92, 65, 115, 115, 101, 116, 115,
				92, 86, 111, 108, 117, 109, 101, 116, 114, 105,
				99, 76, 105, 103, 104, 116, 66, 101, 97, 109,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 72,
				68, 92, 71, 108, 111, 98, 97, 108, 77, 101,
				115, 104, 72, 68, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 60, 92, 65, 115, 115, 101,
				116, 115, 92, 86, 111, 108, 117, 109, 101, 116,
				114, 105, 99, 76, 105, 103, 104, 116, 66, 101,
				97, 109, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 72, 68, 92, 82, 97, 121, 109, 97, 114,
				99, 104, 105, 110, 103, 81, 117, 97, 108, 105,
				116, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 71, 92, 65, 115, 115, 101, 116, 115,
				92, 86, 111, 108, 117, 109, 101, 116, 114, 105,
				99, 76, 105, 103, 104, 116, 66, 101, 97, 109,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 72,
				68, 92, 84, 114, 97, 99, 107, 82, 101, 97,
				108, 116, 105, 109, 101, 67, 104, 97, 110, 103,
				101, 115, 79, 110, 76, 105, 103, 104, 116, 72,
				68, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 60, 92, 65, 115, 115, 101, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 72, 68,
				92, 86, 111, 108, 117, 109, 101, 116, 114, 105,
				99, 67, 111, 111, 107, 105, 101, 72, 68, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 63,
				92, 65, 115, 115, 101, 116, 115, 92, 86, 111,
				108, 117, 109, 101, 116, 114, 105, 99, 76, 105,
				103, 104, 116, 66, 101, 97, 109, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 72, 68, 92, 86,
				111, 108, 117, 109, 101, 116, 114, 105, 99, 76,
				105, 103, 104, 116, 66, 101, 97, 109, 72, 68,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				65, 92, 65, 115, 115, 101, 116, 115, 92, 86,
				111, 108, 117, 109, 101, 116, 114, 105, 99, 76,
				105, 103, 104, 116, 66, 101, 97, 109, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 72, 68, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 72,
				68, 50, 68, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 60, 92, 65, 115, 115, 101, 116,
				115, 92, 86, 111, 108, 117, 109, 101, 116, 114,
				105, 99, 76, 105, 103, 104, 116, 66, 101, 97,
				109, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				72, 68, 92, 86, 111, 108, 117, 109, 101, 116,
				114, 105, 99, 83, 104, 97, 100, 111, 119, 72,
				68, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 61, 92, 65, 115, 115, 101, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 72, 105,
				103, 104, 108, 105, 103, 104, 116, 78, 117, 108,
				108, 65, 116, 116, 114, 105, 98, 117, 116, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				51, 92, 65, 115, 115, 101, 116, 115, 92, 86,
				111, 108, 117, 109, 101, 116, 114, 105, 99, 76,
				105, 103, 104, 116, 66, 101, 97, 109, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 76, 79, 68,
				66, 101, 97, 109, 71, 114, 111, 117, 112, 46,
				99, 115, 0, 0, 0, 7, 0, 0, 0, 54,
				92, 65, 115, 115, 101, 116, 115, 92, 86, 111,
				108, 117, 109, 101, 116, 114, 105, 99, 76, 105,
				103, 104, 116, 66, 101, 97, 109, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 77, 97, 116, 101,
				114, 105, 97, 108, 77, 97, 110, 97, 103, 101,
				114, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 55, 92, 65, 115, 115, 101, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 77, 97,
				116, 101, 114, 105, 97, 108, 77, 111, 100, 105,
				102, 105, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 52, 92, 65, 115, 115, 101,
				116, 115, 92, 86, 111, 108, 117, 109, 101, 116,
				114, 105, 99, 76, 105, 103, 104, 116, 66, 101,
				97, 109, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 77, 101, 115, 104, 71, 101, 110, 101, 114,
				97, 116, 111, 114, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 55, 92, 65, 115, 115, 101,
				116, 115, 92, 86, 111, 108, 117, 109, 101, 116,
				114, 105, 99, 76, 105, 103, 104, 116, 66, 101,
				97, 109, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 77, 105, 110, 77, 97, 120, 82, 97, 110,
				103, 101, 70, 108, 111, 97, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 46, 92, 65,
				115, 115, 101, 116, 115, 92, 86, 111, 108, 117,
				109, 101, 116, 114, 105, 99, 76, 105, 103, 104,
				116, 66, 101, 97, 109, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 78, 111, 105, 115, 101, 51,
				68, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 53, 92, 65, 115, 115, 101, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 80, 108,
				97, 116, 102, 111, 114, 109, 72, 101, 108, 112,
				101, 114, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 52, 92, 65, 115, 115, 101, 116, 115,
				92, 86, 111, 108, 117, 109, 101, 116, 114, 105,
				99, 76, 105, 103, 104, 116, 66, 101, 97, 109,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 80,
				111, 108, 121, 103, 111, 110, 72, 101, 108, 112,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 56, 92, 65, 115, 115, 101, 116, 115,
				92, 86, 111, 108, 117, 109, 101, 116, 114, 105,
				99, 76, 105, 103, 104, 116, 66, 101, 97, 109,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				68, 92, 66, 101, 97, 109, 71, 101, 111, 109,
				101, 116, 114, 121, 83, 68, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 70, 92, 65, 115,
				115, 101, 116, 115, 92, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 83, 68, 92, 68, 121, 110, 97,
				109, 105, 99, 79, 99, 99, 108, 117, 115, 105,
				111, 110, 65, 98, 115, 116, 114, 97, 99, 116,
				66, 97, 115, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 69, 92, 65, 115, 115, 101,
				116, 115, 92, 86, 111, 108, 117, 109, 101, 116,
				114, 105, 99, 76, 105, 103, 104, 116, 66, 101,
				97, 109, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 83, 68, 92, 68, 121, 110, 97, 109, 105,
				99, 79, 99, 99, 108, 117, 115, 105, 111, 110,
				68, 101, 112, 116, 104, 66, 117, 102, 102, 101,
				114, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 68, 92, 65, 115, 115, 101, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 68,
				92, 68, 121, 110, 97, 109, 105, 99, 79, 99,
				99, 108, 117, 115, 105, 111, 110, 82, 97, 121,
				99, 97, 115, 116, 105, 110, 103, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 54, 92, 65,
				115, 115, 101, 116, 115, 92, 86, 111, 108, 117,
				109, 101, 116, 114, 105, 99, 76, 105, 103, 104,
				116, 66, 101, 97, 109, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 83, 68, 92, 71, 108, 111,
				98, 97, 108, 77, 101, 115, 104, 83, 68, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 57,
				92, 65, 115, 115, 101, 116, 115, 92, 86, 111,
				108, 117, 109, 101, 116, 114, 105, 99, 76, 105,
				103, 104, 116, 66, 101, 97, 109, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 68, 92, 83,
				107, 101, 119, 105, 110, 103, 72, 97, 110, 100,
				108, 101, 83, 68, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 63, 92, 65, 115, 115, 101,
				116, 115, 92, 86, 111, 108, 117, 109, 101, 116,
				114, 105, 99, 76, 105, 103, 104, 116, 66, 101,
				97, 109, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 83, 68, 92, 86, 111, 108, 117, 109, 101,
				116, 114, 105, 99, 76, 105, 103, 104, 116, 66,
				101, 97, 109, 83, 68, 46, 99, 115, 0, 0,
				0, 3, 0, 0, 0, 53, 92, 65, 115, 115,
				101, 116, 115, 92, 86, 111, 108, 117, 109, 101,
				116, 114, 105, 99, 76, 105, 103, 104, 116, 66,
				101, 97, 109, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 83, 104, 97, 100, 101, 114, 75, 101,
				121, 119, 111, 114, 100, 115, 46, 99, 115, 0,
				0, 0, 3, 0, 0, 0, 55, 92, 65, 115,
				115, 101, 116, 115, 92, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 83, 104, 97, 100, 101, 114, 80,
				114, 111, 112, 101, 114, 116, 105, 101, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 54,
				92, 65, 115, 115, 101, 116, 115, 92, 86, 111,
				108, 117, 109, 101, 116, 114, 105, 99, 76, 105,
				103, 104, 116, 66, 101, 97, 109, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 112, 111, 116,
				76, 105, 103, 104, 116, 72, 101, 108, 112, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 48, 92, 65, 115, 115, 101, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 82,
				80, 72, 101, 108, 112, 101, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 53, 92, 65,
				115, 115, 101, 116, 115, 92, 86, 111, 108, 117,
				109, 101, 116, 114, 105, 99, 76, 105, 103, 104,
				116, 66, 101, 97, 109, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 84, 114, 97, 110, 115, 102,
				111, 114, 109, 85, 116, 105, 108, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 50, 92,
				65, 115, 115, 101, 116, 115, 92, 86, 111, 108,
				117, 109, 101, 116, 114, 105, 99, 76, 105, 103,
				104, 116, 66, 101, 97, 109, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 84, 114, 105, 103, 103,
				101, 114, 90, 111, 110, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 44, 92, 65, 115,
				115, 101, 116, 115, 92, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 116, 105, 108, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
				65, 115, 115, 101, 116, 115, 92, 86, 111, 108,
				117, 109, 101, 116, 114, 105, 99, 76, 105, 103,
				104, 116, 66, 101, 97, 109, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 116, 105, 108, 115,
				66, 101, 97, 109, 80, 114, 111, 112, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 46,
				92, 65, 115, 115, 101, 116, 115, 92, 86, 111,
				108, 117, 109, 101, 116, 114, 105, 99, 76, 105,
				103, 104, 116, 66, 101, 97, 109, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 86, 101, 114, 115,
				105, 111, 110, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 62, 92, 65, 115, 115, 101, 116,
				115, 92, 86, 111, 108, 117, 109, 101, 116, 114,
				105, 99, 76, 105, 103, 104, 116, 66, 101, 97,
				109, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				68, 117, 115, 116, 80, 97, 114, 116, 105, 99,
				108, 101, 115, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 70, 92, 65, 115, 115, 101, 116,
				115, 92, 86, 111, 108, 117, 109, 101, 116, 114,
				105, 99, 76, 105, 103, 104, 116, 66, 101, 97,
				109, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				86, 111, 108, 117, 109, 101, 116, 114, 105, 99,
				76, 105, 103, 104, 116, 66, 101, 97, 109, 65,
				98, 115, 116, 114, 97, 99, 116, 66, 97, 115,
				101, 46, 99, 115
			},
			TypesData = new byte[5266]
			{
				0, 0, 0, 0, 22, 124, 80, 114, 101, 118,
				105, 101, 119, 84, 101, 114, 114, 97, 105, 110,
				67, 114, 101, 97, 116, 101, 114, 0, 0, 0,
				0, 43, 69, 67, 77, 50, 46, 69, 120, 97,
				109, 112, 108, 101, 115, 46, 70, 105, 114, 115,
				116, 80, 101, 114, 115, 111, 110, 70, 108, 121,
				124, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				73, 110, 112, 117, 116, 0, 0, 0, 0, 39,
				69, 67, 77, 50, 46, 69, 120, 97, 109, 112,
				108, 101, 115, 46, 70, 105, 114, 115, 116, 80,
				101, 114, 115, 111, 110, 70, 108, 121, 124, 70,
				108, 121, 65, 98, 105, 108, 105, 116, 121, 0,
				0, 0, 0, 44, 69, 67, 77, 50, 46, 69,
				120, 97, 109, 112, 108, 101, 115, 46, 70, 105,
				114, 115, 116, 80, 101, 114, 115, 111, 110, 83,
				119, 105, 109, 124, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 73, 110, 112, 117, 116, 0, 0,
				0, 0, 46, 69, 67, 77, 50, 46, 69, 120,
				97, 109, 112, 108, 101, 115, 46, 70, 105, 114,
				115, 116, 80, 101, 114, 115, 111, 110, 124, 70,
				105, 114, 115, 116, 80, 101, 114, 115, 111, 110,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 0,
				0, 0, 0, 51, 69, 67, 77, 50, 46, 69,
				120, 97, 109, 112, 108, 101, 115, 46, 70, 105,
				114, 115, 116, 80, 101, 114, 115, 111, 110, 124,
				70, 105, 114, 115, 116, 80, 101, 114, 115, 111,
				110, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				73, 110, 112, 117, 116, 0, 0, 0, 0, 55,
				69, 67, 77, 50, 46, 69, 120, 97, 109, 112,
				108, 101, 115, 46, 70, 105, 114, 115, 116, 80,
				101, 114, 115, 111, 110, 124, 70, 105, 114, 115,
				116, 80, 101, 114, 115, 111, 110, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 76, 111, 111, 107,
				73, 110, 112, 117, 116, 0, 0, 0, 0, 32,
				69, 67, 77, 50, 46, 69, 120, 97, 109, 112,
				108, 101, 115, 46, 71, 108, 105, 100, 101, 124,
				71, 108, 105, 100, 101, 65, 98, 105, 108, 105,
				116, 121, 0, 0, 0, 0, 36, 69, 67, 77,
				50, 46, 69, 120, 97, 109, 112, 108, 101, 115,
				46, 71, 108, 105, 100, 101, 124, 80, 108, 97,
				121, 101, 114, 67, 111, 110, 116, 114, 111, 108,
				108, 101, 114, 0, 0, 0, 0, 33, 69, 67,
				77, 50, 46, 69, 120, 97, 109, 112, 108, 101,
				115, 46, 74, 117, 109, 112, 124, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 73, 110, 112, 117,
				116, 0, 0, 0, 0, 30, 69, 67, 77, 50,
				46, 69, 120, 97, 109, 112, 108, 101, 115, 46,
				74, 117, 109, 112, 124, 74, 117, 109, 112, 65,
				98, 105, 108, 105, 116, 121, 0, 0, 0, 0,
				36, 69, 67, 77, 50, 46, 69, 120, 97, 109,
				112, 108, 101, 115, 46, 76, 97, 100, 100, 101,
				114, 115, 124, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 73, 110, 112, 117, 116, 0, 0, 0,
				0, 28, 69, 67, 77, 50, 46, 69, 120, 97,
				109, 112, 108, 101, 115, 46, 76, 97, 100, 100,
				101, 114, 115, 124, 76, 97, 100, 100, 101, 114,
				0, 0, 0, 0, 40, 69, 67, 77, 50, 46,
				69, 120, 97, 109, 112, 108, 101, 115, 46, 76,
				97, 100, 100, 101, 114, 115, 124, 76, 97, 100,
				100, 101, 114, 67, 108, 105, 109, 98, 65, 98,
				105, 108, 105, 116, 121, 0, 0, 0, 0, 52,
				69, 67, 77, 50, 46, 69, 120, 97, 109, 112,
				108, 101, 115, 46, 79, 114, 105, 101, 110, 116,
				84, 111, 71, 114, 111, 117, 110, 100, 124, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 79, 114,
				105, 101, 110, 116, 84, 111, 71, 114, 111, 117,
				110, 100, 0, 0, 0, 0, 40, 69, 67, 77,
				50, 46, 69, 120, 97, 109, 112, 108, 101, 115,
				46, 80, 108, 97, 110, 101, 116, 87, 97, 108,
				107, 124, 80, 108, 97, 121, 101, 114, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 0, 0, 0,
				0, 46, 69, 67, 77, 50, 46, 69, 120, 97,
				109, 112, 108, 101, 115, 46, 80, 108, 97, 110,
				101, 116, 87, 97, 108, 107, 124, 84, 104, 105,
				114, 100, 80, 101, 114, 115, 111, 110, 67, 111,
				110, 116, 114, 111, 108, 108, 101, 114, 0, 0,
				0, 0, 50, 69, 67, 77, 50, 46, 69, 120,
				97, 109, 112, 108, 101, 115, 46, 83, 105, 100,
				101, 83, 99, 114, 111, 108, 108, 105, 110, 103,
				124, 83, 105, 100, 101, 83, 99, 114, 111, 108,
				108, 105, 110, 103, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 0, 0, 0, 0, 35, 69, 67,
				77, 50, 46, 69, 120, 97, 109, 112, 108, 101,
				115, 46, 83, 108, 105, 100, 101, 124, 80, 108,
				97, 121, 101, 114, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 0, 0, 0, 0, 44, 69, 67,
				77, 50, 46, 69, 120, 97, 109, 112, 108, 101,
				115, 46, 83, 108, 111, 112, 101, 83, 112, 101,
				101, 100, 77, 111, 100, 105, 102, 105, 101, 114,
				124, 77, 121, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 0, 0, 0, 0, 33, 69, 67, 77,
				50, 46, 69, 120, 97, 109, 112, 108, 101, 115,
				46, 84, 101, 108, 101, 112, 111, 114, 116, 124,
				84, 101, 108, 101, 112, 111, 114, 116, 101, 114,
				0, 0, 0, 0, 47, 69, 67, 77, 50, 46,
				69, 120, 97, 109, 112, 108, 101, 115, 46, 84,
				104, 105, 114, 100, 80, 101, 114, 115, 111, 110,
				124, 84, 104, 105, 114, 100, 80, 101, 114, 115,
				111, 110, 67, 111, 110, 116, 114, 111, 108, 108,
				101, 114, 0, 0, 0, 0, 68, 69, 67, 77,
				50, 46, 69, 120, 97, 109, 112, 108, 101, 115,
				46, 84, 111, 103, 103, 108, 101, 71, 114, 97,
				118, 105, 116, 121, 68, 105, 114, 101, 99, 116,
				105, 111, 110, 124, 84, 111, 103, 103, 108, 101,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 71,
				114, 97, 118, 105, 116, 121, 68, 105, 114, 101,
				99, 116, 105, 111, 110, 0, 0, 0, 0, 50,
				69, 67, 77, 50, 46, 69, 120, 97, 109, 112,
				108, 101, 115, 46, 84, 119, 105, 110, 83, 116,
				105, 99, 107, 77, 111, 118, 101, 109, 101, 110,
				116, 124, 84, 119, 105, 110, 83, 116, 105, 99,
				107, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				0, 0, 0, 0, 28, 69, 67, 77, 50, 46,
				69, 120, 97, 109, 112, 108, 101, 115, 124, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 73, 110,
				112, 117, 116, 0, 0, 0, 0, 28, 69, 67,
				77, 50, 46, 69, 120, 97, 109, 112, 108, 101,
				115, 124, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 80, 97, 117, 115, 101, 0, 0, 0, 0,
				36, 69, 67, 77, 50, 46, 69, 120, 97, 109,
				112, 108, 101, 115, 124, 83, 105, 109, 112, 108,
				101, 67, 97, 109, 101, 114, 97, 67, 111, 110,
				116, 114, 111, 108, 108, 101, 114, 0, 0, 0,
				0, 37, 69, 67, 77, 50, 46, 87, 97, 108,
				107, 116, 104, 114, 111, 117, 103, 104, 46, 69,
				120, 50, 49, 124, 80, 108, 97, 121, 101, 114,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 0,
				0, 0, 0, 38, 69, 67, 77, 50, 46, 87,
				97, 108, 107, 116, 104, 114, 111, 117, 103, 104,
				46, 69, 120, 50, 50, 124, 80, 108, 97, 121,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 108,
				101, 114, 0, 0, 0, 0, 41, 69, 67, 77,
				50, 46, 87, 97, 108, 107, 116, 104, 114, 111,
				117, 103, 104, 46, 69, 120, 51, 49, 124, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 67, 111,
				110, 116, 114, 111, 108, 108, 101, 114, 0, 0,
				0, 0, 38, 69, 67, 77, 50, 46, 87, 97,
				108, 107, 116, 104, 114, 111, 117, 103, 104, 46,
				69, 120, 51, 49, 124, 80, 108, 97, 121, 101,
				114, 67, 111, 110, 116, 114, 111, 108, 108, 101,
				114, 0, 0, 0, 0, 38, 69, 67, 77, 50,
				46, 87, 97, 108, 107, 116, 104, 114, 111, 117,
				103, 104, 46, 69, 120, 51, 51, 124, 82, 111,
				111, 116, 77, 111, 116, 105, 111, 110, 84, 111,
				103, 103, 108, 101, 0, 0, 0, 0, 41, 69,
				67, 77, 50, 46, 87, 97, 108, 107, 116, 104,
				114, 111, 117, 103, 104, 46, 69, 120, 52, 49,
				124, 83, 112, 114, 105, 110, 116, 97, 98, 108,
				101, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				0, 0, 0, 0, 38, 69, 67, 77, 50, 46,
				87, 97, 108, 107, 116, 104, 114, 111, 117, 103,
				104, 46, 69, 120, 52, 50, 124, 80, 108, 97,
				121, 101, 114, 67, 111, 110, 116, 114, 111, 108,
				108, 101, 114, 0, 0, 0, 0, 35, 69, 67,
				77, 50, 46, 87, 97, 108, 107, 116, 104, 114,
				111, 117, 103, 104, 46, 69, 120, 52, 50, 124,
				83, 112, 114, 105, 110, 116, 65, 98, 105, 108,
				105, 116, 121, 0, 0, 0, 0, 38, 69, 67,
				77, 50, 46, 87, 97, 108, 107, 116, 104, 114,
				111, 117, 103, 104, 46, 69, 120, 52, 51, 124,
				68, 97, 115, 104, 105, 110, 103, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 0, 0, 0, 0,
				38, 69, 67, 77, 50, 46, 87, 97, 108, 107,
				116, 104, 114, 111, 117, 103, 104, 46, 69, 120,
				52, 51, 124, 80, 108, 97, 121, 101, 114, 67,
				111, 110, 116, 114, 111, 108, 108, 101, 114, 0,
				0, 0, 0, 37, 69, 67, 77, 50, 46, 87,
				97, 108, 107, 116, 104, 114, 111, 117, 103, 104,
				46, 69, 120, 53, 49, 124, 80, 108, 97, 121,
				101, 114, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 0, 0, 0, 0, 38, 69, 67, 77, 50,
				46, 87, 97, 108, 107, 116, 104, 114, 111, 117,
				103, 104, 46, 69, 120, 53, 50, 124, 80, 108,
				97, 121, 101, 114, 67, 111, 110, 116, 114, 111,
				108, 108, 101, 114, 0, 0, 0, 0, 29, 69,
				67, 77, 50, 46, 87, 97, 108, 107, 116, 104,
				114, 111, 117, 103, 104, 46, 69, 120, 54, 49,
				124, 66, 111, 117, 110, 99, 101, 114, 0, 0,
				0, 0, 31, 69, 67, 77, 50, 46, 87, 97,
				108, 107, 116, 104, 114, 111, 117, 103, 104, 46,
				69, 120, 54, 49, 124, 70, 111, 114, 99, 101,
				90, 111, 110, 101, 0, 0, 0, 0, 39, 69,
				67, 77, 50, 46, 87, 97, 108, 107, 116, 104,
				114, 111, 117, 103, 104, 46, 69, 120, 54, 50,
				124, 65, 112, 112, 108, 121, 76, 97, 110, 100,
				105, 110, 103, 70, 111, 114, 99, 101, 0, 0,
				0, 0, 35, 69, 67, 77, 50, 46, 87, 97,
				108, 107, 116, 104, 114, 111, 117, 103, 104, 46,
				69, 120, 55, 49, 124, 75, 105, 110, 101, 109,
				97, 116, 105, 99, 77, 111, 118, 101, 0, 0,
				0, 0, 37, 69, 67, 77, 50, 46, 87, 97,
				108, 107, 116, 104, 114, 111, 117, 103, 104, 46,
				69, 120, 55, 49, 124, 75, 105, 110, 101, 109,
				97, 116, 105, 99, 82, 111, 116, 97, 116, 101,
				0, 0, 0, 0, 36, 69, 67, 77, 50, 46,
				87, 97, 108, 107, 116, 104, 114, 111, 117, 103,
				104, 46, 69, 88, 55, 52, 124, 79, 110, 101,
				87, 97, 121, 80, 108, 97, 116, 102, 111, 114,
				109, 0, 0, 0, 0, 37, 69, 67, 77, 50,
				46, 87, 97, 108, 107, 116, 104, 114, 111, 117,
				103, 104, 46, 69, 120, 55, 124, 80, 108, 97,
				121, 101, 114, 67, 111, 110, 116, 114, 111, 108,
				108, 101, 114, 0, 0, 0, 0, 33, 69, 67,
				77, 50, 46, 87, 97, 108, 107, 116, 104, 114,
				111, 117, 103, 104, 46, 69, 120, 56, 49, 124,
				67, 108, 105, 99, 107, 84, 111, 77, 111, 118,
				101, 0, 0, 0, 0, 43, 69, 67, 77, 50,
				46, 87, 97, 108, 107, 116, 104, 114, 111, 117,
				103, 104, 46, 69, 120, 57, 49, 124, 70, 105,
				114, 115, 116, 80, 101, 114, 115, 111, 110, 67,
				111, 110, 116, 114, 111, 108, 108, 101, 114, 0,
				0, 0, 0, 41, 69, 67, 77, 50, 46, 87,
				97, 108, 107, 116, 104, 114, 111, 117, 103, 104,
				46, 69, 120, 57, 50, 124, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 0, 0, 0, 0, 43,
				69, 67, 77, 50, 46, 87, 97, 108, 107, 116,
				104, 114, 111, 117, 103, 104, 46, 69, 120, 57,
				50, 124, 84, 104, 105, 114, 100, 80, 101, 114,
				115, 111, 110, 67, 111, 110, 116, 114, 111, 108,
				108, 101, 114, 0, 0, 0, 0, 26, 70, 79,
				87, 46, 68, 101, 109, 111, 115, 124, 66, 108,
				105, 110, 107, 105, 110, 103, 82, 101, 118, 101,
				97, 108, 101, 114, 0, 0, 0, 0, 26, 70,
				79, 87, 46, 68, 101, 109, 111, 115, 124, 70,
				111, 119, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 68, 101, 109, 111, 0, 0, 0, 0, 19,
				70, 79, 87, 46, 68, 101, 109, 111, 115, 124,
				84, 101, 97, 109, 115, 68, 101, 109, 111, 0,
				0, 0, 0, 23, 72, 97, 114, 100, 83, 108,
				97, 115, 104, 101, 115, 124, 68, 101, 109, 111,
				77, 97, 110, 97, 103, 101, 114, 0, 0, 0,
				0, 24, 72, 97, 114, 100, 83, 108, 97, 115,
				104, 101, 115, 124, 83, 101, 108, 102, 68, 101,
				115, 116, 114, 117, 99, 116, 0, 0, 0, 0,
				45, 75, 73, 78, 69, 77, 65, 84, 73, 79,
				78, 46, 77, 97, 103, 105, 99, 66, 108, 101,
				110, 100, 46, 82, 117, 110, 116, 105, 109, 101,
				124, 77, 97, 103, 105, 99, 66, 108, 101, 110,
				100, 65, 115, 115, 101, 116, 0, 0, 0, 0,
				43, 75, 73, 78, 69, 77, 65, 84, 73, 79,
				78, 46, 77, 97, 103, 105, 99, 66, 108, 101,
				110, 100, 46, 82, 117, 110, 116, 105, 109, 101,
				124, 77, 97, 103, 105, 99, 66, 108, 101, 110,
				100, 105, 110, 103, 0, 0, 0, 0, 37, 75,
				73, 78, 69, 77, 65, 84, 73, 79, 78, 46,
				77, 97, 103, 105, 99, 66, 108, 101, 110, 100,
				46, 82, 117, 110, 116, 105, 109, 101, 124, 80,
				111, 115, 101, 74, 111, 98, 0, 0, 0, 0,
				40, 75, 73, 78, 69, 77, 65, 84, 73, 79,
				78, 46, 77, 97, 103, 105, 99, 66, 108, 101,
				110, 100, 46, 82, 117, 110, 116, 105, 109, 101,
				124, 79, 118, 101, 114, 108, 97, 121, 74, 111,
				98, 0, 0, 0, 0, 41, 75, 73, 78, 69,
				77, 65, 84, 73, 79, 78, 46, 77, 97, 103,
				105, 99, 66, 108, 101, 110, 100, 46, 82, 117,
				110, 116, 105, 109, 101, 124, 76, 97, 121, 101,
				114, 105, 110, 103, 74, 111, 98, 0, 0, 0,
				0, 38, 75, 73, 78, 69, 77, 65, 84, 73,
				79, 78, 46, 77, 97, 103, 105, 99, 66, 108,
				101, 110, 100, 46, 82, 117, 110, 116, 105, 109,
				101, 124, 65, 116, 111, 109, 80, 111, 115, 101,
				0, 0, 0, 0, 45, 75, 73, 78, 69, 77,
				65, 84, 73, 79, 78, 46, 77, 97, 103, 105,
				99, 66, 108, 101, 110, 100, 46, 82, 117, 110,
				116, 105, 109, 101, 124, 66, 108, 101, 110, 100,
				83, 116, 114, 101, 97, 109, 65, 116, 111, 109,
				0, 0, 0, 0, 42, 75, 73, 78, 69, 77,
				65, 84, 73, 79, 78, 46, 77, 97, 103, 105,
				99, 66, 108, 101, 110, 100, 46, 82, 117, 110,
				116, 105, 109, 101, 124, 76, 97, 121, 101, 114,
				101, 100, 66, 108, 101, 110, 100, 0, 0, 0,
				0, 47, 75, 73, 78, 69, 77, 65, 84, 73,
				79, 78, 46, 77, 97, 103, 105, 99, 66, 108,
				101, 110, 100, 46, 82, 117, 110, 116, 105, 109,
				101, 124, 77, 97, 103, 105, 99, 66, 108, 101,
				110, 100, 76, 105, 98, 114, 97, 114, 121, 0,
				0, 0, 0, 45, 75, 73, 78, 69, 77, 65,
				84, 73, 79, 78, 46, 77, 97, 103, 105, 99,
				66, 108, 101, 110, 100, 46, 82, 117, 110, 116,
				105, 109, 101, 124, 77, 97, 103, 105, 99, 66,
				108, 101, 110, 100, 83, 116, 97, 116, 101, 0,
				0, 0, 0, 5, 124, 68, 101, 109, 111, 0,
				0, 0, 0, 15, 124, 82, 111, 116, 97, 116,
				101, 79, 110, 83, 99, 114, 111, 108, 108, 0,
				0, 0, 0, 7, 124, 82, 101, 97, 100, 109,
				101, 0, 0, 0, 0, 14, 82, 101, 97, 100,
				109, 101, 124, 83, 101, 99, 116, 105, 111, 110,
				0, 0, 0, 0, 54, 85, 73, 95, 83, 112,
				108, 105, 110, 101, 95, 82, 101, 110, 100, 101,
				114, 101, 114, 46, 69, 120, 97, 109, 112, 108,
				101, 124, 68, 114, 97, 103, 103, 97, 98, 108,
				101, 83, 112, 108, 105, 110, 101, 80, 111, 105,
				110, 116, 69, 120, 97, 109, 112, 108, 101, 0,
				0, 0, 0, 42, 85, 73, 95, 83, 112, 108,
				105, 110, 101, 95, 82, 101, 110, 100, 101, 114,
				101, 114, 46, 69, 120, 97, 109, 112, 108, 101,
				124, 68, 114, 97, 103, 80, 111, 114, 116, 69,
				120, 97, 109, 112, 108, 101, 0, 0, 0, 0,
				50, 85, 73, 95, 83, 112, 108, 105, 110, 101,
				95, 82, 101, 110, 100, 101, 114, 101, 114, 46,
				69, 120, 97, 109, 112, 108, 101, 124, 85, 73,
				83, 112, 108, 105, 110, 101, 82, 101, 110, 100,
				101, 114, 101, 114, 69, 120, 97, 109, 112, 108,
				101, 0, 0, 0, 0, 19, 74, 111, 115, 104,
				72, 46, 85, 73, 124, 85, 73, 71, 114, 97,
				100, 105, 101, 110, 116, 0, 0, 0, 0, 33,
				74, 111, 115, 104, 72, 46, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 124, 86, 101, 99,
				116, 111, 114, 50, 69, 120, 116, 101, 110, 115,
				105, 111, 110, 0, 0, 0, 0, 38, 86, 76,
				66, 95, 83, 97, 109, 112, 108, 101, 115, 124,
				67, 97, 109, 101, 114, 97, 84, 111, 103, 103,
				108, 101, 66, 101, 97, 109, 86, 105, 115, 105,
				98, 105, 108, 105, 116, 121, 0, 0, 0, 0,
				29, 86, 76, 66, 95, 83, 97, 109, 112, 108,
				101, 115, 124, 67, 104, 101, 99, 107, 73, 102,
				73, 110, 115, 105, 100, 101, 66, 101, 97, 109,
				0, 0, 0, 0, 39, 86, 76, 66, 95, 83,
				97, 109, 112, 108, 101, 115, 124, 70, 101, 97,
				116, 117, 114, 101, 115, 78, 111, 116, 83, 117,
				112, 112, 111, 114, 116, 101, 100, 77, 101, 115,
				115, 97, 103, 101, 0, 0, 0, 0, 32, 86,
				76, 66, 95, 83, 97, 109, 112, 108, 101, 115,
				124, 70, 114, 101, 101, 67, 97, 109, 101, 114,
				97, 67, 111, 110, 116, 114, 111, 108, 108, 101,
				114, 0, 0, 0, 0, 26, 86, 76, 66, 95,
				83, 97, 109, 112, 108, 101, 115, 124, 76, 105,
				103, 104, 116, 71, 101, 110, 101, 114, 97, 116,
				111, 114, 0, 0, 0, 0, 19, 86, 76, 66,
				95, 83, 97, 109, 112, 108, 101, 115, 124, 82,
				111, 116, 97, 116, 101, 114, 0, 0, 0, 0,
				18, 86, 76, 66, 124, 66, 97, 116, 99, 104,
				105, 110, 103, 72, 101, 108, 112, 101, 114, 0,
				0, 0, 0, 28, 86, 76, 66, 124, 66, 101,
				97, 109, 71, 101, 111, 109, 101, 116, 114, 121,
				65, 98, 115, 116, 114, 97, 99, 116, 66, 97,
				115, 101, 0, 0, 0, 0, 10, 86, 76, 66,
				124, 67, 111, 110, 102, 105, 103, 0, 0, 0,
				0, 10, 86, 76, 66, 124, 67, 111, 110, 115,
				116, 115, 0, 0, 0, 0, 15, 86, 76, 66,
				46, 67, 111, 110, 115, 116, 115, 124, 72, 101,
				108, 112, 0, 0, 0, 0, 18, 86, 76, 66,
				46, 67, 111, 110, 115, 116, 115, 43, 72, 101,
				108, 112, 124, 83, 68, 0, 0, 0, 0, 18,
				86, 76, 66, 46, 67, 111, 110, 115, 116, 115,
				43, 72, 101, 108, 112, 124, 72, 68, 0, 0,
				0, 0, 19, 86, 76, 66, 46, 67, 111, 110,
				115, 116, 115, 124, 73, 110, 116, 101, 114, 110,
				97, 108, 0, 0, 0, 0, 15, 86, 76, 66,
				46, 67, 111, 110, 115, 116, 115, 124, 66, 101,
				97, 109, 0, 0, 0, 0, 18, 86, 76, 66,
				46, 67, 111, 110, 115, 116, 115, 43, 66, 101,
				97, 109, 124, 83, 68, 0, 0, 0, 0, 18,
				86, 76, 66, 46, 67, 111, 110, 115, 116, 115,
				43, 66, 101, 97, 109, 124, 72, 68, 0, 0,
				0, 0, 24, 86, 76, 66, 46, 67, 111, 110,
				115, 116, 115, 124, 68, 117, 115, 116, 80, 97,
				114, 116, 105, 99, 108, 101, 115, 0, 0, 0,
				0, 23, 86, 76, 66, 46, 67, 111, 110, 115,
				116, 115, 124, 68, 121, 110, 79, 99, 99, 108,
				117, 115, 105, 111, 110, 0, 0, 0, 0, 18,
				86, 76, 66, 46, 67, 111, 110, 115, 116, 115,
				124, 69, 102, 102, 101, 99, 116, 115, 0, 0,
				0, 0, 17, 86, 76, 66, 46, 67, 111, 110,
				115, 116, 115, 124, 83, 104, 97, 100, 111, 119,
				0, 0, 0, 0, 17, 86, 76, 66, 46, 67,
				111, 110, 115, 116, 115, 124, 67, 111, 111, 107,
				105, 101, 0, 0, 0, 0, 17, 86, 76, 66,
				46, 67, 111, 110, 115, 116, 115, 124, 67, 111,
				110, 102, 105, 103, 0, 0, 0, 0, 20, 86,
				76, 66, 46, 67, 111, 110, 115, 116, 115, 43,
				67, 111, 110, 102, 105, 103, 124, 72, 68, 0,
				0, 0, 0, 17, 86, 76, 66, 124, 68, 117,
				109, 109, 121, 77, 97, 116, 101, 114, 105, 97,
				108, 0, 0, 0, 0, 19, 124, 69, 100, 105,
				116, 111, 114, 80, 114, 101, 102, 115, 83, 116,
				114, 105, 110, 103, 115, 0, 0, 0, 0, 22,
				86, 76, 66, 124, 69, 102, 102, 101, 99, 116,
				65, 98, 115, 116, 114, 97, 99, 116, 66, 97,
				115, 101, 0, 0, 0, 0, 17, 86, 76, 66,
				124, 69, 102, 102, 101, 99, 116, 70, 108, 105,
				99, 107, 101, 114, 0, 0, 0, 0, 21, 86,
				76, 66, 124, 69, 102, 102, 101, 99, 116, 70,
				114, 111, 109, 80, 114, 111, 102, 105, 108, 101,
				0, 0, 0, 0, 15, 86, 76, 66, 124, 69,
				102, 102, 101, 99, 116, 80, 117, 108, 115, 101,
				0, 0, 0, 0, 18, 86, 76, 66, 124, 66,
				101, 97, 109, 71, 101, 111, 109, 101, 116, 114,
				121, 72, 68, 0, 0, 0, 0, 16, 86, 76,
				66, 124, 71, 108, 111, 98, 97, 108, 77, 101,
				115, 104, 72, 68, 0, 0, 0, 0, 22, 86,
				76, 66, 124, 82, 97, 121, 109, 97, 114, 99,
				104, 105, 110, 103, 81, 117, 97, 108, 105, 116,
				121, 0, 0, 0, 0, 33, 86, 76, 66, 124,
				84, 114, 97, 99, 107, 82, 101, 97, 108, 116,
				105, 109, 101, 67, 104, 97, 110, 103, 101, 115,
				79, 110, 76, 105, 103, 104, 116, 72, 68, 0,
				0, 0, 0, 22, 86, 76, 66, 124, 86, 111,
				108, 117, 109, 101, 116, 114, 105, 99, 67, 111,
				111, 107, 105, 101, 72, 68, 0, 0, 0, 0,
				25, 86, 76, 66, 124, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 72, 68, 0, 0, 0, 0,
				27, 86, 76, 66, 124, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 72, 68, 50, 68, 0, 0,
				0, 0, 22, 86, 76, 66, 124, 86, 111, 108,
				117, 109, 101, 116, 114, 105, 99, 83, 104, 97,
				100, 111, 119, 72, 68, 0, 0, 0, 0, 26,
				86, 76, 66, 124, 72, 105, 103, 104, 108, 105,
				103, 104, 116, 78, 117, 108, 108, 65, 116, 116,
				114, 105, 98, 117, 116, 101, 0, 0, 0, 0,
				16, 86, 76, 66, 124, 76, 79, 68, 66, 101,
				97, 109, 71, 114, 111, 117, 112, 0, 0, 0,
				0, 19, 86, 76, 66, 124, 77, 97, 116, 101,
				114, 105, 97, 108, 77, 97, 110, 97, 103, 101,
				114, 0, 0, 0, 0, 22, 86, 76, 66, 46,
				77, 97, 116, 101, 114, 105, 97, 108, 77, 97,
				110, 97, 103, 101, 114, 124, 83, 68, 0, 0,
				0, 0, 22, 86, 76, 66, 46, 77, 97, 116,
				101, 114, 105, 97, 108, 77, 97, 110, 97, 103,
				101, 114, 124, 72, 68, 0, 0, 0, 0, 37,
				86, 76, 66, 46, 77, 97, 116, 101, 114, 105,
				97, 108, 77, 97, 110, 97, 103, 101, 114, 124,
				73, 83, 116, 97, 116, 105, 99, 80, 114, 111,
				112, 101, 114, 116, 105, 101, 115, 0, 0, 0,
				0, 38, 86, 76, 66, 46, 77, 97, 116, 101,
				114, 105, 97, 108, 77, 97, 110, 97, 103, 101,
				114, 124, 83, 116, 97, 116, 105, 99, 80, 114,
				111, 112, 101, 114, 116, 105, 101, 115, 83, 68,
				0, 0, 0, 0, 38, 86, 76, 66, 46, 77,
				97, 116, 101, 114, 105, 97, 108, 77, 97, 110,
				97, 103, 101, 114, 124, 83, 116, 97, 116, 105,
				99, 80, 114, 111, 112, 101, 114, 116, 105, 101,
				115, 72, 68, 0, 0, 0, 0, 34, 86, 76,
				66, 46, 77, 97, 116, 101, 114, 105, 97, 108,
				77, 97, 110, 97, 103, 101, 114, 124, 77, 97,
				116, 101, 114, 105, 97, 108, 115, 71, 114, 111,
				117, 112, 0, 0, 0, 0, 20, 86, 76, 66,
				124, 77, 97, 116, 101, 114, 105, 97, 108, 77,
				111, 100, 105, 102, 105, 101, 114, 0, 0, 0,
				0, 30, 86, 76, 66, 46, 77, 97, 116, 101,
				114, 105, 97, 108, 77, 111, 100, 105, 102, 105,
				101, 114, 124, 73, 110, 116, 101, 114, 102, 97,
				99, 101, 0, 0, 0, 0, 17, 86, 76, 66,
				124, 77, 101, 115, 104, 71, 101, 110, 101, 114,
				97, 116, 111, 114, 0, 0, 0, 0, 20, 86,
				76, 66, 124, 77, 105, 110, 77, 97, 120, 82,
				97, 110, 103, 101, 70, 108, 111, 97, 116, 0,
				0, 0, 0, 24, 86, 76, 66, 124, 77, 105,
				110, 77, 97, 120, 82, 97, 110, 103, 101, 65,
				116, 116, 114, 105, 98, 117, 116, 101, 0, 0,
				0, 0, 11, 86, 76, 66, 124, 78, 111, 105,
				115, 101, 51, 68, 0, 0, 0, 0, 18, 86,
				76, 66, 124, 80, 108, 97, 116, 102, 111, 114,
				109, 72, 101, 108, 112, 101, 114, 0, 0, 0,
				0, 17, 86, 76, 66, 124, 80, 111, 108, 121,
				103, 111, 110, 72, 101, 108, 112, 101, 114, 0,
				0, 0, 0, 25, 86, 76, 66, 46, 80, 111,
				108, 121, 103, 111, 110, 72, 101, 108, 112, 101,
				114, 124, 80, 108, 97, 110, 101, 50, 68, 0,
				0, 0, 0, 18, 86, 76, 66, 124, 66, 101,
				97, 109, 71, 101, 111, 109, 101, 116, 114, 121,
				83, 68, 0, 0, 0, 0, 32, 86, 76, 66,
				124, 68, 121, 110, 97, 109, 105, 99, 79, 99,
				99, 108, 117, 115, 105, 111, 110, 65, 98, 115,
				116, 114, 97, 99, 116, 66, 97, 115, 101, 0,
				0, 0, 0, 31, 86, 76, 66, 124, 68, 121,
				110, 97, 109, 105, 99, 79, 99, 99, 108, 117,
				115, 105, 111, 110, 68, 101, 112, 116, 104, 66,
				117, 102, 102, 101, 114, 0, 0, 0, 0, 30,
				86, 76, 66, 124, 68, 121, 110, 97, 109, 105,
				99, 79, 99, 99, 108, 117, 115, 105, 111, 110,
				82, 97, 121, 99, 97, 115, 116, 105, 110, 103,
				0, 0, 0, 0, 40, 86, 76, 66, 46, 68,
				121, 110, 97, 109, 105, 99, 79, 99, 99, 108,
				117, 115, 105, 111, 110, 82, 97, 121, 99, 97,
				115, 116, 105, 110, 103, 124, 72, 105, 116, 82,
				101, 115, 117, 108, 116, 0, 0, 0, 0, 16,
				86, 76, 66, 124, 71, 108, 111, 98, 97, 108,
				77, 101, 115, 104, 83, 68, 0, 0, 0, 0,
				19, 86, 76, 66, 124, 83, 107, 101, 119, 105,
				110, 103, 72, 97, 110, 100, 108, 101, 83, 68,
				0, 0, 0, 0, 25, 86, 76, 66, 124, 86,
				111, 108, 117, 109, 101, 116, 114, 105, 99, 76,
				105, 103, 104, 116, 66, 101, 97, 109, 83, 68,
				0, 0, 0, 0, 18, 86, 76, 66, 124, 83,
				104, 97, 100, 101, 114, 75, 101, 121, 119, 111,
				114, 100, 115, 0, 0, 0, 0, 21, 86, 76,
				66, 46, 83, 104, 97, 100, 101, 114, 75, 101,
				121, 119, 111, 114, 100, 115, 124, 83, 68, 0,
				0, 0, 0, 21, 86, 76, 66, 46, 83, 104,
				97, 100, 101, 114, 75, 101, 121, 119, 111, 114,
				100, 115, 124, 72, 68, 0, 0, 0, 0, 20,
				86, 76, 66, 124, 83, 104, 97, 100, 101, 114,
				80, 114, 111, 112, 101, 114, 116, 105, 101, 115,
				0, 0, 0, 0, 23, 86, 76, 66, 46, 83,
				104, 97, 100, 101, 114, 80, 114, 111, 112, 101,
				114, 116, 105, 101, 115, 124, 83, 68, 0, 0,
				0, 0, 23, 86, 76, 66, 46, 83, 104, 97,
				100, 101, 114, 80, 114, 111, 112, 101, 114, 116,
				105, 101, 115, 124, 72, 68, 0, 0, 0, 0,
				19, 86, 76, 66, 124, 83, 112, 111, 116, 76,
				105, 103, 104, 116, 72, 101, 108, 112, 101, 114,
				0, 0, 0, 0, 13, 86, 76, 66, 124, 83,
				82, 80, 72, 101, 108, 112, 101, 114, 0, 0,
				0, 0, 18, 86, 76, 66, 124, 84, 114, 97,
				110, 115, 102, 111, 114, 109, 85, 116, 105, 108,
				115, 0, 0, 0, 0, 25, 86, 76, 66, 46,
				84, 114, 97, 110, 115, 102, 111, 114, 109, 85,
				116, 105, 108, 115, 124, 80, 97, 99, 107, 101,
				100, 0, 0, 0, 0, 15, 86, 76, 66, 124,
				84, 114, 105, 103, 103, 101, 114, 90, 111, 110,
				101, 0, 0, 0, 0, 9, 86, 76, 66, 124,
				85, 116, 105, 108, 115, 0, 0, 0, 0, 18,
				86, 76, 66, 124, 85, 116, 105, 108, 115, 66,
				101, 97, 109, 80, 114, 111, 112, 115, 0, 0,
				0, 0, 11, 86, 76, 66, 124, 86, 101, 114,
				115, 105, 111, 110, 0, 0, 0, 0, 27, 86,
				76, 66, 124, 86, 111, 108, 117, 109, 101, 116,
				114, 105, 99, 68, 117, 115, 116, 80, 97, 114,
				116, 105, 99, 108, 101, 115, 0, 0, 0, 0,
				35, 86, 76, 66, 124, 86, 111, 108, 117, 109,
				101, 116, 114, 105, 99, 76, 105, 103, 104, 116,
				66, 101, 97, 109, 65, 98, 115, 116, 114, 97,
				99, 116, 66, 97, 115, 101
			},
			TotalFiles = 119,
			TotalTypes = 154,
			IsEditorOnly = false
		};
	}
}
namespace VLB
{
	public static class BatchingHelper
	{
		public static bool forceEnableDepthBlend
		{
			get
			{
				RenderingMode actualRenderingMode = Config.Instance.GetActualRenderingMode(ShaderMode.SD);
				if (actualRenderingMode != RenderingMode.GPUInstancing)
				{
					return actualRenderingMode == RenderingMode.SRPBatcher;
				}
				return true;
			}
		}

		public static bool IsGpuInstancingEnabled(Material material)
		{
			return material.enableInstancing;
		}

		public static void SetMaterialProperties(Material material, bool enableGpuInstancing)
		{
			material.enableInstancing = enableGpuInstancing;
		}

		private static bool DoesRenderingModePreventBatching(ShaderMode shaderMode, ref string reasons)
		{
			RenderingMode actualRenderingMode = Config.Instance.GetActualRenderingMode(shaderMode);
			if (actualRenderingMode != RenderingMode.GPUInstancing && actualRenderingMode != RenderingMode.SRPBatcher)
			{
				reasons = $"Current Rendering Mode is '{actualRenderingMode}'. To enable batching, use '{RenderingMode.GPUInstancing}'";
				if (Config.Instance.renderPipeline != RenderPipeline.BuiltIn)
				{
					reasons += $" or '{RenderingMode.SRPBatcher}'";
				}
				return true;
			}
			return false;
		}

		public static bool CanBeBatched(VolumetricLightBeamSD beamA, VolumetricLightBeamSD beamB, ref string reasons)
		{
			if (DoesRenderingModePreventBatching(ShaderMode.SD, ref reasons))
			{
				return false;
			}
			bool flag = true;
			flag &= CanBeBatched(beamA, ref reasons);
			flag &= CanBeBatched(beamB, ref reasons);
			if (Config.Instance.featureEnabledDynamicOcclusion && beamA.GetComponent<DynamicOcclusionAbstractBase>() == null != (beamB.GetComponent<DynamicOcclusionAbstractBase>() == null))
			{
				AppendErrorMessage(ref reasons, $"{beamA.name}/{beamB.name}: dynamically occluded and non occluded beams cannot be batched together");
				flag = false;
			}
			if (Config.Instance.featureEnabledColorGradient != FeatureEnabledColorGradient.Off && beamA.colorMode != beamB.colorMode)
			{
				AppendErrorMessage(ref reasons, $"'Color Mode' mismatch: {beamA.colorMode} / {beamB.colorMode}");
				flag = false;
			}
			if (beamA.blendingMode != beamB.blendingMode)
			{
				AppendErrorMessage(ref reasons, $"'Blending Mode' mismatch: {beamA.blendingMode} / {beamB.blendingMode}");
				flag = false;
			}
			if (Config.Instance.featureEnabledNoise3D && beamA.isNoiseEnabled != beamB.isNoiseEnabled)
			{
				AppendErrorMessage(ref reasons, $"'3D Noise' enabled mismatch: {beamA.noiseMode} / {beamB.noiseMode}");
				flag = false;
			}
			if (Config.Instance.featureEnabledDepthBlend && !forceEnableDepthBlend && beamA.depthBlendDistance > 0f != beamB.depthBlendDistance > 0f)
			{
				AppendErrorMessage(ref reasons, $"'Opaque Geometry Blending' mismatch: {beamA.depthBlendDistance} / {beamB.depthBlendDistance}");
				flag = false;
			}
			if (Config.Instance.featureEnabledShaderAccuracyHigh && beamA.shaderAccuracy != beamB.shaderAccuracy)
			{
				AppendErrorMessage(ref reasons, $"'Shader Accuracy' mismatch: {beamA.shaderAccuracy} / {beamB.shaderAccuracy}");
				flag = false;
			}
			return flag;
		}

		public static bool CanBeBatched(VolumetricLightBeamSD beam, ref string reasons)
		{
			bool result = true;
			if (Config.Instance.GetActualRenderingMode(ShaderMode.SD) == RenderingMode.GPUInstancing && beam.geomMeshType != MeshType.Shared)
			{
				AppendErrorMessage(ref reasons, $"{beam.name} is not using shared mesh");
				result = false;
			}
			if (Config.Instance.featureEnabledDynamicOcclusion && beam.GetComponent<DynamicOcclusionDepthBuffer>() != null)
			{
				AppendErrorMessage(ref reasons, $"{beam.name} is using the DynamicOcclusion DepthBuffer feature");
				result = false;
			}
			return result;
		}

		public static bool CanBeBatched(VolumetricLightBeamHD beamA, VolumetricLightBeamHD beamB, ref string reasons)
		{
			if (DoesRenderingModePreventBatching(ShaderMode.HD, ref reasons))
			{
				return false;
			}
			bool flag = true;
			flag &= CanBeBatched(beamA, ref reasons);
			flag &= CanBeBatched(beamB, ref reasons);
			if (Config.Instance.featureEnabledColorGradient != FeatureEnabledColorGradient.Off && beamA.colorMode != beamB.colorMode)
			{
				AppendErrorMessage(ref reasons, $"'Color Mode' mismatch: {beamA.colorMode} / {beamB.colorMode}");
				flag = false;
			}
			if (beamA.blendingMode != beamB.blendingMode)
			{
				AppendErrorMessage(ref reasons, $"'Blending Mode' mismatch: {beamA.blendingMode} / {beamB.blendingMode}");
				flag = false;
			}
			if (beamA.attenuationEquation != beamB.attenuationEquation)
			{
				AppendErrorMessage(ref reasons, $"'Attenuation Equation' mismatch: {beamA.attenuationEquation} / {beamB.attenuationEquation}");
				flag = false;
			}
			if (Config.Instance.featureEnabledNoise3D && beamA.isNoiseEnabled != beamB.isNoiseEnabled)
			{
				AppendErrorMessage(ref reasons, $"'3D Noise' enabled mismatch: {beamA.noiseMode} / {beamB.noiseMode}");
				flag = false;
			}
			if (beamA.raymarchingQualityID != beamB.raymarchingQualityID)
			{
				AppendErrorMessage(ref reasons, $"'Raymarching Quality' mismatch: {Config.Instance.GetRaymarchingQualityForUniqueID(beamA.raymarchingQualityID).name} / {Config.Instance.GetRaymarchingQualityForUniqueID(beamB.raymarchingQualityID).name}");
				flag = false;
			}
			return flag;
		}

		public static bool CanBeBatched(VolumetricLightBeamHD beam, ref string reasons)
		{
			bool result = true;
			if (Config.Instance.featureEnabledShadow && beam.GetAdditionalComponentShadow() != null)
			{
				AppendErrorMessage(ref reasons, $"{beam.name} is using the Shadow feature");
				result = false;
			}
			if (Config.Instance.featureEnabledCookie && beam.GetAdditionalComponentCookie() != null)
			{
				AppendErrorMessage(ref reasons, $"{beam.name} is using the Cookie feature");
				result = false;
			}
			return result;
		}

		public static bool CanBeBatched(VolumetricLightBeamAbstractBase beamA, VolumetricLightBeamAbstractBase beamB, ref string reasons)
		{
			if (beamA is VolumetricLightBeamSD beamA2 && beamB is VolumetricLightBeamSD beamB2)
			{
				return CanBeBatched(beamA2, beamB2, ref reasons);
			}
			if (beamA is VolumetricLightBeamHD beamA3 && beamB is VolumetricLightBeamHD beamB3)
			{
				return CanBeBatched(beamA3, beamB3, ref reasons);
			}
			return false;
		}

		private static void AppendErrorMessage(ref string message, string toAppend)
		{
			if (message != "")
			{
				message += "\n";
			}
			message = message + "- " + toAppend;
		}
	}
	public abstract class BeamGeometryAbstractBase : MonoBehaviour
	{
		protected Matrix4x4 m_ColorGradientMatrix;

		protected Material m_CustomMaterial;

		public MeshRenderer meshRenderer { get; protected set; }

		public MeshFilter meshFilter { get; protected set; }

		public Mesh coneMesh { get; protected set; }

		protected abstract VolumetricLightBeamAbstractBase GetMaster();

		private void Start()
		{
			DestroyOrphanBeamGeom();
		}

		private void OnDestroy()
		{
			if ((bool)m_CustomMaterial)
			{
				UnityEngine.Object.DestroyImmediate(m_CustomMaterial);
				m_CustomMaterial = null;
			}
		}

		private void DestroyOrphanBeamGeom()
		{
			VolumetricLightBeamAbstractBase master = GetMaster();
			if (!master || !(master.GetBeamGeometry() == this))
			{
				DestroyBeamGeometryGameObject(this);
			}
		}

		public static void DestroyBeamGeometryGameObject(BeamGeometryAbstractBase beamGeom)
		{
			if ((bool)beamGeom)
			{
				UnityEngine.Object.DestroyImmediate(beamGeom.gameObject);
			}
		}
	}
	[HelpURL("http://saladgamer.com/vlb-doc/config/")]
	public class Config : ScriptableObject
	{
		public const string ClassName = "Config";

		public const string kAssetName = "VLBConfigOverride";

		public const string kAssetNameExt = ".asset";

		public bool geometryOverrideLayer = true;

		public int geometryLayerID = 1;

		public string geometryTag = "Untagged";

		public int geometryRenderQueue = 3000;

		public int geometryRenderQueueHD = 3100;

		[FormerlySerializedAs("renderPipeline")]
		[FormerlySerializedAs("_RenderPipeline")]
		[SerializeField]
		private RenderPipeline m_RenderPipeline;

		[FormerlySerializedAs("renderingMode")]
		[FormerlySerializedAs("_RenderingMode")]
		[SerializeField]
		private RenderingMode m_RenderingMode = RenderingMode.Default;

		public float ditheringFactor;

		public bool useLightColorTemperature = true;

		public int sharedMeshSides = 24;

		public int sharedMeshSegments = 5;

		public float hdBeamsCameraBlendingDistance = 0.5f;

		public int urpDepthCameraScriptableRendererIndex = -1;

		[Range(0.01f, 2f)]
		public float globalNoiseScale = 0.5f;

		public Vector3 globalNoiseVelocity = Consts.Beam.NoiseVelocityDefault;

		public string fadeOutCameraTag = "MainCamera";

		[HighlightNull]
		public Texture3D noiseTexture3D;

		[HighlightNull]
		public ParticleSystem dustParticlesPrefab;

		[HighlightNull]
		public Texture2D ditheringNoiseTexture;

		[HighlightNull]
		public Texture2D jitteringNoiseTexture;

		public FeatureEnabledColorGradient featureEnabledColorGradient = FeatureEnabledColorGradient.HighOnly;

		public bool featureEnabledDepthBlend = true;

		public bool featureEnabledNoise3D = true;

		public bool featureEnabledDynamicOcclusion = true;

		public bool featureEnabledMeshSkewing = true;

		public bool featureEnabledShaderAccuracyHigh = true;

		public bool featureEnabledShadow = true;

		public bool featureEnabledCookie = true;

		[SerializeField]
		private RaymarchingQuality[] m_RaymarchingQualities;

		[SerializeField]
		private int m_DefaultRaymarchingQualityUniqueID;

		[SerializeField]
		private int pluginVersion = -1;

		[SerializeField]
		private Material _DummyMaterial;

		[SerializeField]
		private Material _DummyMaterialHD;

		[SerializeField]
		private Shader _BeamShader;

		[SerializeField]
		private Shader _BeamShaderHD;

		private Camera m_CachedFadeOutCamera;

		private static Config ms_Instance;

		public RenderPipeline renderPipeline
		{
			get
			{
				return m_RenderPipeline;
			}
			set
			{
				UnityEngine.Debug.LogError("Modifying the RenderPipeline in standalone builds is not permitted");
			}
		}

		public RenderingMode renderingMode
		{
			get
			{
				return m_RenderingMode;
			}
			set
			{
				UnityEngine.Debug.LogError("Modifying the RenderingMode in standalone builds is not permitted");
			}
		}

		public bool SD_useSinglePassShader => GetActualRenderingMode(ShaderMode.SD) != RenderingMode.MultiPass;

		public bool SD_requiresDoubleSidedMesh => SD_useSinglePassShader;

		public Transform fadeOutCameraTransform
		{
			get
			{
				if (m_CachedFadeOutCamera == null || !m_CachedFadeOutCamera.isActiveAndEnabled)
				{
					ForceUpdateFadeOutCamera();
				}
				if (!(m_CachedFadeOutCamera != null))
				{
					return null;
				}
				return m_CachedFadeOutCamera.transform;
			}
		}

		public string fadeOutCameraName
		{
			get
			{
				if (!(m_CachedFadeOutCamera != null))
				{
					return "Invalid Camera";
				}
				return m_CachedFadeOutCamera.name;
			}
		}

		public int defaultRaymarchingQualityUniqueID => m_DefaultRaymarchingQualityUniqueID;

		public int raymarchingQualitiesCount => Mathf.Max(1, (m_RaymarchingQualities == null) ? 1 : m_RaymarchingQualities.Length);

		public bool isHDRPExposureWeightSupported => renderPipeline == RenderPipeline.HDRP;

		public bool hasRenderPipelineMismatch => SRPHelper.projectRenderPipeline == RenderPipeline.BuiltIn != (m_RenderPipeline == RenderPipeline.BuiltIn);

		public static Config Instance => GetInstance(assertIfNotFound: true);

		public bool IsSRPBatcherSupported()
		{
			if (renderPipeline == RenderPipeline.BuiltIn)
			{
				return false;
			}
			RenderPipeline projectRenderPipeline = SRPHelper.projectRenderPipeline;
			if (projectRenderPipeline != RenderPipeline.URP)
			{
				return projectRenderPipeline == RenderPipeline.HDRP;
			}
			return true;
		}

		public RenderingMode GetActualRenderingMode(ShaderMode shaderMode)
		{
			if (renderingMode == RenderingMode.SRPBatcher && !IsSRPBatcherSupported())
			{
				return RenderingMode.Default;
			}
			if (renderPipeline != RenderPipeline.BuiltIn && renderingMode == RenderingMode.MultiPass)
			{
				return RenderingMode.Default;
			}
			if (shaderMode == ShaderMode.HD && renderingMode == RenderingMode.MultiPass)
			{
				return RenderingMode.Default;
			}
			return renderingMode;
		}

		public Shader GetBeamShader(ShaderMode mode)
		{
			return GetBeamShaderInternal(mode);
		}

		private ref Shader GetBeamShaderInternal(ShaderMode mode)
		{
			if (mode == ShaderMode.SD)
			{
				return ref _BeamShader;
			}
			return ref _BeamShaderHD;
		}

		private int GetRenderQueueInternal(ShaderMode mode)
		{
			if (mode == ShaderMode.SD)
			{
				return geometryRenderQueue;
			}
			return geometryRenderQueueHD;
		}

		public Material NewMaterialTransient(ShaderMode mode, bool gpuInstanced)
		{
			Material material = MaterialManager.NewMaterialPersistent(GetBeamShader(mode), gpuInstanced);
			if ((bool)material)
			{
				material.hideFlags = Consts.Internal.ProceduralObjectsHideFlags;
				material.renderQueue = GetRenderQueueInternal(mode);
			}
			return material;
		}

		public void SetURPScriptableRendererIndexToDepthCamera(Camera camera)
		{
			if (urpDepthCameraScriptableRendererIndex >= 0)
			{
				UniversalAdditionalCameraData universalAdditionalCameraData = camera.GetUniversalAdditionalCameraData();
				if ((bool)universalAdditionalCameraData)
				{
					universalAdditionalCameraData.SetRenderer(urpDepthCameraScriptableRendererIndex);
				}
			}
		}

		public void ForceUpdateFadeOutCamera()
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag(fadeOutCameraTag);
			if (array == null)
			{
				return;
			}
			GameObject[] array2 = array;
			foreach (GameObject gameObject in array2)
			{
				if ((bool)gameObject)
				{
					Camera component = gameObject.GetComponent<Camera>();
					if ((bool)component && component.isActiveAndEnabled)
					{
						m_CachedFadeOutCamera = component;
						break;
					}
				}
			}
		}

		public RaymarchingQuality GetRaymarchingQualityForIndex(int index)
		{
			return m_RaymarchingQualities[index];
		}

		public RaymarchingQuality GetRaymarchingQualityForUniqueID(int id)
		{
			int raymarchingQualityIndexForUniqueID = GetRaymarchingQualityIndexForUniqueID(id);
			if (raymarchingQualityIndexForUniqueID >= 0)
			{
				return GetRaymarchingQualityForIndex(raymarchingQualityIndexForUniqueID);
			}
			return null;
		}

		public int GetRaymarchingQualityIndexForUniqueID(int id)
		{
			for (int i = 0; i < m_RaymarchingQualities.Length; i++)
			{
				RaymarchingQuality raymarchingQuality = m_RaymarchingQualities[i];
				if (raymarchingQuality != null && raymarchingQuality.uniqueID == id)
				{
					return i;
				}
			}
			UnityEngine.Debug.LogErrorFormat("Failed to find RaymarchingQualityIndex for Unique ID {0}", id);
			return -1;
		}

		public bool IsRaymarchingQualityUniqueIDValid(int id)
		{
			return GetRaymarchingQualityIndexForUniqueID(id) >= 0;
		}

		private void CreateDefaultRaymarchingQualityPreset(bool onlyIfNeeded)
		{
			if (m_RaymarchingQualities == null || m_RaymarchingQualities.Length == 0 || !onlyIfNeeded)
			{
				m_RaymarchingQualities = new RaymarchingQuality[3];
				m_RaymarchingQualities[0] = RaymarchingQuality.New("Fast", 1, 5);
				m_RaymarchingQualities[1] = RaymarchingQuality.New("Balanced", 2, 10);
				m_RaymarchingQualities[2] = RaymarchingQuality.New("High", 3, 20);
				m_DefaultRaymarchingQualityUniqueID = m_RaymarchingQualities[1].uniqueID;
			}
		}

		[RuntimeInitializeOnLoadMethod]
		private static void OnStartup()
		{
			Instance.m_CachedFadeOutCamera = null;
			Instance.RefreshGlobalShaderProperties();
			if (Instance.hasRenderPipelineMismatch)
			{
				UnityEngine.Debug.LogError("It looks like the 'Render Pipeline' is not correctly set in the config. Please make sure to select the proper value depending on your pipeline in use.", Instance);
			}
		}

		public void Reset()
		{
			geometryOverrideLayer = true;
			geometryLayerID = 1;
			geometryTag = "Untagged";
			geometryRenderQueue = 3000;
			geometryRenderQueueHD = 3100;
			sharedMeshSides = 24;
			sharedMeshSegments = 5;
			globalNoiseScale = 0.5f;
			globalNoiseVelocity = Consts.Beam.NoiseVelocityDefault;
			renderPipeline = RenderPipeline.BuiltIn;
			renderingMode = RenderingMode.Default;
			ditheringFactor = 0f;
			useLightColorTemperature = true;
			fadeOutCameraTag = "MainCamera";
			featureEnabledColorGradient = FeatureEnabledColorGradient.HighOnly;
			featureEnabledDepthBlend = true;
			featureEnabledNoise3D = true;
			featureEnabledDynamicOcclusion = true;
			featureEnabledMeshSkewing = true;
			featureEnabledShaderAccuracyHigh = true;
			hdBeamsCameraBlendingDistance = 0.5f;
			urpDepthCameraScriptableRendererIndex = -1;
			CreateDefaultRaymarchingQualityPreset(onlyIfNeeded: false);
			ResetInternalData();
		}

		private void RefreshGlobalShaderProperties()
		{
			Shader.SetGlobalFloat(ShaderProperties.GlobalUsesReversedZBuffer, SystemInfo.usesReversedZBuffer ? 1f : 0f);
			Shader.SetGlobalFloat(ShaderProperties.GlobalDitheringFactor, ditheringFactor);
			Shader.SetGlobalTexture(ShaderProperties.GlobalDitheringNoiseTex, ditheringNoiseTexture);
			Shader.SetGlobalFloat(ShaderProperties.HD.GlobalCameraBlendingDistance, hdBeamsCameraBlendingDistance);
			Shader.SetGlobalTexture(ShaderProperties.HD.GlobalJitteringNoiseTex, jitteringNoiseTexture);
		}

		public void ResetInternalData()
		{
			noiseTexture3D = Resources.Load("Noise3D_64x64x64") as Texture3D;
			dustParticlesPrefab = Resources.Load("DustParticles", typeof(ParticleSystem)) as ParticleSystem;
			ditheringNoiseTexture = Resources.Load("VLBDitheringNoise", typeof(Texture2D)) as Texture2D;
			jitteringNoiseTexture = Resources.Load("VLBBlueNoise", typeof(Texture2D)) as Texture2D;
		}

		public ParticleSystem NewVolumetricDustParticles()
		{
			if (!dustParticlesPrefab)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Debug.LogError("Failed to instantiate VolumetricDustParticles prefab.");
				}
				return null;
			}
			ParticleSystem particleSystem = UnityEngine.Object.Instantiate(dustParticlesPrefab);
			particleSystem.useAutoRandomSeed = false;
			particleSystem.name = "Dust Particles";
			particleSystem.gameObject.hideFlags = Consts.Internal.ProceduralObjectsHideFlags;
			particleSystem.gameObject.SetActive(value: true);
			return particleSystem;
		}

		private void OnEnable()
		{
			CreateDefaultRaymarchingQualityPreset(onlyIfNeeded: true);
			HandleBackwardCompatibility(pluginVersion, 20200);
			pluginVersion = 20200;
		}

		private void HandleBackwardCompatibility(int serializedVersion, int newVersion)
		{
		}

		private static Config LoadAssetInternal(string assetName)
		{
			return Resources.Load<Config>(assetName);
		}

		private static Config GetInstance(bool assertIfNotFound)
		{
			if (ms_Instance == null)
			{
				Config config = LoadAssetInternal("VLBConfigOverride" + PlatformHelper.GetCurrentPlatformSuffix());
				if (config == null)
				{
					config = LoadAssetInternal("VLBConfigOverride");
				}
				ms_Instance = config;
				_ = ms_Instance == null;
			}
			return ms_Instance;
		}
	}
	public static class Consts
	{
		public static class Help
		{
			public static class SD
			{
				public const string UrlBeam = "http://saladgamer.com/vlb-doc/comp-lightbeam-sd/";

				public const string UrlDynamicOcclusionRaycasting = "http://saladgamer.com/vlb-doc/comp-dynocclusion-sd-raycasting/";

				public const string UrlDynamicOcclusionDepthBuffer = "http://saladgamer.com/vlb-doc/comp-dynocclusion-sd-depthbuffer/";

				public const string UrlSkewingHandle = "http://saladgamer.com/vlb-doc/comp-skewinghandle-sd/";

				public const string AddComponentMenuSD = "VLB/SD/";

				public const string AddComponentMenuBeam = "VLB/SD/Volumetric Light Beam SD";

				public const string AddComponentMenuDynamicOcclusionRaycasting = "VLB/SD/Dynamic Occlusion (Raycasting)";

				public const string AddComponentMenuDynamicOcclusionDepthBuffer = "VLB/SD/Dynamic Occlusion (Depth Buffer)";
			}

			public static class HD
			{
				public const string UrlBeam = "http://saladgamer.com/vlb-doc/comp-lightbeam-hd/";

				public const string UrlShadow = "http://saladgamer.com/vlb-doc/comp-shadow-hd/";

				public const string UrlCookie = "http://saladgamer.com/vlb-doc/comp-cookie-hd/";

				public const string UrlTrackRealtimeChangesOnLight = "http://saladgamer.com/vlb-doc/comp-trackrealtimechanges-hd/";

				public const string AddComponentMenuHD = "VLB/HD/";

				public const string AddComponentMenuBeam3D = "VLB/HD/Volumetric Light Beam HD";

				public const string AddComponentMenuBeam2D = "VLB/HD/Volumetric Light Beam HD (2D)";

				public const string AddComponentMenuShadow = "VLB/HD/Volumetric Shadow HD";

				public const string AddComponentMenuCookie = "VLB/HD/Volumetric Cookie HD";

				public const string AddComponentMenuTrackRealtimeChangesOnLight = "VLB/HD/Track Realtime Changes On Light";
			}

			private const string UrlBase = "http://saladgamer.com/vlb-doc/";

			private const string UrlSuffix = "/";

			public const string UrlDustParticles = "http://saladgamer.com/vlb-doc/comp-dustparticles/";

			public const string UrlTriggerZone = "http://saladgamer.com/vlb-doc/comp-triggerzone/";

			public const string UrlEffectFlicker = "http://saladgamer.com/vlb-doc/comp-effect-flicker/";

			public const string UrlEffectPulse = "http://saladgamer.com/vlb-doc/comp-effect-pulse/";

			public const string UrlEffectFromProfile = "http://saladgamer.com/vlb-doc/comp-effect-from-profile/";

			public const string UrlLODBeamGroup = "http://saladgamer.com/vlb-doc/comp-lodbeamgroup/";

			public const string UrlConfig = "http://saladgamer.com/vlb-doc/config/";

			public const string AddComponentMenuBase = "VLB/";

			public const string AddComponentMenuCommon = "VLB/Common/";

			public const string AddComponentMenuDustParticles = "VLB/Common/Volumetric Dust Particles";

			public const string AddComponentMenuTriggerZone = "VLB/Common/Trigger Zone";

			public const string AddComponentMenuEffectFlicker = "VLB/Common/Effect Flicker";

			public const string AddComponentMenuEffectPulse = "VLB/Common/Effect Pulse";

			public const string AddComponentMenuEffectFromProfile = "VLB/Common/Effect From Profile";
		}

		public static class Internal
		{
			public static readonly bool ProceduralObjectsVisibleInEditor = true;

			public static HideFlags ProceduralObjectsHideFlags
			{
				get
				{
					if (!ProceduralObjectsVisibleInEditor)
					{
						return HideFlags.HideAndDontSave;
					}
					return HideFlags.DontSave | HideFlags.NotEditable;
				}
			}
		}

		public static class Beam
		{
			public static class SD
			{
				public const float FresnelPowMaxValue = 10f;

				public const float FresnelPow = 8f;

				public const float GlareFrontalDefault = 0.5f;

				public const float GlareBehindDefault = 0.5f;

				public const float GlareMin = 0f;

				public const float GlareMax = 1f;

				public static readonly Vector2 TiltDefault = Vector2.zero;

				public static readonly Vector3 SkewingLocalForwardDirectionDefault = Vector3.forward;

				public const Transform ClippingPlaneTransformDefault = null;
			}

			public static class HD
			{
				public const AttenuationEquationHD AttenuationEquationDefault = AttenuationEquationHD.Quadratic;

				public const float SideSoftnessDefault = 1f;

				public const float SideSoftnessMin = 0.0001f;

				public const float SideSoftnessMax = 10f;

				public const float JitteringFactorDefault = 0f;

				public const float JitteringFactorMin = 0f;

				public const int JitteringFrameRateDefault = 60;

				public const int JitteringFrameRateMin = 0;

				public const int JitteringFrameRateMax = 120;

				public static readonly MinMaxRangeFloat JitteringLerpRange = new MinMaxRangeFloat(0f, 0.33f);
			}

			public static readonly Color FlatColor = Color.white;

			public const ColorMode ColorModeDefault = ColorMode.Flat;

			public const float MultiplierDefault = 1f;

			public const float MultiplierMin = 0f;

			public const float IntensityDefault = 1f;

			public const float IntensityMin = 0f;

			public const float HDRPExposureWeightDefault = 0f;

			public const float HDRPExposureWeightMin = 0f;

			public const float HDRPExposureWeightMax = 1f;

			public const float SpotAngleDefault = 35f;

			public const float SpotAngleMin = 0.1f;

			public const float SpotAngleMax = 179.9f;

			public const float ConeRadiusStart = 0.1f;

			public const MeshType GeomMeshType = MeshType.Shared;

			public const int GeomSidesDefault = 18;

			public const int GeomSidesMin = 3;

			public const int GeomSidesMax = 256;

			public const int GeomSegmentsDefault = 5;

			public const int GeomSegmentsMin = 0;

			public const int GeomSegmentsMax = 64;

			public const bool GeomCap = false;

			public const bool ScalableDefault = true;

			public const AttenuationEquation AttenuationEquationDefault = AttenuationEquation.Quadratic;

			public const float AttenuationCustomBlendingDefault = 0.5f;

			public const float AttenuationCustomBlendingMin = 0f;

			public const float AttenuationCustomBlendingMax = 1f;

			public const float FallOffStart = 0f;

			public const float FallOffEnd = 3f;

			public const float FallOffDistancesMinThreshold = 0.01f;

			public const float DepthBlendDistance = 2f;

			public const float CameraClippingDistance = 0.5f;

			public const NoiseMode NoiseModeDefault = NoiseMode.Disabled;

			public const float NoiseIntensityMin = 0f;

			public const float NoiseIntensityMax = 1f;

			public const float NoiseIntensityDefault = 0.5f;

			public const float NoiseScaleMin = 0.01f;

			public const float NoiseScaleMax = 2f;

			public const float NoiseScaleDefault = 0.5f;

			public static readonly Vector3 NoiseVelocityDefault = new Vector3(0.07f, 0.18f, 0.05f);

			public const BlendingMode BlendingModeDefault = BlendingMode.Additive;

			public const ShaderAccuracy ShaderAccuracyDefault = ShaderAccuracy.Fast;

			public const float FadeOutBeginDefault = -150f;

			public const float FadeOutEndDefault = -200f;

			public const Dimensions DimensionsDefault = Dimensions.Dim3D;
		}

		public static class DustParticles
		{
			public const float AlphaDefault = 0.5f;

			public const float SizeDefault = 0.01f;

			public const ParticlesDirection DirectionDefault = ParticlesDirection.Random;

			public static readonly Vector3 VelocityDefault = new Vector3(0f, 0f, 0.03f);

			public const float DensityDefault = 5f;

			public const float DensityMin = 0f;

			public const float DensityMax = 1000f;

			public static readonly MinMaxRangeFloat SpawnDistanceRangeDefault = new MinMaxRangeFloat(0f, 0.7f);

			public const bool CullingEnabledDefault = false;

			public const float CullingMaxDistanceDefault = 10f;

			public const float CullingMaxDistanceMin = 1f;
		}

		public static class DynOcclusion
		{
			public static readonly LayerMask LayerMaskDefault = 1;

			public const DynamicOcclusionUpdateRate UpdateRateDefault = DynamicOcclusionUpdateRate.EveryXFrames;

			public const int WaitFramesCountDefault = 3;

			public const Dimensions RaycastingDimensionsDefault = Dimensions.Dim3D;

			public const bool RaycastingConsiderTriggersDefault = false;

			public const float RaycastingMinOccluderAreaDefault = 0f;

			public const float RaycastingMinSurfaceRatioDefault = 0.5f;

			public const float RaycastingMinSurfaceRatioMin = 50f;

			public const float RaycastingMinSurfaceRatioMax = 100f;

			public const float RaycastingMaxSurfaceDotDefault = 0.25f;

			public const float RaycastingMaxSurfaceAngleMin = 45f;

			public const float RaycastingMaxSurfaceAngleMax = 90f;

			public const PlaneAlignment RaycastingPlaneAlignmentDefault = PlaneAlignment.Surface;

			public const float RaycastingPlaneOffsetDefault = 0.1f;

			public const float RaycastingFadeDistanceToSurfaceDefault = 0.25f;

			public const int DepthBufferDepthMapResolutionDefault = 128;

			public const bool DepthBufferOcclusionCullingDefault = true;

			public const float DepthBufferFadeDistanceToSurfaceDefault = 0f;
		}

		public static class Effects
		{
			public const EffectAbstractBase.ComponentsToChange ComponentsToChangeDefault = (EffectAbstractBase.ComponentsToChange)2147483647;

			public const bool RestoreIntensityOnDisableDefault = true;

			public const float FrequencyDefault = 10f;

			public const bool PerformPausesDefault = false;

			public const bool RestoreIntensityOnPauseDefault = false;

			public static readonly MinMaxRangeFloat FlickeringDurationDefault = new MinMaxRangeFloat(1f, 4f);

			public static readonly MinMaxRangeFloat PauseDurationDefault = new MinMaxRangeFloat(0f, 1f);

			public static readonly MinMaxRangeFloat IntensityAmplitudeDefault = new MinMaxRangeFloat(-1f, 1f);

			public const float SmoothingDefault = 0.05f;
		}

		public static class Shadow
		{
			public const float StrengthDefault = 1f;

			public const float StrengthMin = 0f;

			public const float StrengthMax = 1f;

			public static readonly LayerMask LayerMaskDefault = 1;

			public const ShadowUpdateRate UpdateRateDefault = ShadowUpdateRate.EveryXFrames;

			public const int WaitFramesCountDefault = 3;

			public const int DepthMapResolutionDefault = 128;

			public const bool OcclusionCullingDefault = true;

			public static string GetErrorChangeRuntimeDepthMapResolution(VolumetricShadowHD comp)
			{
				return $"Can't change {comp.name} Shadow.depthMapResolution property at runtime after DepthCamera initialization";
			}
		}

		public static class Cookie
		{
			public const float ContributionDefault = 1f;

			public const float ContributionMin = 0f;

			public const float ContributionMax = 1f;

			public const Texture CookieTextureDefault = null;

			public const CookieChannel ChannelDefault = CookieChannel.Alpha;

			public const bool NegativeDefault = false;

			public static readonly Vector2 TranslationDefault = Vector2.zero;

			public const float RotationDefault = 0f;

			public static readonly Vector2 ScaleDefault = Vector2.one;
		}

		public static class Config
		{
			public static class HD
			{
				public const RenderQueue GeometryRenderQueueDefault = (RenderQueue)3100;

				public const float CameraBlendingDistance = 0.5f;

				public const int RaymarchingQualitiesStepsMin = 2;
			}

			public const bool GeometryOverrideLayerDefault = true;

			public const int GeometryLayerIDDefault = 1;

			public const string GeometryTagDefault = "Untagged";

			public const string FadeOutCameraTagDefault = "MainCamera";

			public const RenderQueue GeometryRenderQueueDefault = RenderQueue.Transparent;

			public const RenderPipeline GeometryRenderPipelineDefault = RenderPipeline.BuiltIn;

			public const RenderingMode GeometryRenderingModeDefault = RenderingMode.Default;

			public const int Noise3DSizeDefault = 64;

			public const float DitheringFactor = 0f;

			public const bool UseLightColorTemperatureDefault = true;

			public const bool FeatureEnabledDefault = true;

			public const FeatureEnabledColorGradient FeatureEnabledColorGradientDefault = FeatureEnabledColorGradient.HighOnly;

			public const int SharedMeshSidesDefault = 24;

			public const int SharedMeshSidesMin = 3;

			public const int SharedMeshSidesMax = 256;

			public const int SharedMeshSegmentsDefault = 5;

			public const int SharedMeshSegmentsMin = 0;

			public const int SharedMeshSegmentsMax = 64;
		}

		public const string PluginFolder = "VolumetricLightBeam";
	}
	public static class DummyMaterial
	{
	}
	[AddComponentMenu("")]
	public class EffectAbstractBase : MonoBehaviour
	{
		[Flags]
		public enum ComponentsToChange
		{
			UnityLight = 1,
			VolumetricLightBeam = 2,
			VolumetricDustParticles = 4
		}

		public const string ClassName = "EffectAbstractBase";

		public ComponentsToChange componentsToChange = (ComponentsToChange)2147483647;

		[FormerlySerializedAs("restoreBaseIntensity")]
		public bool restoreIntensityOnDisable = true;

		protected VolumetricLightBeamAbstractBase m_Beam;

		protected Light m_Light;

		protected VolumetricDustParticles m_Particles;

		protected float m_BaseIntensityBeamInside;

		protected float m_BaseIntensityBeamOutside;

		protected float m_BaseIntensityLight;

		[Obsolete("Use 'restoreIntensityOnDisable' instead")]
		public bool restoreBaseIntensity
		{
			get
			{
				return restoreIntensityOnDisable;
			}
			set
			{
				restoreIntensityOnDisable = value;
			}
		}

		public virtual void InitFrom(EffectAbstractBase Source)
		{
			if ((bool)Source)
			{
				componentsToChange = Source.componentsToChange;
				restoreIntensityOnDisable = Source.restoreIntensityOnDisable;
			}
		}

		private void GetIntensity(VolumetricLightBeamSD beam)
		{
			if ((bool)beam)
			{
				m_BaseIntensityBeamInside = beam.intensityInside;
				m_BaseIntensityBeamOutside = beam.intensityOutside;
			}
		}

		private void GetIntensity(VolumetricLightBeamHD beam)
		{
			if ((bool)beam)
			{
				m_BaseIntensityBeamOutside = beam.intensity;
			}
		}

		private void SetIntensity(VolumetricLightBeamSD beam, float additive)
		{
			if ((bool)beam)
			{
				beam.intensityInside = Mathf.Max(0f, m_BaseIntensityBeamInside + additive);
				beam.intensityOutside = Mathf.Max(0f, m_BaseIntensityBeamOutside + additive);
			}
		}

		private void SetIntensity(VolumetricLightBeamHD beam, float additive)
		{
			if ((bool)beam)
			{
				beam.intensity = Mathf.Max(0f, m_BaseIntensityBeamOutside + additive);
			}
		}

		protected void SetAdditiveIntensity(float additive)
		{
			if (componentsToChange.HasFlag(ComponentsToChange.VolumetricLightBeam) && (bool)m_Beam)
			{
				SetIntensity(m_Beam as VolumetricLightBeamSD, additive);
				SetIntensity(m_Beam as VolumetricLightBeamHD, additive);
			}
			if (componentsToChange.HasFlag(ComponentsToChange.UnityLight) && (bool)m_Light)
			{
				m_Light.intensity = Mathf.Max(0f, m_BaseIntensityLight + additive);
			}
			if (componentsToChange.HasFlag(ComponentsToChange.VolumetricDustParticles) && (bool)m_Particles)
			{
				m_Particles.alphaAdditionalRuntime = 1f + additive;
			}
		}

		private void Awake()
		{
			m_Beam = GetComponent<VolumetricLightBeamAbstractBase>();
			m_Light = GetComponent<Light>();
			m_Particles = GetComponent<VolumetricDustParticles>();
			GetIntensity(m_Beam as VolumetricLightBeamSD);
			GetIntensity(m_Beam as VolumetricLightBeamHD);
			m_BaseIntensityLight = (m_Light ? m_Light.intensity : 0f);
		}

		protected virtual void OnEnable()
		{
			StopAllCoroutines();
		}

		private void OnDisable()
		{
			StopAllCoroutines();
			if (restoreIntensityOnDisable)
			{
				SetAdditiveIntensity(0f);
			}
		}
	}
	[HelpURL("http://saladgamer.com/vlb-doc/comp-effect-flicker/")]
	[AddComponentMenu("VLB/Common/Effect Flicker")]
	public class EffectFlicker : EffectAbstractBase
	{
		public new const string ClassName = "EffectFlicker";

		[Range(1f, 60f)]
		public float frequency = 10f;

		public bool performPauses;

		[MinMaxRange(0f, 10f)]
		public MinMaxRangeFloat flickeringDuration = Consts.Effects.FlickeringDurationDefault;

		[MinMaxRange(0f, 10f)]
		public MinMaxRangeFloat pauseDuration = Consts.Effects.PauseDurationDefault;

		public bool restoreIntensityOnPause;

		[MinMaxRange(-5f, 5f)]
		public MinMaxRangeFloat intensityAmplitude = Consts.Effects.IntensityAmplitudeDefault;

		[Range(0f, 0.25f)]
		public float smoothing = 0.05f;

		private float m_CurrentAdditiveIntensity;

		public override void InitFrom(EffectAbstractBase source)
		{
			base.InitFrom(source);
			EffectFlicker effectFlicker = source as EffectFlicker;
			if ((bool)effectFlicker)
			{
				frequency = effectFlicker.frequency;
				performPauses = effectFlicker.performPauses;
				flickeringDuration = effectFlicker.flickeringDuration;
				pauseDuration = effectFlicker.pauseDuration;
				restoreIntensityOnPause = effectFlicker.restoreIntensityOnPause;
				intensityAmplitude = effectFlicker.intensityAmplitude;
				smoothing = effectFlicker.smoothing;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			StartCoroutine(CoUpdate());
		}

		private IEnumerator CoUpdate()
		{
			while (true)
			{
				yield return CoFlicker();
				if (performPauses)
				{
					yield return CoChangeIntensity(pauseDuration.randomValue, restoreIntensityOnPause ? 0f : m_CurrentAdditiveIntensity);
				}
			}
		}

		private IEnumerator CoFlicker()
		{
			float remainingDuration = flickeringDuration.randomValue;
			_ = Time.deltaTime;
			while (!performPauses || remainingDuration > 0f)
			{
				float freqDuration = 1f / frequency;
				yield return CoChangeIntensity(freqDuration, intensityAmplitude.randomValue);
				remainingDuration -= freqDuration;
			}
		}

		private IEnumerator CoChangeIntensity(float expectedDuration, float nextIntensity)
		{
			float velocity = 0f;
			float t = 0f;
			while (t < expectedDuration)
			{
				m_CurrentAdditiveIntensity = Mathf.SmoothDamp(m_CurrentAdditiveIntensity, nextIntensity, ref velocity, smoothing);
				SetAdditiveIntensity(m_CurrentAdditiveIntensity);
				t += Time.deltaTime;
				yield return null;
			}
		}
	}
	[HelpURL("http://saladgamer.com/vlb-doc/comp-effect-from-profile/")]
	[AddComponentMenu("VLB/Common/Effect From Profile")]
	public class EffectFromProfile : MonoBehaviour
	{
		public const string ClassName = "EffectFromProfile";

		[SerializeField]
		private EffectAbstractBase m_EffectProfile;

		private EffectAbstractBase m_EffectInstance;

		public EffectAbstractBase effectProfile
		{
			get
			{
				return m_EffectProfile;
			}
			set
			{
				m_EffectProfile = value;
				InitInstanceFromProfile();
			}
		}

		public void InitInstanceFromProfile()
		{
			if ((bool)m_EffectInstance)
			{
				if ((bool)m_EffectProfile)
				{
					m_EffectInstance.InitFrom(m_EffectProfile);
				}
				else
				{
					m_EffectInstance.enabled = false;
				}
			}
		}

		private void OnEnable()
		{
			if ((bool)m_EffectInstance)
			{
				m_EffectInstance.enabled = true;
			}
			else if ((bool)m_EffectProfile)
			{
				m_EffectInstance = base.gameObject.AddComponent(m_EffectProfile.GetType()) as EffectAbstractBase;
				InitInstanceFromProfile();
			}
		}

		private void OnDisable()
		{
			if ((bool)m_EffectInstance)
			{
				m_EffectInstance.enabled = false;
			}
		}
	}
	[HelpURL("http://saladgamer.com/vlb-doc/comp-effect-pulse/")]
	[AddComponentMenu("VLB/Common/Effect Pulse")]
	public class EffectPulse : EffectAbstractBase
	{
		public new const string ClassName = "EffectPulse";

		[Range(0.1f, 60f)]
		public float frequency = 10f;

		[MinMaxRange(-5f, 5f)]
		public MinMaxRangeFloat intensityAmplitude = Consts.Effects.IntensityAmplitudeDefault;

		public override void InitFrom(EffectAbstractBase source)
		{
			base.InitFrom(source);
			EffectPulse effectPulse = source as EffectPulse;
			if ((bool)effectPulse)
			{
				frequency = effectPulse.frequency;
				intensityAmplitude = effectPulse.intensityAmplitude;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			StartCoroutine(CoUpdate());
		}

		private IEnumerator CoUpdate()
		{
			float t = 0f;
			while (true)
			{
				float num = Mathf.Sin(frequency * t);
				float lerpedValue = intensityAmplitude.GetLerpedValue(num * 0.5f + 0.5f);
				SetAdditiveIntensity(lerpedValue);
				yield return null;
				t += Time.deltaTime;
			}
		}
	}
	public enum FeatureEnabledColorGradient
	{
		Off,
		HighOnly,
		HighAndLow
	}
	public enum ColorMode
	{
		Flat,
		Gradient
	}
	public enum AttenuationEquation
	{
		Linear,
		Quadratic,
		Blend
	}
	public enum AttenuationEquationHD
	{
		Linear,
		Quadratic
	}
	public enum BlendingMode
	{
		Additive,
		SoftAdditive,
		TraditionalTransparency
	}
	public enum ShaderAccuracy
	{
		Fast,
		High
	}
	public enum NoiseMode
	{
		Disabled,
		WorldSpace,
		LocalSpace
	}
	public enum MeshType
	{
		Shared,
		Custom
	}
	public enum RenderPipeline
	{
		BuiltIn,
		URP,
		HDRP
	}
	public enum ShaderMode
	{
		SD,
		HD
	}
	public enum RenderingMode
	{
		MultiPass,
		Default,
		GPUInstancing,
		SRPBatcher
	}
	public enum RenderQueue
	{
		Custom = 0,
		Background = 1000,
		Geometry = 2000,
		AlphaTest = 2450,
		GeometryLast = 2500,
		Transparent = 3000,
		Overlay = 4000
	}
	public enum Dimensions
	{
		Dim3D,
		Dim2D
	}
	public enum PlaneAlignment
	{
		Surface,
		Beam
	}
	[Flags]
	public enum DynamicOcclusionUpdateRate
	{
		Never = 1,
		OnEnable = 2,
		OnBeamMove = 4,
		EveryXFrames = 8,
		OnBeamMoveAndEveryXFrames = 0xC
	}
	public enum ParticlesDirection
	{
		Random,
		LocalSpace,
		WorldSpace
	}
	[Flags]
	public enum ShadowUpdateRate
	{
		Never = 1,
		OnEnable = 2,
		OnBeamMove = 4,
		EveryXFrames = 8,
		OnBeamMoveAndEveryXFrames = 0xC
	}
	public enum CookieChannel
	{
		Red,
		Green,
		Blue,
		Alpha,
		RGBA
	}
	[Flags]
	public enum DirtyProps
	{
		None = 0,
		Intensity = 2,
		HDRPExposureWeight = 4,
		ColorMode = 8,
		Color = 0x10,
		BlendingMode = 0x20,
		Cone = 0x40,
		SideSoftness = 0x80,
		Attenuation = 0x100,
		Dimensions = 0x200,
		RaymarchingQuality = 0x400,
		Jittering = 0x800,
		NoiseMode = 0x1000,
		NoiseIntensity = 0x2000,
		NoiseVelocityAndScale = 0x4000,
		CookieProps = 0x8000,
		ShadowProps = 0x10000,
		AllWithoutMaterialChange = 0x1E8D6,
		OnlyMaterialChangeOnly = 0x1728,
		All = 0x1FFFE
	}
	[Flags]
	public enum BeamProps
	{
		Transform = 1,
		Color = 2,
		BlendingMode = 4,
		Intensity = 8,
		SideSoftness = 0x10,
		SpotShape = 0x20,
		FallOffAttenuation = 0x40,
		Noise3D = 0x80,
		SDConeGeometry = 0x100,
		SDSoftIntersectBlendingDist = 0x200,
		Props2D = 0x400
	}
	[AddComponentMenu("")]
	[ExecuteInEditMode]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam-hd/")]
	public class BeamGeometryHD : BeamGeometryAbstractBase
	{
		public enum InvalidTexture
		{
			Null,
			NoDepth
		}

		private VolumetricLightBeamHD m_Master;

		private VolumetricCookieHD m_Cookie;

		private VolumetricShadowHD m_Shadow;

		private Camera m_CurrentCameraRenderingSRP;

		private DirtyProps m_DirtyProps;

		public bool visible
		{
			set
			{
				if ((bool)base.meshRenderer)
				{
					base.meshRenderer.enabled = value;
				}
			}
		}

		public int sortingLayerID
		{
			set
			{
				if ((bool)base.meshRenderer)
				{
					base.meshRenderer.sortingLayerID = value;
				}
			}
		}

		public int sortingOrder
		{
			set
			{
				if ((bool)base.meshRenderer)
				{
					base.meshRenderer.sortingOrder = value;
				}
			}
		}

		public static bool isCustomRenderPipelineSupported => true;

		private bool shouldUseGPUInstancedMaterial
		{
			get
			{
				if (Config.Instance.GetActualRenderingMode(ShaderMode.HD) == RenderingMode.GPUInstancing)
				{
					if (m_Cookie == null)
					{
						return m_Shadow == null;
					}
					return false;
				}
				return false;
			}
		}

		private bool isNoiseEnabled
		{
			get
			{
				if (m_Master.isNoiseEnabled && m_Master.noiseIntensity > 0f)
				{
					return Noise3D.isSupported;
				}
				return false;
			}
		}

		protected override VolumetricLightBeamAbstractBase GetMaster()
		{
			return m_Master;
		}

		private void OnDisable()
		{
			SRPHelper.UnregisterOnBeginCameraRendering(OnBeginCameraRenderingSRP);
			m_CurrentCameraRenderingSRP = null;
		}

		private void OnEnable()
		{
			SRPHelper.RegisterOnBeginCameraRendering(OnBeginCameraRenderingSRP);
		}

		public void Initialize(VolumetricLightBeamHD master)
		{
			HideFlags proceduralObjectsHideFlags = Consts.Internal.ProceduralObjectsHideFlags;
			m_Master = master;
			base.transform.SetParent(master.transform, worldPositionStays: false);
			base.meshRenderer = base.gameObject.GetOrAddComponent<MeshRenderer>();
			base.meshRenderer.hideFlags = proceduralObjectsHideFlags;
			base.meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
			base.meshRenderer.receiveShadows = false;
			base.meshRenderer.reflectionProbeUsage = ReflectionProbeUsage.Off;
			base.meshRenderer.lightProbeUsage = LightProbeUsage.Off;
			m_Cookie = m_Master.GetAdditionalComponentCookie();
			m_Shadow = m_Master.GetAdditionalComponentShadow();
			if (!shouldUseGPUInstancedMaterial)
			{
				m_CustomMaterial = Config.Instance.NewMaterialTransient(ShaderMode.HD, gpuInstanced: false);
				ApplyMaterial();
			}
			if (m_Master.DoesSupportSorting2D())
			{
				if (SortingLayer.IsValid(m_Master.GetSortingLayerID()))
				{
					sortingLayerID = m_Master.GetSortingLayerID();
				}
				else
				{
					UnityEngine.Debug.LogError($"Beam '{Utils.GetPath(m_Master.transform)}' has an invalid sortingLayerID ({m_Master.GetSortingLayerID()}). Please fix it by setting a valid layer.");
				}
				sortingOrder = m_Master.GetSortingOrder();
			}
			base.meshFilter = base.gameObject.GetOrAddComponent<MeshFilter>();
			base.meshFilter.hideFlags = proceduralObjectsHideFlags;
			base.gameObject.hideFlags = proceduralObjectsHideFlags;
		}

		public void RegenerateMesh()
		{
			if (Config.Instance.geometryOverrideLayer)
			{
				base.gameObject.layer = Config.Instance.geometryLayerID;
			}
			else
			{
				base.gameObject.layer = m_Master.gameObject.layer;
			}
			base.gameObject.tag = Config.Instance.geometryTag;
			base.coneMesh = GlobalMeshHD.Get();
			base.meshFilter.sharedMesh = base.coneMesh;
			UpdateMaterialAndBounds();
		}

		private Vector3 ComputeLocalMatrix()
		{
			float num = Mathf.Max(m_Master.coneRadiusStart, m_Master.coneRadiusEnd);
			Vector3 vector = new Vector3(num, num, m_Master.maxGeometryDistance);
			if (!m_Master.scalable)
			{
				vector = vector.Divide(m_Master.GetLossyScale());
			}
			base.transform.localScale = vector;
			base.transform.localRotation = m_Master.beamInternalLocalRotation;
			return vector;
		}

		private MaterialManager.StaticPropertiesHD ComputeMaterialStaticProperties()
		{
			MaterialManager.ColorGradient colorGradient = MaterialManager.ColorGradient.Off;
			if (m_Master.colorMode == ColorMode.Gradient)
			{
				colorGradient = ((Utils.GetFloatPackingPrecision() != Utils.FloatPackingPrecision.High) ? MaterialManager.ColorGradient.MatrixLow : MaterialManager.ColorGradient.MatrixHigh);
			}
			return new MaterialManager.StaticPropertiesHD
			{
				blendingMode = (MaterialManager.BlendingMode)m_Master.blendingMode,
				attenuation = ((m_Master.attenuationEquation != AttenuationEquationHD.Linear) ? MaterialManager.HD.Attenuation.Quadratic : MaterialManager.HD.Attenuation.Linear),
				noise3D = (isNoiseEnabled ? MaterialManager.Noise3D.On : MaterialManager.Noise3D.Off),
				colorGradient = colorGradient,
				shadow = ((m_Shadow != null) ? MaterialManager.HD.Shadow.On : MaterialManager.HD.Shadow.Off),
				cookie = ((m_Cookie != null) ? ((m_Cookie.channel != CookieChannel.RGBA) ? MaterialManager.HD.Cookie.SingleChannel : MaterialManager.HD.Cookie.RGBA) : MaterialManager.HD.Cookie.Off),
				raymarchingQualityIndex = m_Master.raymarchingQualityIndex
			};
		}

		private bool ApplyMaterial()
		{
			MaterialManager.StaticPropertiesHD staticProps = ComputeMaterialStaticProperties();
			Material material = null;
			if (!shouldUseGPUInstancedMaterial)
			{
				material = m_CustomMaterial;
				if ((bool)material)
				{
					staticProps.ApplyToMaterial(material);
				}
			}
			else
			{
				material = MaterialManager.GetInstancedMaterial(m_Master._INTERNAL_InstancedMaterialGroupID, ref staticProps);
			}
			base.meshRenderer.material = material;
			return material != null;
		}

		public void SetMaterialProp(int nameID, float value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetFloat(nameID, value);
			}
			else
			{
				MaterialManager.materialPropertyBlock.SetFloat(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, Vector4 value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetVector(nameID, value);
			}
			else
			{
				MaterialManager.materialPropertyBlock.SetVector(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, Color value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetColor(nameID, value);
			}
			else
			{
				MaterialManager.materialPropertyBlock.SetColor(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, Matrix4x4 value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetMatrix(nameID, value);
			}
			else
			{
				MaterialManager.materialPropertyBlock.SetMatrix(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, Texture value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetTexture(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, InvalidTexture invalidTexture)
		{
			if ((bool)m_CustomMaterial)
			{
				Texture value = null;
				if (invalidTexture == InvalidTexture.NoDepth)
				{
					value = (SystemInfo.usesReversedZBuffer ? Texture2D.blackTexture : Texture2D.whiteTexture);
				}
				m_CustomMaterial.SetTexture(nameID, value);
			}
		}

		private void MaterialChangeStart()
		{
			if (m_CustomMaterial == null)
			{
				base.meshRenderer.GetPropertyBlock(MaterialManager.materialPropertyBlock);
			}
		}

		private void MaterialChangeStop()
		{
			if (m_CustomMaterial == null)
			{
				base.meshRenderer.SetPropertyBlock(MaterialManager.materialPropertyBlock);
			}
		}

		public void SetPropertyDirty(DirtyProps prop)
		{
			m_DirtyProps |= prop;
			if (prop.HasAtLeastOneFlag(DirtyProps.OnlyMaterialChangeOnly))
			{
				UpdateMaterialAndBounds();
			}
		}

		private void UpdateMaterialAndBounds()
		{
			if (ApplyMaterial())
			{
				MaterialChangeStart();
				m_DirtyProps = DirtyProps.All;
				if (isNoiseEnabled)
				{
					Noise3D.LoadIfNeeded();
				}
				ComputeLocalMatrix();
				UpdateMatricesPropertiesForGPUInstancingSRP();
				MaterialChangeStop();
			}
		}

		private void UpdateMatricesPropertiesForGPUInstancingSRP()
		{
			if (SRPHelper.IsUsingCustomRenderPipeline() && Config.Instance.GetActualRenderingMode(ShaderMode.HD) == RenderingMode.GPUInstancing)
			{
				SetMaterialProp(ShaderProperties.LocalToWorldMatrix, base.transform.localToWorldMatrix);
				SetMaterialProp(ShaderProperties.WorldToLocalMatrix, base.transform.worldToLocalMatrix);
			}
		}

		private void OnBeginCameraRenderingSRP(ScriptableRenderContext context, Camera cam)
		{
			m_CurrentCameraRenderingSRP = cam;
		}

		private void OnWillRenderObject()
		{
			Camera camera = null;
			camera = ((!SRPHelper.IsUsingCustomRenderPipeline()) ? Camera.current : m_CurrentCameraRenderingSRP);
			OnWillCameraRenderThisBeam(camera);
		}

		private void OnWillCameraRenderThisBeam(Camera cam)
		{
			if ((bool)m_Master && (bool)cam && cam.enabled)
			{
				UpdateMaterialPropertiesForCamera(cam);
				if ((bool)m_Shadow)
				{
					m_Shadow.OnWillCameraRenderThisBeam(cam, this);
				}
			}
		}

		private void UpdateDirtyMaterialProperties()
		{
			if (m_DirtyProps == DirtyProps.None)
			{
				return;
			}
			if (m_DirtyProps.HasFlag(DirtyProps.Intensity))
			{
				SetMaterialProp(ShaderProperties.HD.Intensity, m_Master.intensity);
			}
			if (m_DirtyProps.HasFlag(DirtyProps.HDRPExposureWeight) && Config.Instance.isHDRPExposureWeightSupported)
			{
				SetMaterialProp(ShaderProperties.HDRPExposureWeight, m_Master.hdrpExposureWeight);
			}
			if (m_DirtyProps.HasFlag(DirtyProps.SideSoftness))
			{
				SetMaterialProp(ShaderProperties.HD.SideSoftness, m_Master.sideSoftness);
			}
			if (m_DirtyProps.HasFlag(DirtyProps.Color))
			{
				if (m_Master.colorMode == ColorMode.Flat)
				{
					SetMaterialProp(ShaderProperties.ColorFlat, m_Master.colorFlat);
				}
				else
				{
					Utils.FloatPackingPrecision floatPackingPrecision = Utils.GetFloatPackingPrecision();
					m_ColorGradientMatrix = m_Master.colorGradient.SampleInMatrix((int)floatPackingPrecision);
				}
			}
			if (m_DirtyProps.HasFlag(DirtyProps.Cone))
			{
				SetMaterialProp(value: new Vector2(Mathf.Max(m_Master.coneRadiusStart, 0.0001f), Mathf.Max(m_Master.coneRadiusEnd, 0.0001f)), nameID: ShaderProperties.ConeRadius);
				float coneApexOffsetZ = m_Master.GetConeApexOffsetZ(counterApplyScaleForUnscalableBeam: false);
				float x = Mathf.Sign(coneApexOffsetZ) * Mathf.Max(Mathf.Abs(coneApexOffsetZ), 0.0001f);
				SetMaterialProp(ShaderProperties.ConeGeomProps, new Vector2(x, Config.Instance.sharedMeshSides));
				SetMaterialProp(ShaderProperties.DistanceFallOff, new Vector3(m_Master.fallOffStart, m_Master.fallOffEnd, m_Master.maxGeometryDistance));
				ComputeLocalMatrix();
			}
			if (m_DirtyProps.HasFlag(DirtyProps.Jittering))
			{
				SetMaterialProp(ShaderProperties.HD.Jittering, new Vector4(m_Master.jitteringFactor, m_Master.jitteringFrameRate, m_Master.jitteringLerpRange.minValue, m_Master.jitteringLerpRange.maxValue));
			}
			if (isNoiseEnabled)
			{
				if (m_DirtyProps.HasFlag(DirtyProps.NoiseMode) || m_DirtyProps.HasFlag(DirtyProps.NoiseIntensity))
				{
					SetMaterialProp(ShaderProperties.NoiseParam, new Vector2(m_Master.noiseIntensity, (m_Master.noiseMode == NoiseMode.WorldSpace) ? 0f : 1f));
				}
				if (m_DirtyProps.HasFlag(DirtyProps.NoiseVelocityAndScale))
				{
					Vector3 vector = (m_Master.noiseVelocityUseGlobal ? Config.Instance.globalNoiseVelocity : m_Master.noiseVelocityLocal);
					float w = (m_Master.noiseScaleUseGlobal ? Config.Instance.globalNoiseScale : m_Master.noiseScaleLocal);
					SetMaterialProp(ShaderProperties.NoiseVelocityAndScale, new Vector4(vector.x, vector.y, vector.z, w));
				}
			}
			if (m_DirtyProps.HasFlag(DirtyProps.CookieProps))
			{
				VolumetricCookieHD.ApplyMaterialProperties(m_Cookie, this);
			}
			if (m_DirtyProps.HasFlag(DirtyProps.ShadowProps))
			{
				VolumetricShadowHD.ApplyMaterialProperties(m_Shadow, this);
			}
			m_DirtyProps = DirtyProps.None;
		}

		private void UpdateMaterialPropertiesForCamera(Camera cam)
		{
			if ((bool)cam && (bool)m_Master)
			{
				MaterialChangeStart();
				SetMaterialProp(ShaderProperties.HD.TransformScale, m_Master.scalable ? m_Master.GetLossyScale() : Vector3.one);
				Vector3 normalized = base.transform.InverseTransformDirection(cam.transform.forward).normalized;
				SetMaterialProp(ShaderProperties.HD.CameraForwardOS, normalized);
				SetMaterialProp(ShaderProperties.HD.CameraForwardWS, cam.transform.forward);
				UpdateDirtyMaterialProperties();
				if (m_Master.colorMode == ColorMode.Gradient)
				{
					SetMaterialProp(ShaderProperties.ColorGradientMatrix, m_ColorGradientMatrix);
				}
				UpdateMatricesPropertiesForGPUInstancingSRP();
				MaterialChangeStop();
				cam.depthTextureMode |= DepthTextureMode.Depth;
			}
		}
	}
	public static class GlobalMeshHD
	{
		private static Mesh ms_Mesh;

		public static Mesh Get()
		{
			if (ms_Mesh == null)
			{
				Destroy();
				ms_Mesh = MeshGenerator.GenerateConeZ_Radii_DoubleCaps(1f, 1f, 1f, Config.Instance.sharedMeshSides, inverted: true);
				ms_Mesh.hideFlags = Consts.Internal.ProceduralObjectsHideFlags;
			}
			return ms_Mesh;
		}

		public static void Destroy()
		{
			if (ms_Mesh != null)
			{
				UnityEngine.Object.DestroyImmediate(ms_Mesh);
				ms_Mesh = null;
			}
		}
	}
	[Serializable]
	public class RaymarchingQuality
	{
		public string name;

		public int stepCount;

		[SerializeField]
		private int _UniqueID;

		private static RaymarchingQuality ms_DefaultInstance = new RaymarchingQuality(-1);

		private const int kRandomUniqueIdMinRange = 4;

		public int uniqueID => _UniqueID;

		public bool hasValidUniqueID => _UniqueID >= 0;

		public static RaymarchingQuality defaultInstance => ms_DefaultInstance;

		private RaymarchingQuality(int uniqueID)
		{
			_UniqueID = uniqueID;
			name = "New quality";
			stepCount = 10;
		}

		public static RaymarchingQuality New()
		{
			return new RaymarchingQuality(UnityEngine.Random.Range(4, int.MaxValue));
		}

		public static RaymarchingQuality New(string name, int forcedUniqueID, int stepCount)
		{
			return new RaymarchingQuality(forcedUniqueID)
			{
				name = name,
				stepCount = stepCount
			};
		}

		private static bool HasRaymarchingQualityWithSameUniqueID(RaymarchingQuality[] values, int id)
		{
			foreach (RaymarchingQuality raymarchingQuality in values)
			{
				if (raymarchingQuality != null && raymarchingQuality.uniqueID == id)
				{
					return true;
				}
			}
			return false;
		}
	}
	[DisallowMultipleComponent]
	[RequireComponent(typeof(Light), typeof(VolumetricLightBeamHD))]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-trackrealtimechanges-hd/")]
	[AddComponentMenu("VLB/HD/Track Realtime Changes On Light")]
	public class TrackRealtimeChangesOnLightHD : MonoBehaviour
	{
		public const string ClassName = "TrackRealtimeChangesOnLightHD";

		private VolumetricLightBeamHD m_Master;

		private void Awake()
		{
			m_Master = GetComponent<VolumetricLightBeamHD>();
		}

		private void Update()
		{
			if (m_Master.enabled)
			{
				m_Master.AssignPropertiesFromAttachedSpotLight();
			}
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(VolumetricLightBeamHD))]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-cookie-hd/")]
	[AddComponentMenu("VLB/HD/Volumetric Cookie HD")]
	public class VolumetricCookieHD : MonoBehaviour
	{
		public const string ClassName = "VolumetricCookieHD";

		[SerializeField]
		private float m_Contribution = 1f;

		[SerializeField]
		private Texture m_CookieTexture;

		[SerializeField]
		private CookieChannel m_Channel = CookieChannel.Alpha;

		[SerializeField]
		private bool m_Negative;

		[SerializeField]
		private Vector2 m_Translation = Consts.Cookie.TranslationDefault;

		[SerializeField]
		private float m_Rotation;

		[SerializeField]
		private Vector2 m_Scale = Consts.Cookie.ScaleDefault;

		private VolumetricLightBeamHD m_Master;

		public float contribution
		{
			get
			{
				return m_Contribution;
			}
			set
			{
				if (m_Contribution != value)
				{
					m_Contribution = value;
					SetDirty();
				}
			}
		}

		public Texture cookieTexture
		{
			get
			{
				return m_CookieTexture;
			}
			set
			{
				if (m_CookieTexture != value)
				{
					m_CookieTexture = value;
					SetDirty();
				}
			}
		}

		public CookieChannel channel
		{
			get
			{
				return m_Channel;
			}
			set
			{
				if (m_Channel != value)
				{
					m_Channel = value;
					SetDirty();
				}
			}
		}

		public bool negative
		{
			get
			{
				return m_Negative;
			}
			set
			{
				if (m_Negative != value)
				{
					m_Negative = value;
					SetDirty();
				}
			}
		}

		public Vector2 translation
		{
			get
			{
				return m_Translation;
			}
			set
			{
				if (m_Translation != value)
				{
					m_Translation = value;
					SetDirty();
				}
			}
		}

		public float rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
					SetDirty();
				}
			}
		}

		public Vector2 scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
					SetDirty();
				}
			}
		}

		private void SetDirty()
		{
			if ((bool)m_Master)
			{
				m_Master.SetPropertyDirty(DirtyProps.CookieProps);
			}
		}

		public static void ApplyMaterialProperties(VolumetricCookieHD instance, BeamGeometryHD geom)
		{
			if ((bool)instance && instance.enabled && instance.cookieTexture != null)
			{
				geom.SetMaterialProp(ShaderProperties.HD.CookieTexture, instance.cookieTexture);
				geom.SetMaterialProp(ShaderProperties.HD.CookieProperties, new Vector4(instance.negative ? instance.contribution : (0f - instance.contribution), (float)instance.channel, Mathf.Cos(instance.rotation * (MathF.PI / 180f)), Mathf.Sin(instance.rotation * (MathF.PI / 180f))));
				geom.SetMaterialProp(ShaderProperties.HD.CookiePosAndScale, new Vector4(instance.translation.x, instance.translation.y, instance.scale.x, instance.scale.y));
			}
			else
			{
				geom.SetMaterialProp(ShaderProperties.HD.CookieTexture, BeamGeometryHD.InvalidTexture.Null);
				geom.SetMaterialProp(ShaderProperties.HD.CookieProperties, Vector4.zero);
			}
		}

		private void Awake()
		{
			m_Master = GetComponent<VolumetricLightBeamHD>();
		}

		private void OnEnable()
		{
			SetDirty();
		}

		private void OnDisable()
		{
			SetDirty();
		}

		private void OnDidApplyAnimationProperties()
		{
			SetDirty();
		}

		private void Start()
		{
			if (Application.isPlaying)
			{
				SetDirty();
			}
		}

		private void OnDestroy()
		{
			if (Application.isPlaying)
			{
				SetDirty();
			}
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[SelectionBase]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam-hd/")]
	[AddComponentMenu("VLB/HD/Volumetric Light Beam HD")]
	public class VolumetricLightBeamHD : VolumetricLightBeamAbstractBase
	{
		public new const string ClassName = "VolumetricLightBeamHD";

		[SerializeField]
		private bool m_ColorFromLight = true;

		[SerializeField]
		private ColorMode m_ColorMode;

		[SerializeField]
		private Color m_ColorFlat = Consts.Beam.FlatColor;

		[SerializeField]
		private Gradient m_ColorGradient;

		[SerializeField]
		private BlendingMode m_BlendingMode;

		[SerializeField]
		private float m_Intensity = 1f;

		[SerializeField]
		private float m_IntensityMultiplier = 1f;

		[SerializeField]
		private float m_HDRPExposureWeight;

		[SerializeField]
		private float m_SpotAngle = 35f;

		[SerializeField]
		private float m_SpotAngleMultiplier = 1f;

		[SerializeField]
		private float m_ConeRadiusStart = 0.1f;

		[SerializeField]
		private bool m_Scalable = true;

		[SerializeField]
		private float m_FallOffStart;

		[SerializeField]
		private float m_FallOffEnd = 3f;

		[SerializeField]
		private float m_FallOffEndMultiplier = 1f;

		[SerializeField]
		private AttenuationEquationHD m_AttenuationEquation = AttenuationEquationHD.Quadratic;

		[SerializeField]
		private float m_SideSoftness = 1f;

		[SerializeField]
		private int m_RaymarchingQualityID = -1;

		[SerializeField]
		private float m_JitteringFactor;

		[SerializeField]
		private int m_JitteringFrameRate = 60;

		[MinMaxRange(0f, 1f)]
		[SerializeField]
		private MinMaxRangeFloat m_JitteringLerpRange = Consts.Beam.HD.JitteringLerpRange;

		[SerializeField]
		private NoiseMode m_NoiseMode;

		[SerializeField]
		private float m_NoiseIntensity = 0.5f;

		[SerializeField]
		private bool m_NoiseScaleUseGlobal = true;

		[SerializeField]
		private float m_NoiseScaleLocal = 0.5f;

		[SerializeField]
		private bool m_NoiseVelocityUseGlobal = true;

		[SerializeField]
		private Vector3 m_NoiseVelocityLocal = Consts.Beam.NoiseVelocityDefault;

		protected BeamGeometryHD m_BeamGeom;

		public bool colorFromLight
		{
			get
			{
				return m_ColorFromLight;
			}
			set
			{
				if (m_ColorFromLight != value)
				{
					m_ColorFromLight = value;
					ValidateProperties();
				}
			}
		}

		public ColorMode colorMode
		{
			get
			{
				if (Config.Instance.featureEnabledColorGradient == FeatureEnabledColorGradient.Off)
				{
					return ColorMode.Flat;
				}
				return m_ColorMode;
			}
			set
			{
				if (m_ColorMode != value)
				{
					m_ColorMode = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.ColorMode);
				}
			}
		}

		public Color colorFlat
		{
			get
			{
				return m_ColorFlat;
			}
			set
			{
				if (m_ColorFlat != value)
				{
					m_ColorFlat = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Color);
				}
			}
		}

		public Gradient colorGradient
		{
			get
			{
				return m_ColorGradient;
			}
			set
			{
				if (m_ColorGradient != value)
				{
					m_ColorGradient = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Color);
				}
			}
		}

		private bool useColorFromAttachedLightSpot
		{
			get
			{
				if (colorFromLight)
				{
					return base.lightSpotAttached != null;
				}
				return false;
			}
		}

		private bool useColorTemperatureFromAttachedLightSpot
		{
			get
			{
				if (useColorFromAttachedLightSpot && base.lightSpotAttached.useColorTemperature)
				{
					return Config.Instance.useLightColorTemperature;
				}
				return false;
			}
		}

		public float intensity
		{
			get
			{
				return m_Intensity;
			}
			set
			{
				if (m_Intensity != value)
				{
					m_Intensity = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Intensity);
				}
			}
		}

		public float intensityMultiplier
		{
			get
			{
				return m_IntensityMultiplier;
			}
			set
			{
				if (m_IntensityMultiplier != value)
				{
					m_IntensityMultiplier = value;
					ValidateProperties();
				}
			}
		}

		public bool useIntensityFromAttachedLightSpot
		{
			get
			{
				if (intensityMultiplier >= 0f)
				{
					return base.lightSpotAttached != null;
				}
				return false;
			}
			set
			{
				intensityMultiplier = (value ? 1f : (-1f)) * Mathf.Abs(intensityMultiplier);
			}
		}

		public float hdrpExposureWeight
		{
			get
			{
				return m_HDRPExposureWeight;
			}
			set
			{
				if (m_HDRPExposureWeight != value)
				{
					m_HDRPExposureWeight = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.HDRPExposureWeight);
				}
			}
		}

		public BlendingMode blendingMode
		{
			get
			{
				return m_BlendingMode;
			}
			set
			{
				if (m_BlendingMode != value)
				{
					m_BlendingMode = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.BlendingMode);
				}
			}
		}

		public float spotAngle
		{
			get
			{
				return m_SpotAngle;
			}
			set
			{
				if (m_SpotAngle != value)
				{
					m_SpotAngle = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Cone);
				}
			}
		}

		public float spotAngleMultiplier
		{
			get
			{
				return m_SpotAngleMultiplier;
			}
			set
			{
				if (m_SpotAngleMultiplier != value)
				{
					m_SpotAngleMultiplier = value;
					ValidateProperties();
				}
			}
		}

		public bool useSpotAngleFromAttachedLightSpot
		{
			get
			{
				if (spotAngleMultiplier >= 0f)
				{
					return base.lightSpotAttached != null;
				}
				return false;
			}
			set
			{
				spotAngleMultiplier = (value ? 1f : (-1f)) * Mathf.Abs(spotAngleMultiplier);
			}
		}

		public float coneAngle => Mathf.Atan2(coneRadiusEnd - coneRadiusStart, maxGeometryDistance) * 57.29578f * 2f;

		public float coneRadiusStart
		{
			get
			{
				return m_ConeRadiusStart;
			}
			set
			{
				if (m_ConeRadiusStart != value)
				{
					m_ConeRadiusStart = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Cone);
				}
			}
		}

		public float coneRadiusEnd
		{
			get
			{
				return Utils.ComputeConeRadiusEnd(maxGeometryDistance, spotAngle);
			}
			set
			{
				spotAngle = Utils.ComputeSpotAngle(maxGeometryDistance, value);
			}
		}

		public float coneVolume
		{
			get
			{
				float num = coneRadiusStart;
				float num2 = coneRadiusEnd;
				return MathF.PI / 3f * (num * num + num * num2 + num2 * num2) * fallOffEnd;
			}
		}

		public bool scalable
		{
			get
			{
				return m_Scalable;
			}
			set
			{
				if (m_Scalable != value)
				{
					m_Scalable = value;
					SetPropertyDirty(DirtyProps.Attenuation);
				}
			}
		}

		public AttenuationEquationHD attenuationEquation
		{
			get
			{
				return m_AttenuationEquation;
			}
			set
			{
				if (m_AttenuationEquation != value)
				{
					m_AttenuationEquation = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Attenuation);
				}
			}
		}

		public float fallOffStart
		{
			get
			{
				return m_FallOffStart;
			}
			set
			{
				if (m_FallOffStart != value)
				{
					m_FallOffStart = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Cone);
				}
			}
		}

		public float fallOffEnd
		{
			get
			{
				return m_FallOffEnd;
			}
			set
			{
				if (m_FallOffEnd != value)
				{
					m_FallOffEnd = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Cone);
				}
			}
		}

		public float maxGeometryDistance => fallOffEnd;

		public float fallOffEndMultiplier
		{
			get
			{
				return m_FallOffEndMultiplier;
			}
			set
			{
				if (m_FallOffEndMultiplier != value)
				{
					m_FallOffEndMultiplier = value;
					ValidateProperties();
				}
			}
		}

		public bool useFallOffEndFromAttachedLightSpot
		{
			get
			{
				if (fallOffEndMultiplier >= 0f)
				{
					return base.lightSpotAttached != null;
				}
				return false;
			}
			set
			{
				fallOffEndMultiplier = (value ? 1f : (-1f)) * Mathf.Abs(fallOffEndMultiplier);
			}
		}

		public float sideSoftness
		{
			get
			{
				return m_SideSoftness;
			}
			set
			{
				if (m_SideSoftness != value)
				{
					m_SideSoftness = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.SideSoftness);
				}
			}
		}

		public float jitteringFactor
		{
			get
			{
				return m_JitteringFactor;
			}
			set
			{
				if (m_JitteringFactor != value)
				{
					m_JitteringFactor = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Jittering);
				}
			}
		}

		public int jitteringFrameRate
		{
			get
			{
				return m_JitteringFrameRate;
			}
			set
			{
				if (m_JitteringFrameRate != value)
				{
					m_JitteringFrameRate = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Jittering);
				}
			}
		}

		public MinMaxRangeFloat jitteringLerpRange
		{
			get
			{
				return m_JitteringLerpRange;
			}
			set
			{
				if (m_JitteringLerpRange != value)
				{
					m_JitteringLerpRange = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.Jittering);
				}
			}
		}

		public NoiseMode noiseMode
		{
			get
			{
				return m_NoiseMode;
			}
			set
			{
				if (m_NoiseMode != value)
				{
					m_NoiseMode = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.NoiseMode);
				}
			}
		}

		public bool isNoiseEnabled => noiseMode != NoiseMode.Disabled;

		public float noiseIntensity
		{
			get
			{
				return m_NoiseIntensity;
			}
			set
			{
				if (m_NoiseIntensity != value)
				{
					m_NoiseIntensity = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.NoiseIntensity);
				}
			}
		}

		public bool noiseScaleUseGlobal
		{
			get
			{
				return m_NoiseScaleUseGlobal;
			}
			set
			{
				if (m_NoiseScaleUseGlobal != value)
				{
					m_NoiseScaleUseGlobal = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.NoiseVelocityAndScale);
				}
			}
		}

		public float noiseScaleLocal
		{
			get
			{
				return m_NoiseScaleLocal;
			}
			set
			{
				if (m_NoiseScaleLocal != value)
				{
					m_NoiseScaleLocal = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.NoiseVelocityAndScale);
				}
			}
		}

		public bool noiseVelocityUseGlobal
		{
			get
			{
				return m_NoiseVelocityUseGlobal;
			}
			set
			{
				if (m_NoiseVelocityUseGlobal != value)
				{
					m_NoiseVelocityUseGlobal = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.NoiseVelocityAndScale);
				}
			}
		}

		public Vector3 noiseVelocityLocal
		{
			get
			{
				return m_NoiseVelocityLocal;
			}
			set
			{
				if (m_NoiseVelocityLocal != value)
				{
					m_NoiseVelocityLocal = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.NoiseVelocityAndScale);
				}
			}
		}

		public int raymarchingQualityID
		{
			get
			{
				return m_RaymarchingQualityID;
			}
			set
			{
				if (m_RaymarchingQualityID != value)
				{
					m_RaymarchingQualityID = value;
					ValidateProperties();
					SetPropertyDirty(DirtyProps.RaymarchingQuality);
				}
			}
		}

		public int raymarchingQualityIndex
		{
			get
			{
				return Config.Instance.GetRaymarchingQualityIndexForUniqueID(raymarchingQualityID);
			}
			set
			{
				raymarchingQualityID = Config.Instance.GetRaymarchingQualityForIndex(raymarchingQualityIndex).uniqueID;
			}
		}

		public int blendingModeAsInt => Mathf.Clamp((int)blendingMode, 0, Enum.GetValues(typeof(BlendingMode)).Length);

		public Quaternion beamInternalLocalRotation
		{
			get
			{
				if (GetDimensions() != Dimensions.Dim3D)
				{
					return Quaternion.LookRotation(Vector3.right, Vector3.up);
				}
				return Quaternion.identity;
			}
		}

		public Vector3 beamLocalForward
		{
			get
			{
				if (GetDimensions() != Dimensions.Dim3D)
				{
					return Vector3.right;
				}
				return Vector3.forward;
			}
		}

		public Vector3 beamGlobalForward => base.transform.TransformDirection(beamLocalForward);

		public uint _INTERNAL_InstancedMaterialGroupID { get; protected set; }

		public float GetConeApexOffsetZ(bool counterApplyScaleForUnscalableBeam)
		{
			float num = coneRadiusStart / coneRadiusEnd;
			if (num == 1f)
			{
				return float.MaxValue;
			}
			float num2 = maxGeometryDistance * num / (1f - num);
			if (counterApplyScaleForUnscalableBeam && !scalable)
			{
				num2 /= GetLossyScale().z;
			}
			return num2;
		}

		public override bool IsScalable()
		{
			return scalable;
		}

		public override BeamGeometryAbstractBase GetBeamGeometry()
		{
			return m_BeamGeom;
		}

		protected override void SetBeamGeometryNull()
		{
			m_BeamGeom = null;
		}

		public override Vector3 GetLossyScale()
		{
			if (GetDimensions() != Dimensions.Dim3D)
			{
				return new Vector3(base.transform.lossyScale.z, base.transform.lossyScale.y, base.transform.lossyScale.x);
			}
			return base.transform.lossyScale;
		}

		public VolumetricCookieHD GetAdditionalComponentCookie()
		{
			return GetComponent<VolumetricCookieHD>();
		}

		public VolumetricShadowHD GetAdditionalComponentShadow()
		{
			return GetComponent<VolumetricShadowHD>();
		}

		public void SetPropertyDirty(DirtyProps flags)
		{
			if ((bool)m_BeamGeom)
			{
				m_BeamGeom.SetPropertyDirty(flags);
			}
		}

		public virtual Dimensions GetDimensions()
		{
			return Dimensions.Dim3D;
		}

		public virtual bool DoesSupportSorting2D()
		{
			return false;
		}

		public virtual int GetSortingLayerID()
		{
			return 0;
		}

		public virtual int GetSortingOrder()
		{
			return 0;
		}

		public float GetInsideBeamFactor(Vector3 posWS)
		{
			return GetInsideBeamFactorFromObjectSpacePos(base.transform.InverseTransformPoint(posWS));
		}

		public float GetInsideBeamFactorFromObjectSpacePos(Vector3 posOS)
		{
			if (GetDimensions() == Dimensions.Dim2D)
			{
				posOS = new Vector3(posOS.z, posOS.y, posOS.x);
			}
			if (posOS.z < 0f)
			{
				return -1f;
			}
			Vector2 normalized = new Vector2(posOS.xy().magnitude, posOS.z + GetConeApexOffsetZ(counterApplyScaleForUnscalableBeam: true)).normalized;
			return Mathf.Clamp((Mathf.Abs(Mathf.Sin(coneAngle * (MathF.PI / 180f) / 2f)) - Mathf.Abs(normalized.x)) / 0.1f, -1f, 1f);
		}

		public override void GenerateGeometry()
		{
			if (pluginVersion == -1)
			{
				raymarchingQualityID = Config.Instance.defaultRaymarchingQualityUniqueID;
			}
			if (!Config.Instance.IsRaymarchingQualityUniqueIDValid(raymarchingQualityID))
			{
				UnityEngine.Debug.LogErrorFormat(base.gameObject, "HD Beam '{0}': fallback to default quality '{1}'", base.name, Config.Instance.GetRaymarchingQualityForUniqueID(Config.Instance.defaultRaymarchingQualityUniqueID).name);
				raymarchingQualityID = Config.Instance.defaultRaymarchingQualityUniqueID;
				Utils.MarkCurrentSceneDirty();
			}
			HandleBackwardCompatibility(pluginVersion, 20200);
			pluginVersion = 20200;
			ValidateProperties();
			if (m_BeamGeom == null)
			{
				m_BeamGeom = Utils.NewWithComponent<BeamGeometryHD>("Beam Geometry");
				m_BeamGeom.Initialize(this);
			}
			m_BeamGeom.RegenerateMesh();
			m_BeamGeom.visible = base.enabled;
			base.GenerateGeometry();
		}

		public virtual void UpdateAfterManualPropertyChange()
		{
			ValidateProperties();
			SetPropertyDirty(DirtyProps.All);
		}

		private void Start()
		{
			InitLightSpotAttachedCached();
			GenerateGeometry();
		}

		private void OnEnable()
		{
			if ((bool)m_BeamGeom)
			{
				m_BeamGeom.visible = true;
			}
		}

		private void OnDisable()
		{
			if ((bool)m_BeamGeom)
			{
				m_BeamGeom.visible = false;
			}
		}

		private void OnDidApplyAnimationProperties()
		{
			AssignPropertiesFromAttachedSpotLight();
			UpdateAfterManualPropertyChange();
		}

		public void AssignPropertiesFromAttachedSpotLight()
		{
			Light light = base.lightSpotAttached;
			if (!light)
			{
				return;
			}
			if (useIntensityFromAttachedLightSpot)
			{
				intensity = SpotLightHelper.GetIntensity(light) * intensityMultiplier;
			}
			if (useFallOffEndFromAttachedLightSpot)
			{
				fallOffEnd = SpotLightHelper.GetFallOffEnd(light) * fallOffEndMultiplier;
			}
			if (useSpotAngleFromAttachedLightSpot)
			{
				spotAngle = Mathf.Clamp(SpotLightHelper.GetSpotAngle(light) * spotAngleMultiplier, 0.1f, 179.9f);
			}
			if (m_ColorFromLight)
			{
				colorMode = ColorMode.Flat;
				if (useColorTemperatureFromAttachedLightSpot)
				{
					Color color = Mathf.CorrelatedColorTemperatureToRGB(light.colorTemperature);
					colorFlat = (light.color.linear * color).gamma;
				}
				else
				{
					colorFlat = light.color;
				}
			}
		}

		private void ClampProperties()
		{
			m_Intensity = Mathf.Max(m_Intensity, 0f);
			m_FallOffEnd = Mathf.Max(0.01f, m_FallOffEnd);
			m_FallOffStart = Mathf.Clamp(m_FallOffStart, 0f, m_FallOffEnd - 0.01f);
			m_SpotAngle = Mathf.Clamp(m_SpotAngle, 0.1f, 179.9f);
			m_ConeRadiusStart = Mathf.Max(m_ConeRadiusStart, 0f);
			m_SideSoftness = Mathf.Clamp(m_SideSoftness, 0.0001f, 10f);
			m_JitteringFactor = Mathf.Max(m_JitteringFactor, 0f);
			m_JitteringFrameRate = Mathf.Clamp(m_JitteringFrameRate, 0, 120);
			m_NoiseIntensity = Mathf.Clamp(m_NoiseIntensity, 0f, 1f);
		}

		private void ValidateProperties()
		{
			AssignPropertiesFromAttachedSpotLight();
			ClampProperties();
		}

		private void HandleBackwardCompatibility(int serializedVersion, int newVersion)
		{
			if (serializedVersion != -1 && serializedVersion != newVersion)
			{
				Utils.MarkCurrentSceneDirty();
			}
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[SelectionBase]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam-hd/")]
	[AddComponentMenu("VLB/HD/Volumetric Light Beam HD (2D)")]
	public class VolumetricLightBeamHD2D : VolumetricLightBeamHD
	{
		[SerializeField]
		private int m_SortingLayerID;

		[SerializeField]
		private int m_SortingOrder;

		public int sortingLayerID
		{
			get
			{
				return m_SortingLayerID;
			}
			set
			{
				m_SortingLayerID = value;
				if ((bool)m_BeamGeom)
				{
					m_BeamGeom.sortingLayerID = value;
				}
			}
		}

		public string sortingLayerName
		{
			get
			{
				return SortingLayer.IDToName(sortingLayerID);
			}
			set
			{
				sortingLayerID = SortingLayer.NameToID(value);
			}
		}

		public int sortingOrder
		{
			get
			{
				return m_SortingOrder;
			}
			set
			{
				m_SortingOrder = value;
				if ((bool)m_BeamGeom)
				{
					m_BeamGeom.sortingOrder = value;
				}
			}
		}

		public override Dimensions GetDimensions()
		{
			return Dimensions.Dim2D;
		}

		public override bool DoesSupportSorting2D()
		{
			return true;
		}

		public override int GetSortingLayerID()
		{
			return sortingLayerID;
		}

		public override int GetSortingOrder()
		{
			return sortingOrder;
		}

		public override void CopyPropsFrom(VolumetricLightBeamAbstractBase beamSrc, BeamProps beamProps)
		{
			base.CopyPropsFrom(beamSrc, beamProps);
			if (beamSrc is VolumetricLightBeamSD)
			{
				VolumetricLightBeamSD volumetricLightBeamSD = beamSrc as VolumetricLightBeamSD;
				if (beamProps.HasFlag(BeamProps.Props2D))
				{
					sortingLayerID = volumetricLightBeamSD.sortingLayerID;
					sortingOrder = volumetricLightBeamSD.sortingOrder;
				}
			}
			else if (beamSrc is VolumetricLightBeamHD2D)
			{
				VolumetricLightBeamHD2D volumetricLightBeamHD2D = beamSrc as VolumetricLightBeamHD2D;
				if (beamProps.HasFlag(BeamProps.Props2D))
				{
					sortingLayerID = volumetricLightBeamHD2D.sortingLayerID;
					sortingOrder = volumetricLightBeamHD2D.sortingOrder;
				}
			}
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(VolumetricLightBeamHD))]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-shadow-hd/")]
	[AddComponentMenu("VLB/HD/Volumetric Shadow HD")]
	public class VolumetricShadowHD : MonoBehaviour
	{
		private enum ProcessOcclusionSource
		{
			RenderLoop,
			OnEnable,
			EditorUpdate,
			User
		}

		public const string ClassName = "VolumetricShadowHD";

		[SerializeField]
		private float m_Strength = 1f;

		[SerializeField]
		private ShadowUpdateRate m_UpdateRate = ShadowUpdateRate.EveryXFrames;

		[SerializeField]
		private int m_WaitXFrames = 3;

		[SerializeField]
		private LayerMask m_LayerMask = Consts.Shadow.LayerMaskDefault;

		[SerializeField]
		private bool m_UseOcclusionCulling = true;

		[SerializeField]
		private int m_DepthMapResolution = 128;

		private VolumetricLightBeamHD m_Master;

		private TransformUtils.Packed m_TransformPacked;

		private int m_LastFrameRendered = int.MinValue;

		private Camera m_DepthCamera;

		private bool m_NeedToUpdateOcclusionNextFrame;

		public static bool _INTERNAL_ApplyRandomFrameOffset = true;

		public float strength
		{
			get
			{
				return m_Strength;
			}
			set
			{
				if (m_Strength != value)
				{
					m_Strength = value;
					SetDirty();
				}
			}
		}

		public ShadowUpdateRate updateRate
		{
			get
			{
				return m_UpdateRate;
			}
			set
			{
				m_UpdateRate = value;
			}
		}

		public int waitXFrames
		{
			get
			{
				return m_WaitXFrames;
			}
			set
			{
				m_WaitXFrames = value;
			}
		}

		public LayerMask layerMask
		{
			get
			{
				return m_LayerMask;
			}
			set
			{
				m_LayerMask = value;
				UpdateDepthCameraProperties();
			}
		}

		public bool useOcclusionCulling
		{
			get
			{
				return m_UseOcclusionCulling;
			}
			set
			{
				m_UseOcclusionCulling = value;
				UpdateDepthCameraProperties();
			}
		}

		public int depthMapResolution
		{
			get
			{
				return m_DepthMapResolution;
			}
			set
			{
				if (m_DepthCamera != null && Application.isPlaying)
				{
					UnityEngine.Debug.LogErrorFormat(Consts.Shadow.GetErrorChangeRuntimeDepthMapResolution(this));
				}
				m_DepthMapResolution = value;
			}
		}

		public int _INTERNAL_LastFrameRendered => m_LastFrameRendered;

		public void ProcessOcclusionManually()
		{
			ProcessOcclusion(ProcessOcclusionSource.User);
		}

		public void UpdateDepthCameraProperties()
		{
			if ((bool)m_DepthCamera)
			{
				m_DepthCamera.cullingMask = layerMask;
				m_DepthCamera.useOcclusionCulling = useOcclusionCulling;
			}
		}

		private void ProcessOcclusion(ProcessOcclusionSource source)
		{
			if (Config.Instance.featureEnabledShadow && (m_LastFrameRendered != Time.frameCount || !Application.isPlaying || source != ProcessOcclusionSource.OnEnable))
			{
				if (SRPHelper.IsUsingCustomRenderPipeline())
				{
					m_NeedToUpdateOcclusionNextFrame = true;
				}
				else
				{
					ProcessOcclusionInternal();
				}
				SetDirty();
				if (updateRate.HasFlag(ShadowUpdateRate.OnBeamMove))
				{
					m_TransformPacked = base.transform.GetWorldPacked();
				}
				bool num = m_LastFrameRendered < 0;
				m_LastFrameRendered = Time.frameCount;
				if (num && _INTERNAL_ApplyRandomFrameOffset)
				{
					m_LastFrameRendered += UnityEngine.Random.Range(0, waitXFrames);
				}
			}
		}

		public static void ApplyMaterialProperties(VolumetricShadowHD instance, BeamGeometryHD geom)
		{
			if ((bool)instance && instance.enabled)
			{
				geom.SetMaterialProp(ShaderProperties.HD.ShadowDepthTexture, instance.m_DepthCamera.targetTexture);
				Vector3 vector = (instance.m_Master.scalable ? instance.m_Master.GetLossyScale() : Vector3.one);
				geom.SetMaterialProp(ShaderProperties.HD.ShadowProps, new Vector4(Mathf.Sign(vector.x) * Mathf.Sign(vector.z), Mathf.Sign(vector.y), instance.m_Strength, instance.m_DepthCamera.orthographic ? 0f : 1f));
			}
			else
			{
				geom.SetMaterialProp(ShaderProperties.HD.ShadowDepthTexture, BeamGeometryHD.InvalidTexture.NoDepth);
			}
		}

		private void Awake()
		{
			m_Master = GetComponent<VolumetricLightBeamHD>();
		}

		private void OnEnable()
		{
			OnValidateProperties();
			InstantiateOrActivateDepthCamera();
			OnBeamEnabled();
		}

		private void OnDisable()
		{
			if ((bool)m_DepthCamera)
			{
				m_DepthCamera.gameObject.SetActive(value: false);
			}
			SetDirty();
		}

		private void OnDestroy()
		{
			DestroyDepthCamera();
		}

		private void ProcessOcclusionInternal()
		{
			UpdateDepthCameraPropertiesAccordingToBeam();
			m_DepthCamera.Render();
		}

		private void OnBeamEnabled()
		{
			if (base.enabled && !updateRate.HasFlag(ShadowUpdateRate.Never))
			{
				ProcessOcclusion(ProcessOcclusionSource.OnEnable);
			}
		}

		public void OnWillCameraRenderThisBeam(Camera cam, BeamGeometryHD beamGeom)
		{
			if (base.enabled && cam != null && cam.enabled && Time.frameCount != m_LastFrameRendered && updateRate != ShadowUpdateRate.Never)
			{
				bool flag = false;
				if (!flag && updateRate.HasFlag(ShadowUpdateRate.OnBeamMove) && !m_TransformPacked.IsSame(base.transform))
				{
					flag = true;
				}
				if (!flag && updateRate.HasFlag(ShadowUpdateRate.EveryXFrames) && Time.frameCount >= m_LastFrameRendered + waitXFrames)
				{
					flag = true;
				}
				if (flag)
				{
					ProcessOcclusion(ProcessOcclusionSource.RenderLoop);
				}
			}
		}

		private void Update()
		{
			if (m_NeedToUpdateOcclusionNextFrame && (bool)m_Master && (bool)m_DepthCamera && Time.frameCount > 1)
			{
				ProcessOcclusionInternal();
				m_NeedToUpdateOcclusionNextFrame = false;
			}
		}

		private void UpdateDepthCameraPropertiesAccordingToBeam()
		{
			Utils.SetupDepthCamera(m_DepthCamera, m_Master.GetConeApexOffsetZ(counterApplyScaleForUnscalableBeam: true), m_Master.maxGeometryDistance, m_Master.coneRadiusStart, m_Master.coneRadiusEnd, m_Master.beamLocalForward, m_Master.GetLossyScale(), m_Master.scalable, m_Master.beamInternalLocalRotation, shouldScaleMinNearClipPlane: false);
		}

		private void InstantiateOrActivateDepthCamera()
		{
			if (m_DepthCamera != null)
			{
				m_DepthCamera.gameObject.SetActive(value: true);
				return;
			}
			base.gameObject.ForeachComponentsInDirectChildrenOnly(delegate(Camera cam)
			{
				UnityEngine.Object.DestroyImmediate(cam.gameObject);
			}, includeInactive: true);
			m_DepthCamera = Utils.NewWithComponent<Camera>("Depth Camera");
			if ((bool)m_DepthCamera && (bool)m_Master)
			{
				m_DepthCamera.enabled = false;
				UpdateDepthCameraProperties();
				m_DepthCamera.clearFlags = CameraClearFlags.Depth;
				m_DepthCamera.depthTextureMode = DepthTextureMode.Depth;
				m_DepthCamera.renderingPath = RenderingPath.Forward;
				m_DepthCamera.gameObject.hideFlags = Consts.Internal.ProceduralObjectsHideFlags;
				m_DepthCamera.transform.SetParent(base.transform, worldPositionStays: false);
				Config.Instance.SetURPScriptableRendererIndexToDepthCamera(m_DepthCamera);
				RenderTexture targetTexture = new RenderTexture(depthMapResolution, depthMapResolution, 16, RenderTextureFormat.Depth);
				m_DepthCamera.targetTexture = targetTexture;
				UpdateDepthCameraPropertiesAccordingToBeam();
			}
		}

		private void DestroyDepthCamera()
		{
			if ((bool)m_DepthCamera)
			{
				if ((bool)m_DepthCamera.targetTexture)
				{
					m_DepthCamera.targetTexture.Release();
					UnityEngine.Object.DestroyImmediate(m_DepthCamera.targetTexture);
					m_DepthCamera.targetTexture = null;
				}
				UnityEngine.Object.DestroyImmediate(m_DepthCamera.gameObject);
				m_DepthCamera = null;
			}
		}

		private void OnValidateProperties()
		{
			m_WaitXFrames = Mathf.Clamp(m_WaitXFrames, 1, 60);
			m_DepthMapResolution = Mathf.Clamp(Mathf.NextPowerOfTwo(m_DepthMapResolution), 8, 2048);
		}

		private void SetDirty()
		{
			if ((bool)m_Master)
			{
				m_Master.SetPropertyDirty(DirtyProps.ShadowProps);
			}
		}
	}
	public sealed class HighlightNullAttribute : PropertyAttribute
	{
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(LODGroup))]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-lodbeamgroup/")]
	public class LODBeamGroup : MonoBehaviour
	{
		[SerializeField]
		private VolumetricLightBeamAbstractBase[] m_LODBeams;

		[SerializeField]
		private bool m_ResetAllLODsLocalTransform;

		[SerializeField]
		private BeamProps m_LOD0PropsToCopy = (BeamProps)(-1);

		[SerializeField]
		private bool m_CopyLOD0PropsEachFrame;

		[SerializeField]
		private bool m_CullVolumetricDustParticles = true;

		private LODGroup m_LODGroup;

		private void Awake()
		{
			m_LODGroup = GetComponent<LODGroup>();
			SetupLodGroupData();
		}

		private void Start()
		{
			UnifyBeamsProperties();
		}

		public LOD[] GetLODsFromLODGroup()
		{
			return m_LODGroup.GetLODs();
		}

		private void SetLODRenderer(int lodIdx, Renderer renderer)
		{
			SetLODRenderers(lodIdx, (!renderer) ? null : new Renderer[1] { renderer });
		}

		private void SetLODRenderers(int lodIdx, Renderer[] renderers)
		{
			LOD[] lODs = m_LODGroup.GetLODs();
			lODs[lodIdx].renderers = renderers;
			m_LODGroup.SetLODs(lODs);
		}

		private void SetLOD(int lodIdx)
		{
			LOD[] lODs = m_LODGroup.GetLODs();
			if (!lODs.IsValidIndex(lodIdx))
			{
				return;
			}
			BeamGeometryAbstractBase beamGeometry = m_LODBeams[lodIdx].GetBeamGeometry();
			if (!beamGeometry)
			{
				return;
			}
			MeshRenderer meshRenderer = beamGeometry.meshRenderer;
			if (!meshRenderer)
			{
				return;
			}
			if (m_CullVolumetricDustParticles)
			{
				VolumetricDustParticles component = m_LODBeams[lodIdx].GetComponent<VolumetricDustParticles>();
				if ((bool)component)
				{
					ParticleSystemRenderer particleSystemRenderer = component.FindRenderer();
					if ((bool)particleSystemRenderer)
					{
						SetLODRenderers(lodIdx, new Renderer[2] { meshRenderer, particleSystemRenderer });
						return;
					}
				}
			}
			if (lODs[lodIdx].renderers == null || lODs[lodIdx].renderers.Length != 1 || lODs[lodIdx].renderers[0] != meshRenderer)
			{
				SetLODRenderer(lodIdx, meshRenderer);
			}
		}

		private void OnBeamGeometryGenerated(VolumetricLightBeamAbstractBase beam)
		{
			if (GetLODsFromLODGroup() == null || m_LODBeams == null)
			{
				return;
			}
			for (int i = 0; i < m_LODBeams.Length; i++)
			{
				if (m_LODBeams[i] == beam)
				{
					SetLOD(i);
					break;
				}
			}
		}

		private void SetupLodGroupData()
		{
			if (m_LODGroup == null)
			{
				return;
			}
			LOD[] lODsFromLODGroup = GetLODsFromLODGroup();
			if (lODsFromLODGroup == null)
			{
				return;
			}
			if (m_LODBeams == null || m_LODBeams.Length < lODsFromLODGroup.Length)
			{
				Utils.ResizeArray(ref m_LODBeams, lODsFromLODGroup.Length);
			}
			for (int i = 0; i < m_LODBeams.Length; i++)
			{
				if (m_LODBeams[i] == null)
				{
					if (i < lODsFromLODGroup.Length)
					{
						SetLODRenderer(i, null);
					}
				}
				else
				{
					m_LODBeams[i].RegisterBeamGeometryGeneratedCallback(OnBeamGeometryGenerated);
				}
			}
		}

		private void UnifyBeamsProperties()
		{
			if (m_LODBeams == null)
			{
				return;
			}
			if (m_ResetAllLODsLocalTransform)
			{
				VolumetricLightBeamAbstractBase[] lODBeams = m_LODBeams;
				foreach (VolumetricLightBeamAbstractBase volumetricLightBeamAbstractBase in lODBeams)
				{
					if ((bool)volumetricLightBeamAbstractBase)
					{
						volumetricLightBeamAbstractBase.transform.localPosition = Vector3.zero;
						volumetricLightBeamAbstractBase.transform.localRotation = Quaternion.identity;
						volumetricLightBeamAbstractBase.transform.localScale = Vector3.one;
					}
				}
			}
			if (m_LOD0PropsToCopy == (BeamProps)0 || m_LODBeams.Length <= 1)
			{
				return;
			}
			VolumetricLightBeamAbstractBase volumetricLightBeamAbstractBase2 = m_LODBeams[0];
			if (volumetricLightBeamAbstractBase2 == null)
			{
				return;
			}
			for (int j = 1; j < m_LODBeams.Length; j++)
			{
				VolumetricLightBeamAbstractBase volumetricLightBeamAbstractBase3 = m_LODBeams[j];
				if ((bool)volumetricLightBeamAbstractBase3)
				{
					volumetricLightBeamAbstractBase3.CopyPropsFrom(volumetricLightBeamAbstractBase2, m_LOD0PropsToCopy);
					UtilsBeamProps.SetColorFromLight(volumetricLightBeamAbstractBase3, fromLight: false);
					UtilsBeamProps.SetFallOffEndFromLight(volumetricLightBeamAbstractBase3, fromLight: false);
					UtilsBeamProps.SetIntensityFromLight(volumetricLightBeamAbstractBase3, fromLight: false);
					UtilsBeamProps.SetSpotAngleFromLight(volumetricLightBeamAbstractBase3, fromLight: false);
				}
			}
		}

		private void Update()
		{
			if (m_CopyLOD0PropsEachFrame)
			{
				UnifyBeamsProperties();
			}
		}
	}
	public static class MaterialManager
	{
		public enum BlendingMode
		{
			Additive,
			SoftAdditive,
			TraditionalTransparency,
			Count
		}

		public enum ColorGradient
		{
			Off,
			MatrixLow,
			MatrixHigh,
			Count
		}

		public enum Noise3D
		{
			Off,
			On,
			Count
		}

		public static class SD
		{
			public enum DepthBlend
			{
				Off,
				On,
				Count
			}

			public enum DynamicOcclusion
			{
				Off,
				ClippingPlane,
				DepthTexture,
				Count
			}

			public enum MeshSkewing
			{
				Off,
				On,
				Count
			}

			public enum ShaderAccuracy
			{
				Fast,
				High,
				Count
			}
		}

		public static class HD
		{
			public enum Attenuation
			{
				Linear,
				Quadratic,
				Count
			}

			public enum Shadow
			{
				Off,
				On,
				Count
			}

			public enum Cookie
			{
				Off,
				SingleChannel,
				RGBA,
				Count
			}
		}

		private interface IStaticProperties
		{
			int GetPropertiesCount();

			int GetMaterialID();

			void ApplyToMaterial(Material mat);

			ShaderMode GetShaderMode();
		}

		public struct StaticPropertiesSD : IStaticProperties
		{
			public BlendingMode blendingMode;

			public Noise3D noise3D;

			public SD.DepthBlend depthBlend;

			public ColorGradient colorGradient;

			public SD.DynamicOcclusion dynamicOcclusion;

			public SD.MeshSkewing meshSkewing;

			public SD.ShaderAccuracy shaderAccuracy;

			public static int staticPropertiesCount => 432;

			private int blendingModeID => (int)blendingMode;

			private int noise3DID
			{
				get
				{
					if (!Config.Instance.featureEnabledNoise3D)
					{
						return 0;
					}
					return (int)noise3D;
				}
			}

			private int depthBlendID
			{
				get
				{
					if (!Config.Instance.featureEnabledDepthBlend)
					{
						return 0;
					}
					return (int)depthBlend;
				}
			}

			private int colorGradientID
			{
				get
				{
					if (Config.Instance.featureEnabledColorGradient == FeatureEnabledColorGradient.Off)
					{
						return 0;
					}
					return (int)colorGradient;
				}
			}

			private int dynamicOcclusionID
			{
				get
				{
					if (!Config.Instance.featureEnabledDynamicOcclusion)
					{
						return 0;
					}
					return (int)dynamicOcclusion;
				}
			}

			private int meshSkewingID
			{
				get
				{
					if (!Config.Instance.featureEnabledMeshSkewing)
					{
						return 0;
					}
					return (int)meshSkewing;
				}
			}

			private int shaderAccuracyID
			{
				get
				{
					if (!Config.Instance.featureEnabledShaderAccuracyHigh)
					{
						return 0;
					}
					return (int)shaderAccuracy;
				}
			}

			public ShaderMode GetShaderMode()
			{
				return ShaderMode.SD;
			}

			public int GetPropertiesCount()
			{
				return staticPropertiesCount;
			}

			public int GetMaterialID()
			{
				return (((((blendingModeID * 2 + noise3DID) * 2 + depthBlendID) * 3 + colorGradientID) * 3 + dynamicOcclusionID) * 2 + meshSkewingID) * 2 + shaderAccuracyID;
			}

			public void ApplyToMaterial(Material mat)
			{
				mat.SetKeywordEnabled("VLB_ALPHA_AS_BLACK", BlendingMode_AlphaAsBlack[(int)blendingMode]);
				mat.SetKeywordEnabled("VLB_COLOR_GRADIENT_MATRIX_LOW", colorGradient == ColorGradient.MatrixLow);
				mat.SetKeywordEnabled("VLB_COLOR_GRADIENT_MATRIX_HIGH", colorGradient == ColorGradient.MatrixHigh);
				mat.SetKeywordEnabled("VLB_DEPTH_BLEND", depthBlend == SD.DepthBlend.On);
				mat.SetKeywordEnabled("VLB_NOISE_3D", noise3D == Noise3D.On);
				mat.SetKeywordEnabled("VLB_OCCLUSION_CLIPPING_PLANE", dynamicOcclusion == SD.DynamicOcclusion.ClippingPlane);
				mat.SetKeywordEnabled("VLB_OCCLUSION_DEPTH_TEXTURE", dynamicOcclusion == SD.DynamicOcclusion.DepthTexture);
				mat.SetKeywordEnabled("VLB_MESH_SKEWING", meshSkewing == SD.MeshSkewing.On);
				mat.SetKeywordEnabled("VLB_SHADER_ACCURACY_HIGH", shaderAccuracy == SD.ShaderAccuracy.High);
				mat.SetBlendingMode(ShaderProperties.BlendSrcFactor, BlendingMode_SrcFactor[(int)blendingMode]);
				mat.SetBlendingMode(ShaderProperties.BlendDstFactor, BlendingMode_DstFactor[(int)blendingMode]);
				mat.SetZTest(ShaderProperties.ZTest, CompareFunction.LessEqual);
			}
		}

		public struct StaticPropertiesHD : IStaticProperties
		{
			public BlendingMode blendingMode;

			public HD.Attenuation attenuation;

			public Noise3D noise3D;

			public ColorGradient colorGradient;

			public HD.Shadow shadow;

			public HD.Cookie cookie;

			public int raymarchingQualityIndex;

			public static int staticPropertiesCount => 216 * Config.Instance.raymarchingQualitiesCount;

			private int blendingModeID => (int)blendingMode;

			private int attenuationID => (int)attenuation;

			private int noise3DID
			{
				get
				{
					if (!Config.Instance.featureEnabledNoise3D)
					{
						return 0;
					}
					return (int)noise3D;
				}
			}

			private int colorGradientID
			{
				get
				{
					if (Config.Instance.featureEnabledColorGradient == FeatureEnabledColorGradient.Off)
					{
						return 0;
					}
					return (int)colorGradient;
				}
			}

			private int dynamicOcclusionID
			{
				get
				{
					if (!Config.Instance.featureEnabledShadow)
					{
						return 0;
					}
					return (int)shadow;
				}
			}

			private int cookieID
			{
				get
				{
					if (!Config.Instance.featureEnabledCookie)
					{
						return 0;
					}
					return (int)cookie;
				}
			}

			private int raymarchingQualityID => raymarchingQualityIndex;

			public ShaderMode GetShaderMode()
			{
				return ShaderMode.HD;
			}

			public int GetPropertiesCount()
			{
				return staticPropertiesCount;
			}

			public int GetMaterialID()
			{
				return (((((blendingModeID * 2 + attenuationID) * 2 + noise3DID) * 3 + colorGradientID) * 2 + dynamicOcclusionID) * 3 + cookieID) * Config.Instance.raymarchingQualitiesCount + raymarchingQualityID;
			}

			public void ApplyToMaterial(Material mat)
			{
				mat.SetKeywordEnabled("VLB_ALPHA_AS_BLACK", BlendingMode_AlphaAsBlack[(int)blendingMode]);
				mat.SetKeywordEnabled("VLB_ATTENUATION_LINEAR", attenuation == HD.Attenuation.Linear);
				mat.SetKeywordEnabled("VLB_ATTENUATION_QUAD", attenuation == HD.Attenuation.Quadratic);
				mat.SetKeywordEnabled("VLB_COLOR_GRADIENT_MATRIX_LOW", colorGradient == ColorGradient.MatrixLow);
				mat.SetKeywordEnabled("VLB_COLOR_GRADIENT_MATRIX_HIGH", colorGradient == ColorGradient.MatrixHigh);
				mat.SetKeywordEnabled("VLB_NOISE_3D", noise3D == Noise3D.On);
				mat.SetKeywordEnabled("VLB_SHADOW", shadow == HD.Shadow.On);
				mat.SetKeywordEnabled("VLB_COOKIE_1CHANNEL", cookie == HD.Cookie.SingleChannel);
				mat.SetKeywordEnabled("VLB_COOKIE_RGBA", cookie == HD.Cookie.RGBA);
				for (int i = 0; i < Config.Instance.raymarchingQualitiesCount; i++)
				{
					mat.SetKeywordEnabled(ShaderKeywords.HD.GetRaymarchingQuality(i), raymarchingQualityIndex == i);
				}
				mat.SetBlendingMode(ShaderProperties.BlendSrcFactor, BlendingMode_SrcFactor[(int)blendingMode]);
				mat.SetBlendingMode(ShaderProperties.BlendDstFactor, BlendingMode_DstFactor[(int)blendingMode]);
				mat.SetZTest(ShaderProperties.ZTest, CompareFunction.Always);
			}
		}

		private class MaterialsGroup
		{
			public Material[] materials;

			public MaterialsGroup(int count)
			{
				materials = new Material[count];
			}
		}

		private enum ZWrite
		{
			Off,
			On
		}

		public static MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();

		private static readonly BlendMode[] BlendingMode_SrcFactor = new BlendMode[3]
		{
			BlendMode.One,
			BlendMode.OneMinusDstColor,
			BlendMode.SrcAlpha
		};

		private static readonly BlendMode[] BlendingMode_DstFactor = new BlendMode[3]
		{
			BlendMode.One,
			BlendMode.One,
			BlendMode.OneMinusSrcAlpha
		};

		private static readonly bool[] BlendingMode_AlphaAsBlack = new bool[3] { true, true, false };

		private static Hashtable ms_MaterialsGroupSD = new Hashtable(1);

		private static Hashtable ms_MaterialsGroupHD = new Hashtable(1);

		public static Material NewMaterialPersistent(Shader shader, bool gpuInstanced)
		{
			if (!shader)
			{
				UnityEngine.Debug.LogError("Invalid VLB Shader. Please try to reset the VLB Config asset or reinstall the plugin.");
				return null;
			}
			Material material = new Material(shader);
			BatchingHelper.SetMaterialProperties(material, gpuInstanced);
			return material;
		}

		public static Material GetInstancedMaterial(uint groupID, ref StaticPropertiesSD staticProps)
		{
			IStaticProperties staticProps2 = staticProps;
			return GetInstancedMaterial(ms_MaterialsGroupSD, groupID, ref staticProps2);
		}

		public static Material GetInstancedMaterial(uint groupID, ref StaticPropertiesHD staticProps)
		{
			IStaticProperties staticProps2 = staticProps;
			return GetInstancedMaterial(ms_MaterialsGroupHD, groupID, ref staticProps2);
		}

		private static Material GetInstancedMaterial(Hashtable groups, uint groupID, ref IStaticProperties staticProps)
		{
			MaterialsGroup materialsGroup = (MaterialsGroup)groups[groupID];
			if (materialsGroup == null)
			{
				materialsGroup = new MaterialsGroup(staticProps.GetPropertiesCount());
				groups[groupID] = materialsGroup;
			}
			int materialID = staticProps.GetMaterialID();
			Material material = materialsGroup.materials[materialID];
			if (material == null)
			{
				material = Config.Instance.NewMaterialTransient(staticProps.GetShaderMode(), gpuInstanced: true);
				if ((bool)material)
				{
					materialsGroup.materials[materialID] = material;
					staticProps.ApplyToMaterial(material);
				}
			}
			return material;
		}

		public static bool EnableGPUInstancing(ShaderMode shaderMode, bool enabled)
		{
			if (Config.Instance.GetActualRenderingMode(shaderMode) != RenderingMode.GPUInstancing)
			{
				UnityEngine.Debug.LogErrorFormat("To change GPU Instancing at runtime, the VLB plugin's config must be configured to use the GPUInstancing RenderingMode.");
				return false;
			}
			Hashtable obj = ((shaderMode == ShaderMode.SD) ? ms_MaterialsGroupSD : ms_MaterialsGroupHD);
			bool result = false;
			foreach (MaterialsGroup value in obj.Values)
			{
				if (value == null)
				{
					continue;
				}
				Material[] materials = value.materials;
				foreach (Material material in materials)
				{
					if ((bool)material)
					{
						material.enableInstancing = enabled;
						result = true;
					}
				}
			}
			return result;
		}

		private static void SetBlendingMode(this Material mat, int nameID, BlendMode value)
		{
			mat.SetInt(nameID, (int)value);
		}

		private static void SetStencilRef(this Material mat, int nameID, int value)
		{
			mat.SetInt(nameID, value);
		}

		private static void SetStencilComp(this Material mat, int nameID, CompareFunction value)
		{
			mat.SetInt(nameID, (int)value);
		}

		private static void SetStencilOp(this Material mat, int nameID, StencilOp value)
		{
			mat.SetInt(nameID, (int)value);
		}

		private static void SetCull(this Material mat, int nameID, CullMode value)
		{
			mat.SetInt(nameID, (int)value);
		}

		private static void SetZWrite(this Material mat, int nameID, ZWrite value)
		{
			mat.SetInt(nameID, (int)value);
		}

		private static void SetZTest(this Material mat, int nameID, CompareFunction value)
		{
			mat.SetInt(nameID, (int)value);
		}
	}
	public static class MaterialModifier
	{
		public interface Interface
		{
			void SetMaterialProp(int nameID, float value);

			void SetMaterialProp(int nameID, Vector4 value);

			void SetMaterialProp(int nameID, Color value);

			void SetMaterialProp(int nameID, Matrix4x4 value);

			void SetMaterialProp(int nameID, Texture value);
		}

		public delegate void Callback(Interface owner);
	}
	public static class MeshGenerator
	{
		public enum CapMode
		{
			None,
			OneVertexPerCap_1Cap,
			OneVertexPerCap_2Caps,
			SpecificVerticesPerCap_1Cap,
			SpecificVerticesPerCap_2Caps
		}

		private const float kMinTruncatedRadius = 0.001f;

		private static float GetAngleOffset(int numSides)
		{
			if (numSides != 4)
			{
				return 0f;
			}
			return MathF.PI / 4f;
		}

		private static float GetRadiiScale(int numSides)
		{
			if (numSides != 4)
			{
				return 1f;
			}
			return Mathf.Sqrt(2f);
		}

		public static Mesh GenerateConeZ_RadiusAndAngle(float lengthZ, float radiusStart, float coneAngle, int numSides, int numSegments, bool cap, bool doubleSided)
		{
			float radiusEnd = lengthZ * Mathf.Tan(coneAngle * (MathF.PI / 180f) * 0.5f);
			return GenerateConeZ_Radii(lengthZ, radiusStart, radiusEnd, numSides, numSegments, cap, doubleSided);
		}

		public static Mesh GenerateConeZ_Angle(float lengthZ, float coneAngle, int numSides, int numSegments, bool cap, bool doubleSided)
		{
			return GenerateConeZ_RadiusAndAngle(lengthZ, 0f, coneAngle, numSides, numSegments, cap, doubleSided);
		}

		public static Mesh GenerateConeZ_Radii(float lengthZ, float radiusStart, float radiusEnd, int numSides, int numSegments, bool cap, bool doubleSided)
		{
			Mesh mesh = new Mesh();
			bool flag = cap && radiusStart > 0f;
			radiusStart = Mathf.Max(radiusStart, 0.001f);
			float radiiScale = GetRadiiScale(numSides);
			radiusStart *= radiiScale;
			radiusEnd *= radiiScale;
			int num = numSides * (numSegments + 2);
			int num2 = num;
			if (flag)
			{
				num2 += numSides + 1;
			}
			float angleOffset = GetAngleOffset(numSides);
			Vector3[] array = new Vector3[num2];
			for (int i = 0; i < numSides; i++)
			{
				float f = angleOffset + MathF.PI * 2f * (float)i / (float)numSides;
				float num3 = Mathf.Cos(f);
				float num4 = Mathf.Sin(f);
				for (int j = 0; j < numSegments + 2; j++)
				{
					float num5 = (float)j / (float)(numSegments + 1);
					float num6 = Mathf.Lerp(radiusStart, radiusEnd, num5);
					array[i + j * numSides] = new Vector3(num6 * num3, num6 * num4, num5 * lengthZ);
				}
			}
			if (flag)
			{
				int num7 = num;
				array[num7] = Vector3.zero;
				num7++;
				for (int k = 0; k < numSides; k++)
				{
					float f2 = angleOffset + MathF.PI * 2f * (float)k / (float)numSides;
					float num8 = Mathf.Cos(f2);
					float num9 = Mathf.Sin(f2);
					array[num7] = new Vector3(radiusStart * num8, radiusStart * num9, 0f);
					num7++;
				}
			}
			if (!doubleSided)
			{
				mesh.vertices = array;
			}
			else
			{
				Vector3[] array2 = new Vector3[array.Length * 2];
				array.CopyTo(array2, 0);
				array.CopyTo(array2, array.Length);
				mesh.vertices = array2;
			}
			Vector2[] array3 = new Vector2[num2];
			int num10 = 0;
			for (int l = 0; l < num; l++)
			{
				array3[num10++] = Vector2.zero;
			}
			if (flag)
			{
				for (int m = 0; m < numSides + 1; m++)
				{
					array3[num10++] = new Vector2(1f, 0f);
				}
			}
			if (!doubleSided)
			{
				mesh.uv = array3;
			}
			else
			{
				Vector2[] array4 = new Vector2[array3.Length * 2];
				array3.CopyTo(array4, 0);
				array3.CopyTo(array4, array3.Length);
				for (int n = 0; n < array3.Length; n++)
				{
					Vector2 vector = array4[n + array3.Length];
					array4[n + array3.Length] = new Vector2(vector.x, 1f);
				}
				mesh.uv = array4;
			}
			int num11 = numSides * 2 * Mathf.Max(numSegments + 1, 1) * 3;
			if (flag)
			{
				num11 += numSides * 3;
			}
			int[] array5 = new int[num11];
			int num12 = 0;
			for (int num13 = 0; num13 < numSides; num13++)
			{
				int num14 = num13 + 1;
				if (num14 == numSides)
				{
					num14 = 0;
				}
				for (int num15 = 0; num15 < numSegments + 1; num15++)
				{
					int num16 = num15 * numSides;
					array5[num12++] = num16 + num13;
					array5[num12++] = num16 + num14;
					array5[num12++] = num16 + num13 + numSides;
					array5[num12++] = num16 + num14 + numSides;
					array5[num12++] = num16 + num13 + numSides;
					array5[num12++] = num16 + num14;
				}
			}
			if (flag)
			{
				for (int num17 = 0; num17 < numSides - 1; num17++)
				{
					array5[num12++] = num;
					array5[num12++] = num + num17 + 2;
					array5[num12++] = num + num17 + 1;
				}
				array5[num12++] = num;
				array5[num12++] = num + 1;
				array5[num12++] = num + numSides;
			}
			if (!doubleSided)
			{
				mesh.triangles = array5;
			}
			else
			{
				int[] array6 = new int[array5.Length * 2];
				array5.CopyTo(array6, 0);
				for (int num18 = 0; num18 < array5.Length; num18 += 3)
				{
					array6[array5.Length + num18] = array5[num18] + num2;
					array6[array5.Length + num18 + 1] = array5[num18 + 2] + num2;
					array6[array5.Length + num18 + 2] = array5[num18 + 1] + num2;
				}
				mesh.triangles = array6;
			}
			mesh.bounds = ComputeBounds(lengthZ, radiusStart, radiusEnd);
			return mesh;
		}

		public static Mesh GenerateConeZ_Radii_DoubleCaps(float lengthZ, float radiusStart, float radiusEnd, int numSides, bool inverted)
		{
			Mesh mesh = new Mesh();
			radiusStart = Mathf.Max(radiusStart, 0.001f);
			int vertCountSides = numSides * 2;
			int num = vertCountSides;
			Func<int, int> vertSidesStartFromSlide = (int slideID) => numSides * slideID;
			Func<int, int> vertCenterFromSlide = (int slideID) => vertCountSides + slideID;
			int num2 = num + 2;
			float angleOffset = GetAngleOffset(numSides);
			Vector3[] array = new Vector3[num2];
			for (int num3 = 0; num3 < numSides; num3++)
			{
				float f = angleOffset + MathF.PI * 2f * (float)num3 / (float)numSides;
				float num4 = Mathf.Cos(f);
				float num5 = Mathf.Sin(f);
				for (int num6 = 0; num6 < 2; num6++)
				{
					float num7 = num6;
					float num8 = Mathf.Lerp(radiusStart, radiusEnd, num7);
					array[num3 + vertSidesStartFromSlide(num6)] = new Vector3(num8 * num4, num8 * num5, num7 * lengthZ);
				}
			}
			array[vertCenterFromSlide(0)] = Vector3.zero;
			array[vertCenterFromSlide(1)] = new Vector3(0f, 0f, lengthZ);
			mesh.vertices = array;
			int num9 = numSides * 2 * 3;
			num9 += numSides * 3;
			num9 += numSides * 3;
			int[] indices = new int[num9];
			int ind = 0;
			for (int num10 = 0; num10 < numSides; num10++)
			{
				int num11 = num10 + 1;
				if (num11 == numSides)
				{
					num11 = 0;
				}
				for (int num12 = 0; num12 < 1; num12++)
				{
					int num13 = num12 * numSides;
					indices[ind] = num13 + num10;
					indices[ind + (inverted ? 1 : 2)] = num13 + num11;
					indices[ind + ((!inverted) ? 1 : 2)] = num13 + num10 + numSides;
					indices[ind + 3] = num13 + num11 + numSides;
					indices[ind + (inverted ? 4 : 5)] = num13 + num10 + numSides;
					indices[ind + (inverted ? 5 : 4)] = num13 + num11;
					ind += 6;
				}
			}
			Action<int, bool> obj = delegate(int slideID, bool invert)
			{
				int num14 = vertSidesStartFromSlide(slideID);
				for (int i = 0; i < numSides - 1; i++)
				{
					indices[ind] = vertCenterFromSlide(slideID);
					indices[ind + (invert ? 1 : 2)] = num14 + i + 1;
					indices[ind + ((!invert) ? 1 : 2)] = num14 + i;
					ind += 3;
				}
				indices[ind] = vertCenterFromSlide(slideID);
				indices[ind + (invert ? 1 : 2)] = num14;
				indices[ind + ((!invert) ? 1 : 2)] = num14 + numSides - 1;
				ind += 3;
			};
			obj(0, inverted);
			obj(1, !inverted);
			mesh.triangles = indices;
			Bounds bounds = new Bounds(new Vector3(0f, 0f, lengthZ * 0.5f), new Vector3(Mathf.Max(radiusStart, radiusEnd) * 2f, Mathf.Max(radiusStart, radiusEnd) * 2f, lengthZ));
			mesh.bounds = bounds;
			return mesh;
		}

		public static Bounds ComputeBounds(float lengthZ, float radiusStart, float radiusEnd)
		{
			float num = Mathf.Max(radiusStart, radiusEnd) * 2f;
			return new Bounds(new Vector3(0f, 0f, lengthZ * 0.5f), new Vector3(num, num, lengthZ));
		}

		private static int GetCapAdditionalVerticesCount(CapMode capMode, int numSides)
		{
			return capMode switch
			{
				CapMode.None => 0, 
				CapMode.OneVertexPerCap_1Cap => 1, 
				CapMode.OneVertexPerCap_2Caps => 2, 
				CapMode.SpecificVerticesPerCap_1Cap => numSides + 1, 
				CapMode.SpecificVerticesPerCap_2Caps => 2 * (numSides + 1), 
				_ => 0, 
			};
		}

		private static int GetCapAdditionalIndicesCount(CapMode capMode, int numSides)
		{
			switch (capMode)
			{
			case CapMode.None:
				return 0;
			case CapMode.OneVertexPerCap_1Cap:
			case CapMode.SpecificVerticesPerCap_1Cap:
				return numSides * 3;
			case CapMode.OneVertexPerCap_2Caps:
			case CapMode.SpecificVerticesPerCap_2Caps:
				return 2 * (numSides * 3);
			default:
				return 0;
			}
		}

		public static int GetVertexCount(int numSides, int numSegments, CapMode capMode, bool doubleSided)
		{
			int num = numSides * (numSegments + 2);
			num += GetCapAdditionalVerticesCount(capMode, numSides);
			if (doubleSided)
			{
				num *= 2;
			}
			return num;
		}

		public static int GetIndicesCount(int numSides, int numSegments, CapMode capMode, bool doubleSided)
		{
			int num = numSides * (numSegments + 1) * 2 * 3;
			num += GetCapAdditionalIndicesCount(capMode, numSides);
			if (doubleSided)
			{
				num *= 2;
			}
			return num;
		}

		public static int GetSharedMeshVertexCount()
		{
			return GetVertexCount(Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, CapMode.SpecificVerticesPerCap_1Cap, Config.Instance.SD_requiresDoubleSidedMesh);
		}

		public static int GetSharedMeshIndicesCount()
		{
			return GetIndicesCount(Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, CapMode.SpecificVerticesPerCap_1Cap, Config.Instance.SD_requiresDoubleSidedMesh);
		}

		public static int GetSharedMeshHDVertexCount()
		{
			return GetVertexCount(Config.Instance.sharedMeshSides, 0, CapMode.OneVertexPerCap_2Caps, doubleSided: false);
		}

		public static int GetSharedMeshHDIndicesCount()
		{
			return GetIndicesCount(Config.Instance.sharedMeshSides, 0, CapMode.OneVertexPerCap_2Caps, doubleSided: false);
		}
	}
	[Serializable]
	public struct MinMaxRangeFloat : IEquatable<MinMaxRangeFloat>
	{
		[SerializeField]
		private float m_MinValue;

		[SerializeField]
		private float m_MaxValue;

		public float minValue => m_MinValue;

		public float maxValue => m_MaxValue;

		public float randomValue => UnityEngine.Random.Range(minValue, maxValue);

		public Vector2 asVector2 => new Vector2(minValue, maxValue);

		public float GetLerpedValue(float lerp01)
		{
			return Mathf.Lerp(minValue, maxValue, lerp01);
		}

		public MinMaxRangeFloat(float min, float max)
		{
			m_MinValue = min;
			m_MaxValue = max;
		}

		public override bool Equals(object obj)
		{
			if (obj is MinMaxRangeFloat other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(MinMaxRangeFloat other)
		{
			if (m_MinValue == other.m_MinValue)
			{
				return m_MaxValue == other.m_MaxValue;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (m_MinValue, m_MaxValue).GetHashCode();
		}

		public static bool operator ==(MinMaxRangeFloat lhs, MinMaxRangeFloat rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(MinMaxRangeFloat lhs, MinMaxRangeFloat rhs)
		{
			return !(lhs == rhs);
		}
	}
	public class MinMaxRangeAttribute : Attribute
	{
		public float minValue { get; private set; }

		public float maxValue { get; private set; }

		public MinMaxRangeAttribute(float min, float max)
		{
			minValue = min;
			maxValue = max;
		}
	}
	public static class Noise3D
	{
		private static bool ms_IsSupportedChecked;

		private static bool ms_IsSupported;

		private static Texture3D ms_NoiseTexture;

		private const int kMinShaderLevel = 35;

		public static bool isSupported
		{
			get
			{
				if (!ms_IsSupportedChecked)
				{
					ms_IsSupported = SystemInfo.graphicsShaderLevel >= 35;
					if (!ms_IsSupported)
					{
						UnityEngine.Debug.LogWarning(isNotSupportedString);
					}
					ms_IsSupportedChecked = true;
				}
				return ms_IsSupported;
			}
		}

		public static bool isProperlyLoaded => ms_NoiseTexture != null;

		public static string isNotSupportedString => $"3D Noise requires higher shader capabilities (Shader Model 3.5 / OpenGL ES 3.0), which are not available on the current platform: graphicsShaderLevel (current/required) = {SystemInfo.graphicsShaderLevel} / {35}";

		[RuntimeInitializeOnLoadMethod]
		private static void OnStartUp()
		{
			LoadIfNeeded();
		}

		public static void LoadIfNeeded()
		{
			if (isSupported && ms_NoiseTexture == null)
			{
				ms_NoiseTexture = Config.Instance.noiseTexture3D;
				Shader.SetGlobalTexture(ShaderProperties.GlobalNoiseTex3D, ms_NoiseTexture);
				Shader.SetGlobalFloat(ShaderProperties.GlobalNoiseCustomTime, -1f);
			}
		}
	}
	public class PlatformHelper
	{
		public static string GetCurrentPlatformSuffix()
		{
			return GetPlatformSuffix(Application.platform);
		}

		private static string GetPlatformSuffix(RuntimePlatform platform)
		{
			return platform.ToString();
		}
	}
	public class PolygonHelper : MonoBehaviour
	{
		public struct Plane2D
		{
			public Vector2 normal;

			public float distance;

			public float Distance(Vector2 point)
			{
				return Vector2.Dot(normal, point) + distance;
			}

			public Vector2 ClosestPoint(Vector2 pt)
			{
				return pt - normal * Distance(pt);
			}

			public Vector2 Intersect(Vector2 p1, Vector2 p2)
			{
				float num = Vector2.Dot(normal, p1 - p2);
				if (Utils.IsAlmostZero(num))
				{
					return (p1 + p2) * 0.5f;
				}
				float num2 = (normal.x * p1.x + normal.y * p1.y + distance) / num;
				return p1 + num2 * (p2 - p1);
			}

			public bool GetSide(Vector2 point)
			{
				return Distance(point) > 0f;
			}

			public static Plane2D FromPoints(Vector3 p1, Vector3 p2)
			{
				Vector3 normalized = (p2 - p1).normalized;
				return new Plane2D
				{
					normal = new Vector2(normalized.y, 0f - normalized.x),
					distance = (0f - normalized.y) * p1.x + normalized.x * p1.y
				};
			}

			public static Plane2D FromNormalAndPoint(Vector3 normalizedNormal, Vector3 p1)
			{
				return new Plane2D
				{
					normal = normalizedNormal,
					distance = (0f - normalizedNormal.x) * p1.x - normalizedNormal.y * p1.y
				};
			}

			public void Flip()
			{
				normal = -normal;
				distance = 0f - distance;
			}

			public Vector2[] CutConvex(Vector2[] poly)
			{
				List<Vector2> list = new List<Vector2>(poly.Length);
				Vector2 vector = poly[^1];
				foreach (Vector2 vector2 in poly)
				{
					bool side = GetSide(vector);
					bool side2 = GetSide(vector2);
					if (side && side2)
					{
						list.Add(vector2);
					}
					else if (side && !side2)
					{
						list.Add(Intersect(vector, vector2));
					}
					else if (!side && side2)
					{
						list.Add(Intersect(vector, vector2));
						list.Add(vector2);
					}
					vector = vector2;
				}
				return list.ToArray();
			}

			public override string ToString()
			{
				return $"{normal.x} x {normal.y} + {distance}";
			}
		}
	}
	[AddComponentMenu("")]
	[ExecuteInEditMode]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam-sd/")]
	public class BeamGeometrySD : BeamGeometryAbstractBase, MaterialModifier.Interface
	{
		private VolumetricLightBeamSD m_Master;

		private MeshType m_CurrentMeshType;

		private MaterialModifier.Callback m_MaterialModifierCallback;

		private Coroutine m_CoFadeOut;

		private Camera m_CurrentCameraRenderingSRP;

		private bool visible
		{
			get
			{
				return base.meshRenderer.enabled;
			}
			set
			{
				base.meshRenderer.enabled = value;
			}
		}

		public int sortingLayerID
		{
			get
			{
				return base.meshRenderer.sortingLayerID;
			}
			set
			{
				base.meshRenderer.sortingLayerID = value;
			}
		}

		public int sortingOrder
		{
			get
			{
				return base.meshRenderer.sortingOrder;
			}
			set
			{
				base.meshRenderer.sortingOrder = value;
			}
		}

		public bool _INTERNAL_IsFadeOutCoroutineRunning => m_CoFadeOut != null;

		public static bool isCustomRenderPipelineSupported => true;

		private bool shouldUseGPUInstancedMaterial
		{
			get
			{
				if (m_Master._INTERNAL_DynamicOcclusionMode != MaterialManager.SD.DynamicOcclusion.DepthTexture)
				{
					return Config.Instance.GetActualRenderingMode(ShaderMode.SD) == RenderingMode.GPUInstancing;
				}
				return false;
			}
		}

		private bool isNoiseEnabled
		{
			get
			{
				if (m_Master.isNoiseEnabled && m_Master.noiseIntensity > 0f)
				{
					return Noise3D.isSupported;
				}
				return false;
			}
		}

		private bool isDepthBlendEnabled
		{
			get
			{
				if (!BatchingHelper.forceEnableDepthBlend)
				{
					return m_Master.depthBlendDistance > 0f;
				}
				return true;
			}
		}

		protected override VolumetricLightBeamAbstractBase GetMaster()
		{
			return m_Master;
		}

		private float ComputeFadeOutFactor(Transform camTransform)
		{
			if (m_Master.isFadeOutEnabled)
			{
				float value = Vector3.SqrMagnitude(base.meshRenderer.bounds.center - camTransform.position);
				return Mathf.InverseLerp(m_Master.fadeOutEnd * m_Master.fadeOutEnd, m_Master.fadeOutBegin * m_Master.fadeOutBegin, value);
			}
			return 1f;
		}

		private IEnumerator CoUpdateFadeOut()
		{
			while (m_Master.isFadeOutEnabled)
			{
				ComputeFadeOutFactor();
				yield return null;
			}
			SetFadeOutFactorProp(1f);
			m_CoFadeOut = null;
		}

		private void ComputeFadeOutFactor()
		{
			Transform fadeOutCameraTransform = Config.Instance.fadeOutCameraTransform;
			if ((bool)fadeOutCameraTransform)
			{
				float fadeOutFactorProp = ComputeFadeOutFactor(fadeOutCameraTransform);
				SetFadeOutFactorProp(fadeOutFactorProp);
			}
			else
			{
				SetFadeOutFactorProp(1f);
			}
		}

		private void SetFadeOutFactorProp(float value)
		{
			if (value > 0f)
			{
				base.meshRenderer.enabled = true;
				MaterialChangeStart();
				SetMaterialProp(ShaderProperties.SD.FadeOutFactor, value);
				MaterialChangeStop();
			}
			else
			{
				base.meshRenderer.enabled = false;
			}
		}

		private void StopFadeOutCoroutine()
		{
			if (m_CoFadeOut != null)
			{
				StopCoroutine(m_CoFadeOut);
				m_CoFadeOut = null;
			}
		}

		public void RestartFadeOutCoroutine()
		{
			StopFadeOutCoroutine();
			if ((bool)m_Master && m_Master.isFadeOutEnabled)
			{
				m_CoFadeOut = StartCoroutine(CoUpdateFadeOut());
			}
		}

		public void OnMasterEnable()
		{
			visible = true;
			RestartFadeOutCoroutine();
		}

		public void OnMasterDisable()
		{
			StopFadeOutCoroutine();
			visible = false;
		}

		private void OnDisable()
		{
			SRPHelper.UnregisterOnBeginCameraRendering(OnBeginCameraRenderingSRP);
			m_CurrentCameraRenderingSRP = null;
		}

		private void OnEnable()
		{
			RestartFadeOutCoroutine();
			SRPHelper.RegisterOnBeginCameraRendering(OnBeginCameraRenderingSRP);
		}

		public void Initialize(VolumetricLightBeamSD master)
		{
			HideFlags proceduralObjectsHideFlags = Consts.Internal.ProceduralObjectsHideFlags;
			m_Master = master;
			base.transform.SetParent(master.transform, worldPositionStays: false);
			base.meshRenderer = base.gameObject.GetOrAddComponent<MeshRenderer>();
			base.meshRenderer.hideFlags = proceduralObjectsHideFlags;
			base.meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
			base.meshRenderer.receiveShadows = false;
			base.meshRenderer.reflectionProbeUsage = ReflectionProbeUsage.Off;
			base.meshRenderer.lightProbeUsage = LightProbeUsage.Off;
			if (!shouldUseGPUInstancedMaterial)
			{
				m_CustomMaterial = Config.Instance.NewMaterialTransient(ShaderMode.SD, gpuInstanced: false);
				ApplyMaterial();
			}
			if (SortingLayer.IsValid(m_Master.sortingLayerID))
			{
				sortingLayerID = m_Master.sortingLayerID;
			}
			else
			{
				UnityEngine.Debug.LogError($"Beam '{Utils.GetPath(m_Master.transform)}' has an invalid sortingLayerID ({m_Master.sortingLayerID}). Please fix it by setting a valid layer.");
			}
			sortingOrder = m_Master.sortingOrder;
			base.meshFilter = base.gameObject.GetOrAddComponent<MeshFilter>();
			base.meshFilter.hideFlags = proceduralObjectsHideFlags;
			base.gameObject.hideFlags = proceduralObjectsHideFlags;
			RestartFadeOutCoroutine();
		}

		public void RegenerateMesh(bool masterEnabled)
		{
			if (Config.Instance.geometryOverrideLayer)
			{
				base.gameObject.layer = Config.Instance.geometryLayerID;
			}
			else
			{
				base.gameObject.layer = m_Master.gameObject.layer;
			}
			base.gameObject.tag = Config.Instance.geometryTag;
			if ((bool)base.coneMesh && m_CurrentMeshType == MeshType.Custom)
			{
				UnityEngine.Object.DestroyImmediate(base.coneMesh);
			}
			m_CurrentMeshType = m_Master.geomMeshType;
			switch (m_Master.geomMeshType)
			{
			case MeshType.Custom:
				base.coneMesh = MeshGenerator.GenerateConeZ_Radii(1f, 1f, 1f, m_Master.geomCustomSides, m_Master.geomCustomSegments, m_Master.geomCap, Config.Instance.SD_requiresDoubleSidedMesh);
				base.coneMesh.hideFlags = Consts.Internal.ProceduralObjectsHideFlags;
				base.meshFilter.mesh = base.coneMesh;
				break;
			case MeshType.Shared:
				base.coneMesh = GlobalMeshSD.Get();
				base.meshFilter.sharedMesh = base.coneMesh;
				break;
			default:
				UnityEngine.Debug.LogError("Unsupported MeshType");
				break;
			}
			UpdateMaterialAndBounds();
			visible = masterEnabled;
		}

		private Vector3 ComputeLocalMatrix()
		{
			float num = Mathf.Max(m_Master.coneRadiusStart, m_Master.coneRadiusEnd);
			base.transform.localScale = new Vector3(num, num, m_Master.maxGeometryDistance);
			base.transform.localRotation = m_Master.beamInternalLocalRotation;
			return base.transform.localScale;
		}

		private MaterialManager.StaticPropertiesSD ComputeMaterialStaticProperties()
		{
			MaterialManager.ColorGradient colorGradient = MaterialManager.ColorGradient.Off;
			if (m_Master.colorMode == ColorMode.Gradient)
			{
				colorGradient = ((Utils.GetFloatPackingPrecision() != Utils.FloatPackingPrecision.High) ? MaterialManager.ColorGradient.MatrixLow : MaterialManager.ColorGradient.MatrixHigh);
			}
			return new MaterialManager.StaticPropertiesSD
			{
				blendingMode = (MaterialManager.BlendingMode)m_Master.blendingMode,
				noise3D = (isNoiseEnabled ? MaterialManager.Noise3D.On : MaterialManager.Noise3D.Off),
				depthBlend = (isDepthBlendEnabled ? MaterialManager.SD.DepthBlend.On : MaterialManager.SD.DepthBlend.Off),
				colorGradient = colorGradient,
				dynamicOcclusion = m_Master._INTERNAL_DynamicOcclusionMode_Runtime,
				meshSkewing = (m_Master.hasMeshSkewing ? MaterialManager.SD.MeshSkewing.On : MaterialManager.SD.MeshSkewing.Off),
				shaderAccuracy = ((m_Master.shaderAccuracy != ShaderAccuracy.Fast) ? MaterialManager.SD.ShaderAccuracy.High : MaterialManager.SD.ShaderAccuracy.Fast)
			};
		}

		private bool ApplyMaterial()
		{
			MaterialManager.StaticPropertiesSD staticProps = ComputeMaterialStaticProperties();
			Material material = null;
			if (!shouldUseGPUInstancedMaterial)
			{
				material = m_CustomMaterial;
				if ((bool)material)
				{
					staticProps.ApplyToMaterial(material);
				}
			}
			else
			{
				material = MaterialManager.GetInstancedMaterial(m_Master._INTERNAL_InstancedMaterialGroupID, ref staticProps);
			}
			base.meshRenderer.material = material;
			return material != null;
		}

		public void SetMaterialProp(int nameID, float value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetFloat(nameID, value);
			}
			else
			{
				MaterialManager.materialPropertyBlock.SetFloat(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, Vector4 value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetVector(nameID, value);
			}
			else
			{
				MaterialManager.materialPropertyBlock.SetVector(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, Color value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetColor(nameID, value);
			}
			else
			{
				MaterialManager.materialPropertyBlock.SetColor(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, Matrix4x4 value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetMatrix(nameID, value);
			}
			else
			{
				MaterialManager.materialPropertyBlock.SetMatrix(nameID, value);
			}
		}

		public void SetMaterialProp(int nameID, Texture value)
		{
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetTexture(nameID, value);
			}
			else
			{
				UnityEngine.Debug.LogError("Setting a Texture property to a GPU instanced material is not supported");
			}
		}

		private void MaterialChangeStart()
		{
			if (m_CustomMaterial == null)
			{
				base.meshRenderer.GetPropertyBlock(MaterialManager.materialPropertyBlock);
			}
		}

		private void MaterialChangeStop()
		{
			if (m_CustomMaterial == null)
			{
				base.meshRenderer.SetPropertyBlock(MaterialManager.materialPropertyBlock);
			}
		}

		public void SetDynamicOcclusionCallback(string shaderKeyword, MaterialModifier.Callback cb)
		{
			m_MaterialModifierCallback = cb;
			if ((bool)m_CustomMaterial)
			{
				m_CustomMaterial.SetKeywordEnabled(shaderKeyword, cb != null);
				cb?.Invoke(this);
			}
			else
			{
				UpdateMaterialAndBounds();
			}
		}

		public void UpdateMaterialAndBounds()
		{
			if (!ApplyMaterial())
			{
				return;
			}
			MaterialChangeStart();
			if (m_CustomMaterial == null && m_MaterialModifierCallback != null)
			{
				m_MaterialModifierCallback(this);
			}
			float f = m_Master.coneAngle * (MathF.PI / 180f) / 2f;
			SetMaterialProp(ShaderProperties.SD.ConeSlopeCosSin, new Vector2(Mathf.Cos(f), Mathf.Sin(f)));
			SetMaterialProp(value: new Vector2(Mathf.Max(m_Master.coneRadiusStart, 0.0001f), Mathf.Max(m_Master.coneRadiusEnd, 0.0001f)), nameID: ShaderProperties.ConeRadius);
			float x = Mathf.Sign(m_Master.coneApexOffsetZ) * Mathf.Max(Mathf.Abs(m_Master.coneApexOffsetZ), 0.0001f);
			SetMaterialProp(ShaderProperties.ConeGeomProps, new Vector2(x, m_Master.geomSides));
			if (m_Master.usedColorMode == ColorMode.Flat)
			{
				SetMaterialProp(ShaderProperties.ColorFlat, m_Master.color);
			}
			else
			{
				Utils.FloatPackingPrecision floatPackingPrecision = Utils.GetFloatPackingPrecision();
				m_ColorGradientMatrix = m_Master.colorGradient.SampleInMatrix((int)floatPackingPrecision);
			}
			m_Master.GetInsideAndOutsideIntensity(out var inside, out var outside);
			SetMaterialProp(ShaderProperties.SD.AlphaInside, inside);
			SetMaterialProp(ShaderProperties.SD.AlphaOutside, outside);
			SetMaterialProp(ShaderProperties.SD.AttenuationLerpLinearQuad, m_Master.attenuationLerpLinearQuad);
			SetMaterialProp(ShaderProperties.DistanceFallOff, new Vector3(m_Master.fallOffStart, m_Master.fallOffEnd, m_Master.maxGeometryDistance));
			SetMaterialProp(ShaderProperties.SD.DistanceCamClipping, m_Master.cameraClippingDistance);
			SetMaterialProp(ShaderProperties.SD.FresnelPow, Mathf.Max(0.001f, m_Master.fresnelPow));
			SetMaterialProp(ShaderProperties.SD.GlareBehind, m_Master.glareBehind);
			SetMaterialProp(ShaderProperties.SD.GlareFrontal, m_Master.glareFrontal);
			SetMaterialProp(ShaderProperties.SD.DrawCap, m_Master.geomCap ? 1 : 0);
			SetMaterialProp(ShaderProperties.SD.TiltVector, m_Master.tiltFactor);
			SetMaterialProp(ShaderProperties.SD.AdditionalClippingPlaneWS, m_Master.additionalClippingPlane);
			if (Config.Instance.isHDRPExposureWeightSupported)
			{
				SetMaterialProp(ShaderProperties.HDRPExposureWeight, m_Master.hdrpExposureWeight);
			}
			if (isDepthBlendEnabled)
			{
				SetMaterialProp(ShaderProperties.SD.DepthBlendDistance, m_Master.depthBlendDistance);
			}
			if (isNoiseEnabled)
			{
				Noise3D.LoadIfNeeded();
				Vector3 vector = (m_Master.noiseVelocityUseGlobal ? Config.Instance.globalNoiseVelocity : m_Master.noiseVelocityLocal);
				float w = (m_Master.noiseScaleUseGlobal ? Config.Instance.globalNoiseScale : m_Master.noiseScaleLocal);
				SetMaterialProp(ShaderProperties.NoiseVelocityAndScale, new Vector4(vector.x, vector.y, vector.z, w));
				SetMaterialProp(ShaderProperties.NoiseParam, new Vector2(m_Master.noiseIntensity, (m_Master.noiseMode == NoiseMode.WorldSpace) ? 0f : 1f));
			}
			Vector3 vector2 = ComputeLocalMatrix();
			if (m_Master.hasMeshSkewing)
			{
				Vector3 skewingLocalForwardDirectionNormalized = m_Master.skewingLocalForwardDirectionNormalized;
				SetMaterialProp(ShaderProperties.SD.LocalForwardDirection, skewingLocalForwardDirectionNormalized);
				if (base.coneMesh != null)
				{
					Vector3 vector3 = skewingLocalForwardDirectionNormalized;
					vector3 /= vector3.z;
					vector3 *= m_Master.fallOffEnd;
					vector3.x /= vector2.x;
					vector3.y /= vector2.y;
					Bounds bounds = MeshGenerator.ComputeBounds(1f, 1f, 1f);
					Vector3 min = bounds.min;
					Vector3 max = bounds.max;
					if (vector3.x > 0f)
					{
						max.x += vector3.x;
					}
					else
					{
						min.x += vector3.x;
					}
					if (vector3.y > 0f)
					{
						max.y += vector3.y;
					}
					else
					{
						min.y += vector3.y;
					}
					bounds.min = min;
					bounds.max = max;
					base.coneMesh.bounds = bounds;
				}
			}
			UpdateMatricesPropertiesForGPUInstancingSRP();
			MaterialChangeStop();
		}

		private void UpdateMatricesPropertiesForGPUInstancingSRP()
		{
			if (SRPHelper.IsUsingCustomRenderPipeline() && Config.Instance.GetActualRenderingMode(ShaderMode.SD) == RenderingMode.GPUInstancing)
			{
				SetMaterialProp(ShaderProperties.LocalToWorldMatrix, base.transform.localToWorldMatrix);
				SetMaterialProp(ShaderProperties.WorldToLocalMatrix, base.transform.worldToLocalMatrix);
			}
		}

		private void OnBeginCameraRenderingSRP(ScriptableRenderContext context, Camera cam)
		{
			m_CurrentCameraRenderingSRP = cam;
		}

		private void OnWillRenderObject()
		{
			Camera camera = null;
			camera = ((!SRPHelper.IsUsingCustomRenderPipeline()) ? Camera.current : m_CurrentCameraRenderingSRP);
			OnWillCameraRenderThisBeam(camera);
		}

		private void OnWillCameraRenderThisBeam(Camera cam)
		{
			if ((bool)m_Master && (bool)cam && cam.enabled)
			{
				UpdateCameraRelatedProperties(cam);
				m_Master._INTERNAL_OnWillCameraRenderThisBeam(cam);
			}
		}

		private void UpdateCameraRelatedProperties(Camera cam)
		{
			if ((bool)cam && (bool)m_Master)
			{
				MaterialChangeStart();
				Vector3 posOS = m_Master.transform.InverseTransformPoint(cam.transform.position);
				Vector3 normalized = base.transform.InverseTransformDirection(cam.transform.forward).normalized;
				float w = (cam.orthographic ? (-1f) : m_Master.GetInsideBeamFactorFromObjectSpacePos(posOS));
				SetMaterialProp(ShaderProperties.SD.CameraParams, new Vector4(normalized.x, normalized.y, normalized.z, w));
				UpdateMatricesPropertiesForGPUInstancingSRP();
				if (m_Master.usedColorMode == ColorMode.Gradient)
				{
					SetMaterialProp(ShaderProperties.ColorGradientMatrix, m_ColorGradientMatrix);
				}
				MaterialChangeStop();
				if (m_Master.depthBlendDistance > 0f)
				{
					cam.depthTextureMode |= DepthTextureMode.Depth;
				}
			}
		}
	}
	[AddComponentMenu("")]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(VolumetricLightBeamSD))]
	public abstract class DynamicOcclusionAbstractBase : MonoBehaviour
	{
		protected enum ProcessOcclusionSource
		{
			RenderLoop,
			OnEnable,
			EditorUpdate,
			User
		}

		public const string ClassName = "DynamicOcclusionAbstractBase";

		public DynamicOcclusionUpdateRate updateRate = DynamicOcclusionUpdateRate.EveryXFrames;

		[FormerlySerializedAs("waitFrameCount")]
		public int waitXFrames = 3;

		public static bool _INTERNAL_ApplyRandomFrameOffset = true;

		private TransformUtils.Packed m_TransformPacked;

		private int m_LastFrameRendered = int.MinValue;

		protected VolumetricLightBeamSD m_Master;

		protected MaterialModifier.Callback m_MaterialModifierCallbackCached;

		public int _INTERNAL_LastFrameRendered => m_LastFrameRendered;

		public event Action onOcclusionProcessed;

		public void ProcessOcclusionManually()
		{
			ProcessOcclusion(ProcessOcclusionSource.User);
		}

		protected void ProcessOcclusion(ProcessOcclusionSource source)
		{
			if (Config.Instance.featureEnabledDynamicOcclusion && (m_LastFrameRendered != Time.frameCount || !Application.isPlaying || source != ProcessOcclusionSource.OnEnable))
			{
				bool flag = OnProcessOcclusion(source);
				if (this.onOcclusionProcessed != null)
				{
					this.onOcclusionProcessed();
				}
				if ((bool)m_Master)
				{
					m_Master._INTERNAL_SetDynamicOcclusionCallback(GetShaderKeyword(), flag ? m_MaterialModifierCallbackCached : null);
				}
				if (updateRate.HasFlag(DynamicOcclusionUpdateRate.OnBeamMove))
				{
					m_TransformPacked = base.transform.GetWorldPacked();
				}
				bool num = m_LastFrameRendered < 0;
				m_LastFrameRendered = Time.frameCount;
				if (num && _INTERNAL_ApplyRandomFrameOffset)
				{
					m_LastFrameRendered += UnityEngine.Random.Range(0, waitXFrames);
				}
			}
		}

		protected abstract string GetShaderKeyword();

		protected abstract MaterialManager.SD.DynamicOcclusion GetDynamicOcclusionMode();

		protected abstract bool OnProcessOcclusion(ProcessOcclusionSource source);

		protected abstract void OnModifyMaterialCallback(MaterialModifier.Interface owner);

		protected abstract void OnEnablePostValidate();

		protected virtual void OnValidateProperties()
		{
			waitXFrames = Mathf.Clamp(waitXFrames, 1, 60);
		}

		protected virtual void Awake()
		{
			m_Master = GetComponent<VolumetricLightBeamSD>();
			m_Master._INTERNAL_DynamicOcclusionMode = GetDynamicOcclusionMode();
		}

		protected virtual void OnDestroy()
		{
			m_Master._INTERNAL_DynamicOcclusionMode = MaterialManager.SD.DynamicOcclusion.Off;
			DisableOcclusion();
		}

		protected virtual void OnEnable()
		{
			m_MaterialModifierCallbackCached = OnModifyMaterialCallback;
			OnValidateProperties();
			OnEnablePostValidate();
			m_Master.onWillCameraRenderThisBeam += OnWillCameraRender;
			if (!updateRate.HasFlag(DynamicOcclusionUpdateRate.Never))
			{
				m_Master.RegisterOnBeamGeometryInitializedCallback(delegate
				{
					ProcessOcclusion(ProcessOcclusionSource.OnEnable);
				});
			}
		}

		protected virtual void OnDisable()
		{
			m_Master.onWillCameraRenderThisBeam -= OnWillCameraRender;
			DisableOcclusion();
		}

		private void OnWillCameraRender(Camera cam)
		{
			if (cam != null && cam.enabled && Time.frameCount != m_LastFrameRendered)
			{
				bool flag = false;
				if (!flag && updateRate.HasFlag(DynamicOcclusionUpdateRate.OnBeamMove) && !m_TransformPacked.IsSame(base.transform))
				{
					flag = true;
				}
				if (!flag && updateRate.HasFlag(DynamicOcclusionUpdateRate.EveryXFrames) && Time.frameCount >= m_LastFrameRendered + waitXFrames)
				{
					flag = true;
				}
				if (flag)
				{
					ProcessOcclusion(ProcessOcclusionSource.RenderLoop);
				}
			}
		}

		private void DisableOcclusion()
		{
			m_Master._INTERNAL_SetDynamicOcclusionCallback(GetShaderKeyword(), null);
		}
	}
	[ExecuteInEditMode]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-dynocclusion-sd-depthbuffer/")]
	[AddComponentMenu("VLB/SD/Dynamic Occlusion (Depth Buffer)")]
	public class DynamicOcclusionDepthBuffer : DynamicOcclusionAbstractBase
	{
		public new const string ClassName = "DynamicOcclusionDepthBuffer";

		public LayerMask layerMask = Consts.DynOcclusion.LayerMaskDefault;

		public bool useOcclusionCulling = true;

		public int depthMapResolution = 128;

		public float fadeDistanceToSurface;

		private Camera m_DepthCamera;

		private bool m_NeedToUpdateOcclusionNextFrame;

		protected override string GetShaderKeyword()
		{
			return "VLB_OCCLUSION_DEPTH_TEXTURE";
		}

		protected override MaterialManager.SD.DynamicOcclusion GetDynamicOcclusionMode()
		{
			return MaterialManager.SD.DynamicOcclusion.DepthTexture;
		}

		private void ProcessOcclusionInternal()
		{
			UpdateDepthCameraPropertiesAccordingToBeam();
			m_DepthCamera.Render();
		}

		protected override bool OnProcessOcclusion(ProcessOcclusionSource source)
		{
			if (SRPHelper.IsUsingCustomRenderPipeline())
			{
				m_NeedToUpdateOcclusionNextFrame = true;
			}
			else
			{
				ProcessOcclusionInternal();
			}
			return true;
		}

		private void Update()
		{
			if (m_NeedToUpdateOcclusionNextFrame && (bool)m_Master && (bool)m_DepthCamera && Time.frameCount > 1)
			{
				ProcessOcclusionInternal();
				m_NeedToUpdateOcclusionNextFrame = false;
			}
		}

		private void UpdateDepthCameraPropertiesAccordingToBeam()
		{
			Utils.SetupDepthCamera(m_DepthCamera, m_Master.coneApexOffsetZ, m_Master.maxGeometryDistance, m_Master.coneRadiusStart, m_Master.coneRadiusEnd, m_Master.beamLocalForward, m_Master.GetLossyScale(), m_Master.IsScalable(), m_Master.beamInternalLocalRotation, shouldScaleMinNearClipPlane: true);
		}

		public bool HasLayerMaskIssues()
		{
			if (Config.Instance.geometryOverrideLayer)
			{
				int num = 1 << Config.Instance.geometryLayerID;
				return (layerMask.value & num) == num;
			}
			return false;
		}

		protected override void OnValidateProperties()
		{
			base.OnValidateProperties();
			depthMapResolution = Mathf.Clamp(Mathf.NextPowerOfTwo(depthMapResolution), 8, 2048);
			fadeDistanceToSurface = Mathf.Max(fadeDistanceToSurface, 0f);
		}

		private void InstantiateOrActivateDepthCamera()
		{
			if (m_DepthCamera != null)
			{
				m_DepthCamera.gameObject.SetActive(value: true);
				return;
			}
			base.gameObject.ForeachComponentsInDirectChildrenOnly(delegate(Camera cam)
			{
				UnityEngine.Object.DestroyImmediate(cam.gameObject);
			}, includeInactive: true);
			m_DepthCamera = Utils.NewWithComponent<Camera>("Depth Camera");
			if ((bool)m_DepthCamera && (bool)m_Master)
			{
				m_DepthCamera.enabled = false;
				m_DepthCamera.cullingMask = layerMask;
				m_DepthCamera.clearFlags = CameraClearFlags.Depth;
				m_DepthCamera.depthTextureMode = DepthTextureMode.Depth;
				m_DepthCamera.renderingPath = RenderingPath.VertexLit;
				m_DepthCamera.useOcclusionCulling = useOcclusionCulling;
				m_DepthCamera.gameObject.hideFlags = Consts.Internal.ProceduralObjectsHideFlags;
				m_DepthCamera.transform.SetParent(base.transform, worldPositionStays: false);
				Config.Instance.SetURPScriptableRendererIndexToDepthCamera(m_DepthCamera);
				RenderTexture targetTexture = new RenderTexture(depthMapResolution, depthMapResolution, 16, RenderTextureFormat.Depth);
				m_DepthCamera.targetTexture = targetTexture;
				UpdateDepthCameraPropertiesAccordingToBeam();
			}
		}

		protected override void OnEnablePostValidate()
		{
			InstantiateOrActivateDepthCamera();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if ((bool)m_DepthCamera)
			{
				m_DepthCamera.gameObject.SetActive(value: false);
			}
		}

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			DestroyDepthCamera();
		}

		private void DestroyDepthCamera()
		{
			if ((bool)m_DepthCamera)
			{
				if ((bool)m_DepthCamera.targetTexture)
				{
					m_DepthCamera.targetTexture.Release();
					UnityEngine.Object.DestroyImmediate(m_DepthCamera.targetTexture);
					m_DepthCamera.targetTexture = null;
				}
				UnityEngine.Object.DestroyImmediate(m_DepthCamera.gameObject);
				m_DepthCamera = null;
			}
		}

		protected override void OnModifyMaterialCallback(MaterialModifier.Interface owner)
		{
			owner.SetMaterialProp(ShaderProperties.SD.DynamicOcclusionDepthTexture, m_DepthCamera.targetTexture);
			Vector3 lossyScale = m_Master.GetLossyScale();
			owner.SetMaterialProp(ShaderProperties.SD.DynamicOcclusionDepthProps, new Vector4(Mathf.Sign(lossyScale.x) * Mathf.Sign(lossyScale.z), Mathf.Sign(lossyScale.y), fadeDistanceToSurface, m_DepthCamera.orthographic ? 0f : 1f));
		}
	}
	[ExecuteInEditMode]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-dynocclusion-sd-raycasting/")]
	[AddComponentMenu("VLB/SD/Dynamic Occlusion (Raycasting)")]
	public class DynamicOcclusionRaycasting : DynamicOcclusionAbstractBase
	{
		public struct HitResult
		{
			public Vector3 point;

			public Vector3 normal;

			public float distance;

			private Collider2D collider2D;

			private Collider collider3D;

			public bool hasCollider
			{
				get
				{
					if (!collider2D)
					{
						return collider3D;
					}
					return true;
				}
			}

			public string name
			{
				get
				{
					if ((bool)collider3D)
					{
						return collider3D.name;
					}
					if ((bool)collider2D)
					{
						return collider2D.name;
					}
					return "null collider";
				}
			}

			public Bounds bounds
			{
				get
				{
					if ((bool)collider3D)
					{
						return collider3D.bounds;
					}
					if ((bool)collider2D)
					{
						return collider2D.bounds;
					}
					return default(Bounds);
				}
			}

			public HitResult(ref RaycastHit hit3D)
			{
				point = hit3D.point;
				normal = hit3D.normal;
				distance = hit3D.distance;
				collider3D = hit3D.collider;
				collider2D = null;
			}

			public HitResult(ref RaycastHit2D hit2D)
			{
				point = hit2D.point;
				normal = hit2D.normal;
				distance = hit2D.distance;
				collider2D = hit2D.collider;
				collider3D = null;
			}

			public void SetNull()
			{
				collider2D = null;
				collider3D = null;
			}
		}

		private enum Direction
		{
			Up = 0,
			Down = 1,
			Left = 2,
			Right = 3,
			Max2D = 1,
			Max3D = 3
		}

		public new const string ClassName = "DynamicOcclusionRaycasting";

		public Dimensions dimensions;

		public LayerMask layerMask = Consts.DynOcclusion.LayerMaskDefault;

		public bool considerTriggers;

		public float minOccluderArea;

		public float minSurfaceRatio = 0.5f;

		public float maxSurfaceDot = 0.25f;

		public PlaneAlignment planeAlignment;

		public float planeOffset = 0.1f;

		[FormerlySerializedAs("fadeDistanceToPlane")]
		public float fadeDistanceToSurface = 0.25f;

		private HitResult m_CurrentHit;

		private float m_RangeMultiplier = 1f;

		private uint m_PrevNonSubHitDirectionId;

		[Obsolete("Use 'fadeDistanceToSurface' instead")]
		public float fadeDistanceToPlane
		{
			get
			{
				return fadeDistanceToSurface;
			}
			set
			{
				fadeDistanceToSurface = value;
			}
		}

		public Plane planeEquationWS { get; private set; }

		private QueryTriggerInteraction queryTriggerInteraction
		{
			get
			{
				if (!considerTriggers)
				{
					return QueryTriggerInteraction.Ignore;
				}
				return QueryTriggerInteraction.Collide;
			}
		}

		private float raycastMaxDistance => m_Master.raycastDistance * m_RangeMultiplier * m_Master.GetLossyScale().z;

		public bool IsColliderHiddenByDynamicOccluder(Collider collider)
		{
			if (!planeEquationWS.IsValid())
			{
				return false;
			}
			return !GeometryUtility.TestPlanesAABB(new Plane[1] { planeEquationWS }, collider.bounds);
		}

		protected override string GetShaderKeyword()
		{
			return "VLB_OCCLUSION_CLIPPING_PLANE";
		}

		protected override MaterialManager.SD.DynamicOcclusion GetDynamicOcclusionMode()
		{
			return MaterialManager.SD.DynamicOcclusion.ClippingPlane;
		}

		protected override void OnValidateProperties()
		{
			base.OnValidateProperties();
			minOccluderArea = Mathf.Max(minOccluderArea, 0f);
			fadeDistanceToSurface = Mathf.Max(fadeDistanceToSurface, 0f);
		}

		protected override void OnEnablePostValidate()
		{
			m_CurrentHit.SetNull();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			SetHitNull();
		}

		private void Start()
		{
			if (Application.isPlaying)
			{
				TriggerZone component = GetComponent<TriggerZone>();
				if ((bool)component)
				{
					m_RangeMultiplier = Mathf.Max(1f, component.rangeMultiplier);
				}
			}
		}

		private Vector3 GetRandomVectorAround(Vector3 direction, float angleDiff)
		{
			float num = angleDiff * 0.5f;
			return Quaternion.Euler(UnityEngine.Random.Range(0f - num, num), UnityEngine.Random.Range(0f - num, num), UnityEngine.Random.Range(0f - num, num)) * direction;
		}

		private HitResult GetBestHit(Vector3 rayPos, Vector3 rayDir)
		{
			if (dimensions != Dimensions.Dim2D)
			{
				return GetBestHit3D(rayPos, rayDir);
			}
			return GetBestHit2D(rayPos, rayDir);
		}

		private HitResult GetBestHit3D(Vector3 rayPos, Vector3 rayDir)
		{
			RaycastHit[] array = Physics.RaycastAll(rayPos, rayDir, raycastMaxDistance, layerMask.value, queryTriggerInteraction);
			int num = -1;
			float num2 = float.MaxValue;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].collider.gameObject != m_Master.gameObject && array[i].collider.bounds.GetMaxArea2D() >= minOccluderArea && array[i].distance < num2)
				{
					num2 = array[i].distance;
					num = i;
				}
			}
			if (num != -1)
			{
				return new HitResult(ref array[num]);
			}
			return default(HitResult);
		}

		private HitResult GetBestHit2D(Vector3 rayPos, Vector3 rayDir)
		{
			RaycastHit2D[] array = Physics2D.RaycastAll(new Vector2(rayPos.x, rayPos.y), new Vector2(rayDir.x, rayDir.y), raycastMaxDistance, layerMask.value);
			int num = -1;
			float num2 = float.MaxValue;
			for (int i = 0; i < array.Length; i++)
			{
				if ((considerTriggers || !array[i].collider.isTrigger) && array[i].collider.gameObject != m_Master.gameObject && array[i].collider.bounds.GetMaxArea2D() >= minOccluderArea && array[i].distance < num2)
				{
					num2 = array[i].distance;
					num = i;
				}
			}
			if (num != -1)
			{
				return new HitResult(ref array[num]);
			}
			return default(HitResult);
		}

		private uint GetDirectionCount()
		{
			if (dimensions != Dimensions.Dim2D)
			{
				return 4u;
			}
			return 2u;
		}

		private Vector3 GetDirection(uint dirInt)
		{
			dirInt %= GetDirectionCount();
			return dirInt switch
			{
				0u => m_Master.raycastGlobalUp, 
				3u => m_Master.raycastGlobalRight, 
				1u => -m_Master.raycastGlobalUp, 
				2u => -m_Master.raycastGlobalRight, 
				_ => Vector3.zero, 
			};
		}

		private bool IsHitValid(ref HitResult hit, Vector3 forwardVec)
		{
			if (hit.hasCollider)
			{
				return Vector3.Dot(hit.normal, -forwardVec) >= maxSurfaceDot;
			}
			return false;
		}

		protected override bool OnProcessOcclusion(ProcessOcclusionSource source)
		{
			Vector3 raycastGlobalForward = m_Master.raycastGlobalForward;
			HitResult hit = GetBestHit(base.transform.position, raycastGlobalForward);
			if (IsHitValid(ref hit, raycastGlobalForward))
			{
				if (minSurfaceRatio > 0.5f)
				{
					float raycastDistance = m_Master.raycastDistance;
					for (uint num = 0u; num < GetDirectionCount(); num++)
					{
						Vector3 vector = GetDirection(num + m_PrevNonSubHitDirectionId) * (minSurfaceRatio * 2f - 1f);
						vector.Scale(base.transform.localScale);
						Vector3 vector2 = base.transform.position + vector * m_Master.coneRadiusStart;
						Vector3 vector3 = base.transform.position + vector * m_Master.coneRadiusEnd + raycastGlobalForward * raycastDistance;
						HitResult hit2 = GetBestHit(vector2, (vector3 - vector2).normalized);
						if (IsHitValid(ref hit2, raycastGlobalForward))
						{
							if (hit2.distance > hit.distance)
							{
								hit = hit2;
							}
							continue;
						}
						m_PrevNonSubHitDirectionId = num;
						hit.SetNull();
						break;
					}
				}
			}
			else
			{
				hit.SetNull();
			}
			SetHit(ref hit);
			return hit.hasCollider;
		}

		private void SetHit(ref HitResult hit)
		{
			if (!hit.hasCollider)
			{
				SetHitNull();
				return;
			}
			PlaneAlignment planeAlignment = this.planeAlignment;
			if (planeAlignment != PlaneAlignment.Surface && planeAlignment == PlaneAlignment.Beam)
			{
				SetClippingPlane(new Plane(-m_Master.raycastGlobalForward, hit.point));
			}
			else
			{
				SetClippingPlane(new Plane(hit.normal, hit.point));
			}
			m_CurrentHit = hit;
		}

		private void SetHitNull()
		{
			SetClippingPlaneOff();
			m_CurrentHit.SetNull();
		}

		protected override void OnModifyMaterialCallback(MaterialModifier.Interface owner)
		{
			Plane plane = planeEquationWS;
			owner.SetMaterialProp(ShaderProperties.SD.DynamicOcclusionClippingPlaneWS, new Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.distance));
			owner.SetMaterialProp(ShaderProperties.SD.DynamicOcclusionClippingPlaneProps, fadeDistanceToSurface);
		}

		private void SetClippingPlane(Plane planeWS)
		{
			planeWS = planeWS.TranslateCustom(planeWS.normal * planeOffset);
			SetPlaneWS(planeWS);
			m_Master._INTERNAL_SetDynamicOcclusionCallback(GetShaderKeyword(), m_MaterialModifierCallbackCached);
		}

		private void SetClippingPlaneOff()
		{
			SetPlaneWS(default(Plane));
			m_Master._INTERNAL_SetDynamicOcclusionCallback(GetShaderKeyword(), null);
		}

		private void SetPlaneWS(Plane planeWS)
		{
			planeEquationWS = planeWS;
		}
	}
	public static class GlobalMeshSD
	{
		private static Mesh ms_Mesh;

		private static bool ms_DoubleSided;

		public static Mesh Get()
		{
			bool sD_requiresDoubleSidedMesh = Config.Instance.SD_requiresDoubleSidedMesh;
			if (ms_Mesh == null || ms_DoubleSided != sD_requiresDoubleSidedMesh)
			{
				Destroy();
				ms_Mesh = MeshGenerator.GenerateConeZ_Radii(1f, 1f, 1f, Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, cap: true, sD_requiresDoubleSidedMesh);
				ms_Mesh.hideFlags = Consts.Internal.ProceduralObjectsHideFlags;
				ms_DoubleSided = sD_requiresDoubleSidedMesh;
			}
			return ms_Mesh;
		}

		public static void Destroy()
		{
			if (ms_Mesh != null)
			{
				UnityEngine.Object.DestroyImmediate(ms_Mesh);
				ms_Mesh = null;
			}
		}
	}
	[ExecuteInEditMode]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-skewinghandle-sd/")]
	public class SkewingHandleSD : MonoBehaviour
	{
		public const string ClassName = "SkewingHandleSD";

		public VolumetricLightBeamSD volumetricLightBeam;

		public bool shouldUpdateEachFrame;

		public bool IsAttachedToSelf()
		{
			if (volumetricLightBeam != null)
			{
				return volumetricLightBeam.gameObject == base.gameObject;
			}
			return false;
		}

		public bool CanSetSkewingVector()
		{
			if (volumetricLightBeam != null)
			{
				return volumetricLightBeam.canHaveMeshSkewing;
			}
			return false;
		}

		public bool CanUpdateEachFrame()
		{
			if (CanSetSkewingVector())
			{
				return volumetricLightBeam.trackChangesDuringPlaytime;
			}
			return false;
		}

		private bool ShouldUpdateEachFrame()
		{
			if (shouldUpdateEachFrame)
			{
				return CanUpdateEachFrame();
			}
			return false;
		}

		private void OnEnable()
		{
			if (CanSetSkewingVector())
			{
				SetSkewingVector();
			}
		}

		private void Start()
		{
			if (Application.isPlaying && ShouldUpdateEachFrame())
			{
				StartCoroutine(CoUpdate());
			}
		}

		private IEnumerator CoUpdate()
		{
			while (ShouldUpdateEachFrame())
			{
				SetSkewingVector();
				yield return null;
			}
		}

		private void SetSkewingVector()
		{
			Vector3 skewingLocalForwardDirection = volumetricLightBeam.transform.InverseTransformPoint(base.transform.position);
			volumetricLightBeam.skewingLocalForwardDirection = skewingLocalForwardDirection;
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[SelectionBase]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam-sd/")]
	[AddComponentMenu("VLB/SD/Volumetric Light Beam SD")]
	public class VolumetricLightBeamSD : VolumetricLightBeamAbstractBase
	{
		public delegate void OnWillCameraRenderCB(Camera cam);

		public delegate void OnBeamGeometryInitialized();

		public new const string ClassName = "VolumetricLightBeamSD";

		public bool colorFromLight = true;

		public ColorMode colorMode;

		[ColorUsage(false, true)]
		[FormerlySerializedAs("colorValue")]
		public Color color = Consts.Beam.FlatColor;

		public Gradient colorGradient;

		public bool intensityFromLight = true;

		public bool intensityModeAdvanced;

		[FormerlySerializedAs("alphaInside")]
		[Min(0f)]
		public float intensityInside = 1f;

		[FormerlySerializedAs("alphaOutside")]
		[FormerlySerializedAs("alpha")]
		[Min(0f)]
		public float intensityOutside = 1f;

		[Min(0f)]
		public float intensityMultiplier = 1f;

		[Range(0f, 1f)]
		public float hdrpExposureWeight;

		public BlendingMode blendingMode;

		[FormerlySerializedAs("angleFromLight")]
		public bool spotAngleFromLight = true;

		[Range(0.1f, 179.9f)]
		public float spotAngle = 35f;

		[Min(0f)]
		public float spotAngleMultiplier = 1f;

		[FormerlySerializedAs("radiusStart")]
		public float coneRadiusStart = 0.1f;

		public ShaderAccuracy shaderAccuracy;

		public MeshType geomMeshType;

		[FormerlySerializedAs("geomSides")]
		public int geomCustomSides = 18;

		public int geomCustomSegments = 5;

		public Vector3 skewingLocalForwardDirection = Consts.Beam.SD.SkewingLocalForwardDirectionDefault;

		public Transform clippingPlaneTransform;

		public bool geomCap;

		public AttenuationEquation attenuationEquation = AttenuationEquation.Quadratic;

		[Range(0f, 1f)]
		public float attenuationCustomBlending = 0.5f;

		[FormerlySerializedAs("fadeStart")]
		public float fallOffStart;

		[FormerlySerializedAs("fadeEnd")]
		public float fallOffEnd = 3f;

		[FormerlySerializedAs("fadeEndFromLight")]
		public bool fallOffEndFromLight = true;

		[Min(0f)]
		public float fallOffEndMultiplier = 1f;

		public float depthBlendDistance = 2f;

		public float cameraClippingDistance = 0.5f;

		[Range(0f, 1f)]
		public float glareFrontal = 0.5f;

		[Range(0f, 1f)]
		public float glareBehind = 0.5f;

		[FormerlySerializedAs("fresnelPowOutside")]
		public float fresnelPow = 8f;

		public NoiseMode noiseMode;

		[Range(0f, 1f)]
		public float noiseIntensity = 0.5f;

		public bool noiseScaleUseGlobal = true;

		[Range(0.01f, 2f)]
		public float noiseScaleLocal = 0.5f;

		public bool noiseVelocityUseGlobal = true;

		public Vector3 noiseVelocityLocal = Consts.Beam.NoiseVelocityDefault;

		public Dimensions dimensions;

		public Vector2 tiltFactor = Consts.Beam.SD.TiltDefault;

		private MaterialManager.SD.DynamicOcclusion m_INTERNAL_DynamicOcclusionMode;

		private bool m_INTERNAL_DynamicOcclusionMode_Runtime;

		private OnBeamGeometryInitialized m_OnBeamGeometryInitialized;

		[FormerlySerializedAs("trackChangesDuringPlaytime")]
		[SerializeField]
		private bool _TrackChangesDuringPlaytime;

		[SerializeField]
		private int _SortingLayerID;

		[SerializeField]
		private int _SortingOrder;

		[FormerlySerializedAs("fadeOutBegin")]
		[SerializeField]
		private float _FadeOutBegin = -150f;

		[FormerlySerializedAs("fadeOutEnd")]
		[SerializeField]
		private float _FadeOutEnd = -200f;

		private BeamGeometrySD m_BeamGeom;

		private Coroutine m_CoPlaytimeUpdate;

		public ColorMode usedColorMode
		{
			get
			{
				if (Config.Instance.featureEnabledColorGradient == FeatureEnabledColorGradient.Off)
				{
					return ColorMode.Flat;
				}
				return colorMode;
			}
		}

		private bool useColorFromAttachedLightSpot
		{
			get
			{
				if (colorFromLight)
				{
					return base.lightSpotAttached != null;
				}
				return false;
			}
		}

		private bool useColorTemperatureFromAttachedLightSpot
		{
			get
			{
				if (useColorFromAttachedLightSpot && base.lightSpotAttached.useColorTemperature)
				{
					return Config.Instance.useLightColorTemperature;
				}
				return false;
			}
		}

		[Obsolete("Use 'intensityGlobal' or 'intensityInside' instead")]
		public float alphaInside
		{
			get
			{
				return intensityInside;
			}
			set
			{
				intensityInside = value;
			}
		}

		[Obsolete("Use 'intensityGlobal' or 'intensityOutside' instead")]
		public float alphaOutside
		{
			get
			{
				return intensityOutside;
			}
			set
			{
				intensityOutside = value;
			}
		}

		public float intensityGlobal
		{
			get
			{
				return intensityOutside;
			}
			set
			{
				intensityInside = value;
				intensityOutside = value;
			}
		}

		public bool useIntensityFromAttachedLightSpot
		{
			get
			{
				if (intensityFromLight)
				{
					return base.lightSpotAttached != null;
				}
				return false;
			}
		}

		public bool useSpotAngleFromAttachedLightSpot
		{
			get
			{
				if (spotAngleFromLight)
				{
					return base.lightSpotAttached != null;
				}
				return false;
			}
		}

		public float coneAngle => Mathf.Atan2(coneRadiusEnd - coneRadiusStart, maxGeometryDistance) * 57.29578f * 2f;

		public float coneRadiusEnd
		{
			get
			{
				return Utils.ComputeConeRadiusEnd(maxGeometryDistance, spotAngle);
			}
			set
			{
				spotAngle = Utils.ComputeSpotAngle(maxGeometryDistance, value);
			}
		}

		public float coneVolume
		{
			get
			{
				float num = coneRadiusStart;
				float num2 = coneRadiusEnd;
				return MathF.PI / 3f * (num * num + num * num2 + num2 * num2) * fallOffEnd;
			}
		}

		public float coneApexOffsetZ
		{
			get
			{
				float num = coneRadiusStart / coneRadiusEnd;
				if (num != 1f)
				{
					return maxGeometryDistance * num / (1f - num);
				}
				return float.MaxValue;
			}
		}

		public Vector3 coneApexPositionLocal => new Vector3(0f, 0f, 0f - coneApexOffsetZ);

		public Vector3 coneApexPositionGlobal => base.transform.localToWorldMatrix.MultiplyPoint(coneApexPositionLocal);

		public int geomSides
		{
			get
			{
				if (geomMeshType != MeshType.Custom)
				{
					return Config.Instance.sharedMeshSides;
				}
				return geomCustomSides;
			}
			set
			{
				geomCustomSides = value;
				UnityEngine.Debug.LogWarningFormat("The setter VLB.{0}.geomSides is OBSOLETE and has been renamed to geomCustomSides.", "VolumetricLightBeamSD");
			}
		}

		public int geomSegments
		{
			get
			{
				if (geomMeshType != MeshType.Custom)
				{
					return Config.Instance.sharedMeshSegments;
				}
				return geomCustomSegments;
			}
			set
			{
				geomCustomSegments = value;
				UnityEngine.Debug.LogWarningFormat("The setter VLB.{0}.geomSegments is OBSOLETE and has been renamed to geomCustomSegments.", "VolumetricLightBeamSD");
			}
		}

		public Vector3 skewingLocalForwardDirectionNormalized
		{
			get
			{
				if (Mathf.Approximately(skewingLocalForwardDirection.z, 0f))
				{
					UnityEngine.Debug.LogErrorFormat("Beam {0} has a skewingLocalForwardDirection with a null Z, which is forbidden", base.name);
					return Vector3.forward;
				}
				return skewingLocalForwardDirection.normalized;
			}
		}

		public bool canHaveMeshSkewing => geomMeshType == MeshType.Custom;

		public bool hasMeshSkewing
		{
			get
			{
				if (!Config.Instance.featureEnabledMeshSkewing)
				{
					return false;
				}
				if (!canHaveMeshSkewing)
				{
					return false;
				}
				if (Mathf.Approximately(Vector3.Dot(skewingLocalForwardDirectionNormalized, Vector3.forward), 1f))
				{
					return false;
				}
				return true;
			}
		}

		public Vector4 additionalClippingPlane
		{
			get
			{
				if (!(clippingPlaneTransform == null))
				{
					return Utils.PlaneEquation(clippingPlaneTransform.forward, clippingPlaneTransform.position);
				}
				return Vector4.zero;
			}
		}

		public float attenuationLerpLinearQuad
		{
			get
			{
				if (attenuationEquation == AttenuationEquation.Linear)
				{
					return 0f;
				}
				if (attenuationEquation == AttenuationEquation.Quadratic)
				{
					return 1f;
				}
				return attenuationCustomBlending;
			}
		}

		[Obsolete("Use 'fallOffStart' instead")]
		public float fadeStart
		{
			get
			{
				return fallOffStart;
			}
			set
			{
				fallOffStart = value;
			}
		}

		[Obsolete("Use 'fallOffEnd' instead")]
		public float fadeEnd
		{
			get
			{
				return fallOffEnd;
			}
			set
			{
				fallOffEnd = value;
			}
		}

		[Obsolete("Use 'fallOffEndFromLight' instead")]
		public bool fadeEndFromLight
		{
			get
			{
				return fallOffEndFromLight;
			}
			set
			{
				fallOffEndFromLight = value;
			}
		}

		public bool useFallOffEndFromAttachedLightSpot
		{
			get
			{
				if (fallOffEndFromLight)
				{
					return base.lightSpotAttached != null;
				}
				return false;
			}
		}

		public float maxGeometryDistance => fallOffEnd + Mathf.Max(Mathf.Abs(tiltFactor.x), Mathf.Abs(tiltFactor.y));

		public bool isNoiseEnabled => noiseMode != NoiseMode.Disabled;

		[Obsolete("Use 'noiseMode' instead")]
		public bool noiseEnabled
		{
			get
			{
				return isNoiseEnabled;
			}
			set
			{
				noiseMode = (value ? NoiseMode.WorldSpace : NoiseMode.Disabled);
			}
		}

		public float fadeOutBegin
		{
			get
			{
				return _FadeOutBegin;
			}
			set
			{
				SetFadeOutValue(ref _FadeOutBegin, value);
			}
		}

		public float fadeOutEnd
		{
			get
			{
				return _FadeOutEnd;
			}
			set
			{
				SetFadeOutValue(ref _FadeOutEnd, value);
			}
		}

		public bool isFadeOutEnabled
		{
			get
			{
				if (_FadeOutBegin >= 0f)
				{
					return _FadeOutEnd >= 0f;
				}
				return false;
			}
		}

		public bool isTilted => !tiltFactor.Approximately(Vector2.zero);

		public int sortingLayerID
		{
			get
			{
				return _SortingLayerID;
			}
			set
			{
				_SortingLayerID = value;
				if ((bool)m_BeamGeom)
				{
					m_BeamGeom.sortingLayerID = value;
				}
			}
		}

		public string sortingLayerName
		{
			get
			{
				return SortingLayer.IDToName(sortingLayerID);
			}
			set
			{
				sortingLayerID = SortingLayer.NameToID(value);
			}
		}

		public int sortingOrder
		{
			get
			{
				return _SortingOrder;
			}
			set
			{
				_SortingOrder = value;
				if ((bool)m_BeamGeom)
				{
					m_BeamGeom.sortingOrder = value;
				}
			}
		}

		public bool trackChangesDuringPlaytime
		{
			get
			{
				return _TrackChangesDuringPlaytime;
			}
			set
			{
				_TrackChangesDuringPlaytime = value;
				StartPlaytimeUpdateIfNeeded();
			}
		}

		public bool isCurrentlyTrackingChanges => m_CoPlaytimeUpdate != null;

		public int blendingModeAsInt => Mathf.Clamp((int)blendingMode, 0, Enum.GetValues(typeof(BlendingMode)).Length);

		public Quaternion beamInternalLocalRotation
		{
			get
			{
				if (dimensions != Dimensions.Dim3D)
				{
					return Quaternion.LookRotation(Vector3.right, Vector3.up);
				}
				return Quaternion.identity;
			}
		}

		public Vector3 beamLocalForward
		{
			get
			{
				if (dimensions != Dimensions.Dim3D)
				{
					return Vector3.right;
				}
				return Vector3.forward;
			}
		}

		public Vector3 beamGlobalForward => base.transform.TransformDirection(beamLocalForward);

		public float raycastDistance
		{
			get
			{
				if (!hasMeshSkewing)
				{
					return maxGeometryDistance;
				}
				float z = skewingLocalForwardDirectionNormalized.z;
				if (!Mathf.Approximately(z, 0f))
				{
					return maxGeometryDistance / z;
				}
				return maxGeometryDistance;
			}
		}

		public Vector3 raycastGlobalForward => ComputeRaycastGlobalVector(hasMeshSkewing ? skewingLocalForwardDirectionNormalized : Vector3.forward);

		public Vector3 raycastGlobalUp => ComputeRaycastGlobalVector(Vector3.up);

		public Vector3 raycastGlobalRight => ComputeRaycastGlobalVector(Vector3.right);

		public MaterialManager.SD.DynamicOcclusion _INTERNAL_DynamicOcclusionMode
		{
			get
			{
				if (!Config.Instance.featureEnabledDynamicOcclusion)
				{
					return MaterialManager.SD.DynamicOcclusion.Off;
				}
				return m_INTERNAL_DynamicOcclusionMode;
			}
			set
			{
				m_INTERNAL_DynamicOcclusionMode = value;
			}
		}

		public MaterialManager.SD.DynamicOcclusion _INTERNAL_DynamicOcclusionMode_Runtime
		{
			get
			{
				if (!m_INTERNAL_DynamicOcclusionMode_Runtime)
				{
					return MaterialManager.SD.DynamicOcclusion.Off;
				}
				return _INTERNAL_DynamicOcclusionMode;
			}
		}

		public uint _INTERNAL_InstancedMaterialGroupID { get; protected set; }

		public string meshStats
		{
			get
			{
				Mesh mesh = (m_BeamGeom ? m_BeamGeom.coneMesh : null);
				if ((bool)mesh)
				{
					return $"Cone angle: {coneAngle:0.0} degrees\nMesh: {mesh.vertexCount} vertices, {mesh.triangles.Length / 3} triangles";
				}
				return "no mesh available";
			}
		}

		public int meshVerticesCount
		{
			get
			{
				if (!m_BeamGeom || !m_BeamGeom.coneMesh)
				{
					return 0;
				}
				return m_BeamGeom.coneMesh.vertexCount;
			}
		}

		public int meshTrianglesCount
		{
			get
			{
				if (!m_BeamGeom || !m_BeamGeom.coneMesh)
				{
					return 0;
				}
				return m_BeamGeom.coneMesh.triangles.Length / 3;
			}
		}

		public event OnWillCameraRenderCB onWillCameraRenderThisBeam;

		public void GetInsideAndOutsideIntensity(out float inside, out float outside)
		{
			if (intensityModeAdvanced)
			{
				inside = intensityInside;
				outside = intensityOutside;
			}
			else
			{
				inside = (outside = intensityOutside);
			}
		}

		public override bool IsScalable()
		{
			return true;
		}

		public override BeamGeometryAbstractBase GetBeamGeometry()
		{
			return m_BeamGeom;
		}

		protected override void SetBeamGeometryNull()
		{
			m_BeamGeom = null;
		}

		public override Vector3 GetLossyScale()
		{
			if (dimensions != Dimensions.Dim3D)
			{
				return new Vector3(base.transform.lossyScale.z, base.transform.lossyScale.y, base.transform.lossyScale.x);
			}
			return base.transform.lossyScale;
		}

		private Vector3 ComputeRaycastGlobalVector(Vector3 localVec)
		{
			return base.transform.rotation * beamInternalLocalRotation * localVec;
		}

		public void _INTERNAL_SetDynamicOcclusionCallback(string shaderKeyword, MaterialModifier.Callback cb)
		{
			m_INTERNAL_DynamicOcclusionMode_Runtime = cb != null;
			if ((bool)m_BeamGeom)
			{
				m_BeamGeom.SetDynamicOcclusionCallback(shaderKeyword, cb);
			}
		}

		public void _INTERNAL_OnWillCameraRenderThisBeam(Camera cam)
		{
			if (this.onWillCameraRenderThisBeam != null)
			{
				this.onWillCameraRenderThisBeam(cam);
			}
		}

		public void RegisterOnBeamGeometryInitializedCallback(OnBeamGeometryInitialized cb)
		{
			m_OnBeamGeometryInitialized = (OnBeamGeometryInitialized)Delegate.Combine(m_OnBeamGeometryInitialized, cb);
			if ((bool)m_BeamGeom)
			{
				CallOnBeamGeometryInitializedCallback();
			}
		}

		private void CallOnBeamGeometryInitializedCallback()
		{
			if (m_OnBeamGeometryInitialized != null)
			{
				m_OnBeamGeometryInitialized();
				m_OnBeamGeometryInitialized = null;
			}
		}

		private void SetFadeOutValue(ref float propToChange, float value)
		{
			bool flag = isFadeOutEnabled;
			propToChange = value;
			if (isFadeOutEnabled != flag)
			{
				OnFadeOutStateChanged();
			}
		}

		private void OnFadeOutStateChanged()
		{
			if (isFadeOutEnabled && (bool)m_BeamGeom)
			{
				m_BeamGeom.RestartFadeOutCoroutine();
			}
		}

		public float GetInsideBeamFactor(Vector3 posWS)
		{
			return GetInsideBeamFactorFromObjectSpacePos(base.transform.InverseTransformPoint(posWS));
		}

		public float GetInsideBeamFactorFromObjectSpacePos(Vector3 posOS)
		{
			if (dimensions == Dimensions.Dim2D)
			{
				posOS = new Vector3(posOS.z, posOS.y, posOS.x);
			}
			if (posOS.z < 0f)
			{
				return -1f;
			}
			Vector2 vector = posOS.xy();
			if (hasMeshSkewing)
			{
				Vector3 aVector = skewingLocalForwardDirectionNormalized;
				vector -= aVector.xy() * (posOS.z / aVector.z);
			}
			Vector2 normalized = new Vector2(vector.magnitude, posOS.z + coneApexOffsetZ).normalized;
			return Mathf.Clamp((Mathf.Abs(Mathf.Sin(coneAngle * (MathF.PI / 180f) / 2f)) - Mathf.Abs(normalized.x)) / 0.1f, -1f, 1f);
		}

		[Obsolete("Use 'GenerateGeometry()' instead")]
		public void Generate()
		{
			GenerateGeometry();
		}

		public override void GenerateGeometry()
		{
			HandleBackwardCompatibility(pluginVersion, 20200);
			pluginVersion = 20200;
			ValidateProperties();
			if (m_BeamGeom == null)
			{
				m_BeamGeom = Utils.NewWithComponent<BeamGeometrySD>("Beam Geometry");
				m_BeamGeom.Initialize(this);
				CallOnBeamGeometryInitializedCallback();
			}
			m_BeamGeom.RegenerateMesh(base.enabled);
			base.GenerateGeometry();
		}

		public virtual void UpdateAfterManualPropertyChange()
		{
			ValidateProperties();
			if ((bool)m_BeamGeom)
			{
				m_BeamGeom.UpdateMaterialAndBounds();
			}
		}

		private void Start()
		{
			InitLightSpotAttachedCached();
			GenerateGeometry();
		}

		private void OnEnable()
		{
			if ((bool)m_BeamGeom)
			{
				m_BeamGeom.OnMasterEnable();
			}
			StartPlaytimeUpdateIfNeeded();
		}

		private void OnDisable()
		{
			if ((bool)m_BeamGeom)
			{
				m_BeamGeom.OnMasterDisable();
			}
			m_CoPlaytimeUpdate = null;
		}

		private void StartPlaytimeUpdateIfNeeded()
		{
			if (Application.isPlaying && trackChangesDuringPlaytime && m_CoPlaytimeUpdate == null)
			{
				m_CoPlaytimeUpdate = StartCoroutine(CoPlaytimeUpdate());
			}
		}

		private IEnumerator CoPlaytimeUpdate()
		{
			while (trackChangesDuringPlaytime && base.enabled)
			{
				UpdateAfterManualPropertyChange();
				yield return null;
			}
			m_CoPlaytimeUpdate = null;
		}

		private void AssignPropertiesFromAttachedSpotLight()
		{
			Light light = base.lightSpotAttached;
			if (!light)
			{
				return;
			}
			if (intensityFromLight)
			{
				intensityModeAdvanced = false;
				intensityGlobal = SpotLightHelper.GetIntensity(light) * intensityMultiplier;
			}
			if (fallOffEndFromLight)
			{
				fallOffEnd = SpotLightHelper.GetFallOffEnd(light) * fallOffEndMultiplier;
			}
			if (spotAngleFromLight)
			{
				spotAngle = Mathf.Clamp(SpotLightHelper.GetSpotAngle(light) * spotAngleMultiplier, 0.1f, 179.9f);
			}
			if (colorFromLight)
			{
				colorMode = ColorMode.Flat;
				if (useColorTemperatureFromAttachedLightSpot)
				{
					Color color = Mathf.CorrelatedColorTemperatureToRGB(light.colorTemperature);
					this.color = (light.color.linear * color).gamma;
				}
				else
				{
					this.color = light.color;
				}
			}
		}

		private void ClampProperties()
		{
			intensityInside = Mathf.Max(intensityInside, 0f);
			intensityOutside = Mathf.Max(intensityOutside, 0f);
			intensityMultiplier = Mathf.Max(intensityMultiplier, 0f);
			attenuationCustomBlending = Mathf.Clamp(attenuationCustomBlending, 0f, 1f);
			fallOffEnd = Mathf.Max(0.01f, fallOffEnd);
			fallOffStart = Mathf.Clamp(fallOffStart, 0f, fallOffEnd - 0.01f);
			fallOffEndMultiplier = Mathf.Max(fallOffEndMultiplier, 0f);
			spotAngle = Mathf.Clamp(spotAngle, 0.1f, 179.9f);
			spotAngleMultiplier = Mathf.Max(spotAngleMultiplier, 0f);
			coneRadiusStart = Mathf.Max(coneRadiusStart, 0f);
			depthBlendDistance = Mathf.Max(depthBlendDistance, 0f);
			cameraClippingDistance = Mathf.Max(cameraClippingDistance, 0f);
			geomCustomSides = Mathf.Clamp(geomCustomSides, 3, 256);
			geomCustomSegments = Mathf.Clamp(geomCustomSegments, 0, 64);
			fresnelPow = Mathf.Max(0f, fresnelPow);
			glareBehind = Mathf.Clamp(glareBehind, 0f, 1f);
			glareFrontal = Mathf.Clamp(glareFrontal, 0f, 1f);
			noiseIntensity = Mathf.Clamp(noiseIntensity, 0f, 1f);
		}

		private void ValidateProperties()
		{
			AssignPropertiesFromAttachedSpotLight();
			ClampProperties();
		}

		private void HandleBackwardCompatibility(int serializedVersion, int newVersion)
		{
			if (serializedVersion != -1 && serializedVersion != newVersion)
			{
				if (serializedVersion < 1301)
				{
					attenuationEquation = AttenuationEquation.Linear;
				}
				if (serializedVersion < 1501)
				{
					geomMeshType = MeshType.Custom;
					geomCustomSegments = 5;
				}
				if (serializedVersion < 1610)
				{
					intensityFromLight = false;
					intensityModeAdvanced = !Mathf.Approximately(intensityInside, intensityOutside);
				}
				if (serializedVersion < 1910 && !intensityModeAdvanced && !Mathf.Approximately(intensityInside, intensityOutside))
				{
					intensityInside = intensityOutside;
				}
				Utils.MarkCurrentSceneDirty();
			}
		}
	}
	public static class ShaderKeywords
	{
		public static class SD
		{
			public const string DepthBlend = "VLB_DEPTH_BLEND";

			public const string OcclusionClippingPlane = "VLB_OCCLUSION_CLIPPING_PLANE";

			public const string OcclusionDepthTexture = "VLB_OCCLUSION_DEPTH_TEXTURE";

			public const string MeshSkewing = "VLB_MESH_SKEWING";

			public const string ShaderAccuracyHigh = "VLB_SHADER_ACCURACY_HIGH";
		}

		public static class HD
		{
			public const string AttenuationLinear = "VLB_ATTENUATION_LINEAR";

			public const string AttenuationQuad = "VLB_ATTENUATION_QUAD";

			public const string Shadow = "VLB_SHADOW";

			public const string CookieSingleChannel = "VLB_COOKIE_1CHANNEL";

			public const string CookieRGBA = "VLB_COOKIE_RGBA";

			public const string RaymarchingStepCount = "VLB_RAYMARCHING_STEP_COUNT";

			public static string GetRaymarchingQuality(int id)
			{
				return "VLB_RAYMARCHING_QUALITY_" + id;
			}
		}

		public const string AlphaAsBlack = "VLB_ALPHA_AS_BLACK";

		public const string ColorGradientMatrixLow = "VLB_COLOR_GRADIENT_MATRIX_LOW";

		public const string ColorGradientMatrixHigh = "VLB_COLOR_GRADIENT_MATRIX_HIGH";

		public const string Noise3D = "VLB_NOISE_3D";
	}
	public static class ShaderProperties
	{
		public static class SD
		{
			public static readonly int FadeOutFactor = Shader.PropertyToID("_FadeOutFactor");

			public static readonly int ConeSlopeCosSin = Shader.PropertyToID("_ConeSlopeCosSin");

			public static readonly int AlphaInside = Shader.PropertyToID("_AlphaInside");

			public static readonly int AlphaOutside = Shader.PropertyToID("_AlphaOutside");

			public static readonly int AttenuationLerpLinearQuad = Shader.PropertyToID("_AttenuationLerpLinearQuad");

			public static readonly int DistanceCamClipping = Shader.PropertyToID("_DistanceCamClipping");

			public static readonly int FresnelPow = Shader.PropertyToID("_FresnelPow");

			public static readonly int GlareBehind = Shader.PropertyToID("_GlareBehind");

			public static readonly int GlareFrontal = Shader.PropertyToID("_GlareFrontal");

			public static readonly int DrawCap = Shader.PropertyToID("_DrawCap");

			public static readonly int DepthBlendDistance = Shader.PropertyToID("_DepthBlendDistance");

			public static readonly int CameraParams = Shader.PropertyToID("_CameraParams");

			public static readonly int DynamicOcclusionClippingPlaneWS = Shader.PropertyToID("_DynamicOcclusionClippingPlaneWS");

			public static readonly int DynamicOcclusionClippingPlaneProps = Shader.PropertyToID("_DynamicOcclusionClippingPlaneProps");

			public static readonly int DynamicOcclusionDepthTexture = Shader.PropertyToID("_DynamicOcclusionDepthTexture");

			public static readonly int DynamicOcclusionDepthProps = Shader.PropertyToID("_DynamicOcclusionDepthProps");

			public static readonly int LocalForwardDirection = Shader.PropertyToID("_LocalForwardDirection");

			public static readonly int TiltVector = Shader.PropertyToID("_TiltVector");

			public static readonly int AdditionalClippingPlaneWS = Shader.PropertyToID("_AdditionalClippingPlaneWS");
		}

		public static class HD
		{
			public static readonly int Intensity = Shader.PropertyToID("_Intensity");

			public static readonly int SideSoftness = Shader.PropertyToID("_SideSoftness");

			public static readonly int CameraForwardOS = Shader.PropertyToID("_CameraForwardOS");

			public static readonly int CameraForwardWS = Shader.PropertyToID("_CameraForwardWS");

			public static readonly int TransformScale = Shader.PropertyToID("_TransformScale");

			public static readonly int ShadowDepthTexture = Shader.PropertyToID("_ShadowDepthTexture");

			public static readonly int ShadowProps = Shader.PropertyToID("_ShadowProps");

			public static readonly int Jittering = Shader.PropertyToID("_Jittering");

			public static readonly int CookieTexture = Shader.PropertyToID("_CookieTexture");

			public static readonly int CookieProperties = Shader.PropertyToID("_CookieProperties");

			public static readonly int CookiePosAndScale = Shader.PropertyToID("_CookiePosAndScale");

			public static readonly int GlobalCameraBlendingDistance = Shader.PropertyToID("_VLB_CameraBlendingDistance");

			public static readonly int GlobalJitteringNoiseTex = Shader.PropertyToID("_VLB_JitteringNoiseTex");
		}

		public static readonly int ConeRadius = Shader.PropertyToID("_ConeRadius");

		public static readonly int ConeGeomProps = Shader.PropertyToID("_ConeGeomProps");

		public static readonly int ColorFlat = Shader.PropertyToID("_ColorFlat");

		public static readonly int DistanceFallOff = Shader.PropertyToID("_DistanceFallOff");

		public static readonly int NoiseVelocityAndScale = Shader.PropertyToID("_NoiseVelocityAndScale");

		public static readonly int NoiseParam = Shader.PropertyToID("_NoiseParam");

		public static readonly int ColorGradientMatrix = Shader.PropertyToID("_ColorGradientMatrix");

		public static readonly int LocalToWorldMatrix = Shader.PropertyToID("_LocalToWorldMatrix");

		public static readonly int WorldToLocalMatrix = Shader.PropertyToID("_WorldToLocalMatrix");

		public static readonly int BlendSrcFactor = Shader.PropertyToID("_BlendSrcFactor");

		public static readonly int BlendDstFactor = Shader.PropertyToID("_BlendDstFactor");

		public static readonly int ZTest = Shader.PropertyToID("_ZTest");

		public static readonly int ParticlesTintColor = Shader.PropertyToID("_TintColor");

		public static readonly int HDRPExposureWeight = Shader.PropertyToID("_HDRPExposureWeight");

		public static readonly int GlobalUsesReversedZBuffer = Shader.PropertyToID("_VLB_UsesReversedZBuffer");

		public static readonly int GlobalNoiseTex3D = Shader.PropertyToID("_VLB_NoiseTex3D");

		public static readonly int GlobalNoiseCustomTime = Shader.PropertyToID("_VLB_NoiseCustomTime");

		public static readonly int GlobalDitheringFactor = Shader.PropertyToID("_VLB_DitheringFactor");

		public static readonly int GlobalDitheringNoiseTex = Shader.PropertyToID("_VLB_DitheringNoiseTex");
	}
	public static class SpotLightHelper
	{
		public static float GetIntensity(Light light)
		{
			if (!(light != null))
			{
				return 0f;
			}
			return light.intensity;
		}

		public static float GetSpotAngle(Light light)
		{
			if (!(light != null))
			{
				return 0f;
			}
			return light.spotAngle;
		}

		public static float GetFallOffEnd(Light light)
		{
			if (!(light != null))
			{
				return 0f;
			}
			return light.range;
		}
	}
	public static class SRPHelper
	{
		private static bool m_IsRenderPipelineCached;

		private static RenderPipeline m_RenderPipelineCached;

		public static string renderPipelineScriptingDefineSymbolAsString => "VLB_URP";

		public static RenderPipeline projectRenderPipeline
		{
			get
			{
				if (!m_IsRenderPipelineCached)
				{
					m_RenderPipelineCached = ComputeRenderPipeline();
					m_IsRenderPipelineCached = true;
				}
				return m_RenderPipelineCached;
			}
		}

		private static RenderPipeline ComputeRenderPipeline()
		{
			RenderPipelineAsset defaultRenderPipeline = GraphicsSettings.defaultRenderPipeline;
			if ((bool)defaultRenderPipeline)
			{
				string text = defaultRenderPipeline.GetType().ToString();
				if (text.Contains("Universal"))
				{
					return RenderPipeline.URP;
				}
				if (text.Contains("Lightweight"))
				{
					return RenderPipeline.URP;
				}
				if (text.Contains("HD"))
				{
					return RenderPipeline.HDRP;
				}
			}
			return RenderPipeline.BuiltIn;
		}

		public static bool IsUsingCustomRenderPipeline()
		{
			if (RenderPipelineManager.currentPipeline == null)
			{
				return GraphicsSettings.defaultRenderPipeline != null;
			}
			return true;
		}

		public static void RegisterOnBeginCameraRendering(Action<ScriptableRenderContext, Camera> cb)
		{
			if (IsUsingCustomRenderPipeline())
			{
				RenderPipelineManager.beginCameraRendering -= cb;
				RenderPipelineManager.beginCameraRendering += cb;
			}
		}

		public static void UnregisterOnBeginCameraRendering(Action<ScriptableRenderContext, Camera> cb)
		{
			if (IsUsingCustomRenderPipeline())
			{
				RenderPipelineManager.beginCameraRendering -= cb;
			}
		}
	}
	public static class TransformUtils
	{
		public struct Packed
		{
			public Vector3 position;

			public Quaternion rotation;

			public Vector3 lossyScale;

			public bool IsSame(Transform transf)
			{
				if (transf.position == position && transf.rotation == rotation)
				{
					return transf.lossyScale == lossyScale;
				}
				return false;
			}
		}

		public static Packed GetWorldPacked(this Transform self)
		{
			return new Packed
			{
				position = self.position,
				rotation = self.rotation,
				lossyScale = self.lossyScale
			};
		}
	}
	[DisallowMultipleComponent]
	[RequireComponent(typeof(VolumetricLightBeamAbstractBase))]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-triggerzone/")]
	[AddComponentMenu("VLB/Common/Trigger Zone")]
	public class TriggerZone : MonoBehaviour
	{
		private enum TriggerZoneUpdateRate
		{
			OnEnable,
			OnOcclusionChange
		}

		public const string ClassName = "TriggerZone";

		public bool setIsTrigger = true;

		public float rangeMultiplier = 1f;

		private const int kMeshColliderNumSides = 8;

		private VolumetricLightBeamAbstractBase m_Beam;

		private DynamicOcclusionRaycasting m_DynamicOcclusionRaycasting;

		private PolygonCollider2D m_PolygonCollider2D;

		private TriggerZoneUpdateRate updateRate
		{
			get
			{
				if (UtilsBeamProps.GetDimensions(m_Beam) == Dimensions.Dim3D)
				{
					return TriggerZoneUpdateRate.OnEnable;
				}
				if (!(m_DynamicOcclusionRaycasting != null))
				{
					return TriggerZoneUpdateRate.OnEnable;
				}
				return TriggerZoneUpdateRate.OnOcclusionChange;
			}
		}

		private void OnEnable()
		{
			m_Beam = GetComponent<VolumetricLightBeamAbstractBase>();
			m_DynamicOcclusionRaycasting = GetComponent<DynamicOcclusionRaycasting>();
			switch (updateRate)
			{
			case TriggerZoneUpdateRate.OnEnable:
				ComputeZone();
				base.enabled = false;
				break;
			case TriggerZoneUpdateRate.OnOcclusionChange:
				if ((bool)m_DynamicOcclusionRaycasting)
				{
					m_DynamicOcclusionRaycasting.onOcclusionProcessed += OnOcclusionProcessed;
				}
				break;
			}
		}

		private void OnOcclusionProcessed()
		{
			ComputeZone();
		}

		private void ComputeZone()
		{
			if (!m_Beam)
			{
				return;
			}
			float coneRadiusStart = UtilsBeamProps.GetConeRadiusStart(m_Beam);
			float num = UtilsBeamProps.GetFallOffEnd(m_Beam) * rangeMultiplier;
			float num2 = Mathf.LerpUnclamped(coneRadiusStart, UtilsBeamProps.GetConeRadiusEnd(m_Beam), rangeMultiplier);
			if (UtilsBeamProps.GetDimensions(m_Beam) == Dimensions.Dim3D)
			{
				MeshCollider orAddComponent = base.gameObject.GetOrAddComponent<MeshCollider>();
				Mathf.Min(UtilsBeamProps.GetGeomSides(m_Beam), 8);
				Mesh mesh = MeshGenerator.GenerateConeZ_Radii_DoubleCaps(num, coneRadiusStart, num2, 8, inverted: false);
				mesh.hideFlags = Consts.Internal.ProceduralObjectsHideFlags;
				orAddComponent.sharedMesh = mesh;
				orAddComponent.convex = setIsTrigger;
				orAddComponent.isTrigger = setIsTrigger;
				return;
			}
			if (m_PolygonCollider2D == null)
			{
				m_PolygonCollider2D = base.gameObject.GetOrAddComponent<PolygonCollider2D>();
			}
			Vector2[] array = new Vector2[4]
			{
				new Vector2(0f, 0f - coneRadiusStart),
				new Vector2(num, 0f - num2),
				new Vector2(num, num2),
				new Vector2(0f, coneRadiusStart)
			};
			if ((bool)m_DynamicOcclusionRaycasting && m_DynamicOcclusionRaycasting.planeEquationWS.IsValid())
			{
				Plane planeEquationWS = m_DynamicOcclusionRaycasting.planeEquationWS;
				if (Utils.IsAlmostZero(planeEquationWS.normal.z))
				{
					Vector3 vector = planeEquationWS.ClosestPointOnPlaneCustom(Vector3.zero);
					Vector3 vector2 = planeEquationWS.ClosestPointOnPlaneCustom(Vector3.up);
					if (Utils.IsAlmostZero(Vector3.SqrMagnitude(vector - vector2)))
					{
						vector = planeEquationWS.ClosestPointOnPlaneCustom(Vector3.right);
					}
					vector = base.transform.InverseTransformPoint(vector);
					vector2 = base.transform.InverseTransformPoint(vector2);
					PolygonHelper.Plane2D plane2D = PolygonHelper.Plane2D.FromPoints(vector, vector2);
					if (plane2D.normal.x > 0f)
					{
						plane2D.Flip();
					}
					array = plane2D.CutConvex(array);
				}
			}
			m_PolygonCollider2D.points = array;
			m_PolygonCollider2D.isTrigger = setIsTrigger;
		}
	}
	public static class Utils
	{
		public enum FloatPackingPrecision
		{
			High = 64,
			Low = 8,
			Undef = 0
		}

		private const float kEpsilon = 1E-05f;

		private static FloatPackingPrecision ms_FloatPackingPrecision;

		private const int kFloatPackingHighMinShaderLevel = 35;

		public static float ComputeConeRadiusEnd(float fallOffEnd, float spotAngle)
		{
			return fallOffEnd * Mathf.Tan(spotAngle * (MathF.PI / 180f) * 0.5f);
		}

		public static float ComputeSpotAngle(float fallOffEnd, float coneRadiusEnd)
		{
			return Mathf.Atan2(coneRadiusEnd, fallOffEnd) * 57.29578f * 2f;
		}

		public static void Swap<T>(ref T a, ref T b)
		{
			T val = a;
			a = b;
			b = val;
		}

		public static void ResizeArray<T>(ref T[] array, int newSize)
		{
			Array.Resize(ref array, newSize);
		}

		public static bool IsValidIndex<T>(this T[] array, int idx)
		{
			if (idx >= 0)
			{
				return idx < array.Length;
			}
			return false;
		}

		public static string GetPath(Transform current)
		{
			if (current.parent == null)
			{
				return "/" + current.name;
			}
			return GetPath(current.parent) + "/" + current.name;
		}

		public static T NewWithComponent<T>(string name) where T : UnityEngine.Component
		{
			return new GameObject(name, typeof(T)).GetComponent<T>();
		}

		public static T GetOrAddComponent<T>(this GameObject self) where T : UnityEngine.Component
		{
			T val = self.GetComponent<T>();
			if (val == null)
			{
				val = self.AddComponent<T>();
			}
			return val;
		}

		public static T GetOrAddComponent<T>(this MonoBehaviour self) where T : UnityEngine.Component
		{
			return self.gameObject.GetOrAddComponent<T>();
		}

		public static void ForeachComponentsInAnyChildrenOnly<T>(this GameObject self, Action<T> lambda, bool includeInactive = false) where T : UnityEngine.Component
		{
			T[] componentsInChildren = self.GetComponentsInChildren<T>(includeInactive);
			foreach (T val in componentsInChildren)
			{
				if (val.gameObject != self)
				{
					lambda(val);
				}
			}
		}

		public static void ForeachComponentsInDirectChildrenOnly<T>(this GameObject self, Action<T> lambda, bool includeInactive = false) where T : UnityEngine.Component
		{
			T[] componentsInChildren = self.GetComponentsInChildren<T>(includeInactive);
			foreach (T val in componentsInChildren)
			{
				if (val.transform.parent == self.transform)
				{
					lambda(val);
				}
			}
		}

		public static void SetupDepthCamera(Camera depthCamera, float coneApexOffsetZ, float maxGeometryDistance, float coneRadiusStart, float coneRadiusEnd, Vector3 beamLocalForward, Vector3 lossyScale, bool isScalable, Quaternion beamInternalLocalRotation, bool shouldScaleMinNearClipPlane)
		{
			if (!isScalable)
			{
				lossyScale.x = (lossyScale.y = 1f);
			}
			float num = coneApexOffsetZ;
			bool flag = num >= 0f;
			num = Mathf.Max(num, 0f);
			depthCamera.orthographic = !flag;
			depthCamera.transform.localPosition = beamLocalForward * (0f - num);
			Quaternion localRotation = beamInternalLocalRotation;
			if (Mathf.Sign(lossyScale.z) < 0f)
			{
				localRotation *= Quaternion.Euler(0f, 180f, 0f);
			}
			depthCamera.transform.localRotation = localRotation;
			if (!Mathf.Approximately(lossyScale.y * lossyScale.z, 0f))
			{
				float num2 = (flag ? 0.1f : 0f);
				float num3 = Mathf.Abs(lossyScale.z);
				depthCamera.nearClipPlane = Mathf.Max(num * num3, num2 * (shouldScaleMinNearClipPlane ? num3 : 1f));
				depthCamera.farClipPlane = (maxGeometryDistance + num * (isScalable ? 1f : num3)) * (isScalable ? num3 : 1f);
				depthCamera.aspect = Mathf.Abs(lossyScale.x / lossyScale.y);
				if (flag)
				{
					float fieldOfView = Mathf.Atan2(coneRadiusEnd * Mathf.Abs(lossyScale.y), depthCamera.farClipPlane) * 57.29578f * 2f;
					depthCamera.fieldOfView = fieldOfView;
				}
				else
				{
					depthCamera.orthographicSize = coneRadiusStart * lossyScale.y;
				}
			}
		}

		public static bool HasFlag(this Enum mask, Enum flags)
		{
			return ((int)(object)mask & (int)(object)flags) == (int)(object)flags;
		}

		public static Vector3 Divide(this Vector3 aVector, Vector3 scale)
		{
			if (Mathf.Approximately(scale.x * scale.y * scale.z, 0f))
			{
				return Vector3.zero;
			}
			return new Vector3(aVector.x / scale.x, aVector.y / scale.y, aVector.z / scale.z);
		}

		public static Vector2 xy(this Vector3 aVector)
		{
			return new Vector2(aVector.x, aVector.y);
		}

		public static Vector2 xz(this Vector3 aVector)
		{
			return new Vector2(aVector.x, aVector.z);
		}

		public static Vector2 yz(this Vector3 aVector)
		{
			return new Vector2(aVector.y, aVector.z);
		}

		public static Vector2 yx(this Vector3 aVector)
		{
			return new Vector2(aVector.y, aVector.x);
		}

		public static Vector2 zx(this Vector3 aVector)
		{
			return new Vector2(aVector.z, aVector.x);
		}

		public static Vector2 zy(this Vector3 aVector)
		{
			return new Vector2(aVector.z, aVector.y);
		}

		public static bool Approximately(this float a, float b, float epsilon = 1E-05f)
		{
			return Mathf.Abs(a - b) < epsilon;
		}

		public static bool Approximately(this Vector2 a, Vector2 b, float epsilon = 1E-05f)
		{
			return Vector2.SqrMagnitude(a - b) < epsilon;
		}

		public static bool Approximately(this Vector3 a, Vector3 b, float epsilon = 1E-05f)
		{
			return Vector3.SqrMagnitude(a - b) < epsilon;
		}

		public static bool Approximately(this Vector4 a, Vector4 b, float epsilon = 1E-05f)
		{
			return Vector4.SqrMagnitude(a - b) < epsilon;
		}

		public static Vector4 AsVector4(this Vector3 vec3, float w)
		{
			return new Vector4(vec3.x, vec3.y, vec3.z, w);
		}

		public static Vector4 PlaneEquation(Vector3 normalizedNormal, Vector3 pt)
		{
			return normalizedNormal.AsVector4(0f - Vector3.Dot(normalizedNormal, pt));
		}

		public static float GetVolumeCubic(this Bounds self)
		{
			return self.size.x * self.size.y * self.size.z;
		}

		public static float GetMaxArea2D(this Bounds self)
		{
			return Mathf.Max(Mathf.Max(self.size.x * self.size.y, self.size.y * self.size.z), self.size.x * self.size.z);
		}

		public static Color Opaque(this Color self)
		{
			return new Color(self.r, self.g, self.b, 1f);
		}

		public static Color ComputeComplementaryColor(this Color self, bool blackAndWhite)
		{
			if (blackAndWhite)
			{
				if (!((double)self.r * 0.299 + (double)self.g * 0.587 + (double)self.b * 0.114 > 0.729411780834198))
				{
					return Color.white;
				}
				return Color.black;
			}
			return new Color(1f - self.r, 1f - self.g, 1f - self.b);
		}

		public static Plane TranslateCustom(this Plane plane, Vector3 translation)
		{
			plane.distance += Vector3.Dot(translation.normalized, plane.normal) * translation.magnitude;
			return plane;
		}

		public static Vector3 ClosestPointOnPlaneCustom(this Plane plane, Vector3 point)
		{
			return point - plane.GetDistanceToPoint(point) * plane.normal;
		}

		public static bool IsAlmostZero(float f)
		{
			return Mathf.Abs(f) < 0.001f;
		}

		public static bool IsValid(this Plane plane)
		{
			return plane.normal.sqrMagnitude > 0.5f;
		}

		public static void SetKeywordEnabled(this Material mat, string name, bool enabled)
		{
			if (enabled)
			{
				mat.EnableKeyword(name);
			}
			else
			{
				mat.DisableKeyword(name);
			}
		}

		public static void SetShaderKeywordEnabled(string name, bool enabled)
		{
			if (enabled)
			{
				Shader.EnableKeyword(name);
			}
			else
			{
				Shader.DisableKeyword(name);
			}
		}

		public static Matrix4x4 SampleInMatrix(this Gradient self, int floatPackingPrecision)
		{
			Matrix4x4 result = default(Matrix4x4);
			for (int i = 0; i < 16; i++)
			{
				Color color = self.Evaluate(Mathf.Clamp01((float)i / 15f));
				result[i] = color.PackToFloat(floatPackingPrecision);
			}
			return result;
		}

		public static Color[] SampleInArray(this Gradient self, int samplesCount)
		{
			Color[] array = new Color[samplesCount];
			for (int i = 0; i < samplesCount; i++)
			{
				array[i] = self.Evaluate(Mathf.Clamp01((float)i / (float)(samplesCount - 1)));
			}
			return array;
		}

		private static Vector4 Vector4_Floor(Vector4 vec)
		{
			return new Vector4(Mathf.Floor(vec.x), Mathf.Floor(vec.y), Mathf.Floor(vec.z), Mathf.Floor(vec.w));
		}

		public static float PackToFloat(this Color color, int floatPackingPrecision)
		{
			Vector4 vector = Vector4_Floor(color * (floatPackingPrecision - 1));
			return 0f + vector.x * (float)floatPackingPrecision * (float)floatPackingPrecision * (float)floatPackingPrecision + vector.y * (float)floatPackingPrecision * (float)floatPackingPrecision + vector.z * (float)floatPackingPrecision + vector.w;
		}

		public static FloatPackingPrecision GetFloatPackingPrecision()
		{
			if (ms_FloatPackingPrecision == FloatPackingPrecision.Undef)
			{
				ms_FloatPackingPrecision = ((SystemInfo.graphicsShaderLevel >= 35) ? FloatPackingPrecision.High : FloatPackingPrecision.Low);
			}
			return ms_FloatPackingPrecision;
		}

		public static bool HasAtLeastOneFlag(this Enum mask, Enum flags)
		{
			return ((int)(object)mask & (int)(object)flags) != 0;
		}

		public static void MarkCurrentSceneDirty()
		{
		}

		public static void MarkObjectDirty(UnityEngine.Object obj)
		{
		}
	}
	public static class UtilsBeamProps
	{
		public static bool CanChangeDuringPlaytime(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.trackChangesDuringPlaytime;
			}
			return true;
		}

		public static Quaternion GetInternalLocalRotation(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.beamInternalLocalRotation;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.beamInternalLocalRotation;
			}
			return Quaternion.identity;
		}

		public static void SetIntensityFromLight(VolumetricLightBeamAbstractBase self, bool fromLight)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				volumetricLightBeamSD.intensityFromLight = fromLight;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				volumetricLightBeamHD.useIntensityFromAttachedLightSpot = fromLight;
			}
		}

		public static float GetThickness(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return Mathf.Clamp01(1f - volumetricLightBeamSD.fresnelPow / 10f);
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return Mathf.Clamp01(1f - volumetricLightBeamHD.sideSoftness / 10f);
			}
			return 0f;
		}

		public static void SetThickness(VolumetricLightBeamAbstractBase self, float value)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				volumetricLightBeamSD.fresnelPow = (1f - value) * 10f;
				return;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				volumetricLightBeamHD.sideSoftness = (1f - value) * 10f;
			}
		}

		public static float GetFallOffEnd(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.fallOffEnd;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.fallOffEnd;
			}
			return 0f;
		}

		public static ColorMode GetColorMode(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.usedColorMode;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.colorMode;
			}
			return ColorMode.Flat;
		}

		public static Color GetColorFlat(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.color;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.colorFlat;
			}
			return Color.white;
		}

		public static Gradient GetColorGradient(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.colorGradient;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.colorGradient;
			}
			return null;
		}

		public static void SetColorFromLight(VolumetricLightBeamAbstractBase self, bool fromLight)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				volumetricLightBeamSD.colorFromLight = fromLight;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				volumetricLightBeamHD.colorFromLight = fromLight;
			}
		}

		public static float GetConeAngle(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.coneAngle;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.coneAngle;
			}
			return 0f;
		}

		public static void SetSpotAngleFromLight(VolumetricLightBeamAbstractBase self, bool fromLight)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				volumetricLightBeamSD.spotAngleFromLight = fromLight;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				volumetricLightBeamHD.useSpotAngleFromAttachedLightSpot = fromLight;
			}
		}

		public static float GetConeRadiusStart(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.coneRadiusStart;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.coneRadiusStart;
			}
			return 0f;
		}

		public static float GetConeRadiusEnd(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.coneRadiusEnd;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.coneRadiusEnd;
			}
			return 0f;
		}

		public static int GetSortingLayerID(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.sortingLayerID;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.GetSortingLayerID();
			}
			return 0;
		}

		public static int GetSortingOrder(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.sortingOrder;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.GetSortingOrder();
			}
			return 0;
		}

		public static bool GetFadeOutEnabled(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.isFadeOutEnabled;
			}
			return false;
		}

		public static float GetFadeOutEnd(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.fadeOutEnd;
			}
			return 0f;
		}

		public static void SetFallOffEndFromLight(VolumetricLightBeamAbstractBase self, bool fromLight)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				volumetricLightBeamSD.fallOffEndFromLight = fromLight;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				volumetricLightBeamHD.useFallOffEndFromAttachedLightSpot = fromLight;
			}
		}

		public static Dimensions GetDimensions(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.dimensions;
			}
			VolumetricLightBeamHD volumetricLightBeamHD = self as VolumetricLightBeamHD;
			if ((bool)volumetricLightBeamHD)
			{
				return volumetricLightBeamHD.GetDimensions();
			}
			return Dimensions.Dim3D;
		}

		public static int GetGeomSides(VolumetricLightBeamAbstractBase self)
		{
			VolumetricLightBeamSD volumetricLightBeamSD = self as VolumetricLightBeamSD;
			if ((bool)volumetricLightBeamSD)
			{
				return volumetricLightBeamSD.geomSides;
			}
			return Config.Instance.sharedMeshSides;
		}

		public static AttenuationEquation ConvertAttenuation(AttenuationEquationHD value)
		{
			return (AttenuationEquation)value;
		}

		public static AttenuationEquationHD ConvertAttenuation(AttenuationEquation value)
		{
			if (value == AttenuationEquation.Blend)
			{
				return AttenuationEquationHD.Linear;
			}
			return (AttenuationEquationHD)value;
		}
	}
	public static class Version
	{
		public const int Current = 20200;

		public static string CurrentAsString => GetVersionAsString(20200);

		private static string GetVersionAsString(int version)
		{
			int num = version / 10000;
			int num2 = (version - num * 10000) / 100;
			int num3 = (version - num * 10000 - num2 * 100) / 1;
			return $"{num}.{num2}.{num3}";
		}
	}
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(VolumetricLightBeamAbstractBase))]
	[HelpURL("http://saladgamer.com/vlb-doc/comp-dustparticles/")]
	[AddComponentMenu("VLB/Common/Volumetric Dust Particles")]
	public class VolumetricDustParticles : MonoBehaviour
	{
		public const string ClassName = "VolumetricDustParticles";

		[Range(0f, 1f)]
		public float alpha = 0.5f;

		[Range(0.0001f, 0.1f)]
		public float size = 0.01f;

		public ParticlesDirection direction;

		public Vector3 velocity = Consts.DustParticles.VelocityDefault;

		[Obsolete("Use 'velocity' instead")]
		public float speed = 0.03f;

		public float density = 5f;

		[MinMaxRange(0f, 1f)]
		public MinMaxRangeFloat spawnDistanceRange = Consts.DustParticles.SpawnDistanceRangeDefault;

		[Obsolete("Use 'spawnDistanceRange' instead")]
		public float spawnMinDistance;

		[Obsolete("Use 'spawnDistanceRange' instead")]
		public float spawnMaxDistance = 0.7f;

		public bool cullingEnabled;

		public float cullingMaxDistance = 10f;

		[SerializeField]
		private float m_AlphaAdditionalRuntime = 1f;

		private ParticleSystem m_Particles;

		private ParticleSystemRenderer m_Renderer;

		private Material m_Material;

		private Gradient m_GradientCached = new Gradient();

		private bool m_RuntimePropertiesDirty = true;

		private VolumetricLightBeamAbstractBase m_Master;

		public bool isCulled { get; private set; }

		public float alphaAdditionalRuntime
		{
			get
			{
				return m_AlphaAdditionalRuntime;
			}
			set
			{
				if (m_AlphaAdditionalRuntime != value)
				{
					m_AlphaAdditionalRuntime = value;
					m_RuntimePropertiesDirty = true;
				}
			}
		}

		public bool particlesAreInstantiated => m_Particles;

		public int particlesCurrentCount
		{
			get
			{
				if (!m_Particles)
				{
					return 0;
				}
				return m_Particles.particleCount;
			}
		}

		public int particlesMaxCount
		{
			get
			{
				if (!m_Particles)
				{
					return 0;
				}
				return m_Particles.main.maxParticles;
			}
		}

		public ParticleSystemRenderer FindRenderer()
		{
			if ((bool)m_Renderer)
			{
				return m_Renderer;
			}
			return m_Particles.GetComponent<ParticleSystemRenderer>();
		}

		private void Start()
		{
			isCulled = false;
			m_Master = GetComponent<VolumetricLightBeamAbstractBase>();
			HandleBackwardCompatibility(m_Master._INTERNAL_pluginVersion, 20200);
			InstantiateParticleSystem();
			SetActiveAndPlay();
		}

		private void InstantiateParticleSystem()
		{
			base.gameObject.ForeachComponentsInDirectChildrenOnly(delegate(ParticleSystem ps)
			{
				UnityEngine.Object.DestroyImmediate(ps.gameObject);
			}, includeInactive: true);
			m_Particles = Config.Instance.NewVolumetricDustParticles();
			if ((bool)m_Particles)
			{
				m_Particles.transform.SetParent(base.transform, worldPositionStays: false);
				m_Renderer = m_Particles.GetComponent<ParticleSystemRenderer>();
				m_Material = new Material(m_Renderer.sharedMaterial);
				m_Renderer.material = m_Material;
			}
		}

		private void OnEnable()
		{
			SetActiveAndPlay();
		}

		private void SetActive(bool active)
		{
			if ((bool)m_Particles)
			{
				m_Particles.gameObject.SetActive(active);
			}
		}

		private void SetActiveAndPlay()
		{
			SetActive(active: true);
			Play();
		}

		private void Play()
		{
			if ((bool)m_Particles)
			{
				SetParticleProperties();
				m_Particles.Simulate(0f);
				m_Particles.Play(withChildren: true);
			}
		}

		private void OnDisable()
		{
			SetActive(active: false);
		}

		private void OnDestroy()
		{
			if ((bool)m_Particles)
			{
				UnityEngine.Object.DestroyImmediate(m_Particles.gameObject);
				m_Particles = null;
			}
			if ((bool)m_Material)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
				m_Material = null;
			}
		}

		private void Update()
		{
			UpdateCulling();
			if (UtilsBeamProps.CanChangeDuringPlaytime(m_Master))
			{
				SetParticleProperties();
			}
			if (m_RuntimePropertiesDirty && m_Material != null)
			{
				m_Material.SetColor(ShaderProperties.ParticlesTintColor, new Color(1f, 1f, 1f, alphaAdditionalRuntime));
				m_RuntimePropertiesDirty = false;
			}
		}

		private void SetParticleProperties()
		{
			if (!m_Particles || !m_Particles.gameObject.activeSelf)
			{
				return;
			}
			m_Particles.transform.localRotation = UtilsBeamProps.GetInternalLocalRotation(m_Master);
			m_Particles.transform.localScale = (m_Master.IsScalable() ? Vector3.one : Vector3.one.Divide(m_Master.GetLossyScale()));
			float num = UtilsBeamProps.GetFallOffEnd(m_Master) * (spawnDistanceRange.maxValue - spawnDistanceRange.minValue);
			float num2 = num * density;
			int maxParticles = (int)(num2 * 4f);
			ParticleSystem.MainModule main = m_Particles.main;
			ParticleSystem.MinMaxCurve startLifetime = main.startLifetime;
			startLifetime.mode = ParticleSystemCurveMode.TwoConstants;
			startLifetime.constantMin = 4f;
			startLifetime.constantMax = 6f;
			main.startLifetime = startLifetime;
			ParticleSystem.MinMaxCurve startSize = main.startSize;
			startSize.mode = ParticleSystemCurveMode.TwoConstants;
			startSize.constantMin = size * 0.9f;
			startSize.constantMax = size * 1.1f;
			main.startSize = startSize;
			ParticleSystem.MinMaxGradient startColor = main.startColor;
			if (UtilsBeamProps.GetColorMode(m_Master) == ColorMode.Flat)
			{
				startColor.mode = ParticleSystemGradientMode.Color;
				Color colorFlat = UtilsBeamProps.GetColorFlat(m_Master);
				colorFlat.a *= alpha;
				startColor.color = colorFlat;
			}
			else
			{
				startColor.mode = ParticleSystemGradientMode.Gradient;
				Gradient colorGradient = UtilsBeamProps.GetColorGradient(m_Master);
				GradientColorKey[] colorKeys = colorGradient.colorKeys;
				GradientAlphaKey[] alphaKeys = colorGradient.alphaKeys;
				for (int i = 0; i < alphaKeys.Length; i++)
				{
					alphaKeys[i].alpha *= alpha;
				}
				m_GradientCached.SetKeys(colorKeys, alphaKeys);
				startColor.gradient = m_GradientCached;
			}
			main.startColor = startColor;
			ParticleSystem.MinMaxCurve startSpeed = main.startSpeed;
			startSpeed.constant = ((direction == ParticlesDirection.Random) ? Mathf.Abs(velocity.z) : 0f);
			main.startSpeed = startSpeed;
			ParticleSystem.VelocityOverLifetimeModule velocityOverLifetime = m_Particles.velocityOverLifetime;
			velocityOverLifetime.enabled = direction != ParticlesDirection.Random;
			velocityOverLifetime.space = ((direction != ParticlesDirection.LocalSpace) ? ParticleSystemSimulationSpace.World : ParticleSystemSimulationSpace.Local);
			velocityOverLifetime.xMultiplier = velocity.x;
			velocityOverLifetime.yMultiplier = velocity.y;
			velocityOverLifetime.zMultiplier = velocity.z;
			main.maxParticles = maxParticles;
			float thickness = UtilsBeamProps.GetThickness(m_Master);
			float fallOffEnd = UtilsBeamProps.GetFallOffEnd(m_Master);
			ParticleSystem.ShapeModule shape = m_Particles.shape;
			shape.shapeType = ParticleSystemShapeType.ConeVolume;
			float num3 = UtilsBeamProps.GetConeAngle(m_Master) * Mathf.Lerp(0.7f, 1f, thickness);
			shape.angle = num3 * 0.5f;
			float a = UtilsBeamProps.GetConeRadiusStart(m_Master) * Mathf.Lerp(0.3f, 1f, thickness);
			float b = Utils.ComputeConeRadiusEnd(fallOffEnd, num3);
			shape.radius = Mathf.Lerp(a, b, spawnDistanceRange.minValue);
			shape.length = num;
			float z = fallOffEnd * spawnDistanceRange.minValue;
			shape.position = new Vector3(0f, 0f, z);
			shape.arc = 360f;
			shape.randomDirectionAmount = ((direction == ParticlesDirection.Random) ? 1f : 0f);
			ParticleSystem.EmissionModule emission = m_Particles.emission;
			ParticleSystem.MinMaxCurve rateOverTime = emission.rateOverTime;
			rateOverTime.constant = num2;
			emission.rateOverTime = rateOverTime;
			if ((bool)m_Renderer)
			{
				m_Renderer.sortingLayerID = UtilsBeamProps.GetSortingLayerID(m_Master);
				m_Renderer.sortingOrder = UtilsBeamProps.GetSortingOrder(m_Master);
			}
		}

		private void HandleBackwardCompatibility(int serializedVersion, int newVersion)
		{
			if (serializedVersion == -1 || serializedVersion == newVersion)
			{
				return;
			}
			if (serializedVersion < 1880)
			{
				if (direction == ParticlesDirection.Random)
				{
					direction = ParticlesDirection.LocalSpace;
				}
				else
				{
					direction = ParticlesDirection.Random;
				}
				velocity = new Vector3(0f, 0f, speed);
			}
			if (serializedVersion < 1940)
			{
				spawnDistanceRange = new MinMaxRangeFloat(spawnMinDistance, spawnMaxDistance);
			}
			Utils.MarkCurrentSceneDirty();
		}

		private void UpdateCulling()
		{
			if (!m_Particles)
			{
				return;
			}
			bool flag = true;
			bool fadeOutEnabled = UtilsBeamProps.GetFadeOutEnabled(m_Master);
			if ((cullingEnabled || fadeOutEnabled) && m_Master.hasGeometry)
			{
				if ((bool)Config.Instance.fadeOutCameraTransform)
				{
					float num = cullingMaxDistance;
					if (fadeOutEnabled)
					{
						num = Mathf.Min(num, UtilsBeamProps.GetFadeOutEnd(m_Master));
					}
					float num2 = num * num;
					flag = m_Master.bounds.SqrDistance(Config.Instance.fadeOutCameraTransform.position) <= num2;
				}
				else
				{
					UnityEngine.Debug.LogErrorFormat(base.gameObject, "Fail to retrieve the camera with tag '{0}' (specified in VLB Config's 'fadeOutCameraTag') for the {1} Culling feature.", Config.Instance.fadeOutCameraTag, "VolumetricDustParticles");
				}
			}
			if (m_Particles.gameObject.activeSelf != flag)
			{
				SetActive(flag);
				isCulled = !flag;
			}
			if (flag && !m_Particles.isPlaying)
			{
				m_Particles.Play();
			}
		}
	}
	public abstract class VolumetricLightBeamAbstractBase : MonoBehaviour
	{
		public delegate void BeamGeometryGeneratedHandler(VolumetricLightBeamAbstractBase beam);

		public enum AttachedLightType
		{
			NoLight,
			OtherLight,
			SpotLight
		}

		public const string ClassName = "VolumetricLightBeamAbstractBase";

		[SerializeField]
		protected int pluginVersion = -1;

		protected Light m_CachedLightSpot;

		public bool hasGeometry => GetBeamGeometry() != null;

		public Bounds bounds
		{
			get
			{
				if (!(GetBeamGeometry() != null))
				{
					return new Bounds(Vector3.zero, Vector3.zero);
				}
				return GetBeamGeometry().meshRenderer.bounds;
			}
		}

		public int _INTERNAL_pluginVersion => pluginVersion;

		public Light lightSpotAttached => m_CachedLightSpot;

		private event BeamGeometryGeneratedHandler BeamGeometryGeneratedEvent;

		public abstract BeamGeometryAbstractBase GetBeamGeometry();

		protected abstract void SetBeamGeometryNull();

		public void RegisterBeamGeometryGeneratedCallback(BeamGeometryGeneratedHandler callback)
		{
			if (hasGeometry)
			{
				callback(this);
			}
			else
			{
				BeamGeometryGeneratedEvent += callback;
			}
		}

		public virtual void GenerateGeometry()
		{
			if (this.BeamGeometryGeneratedEvent != null)
			{
				this.BeamGeometryGeneratedEvent(this);
				this.BeamGeometryGeneratedEvent = null;
			}
		}

		public abstract bool IsScalable();

		public abstract Vector3 GetLossyScale();

		public virtual void CopyPropsFrom(VolumetricLightBeamAbstractBase beamSrc, BeamProps beamProps)
		{
			if (beamProps.HasFlag(BeamProps.Transform))
			{
				base.transform.position = beamSrc.transform.position;
				base.transform.rotation = beamSrc.transform.rotation;
				base.transform.localScale = beamSrc.transform.localScale;
			}
			if (beamProps.HasFlag(BeamProps.SideSoftness))
			{
				UtilsBeamProps.SetThickness(this, UtilsBeamProps.GetThickness(beamSrc));
			}
		}

		public Light GetLightSpotAttachedSlow(out AttachedLightType lightType)
		{
			Light component = GetComponent<Light>();
			if ((bool)component)
			{
				if (component.type == LightType.Spot)
				{
					lightType = AttachedLightType.SpotLight;
					return component;
				}
				lightType = AttachedLightType.OtherLight;
				return null;
			}
			lightType = AttachedLightType.NoLight;
			return null;
		}

		protected void InitLightSpotAttachedCached()
		{
			m_CachedLightSpot = GetLightSpotAttachedSlow(out var _);
		}

		private void OnDestroy()
		{
			DestroyBeam();
		}

		protected void DestroyBeam()
		{
			if (Application.isPlaying)
			{
				BeamGeometryAbstractBase.DestroyBeamGeometryGameObject(GetBeamGeometry());
			}
			SetBeamGeometryNull();
		}
	}
}
namespace VLB_Samples
{
	[RequireComponent(typeof(Camera))]
	public class CameraToggleBeamVisibility : MonoBehaviour
	{
		[SerializeField]
		private KeyCode m_KeyCode = KeyCode.Space;

		private void Update()
		{
			if (Input.GetKeyDown(m_KeyCode))
			{
				Camera component = GetComponent<Camera>();
				int geometryLayerID = Config.Instance.geometryLayerID;
				int num = 1 << geometryLayerID;
				if ((component.cullingMask & num) == num)
				{
					component.cullingMask &= ~num;
				}
				else
				{
					component.cullingMask |= num;
				}
			}
		}
	}
	[RequireComponent(typeof(Collider), typeof(Rigidbody), typeof(MeshRenderer))]
	public class CheckIfInsideBeam : MonoBehaviour
	{
		private bool isInsideBeam;

		private Material m_Material;

		private Collider m_Collider;

		private void Start()
		{
			m_Collider = GetComponent<Collider>();
			MeshRenderer component = GetComponent<MeshRenderer>();
			if ((bool)component)
			{
				m_Material = component.material;
			}
		}

		private void Update()
		{
			if ((bool)m_Material)
			{
				m_Material.SetColor("_Color", isInsideBeam ? Color.green : Color.red);
			}
		}

		private void FixedUpdate()
		{
			isInsideBeam = false;
		}

		private void OnTriggerStay(Collider trigger)
		{
			DynamicOcclusionRaycasting component = trigger.GetComponent<DynamicOcclusionRaycasting>();
			if ((bool)component)
			{
				isInsideBeam = !component.IsColliderHiddenByDynamicOccluder(m_Collider);
			}
			else
			{
				isInsideBeam = true;
			}
		}
	}
	public class FeaturesNotSupportedMessage : MonoBehaviour
	{
		private void Start()
		{
			if (!Noise3D.isSupported)
			{
				UnityEngine.Debug.LogWarning(Noise3D.isNotSupportedString);
			}
		}
	}
	public class FreeCameraController : MonoBehaviour
	{
		public float cameraSensitivity = 90f;

		public float speedNormal = 10f;

		public float speedFactorSlow = 0.25f;

		public float speedFactorFast = 3f;

		public float speedClimb = 4f;

		private float rotationH;

		private float rotationV;

		private bool m_UseMouseView = true;

		private bool useMouseView
		{
			get
			{
				return m_UseMouseView;
			}
			set
			{
				m_UseMouseView = value;
				Cursor.lockState = (value ? CursorLockMode.Locked : CursorLockMode.None);
				Cursor.visible = !value;
			}
		}

		private void Start()
		{
			useMouseView = true;
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			rotationH = eulerAngles.y;
			rotationV = eulerAngles.x;
			if (rotationV > 180f)
			{
				rotationV -= 360f;
			}
		}

		private void Update()
		{
			if (useMouseView)
			{
				rotationH += Input.GetAxis("Mouse X") * cameraSensitivity * Time.deltaTime;
				rotationV -= Input.GetAxis("Mouse Y") * cameraSensitivity * Time.deltaTime;
			}
			rotationV = Mathf.Clamp(rotationV, -90f, 90f);
			base.transform.rotation = Quaternion.AngleAxis(rotationH, Vector3.up);
			base.transform.rotation *= Quaternion.AngleAxis(rotationV, Vector3.right);
			float num = speedNormal;
			if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
			{
				num *= speedFactorFast;
			}
			else if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))
			{
				num *= speedFactorSlow;
			}
			base.transform.position += num * Input.GetAxis("Vertical") * Time.deltaTime * base.transform.forward;
			base.transform.position += num * Input.GetAxis("Horizontal") * Time.deltaTime * base.transform.right;
			if (Input.GetKey(KeyCode.Q))
			{
				base.transform.position += speedClimb * Time.deltaTime * Vector3.up;
			}
			if (Input.GetKey(KeyCode.E))
			{
				base.transform.position += speedClimb * Time.deltaTime * Vector3.down;
			}
			if (Input.GetMouseButtonDown(0) || Input.GetMouseButtonDown(1) || Input.GetMouseButtonDown(2))
			{
				useMouseView = !useMouseView;
			}
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				useMouseView = false;
			}
		}
	}
	public class LightGenerator : MonoBehaviour
	{
		[Range(1f, 100f)]
		[SerializeField]
		private int CountX = 10;

		[Range(1f, 100f)]
		[SerializeField]
		private int CountY = 10;

		[SerializeField]
		private float OffsetUnits = 1f;

		[SerializeField]
		private float PositionY = 1f;

		[SerializeField]
		private bool NoiseEnabled;

		[SerializeField]
		private bool AddLight = true;

		public void Generate()
		{
			for (int i = 0; i < CountX; i++)
			{
				for (int j = 0; j < CountY; j++)
				{
					GameObject gameObject = null;
					gameObject = ((!AddLight) ? new GameObject("Light_" + i + "_" + j, typeof(VolumetricLightBeamSD), typeof(Rotater)) : new GameObject("Light_" + i + "_" + j, typeof(Light), typeof(VolumetricLightBeamSD), typeof(Rotater)));
					gameObject.transform.SetPositionAndRotation(new Vector3((float)i * OffsetUnits, PositionY, (float)j * OffsetUnits), Quaternion.Euler((float)UnityEngine.Random.Range(-45, 45) + 90f, UnityEngine.Random.Range(0, 360), 0f));
					VolumetricLightBeamSD component = gameObject.GetComponent<VolumetricLightBeamSD>();
					if (AddLight)
					{
						Light component2 = gameObject.GetComponent<Light>();
						component2.type = LightType.Spot;
						component2.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, 1f);
						component2.range = UnityEngine.Random.Range(3f, 8f);
						component2.intensity = UnityEngine.Random.Range(0.2f, 5f);
						component2.spotAngle = UnityEngine.Random.Range(10f, 90f);
						if (Config.Instance.geometryOverrideLayer)
						{
							component2.cullingMask = ~(1 << Config.Instance.geometryLayerID);
						}
					}
					else
					{
						component.color = new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value, 1f);
						component.fallOffEnd = UnityEngine.Random.Range(3f, 8f);
						component.spotAngle = UnityEngine.Random.Range(10f, 90f);
					}
					component.coneRadiusStart = UnityEngine.Random.Range(0f, 0.1f);
					component.geomCustomSides = UnityEngine.Random.Range(12, 36);
					component.fresnelPow = UnityEngine.Random.Range(1f, 7.5f);
					component.noiseMode = (NoiseEnabled ? NoiseMode.WorldSpace : NoiseMode.Disabled);
					gameObject.GetComponent<Rotater>().EulerSpeed = new Vector3(0f, UnityEngine.Random.Range(-500, 500), 0f);
				}
			}
		}
	}
	public class Rotater : MonoBehaviour
	{
		[FormerlySerializedAs("m_EulerSpeed")]
		public Vector3 EulerSpeed = Vector3.zero;

		private void Update()
		{
			Vector3 eulerAngles = base.transform.rotation.eulerAngles;
			eulerAngles += EulerSpeed * Time.deltaTime;
			base.transform.rotation = Quaternion.Euler(eulerAngles);
		}
	}
}
namespace JoshH.Extensions
{
	public static class Vector2Extension
	{
		public static Vector2 Rotate(this Vector2 v, float degrees)
		{
			float num = Mathf.Sin(degrees * (MathF.PI / 180f));
			float num2 = Mathf.Cos(degrees * (MathF.PI / 180f));
			float x = v.x;
			float y = v.y;
			v.x = num2 * x - num * y;
			v.y = num * x + num2 * y;
			return v;
		}
	}
}
namespace JoshH.UI
{
	[AddComponentMenu("UI/Effects/UI Gradient")]
	[RequireComponent(typeof(RectTransform))]
	public class UIGradient : BaseMeshEffect
	{
		public enum UIGradientBlendMode
		{
			Override,
			Multiply
		}

		public enum UIGradientType
		{
			Linear,
			Corner,
			ComplexLinear
		}

		[Tooltip("How the gradient color will be blended with the graphics color.")]
		[SerializeField]
		private UIGradientBlendMode blendMode;

		[SerializeField]
		[Range(0f, 1f)]
		private float intensity = 1f;

		[SerializeField]
		private UIGradientType gradientType;

		[SerializeField]
		private Color linearColor1 = Color.yellow;

		[SerializeField]
		private Color linearColor2 = Color.red;

		[SerializeField]
		private Color cornerColorUpperLeft = Color.red;

		[SerializeField]
		private Color cornerColorUpperRight = Color.yellow;

		[SerializeField]
		private Color cornerColorLowerRight = Color.green;

		[SerializeField]
		private Color cornerColorLowerLeft = Color.blue;

		[SerializeField]
		private Gradient linearGradient;

		[SerializeField]
		[Range(0f, 360f)]
		private float angle;

		private RectTransform _rectTransform;

		protected RectTransform rectTransform
		{
			get
			{
				if (_rectTransform == null)
				{
					_rectTransform = base.transform as RectTransform;
				}
				return _rectTransform;
			}
		}

		public UIGradientBlendMode BlendMode
		{
			get
			{
				return blendMode;
			}
			set
			{
				blendMode = value;
				ForceUpdateGraphic();
			}
		}

		public float Intensity
		{
			get
			{
				return intensity;
			}
			set
			{
				intensity = Mathf.Clamp01(value);
				ForceUpdateGraphic();
			}
		}

		public UIGradientType GradientType
		{
			get
			{
				return gradientType;
			}
			set
			{
				gradientType = value;
				ForceUpdateGraphic();
			}
		}

		public Color LinearColor1
		{
			get
			{
				return linearColor1;
			}
			set
			{
				linearColor1 = value;
				ForceUpdateGraphic();
			}
		}

		public Color LinearColor2
		{
			get
			{
				return linearColor2;
			}
			set
			{
				linearColor2 = value;
				ForceUpdateGraphic();
			}
		}

		public Color CornerColorUpperLeft
		{
			get
			{
				return cornerColorUpperLeft;
			}
			set
			{
				cornerColorUpperLeft = value;
				ForceUpdateGraphic();
			}
		}

		public Color CornerColorUpperRight
		{
			get
			{
				return cornerColorUpperRight;
			}
			set
			{
				cornerColorUpperRight = value;
				ForceUpdateGraphic();
			}
		}

		public Color CornerColorLowerRight
		{
			get
			{
				return cornerColorLowerRight;
			}
			set
			{
				cornerColorLowerRight = value;
				ForceUpdateGraphic();
			}
		}

		public Color CornerColorLowerLeft
		{
			get
			{
				return cornerColorLowerLeft;
			}
			set
			{
				cornerColorLowerLeft = value;
				ForceUpdateGraphic();
			}
		}

		public float Angle
		{
			get
			{
				return angle;
			}
			set
			{
				if (value < 0f)
				{
					angle = value % 360f + 360f;
				}
				else
				{
					angle = value % 360f;
				}
				ForceUpdateGraphic();
			}
		}

		public Gradient LinearGradient
		{
			get
			{
				return linearGradient;
			}
			set
			{
				linearGradient = value;
				ForceUpdateGraphic();
			}
		}

		public override void ModifyMesh(VertexHelper vh)
		{
			if (!base.enabled)
			{
				return;
			}
			UIVertex vertex = default(UIVertex);
			if (gradientType == UIGradientType.ComplexLinear)
			{
				CutMesh(vh);
			}
			for (int i = 0; i < vh.currentVertCount; i++)
			{
				vh.PopulateUIVertex(ref vertex, i);
				Vector2 normalizedPosition = ((Vector2)vertex.position - rectTransform.rect.min) / (rectTransform.rect.max - rectTransform.rect.min);
				normalizedPosition = RotateNormalizedPosition(normalizedPosition, angle);
				Color c = Color.black;
				if (gradientType == UIGradientType.Linear)
				{
					c = GetColorInGradient(linearColor1, linearColor1, linearColor2, linearColor2, normalizedPosition);
				}
				else if (gradientType == UIGradientType.Corner)
				{
					c = GetColorInGradient(cornerColorUpperLeft, cornerColorUpperRight, cornerColorLowerRight, cornerColorLowerLeft, normalizedPosition);
				}
				else if (gradientType == UIGradientType.ComplexLinear)
				{
					c = linearGradient.Evaluate(normalizedPosition.y);
				}
				vertex.color = BlendColor(vertex.color, c, blendMode, intensity);
				vh.SetUIVertex(vertex, i);
			}
		}

		protected void CutMesh(VertexHelper vh)
		{
			List<UIVertex> list = new List<UIVertex>();
			vh.GetUIVertexStream(list);
			vh.Clear();
			List<UIVertex> list2 = new List<UIVertex>();
			Vector2 cutDirection = GetCutDirection();
			foreach (float item in linearGradient.alphaKeys.Select((GradientAlphaKey x) => x.time).Union(linearGradient.colorKeys.Select((GradientColorKey x) => x.time)))
			{
				list2.Clear();
				Vector2 cutOrigin = GetCutOrigin(item);
				if (!((double)item < 0.001) && !((double)item > 0.999))
				{
					for (int num = 0; num < list.Count; num += 3)
					{
						CutTriangle(list, num, list2, cutDirection, cutOrigin);
					}
					list.Clear();
					list.AddRange(list2);
				}
			}
			vh.AddUIVertexTriangleStream(list);
		}

		private UIVertex UIVertexLerp(UIVertex v1, UIVertex v2, float f)
		{
			return new UIVertex
			{
				position = Vector3.Lerp(v1.position, v2.position, f),
				color = Color.Lerp(v1.color, v2.color, f),
				uv0 = Vector2.Lerp(v1.uv0, v2.uv0, f),
				uv1 = Vector2.Lerp(v1.uv1, v2.uv1, f),
				uv2 = Vector2.Lerp(v1.uv2, v2.uv2, f),
				uv3 = Vector2.Lerp(v1.uv3, v2.uv3, f)
			};
		}

		private Vector2 GetCutDirection()
		{
			Vector2 v = Vector2.up.Rotate(0f - angle);
			v = new Vector2(v.x / rectTransform.rect.size.x, v.y / rectTransform.rect.size.y);
			return v.Rotate(90f);
		}

		private void CutTriangle(List<UIVertex> tris, int idx, List<UIVertex> list, Vector2 cutDirection, Vector2 point)
		{
			UIVertex uIVertex = tris[idx];
			UIVertex uIVertex2 = tris[idx + 1];
			UIVertex uIVertex3 = tris[idx + 2];
			float f = OnLine(uIVertex2.position, uIVertex3.position, point, cutDirection);
			float f2 = OnLine(uIVertex.position, uIVertex2.position, point, cutDirection);
			float f3 = OnLine(uIVertex3.position, uIVertex.position, point, cutDirection);
			if (IsOnLine(f2))
			{
				if (IsOnLine(f))
				{
					UIVertex item = UIVertexLerp(uIVertex, uIVertex2, f2);
					UIVertex item2 = UIVertexLerp(uIVertex2, uIVertex3, f);
					list.AddRange(new List<UIVertex> { uIVertex, item, uIVertex3, item, item2, uIVertex3, item, uIVertex2, item2 });
				}
				else
				{
					UIVertex item3 = UIVertexLerp(uIVertex, uIVertex2, f2);
					UIVertex item4 = UIVertexLerp(uIVertex3, uIVertex, f3);
					list.AddRange(new List<UIVertex> { uIVertex3, item4, uIVertex2, item4, item3, uIVertex2, item4, uIVertex, item3 });
				}
			}
			else if (IsOnLine(f))
			{
				UIVertex item5 = UIVertexLerp(uIVertex2, uIVertex3, f);
				UIVertex item6 = UIVertexLerp(uIVertex3, uIVertex, f3);
				list.AddRange(new List<UIVertex> { uIVertex2, item5, uIVertex, item5, item6, uIVertex, item5, uIVertex3, item6 });
			}
			else
			{
				list.AddRange(tris.GetRange(idx, 3));
			}
		}

		private bool IsOnLine(float f)
		{
			if (f <= 1f)
			{
				return f > 0f;
			}
			return false;
		}

		private float OnLine(Vector2 p1, Vector2 p2, Vector2 o, Vector2 dir)
		{
			float num = (p2.x - p1.x) * dir.y - (p2.y - p1.y) * dir.x;
			if (num == 0f)
			{
				return -1f;
			}
			return ((o.x - p1.x) * dir.y - (o.y - p1.y) * dir.x) / num;
		}

		private float ProjectedDistance(Vector2 p1, Vector2 p2, Vector2 normal)
		{
			return Vector2.Distance(Vector3.Project(p1, normal), Vector3.Project(p2, normal));
		}

		private Vector2 GetCutOrigin(float f)
		{
			Vector2 vector = Vector2.up.Rotate(0f - angle);
			vector = new Vector2(vector.x / rectTransform.rect.size.x, vector.y / rectTransform.rect.size.y);
			Vector3 vector2;
			Vector3 vector3;
			if (angle % 180f < 90f)
			{
				vector2 = Vector3.Project(Vector2.Scale(rectTransform.rect.size, Vector2.down + Vector2.left) * 0.5f, vector);
				vector3 = Vector3.Project(Vector2.Scale(rectTransform.rect.size, Vector2.up + Vector2.right) * 0.5f, vector);
			}
			else
			{
				vector2 = Vector3.Project(Vector2.Scale(rectTransform.rect.size, Vector2.up + Vector2.left) * 0.5f, vector);
				vector3 = Vector3.Project(Vector2.Scale(rectTransform.rect.size, Vector2.down + Vector2.right) * 0.5f, vector);
			}
			if (angle % 360f >= 180f)
			{
				return Vector2.Lerp(vector3, vector2, f) + rectTransform.rect.center;
			}
			return Vector2.Lerp(vector2, vector3, f) + rectTransform.rect.center;
		}

		private Color BlendColor(Color c1, Color c2, UIGradientBlendMode mode, float intensity)
		{
			switch (mode)
			{
			case UIGradientBlendMode.Override:
				return Color.Lerp(c1, c2, intensity);
			case UIGradientBlendMode.Multiply:
				return Color.Lerp(c1, c1 * c2, intensity);
			default:
				UnityEngine.Debug.LogErrorFormat("Mode is not supported: {0}", mode);
				return c1;
			}
		}

		private Vector2 RotateNormalizedPosition(Vector2 normalizedPosition, float angle)
		{
			float f = MathF.PI / 180f * ((angle < 0f) ? (angle % 90f + 90f) : (angle % 90f));
			float num = Mathf.Sin(f) + Mathf.Cos(f);
			return (normalizedPosition - Vector2.one * 0.5f).Rotate(angle) / num + Vector2.one * 0.5f;
		}

		public void ForceUpdateGraphic()
		{
			if (base.graphic != null)
			{
				base.graphic.SetVerticesDirty();
			}
		}

		private Color GetColorInGradient(Color ul, Color ur, Color lr, Color ll, Vector2 normalizedPosition)
		{
			return Color.Lerp(Color.Lerp(ll, lr, normalizedPosition.x), Color.Lerp(ul, ur, normalizedPosition.x), normalizedPosition.y);
		}
	}
}
namespace UI_Spline_Renderer.Example
{
	public class DraggableSplinePointExample : MonoBehaviour, IDragHandler, IEventSystemHandler, IBeginDragHandler, IEndDragHandler
	{
		public UISplineRenderer uiSplineRenderer;

		public Image myImage;

		public int splineIndex;

		public int knotIndex;

		public Color connectedColor;

		public bool isConnected;

		private BezierKnot _originalKnot;

		public void OnDrag(PointerEventData eventData)
		{
			Vector3 vector = base.transform.parent.InverseTransformPoint(eventData.position);
			BezierKnot value = new BezierKnot(vector);
			uiSplineRenderer.splineContainer[splineIndex].SetKnot(knotIndex, value);
		}

		public void OnBeginDrag(PointerEventData eventData)
		{
			uiSplineRenderer.raycastTarget = false;
			myImage.raycastTarget = false;
			uiSplineRenderer.color = Color.white;
			if (!isConnected)
			{
				_originalKnot = uiSplineRenderer.splineContainer[splineIndex][knotIndex];
			}
		}

		public void OnEndDrag(PointerEventData eventData)
		{
			foreach (GameObject item in eventData.hovered)
			{
				if ((bool)item.GetComponent<DragPortExample>())
				{
					Connect(item.transform);
					uiSplineRenderer.raycastTarget = true;
					myImage.raycastTarget = true;
					return;
				}
			}
			Disconnect();
		}

		private void Connect(Transform t)
		{
			Vector3 vector = base.transform.parent.InverseTransformPoint(t.position);
			BezierKnot value = new BezierKnot(vector);
			uiSplineRenderer.splineContainer[splineIndex].SetKnot(knotIndex, value);
			uiSplineRenderer.color = connectedColor;
			isConnected = true;
		}

		private void Disconnect()
		{
			uiSplineRenderer.color = Color.white;
			uiSplineRenderer.splineContainer[splineIndex].SetKnot(knotIndex, _originalKnot);
			isConnected = false;
			uiSplineRenderer.raycastTarget = true;
			myImage.raycastTarget = true;
		}
	}
	public class DragPortExample : MonoBehaviour
	{
	}
	public class UISplineRendererExample : MonoBehaviour
	{
		public UISplineRenderer target_uvAnimation;

		public UISplineRenderer target_interaction;

		private void Start()
		{
			target_interaction.GetComponent<Button>().onClick.AddListener(delegate
			{
				UnityEngine.Debug.Log("Spline Clicked !");
			});
		}

		private void Update()
		{
			UpdateUV();
		}

		private void UpdateUV()
		{
			target_uvAnimation.uvOffset += new Vector2(0f, Time.deltaTime * 2f);
			target_uvAnimation.clipRange = new Vector2(0f, (Mathf.Sin(Time.time) + 1f) * 0.5f);
		}
	}
}
namespace KINEMATION.MagicBlend.Runtime
{
	public class MagicBlendAsset : ScriptableObject, IRigUser
	{
		[Header("Rig")]
		public KRig rigAsset;

		[Header("Blending")]
		[Min(0f)]
		public float blendTime = 0.15f;

		public AnimationCurve blendCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

		[Header("Poses")]
		public AnimationClip basePose;

		public AnimationClip overlayPose;

		[Tooltip("If Overlay is static or not.")]
		public bool isAnimation;

		[Unfold]
		public List<LayeredBlend> layeredBlends = new List<LayeredBlend>();

		[Range(0f, 1f)]
		public float globalWeight = 1f;

		public KRig GetRigAsset()
		{
			return rigAsset;
		}
	}
	[HelpURL("https://kinemation.gitbook.io/magic-blend-documentation/")]
	public class MagicBlending : MonoBehaviour
	{
		public PlayableGraph playableGraph;

		[Tooltip("This asset controls the blending weights.")]
		[SerializeField]
		private MagicBlendAsset blendAsset;

		[Tooltip("Will update weights every frame.")]
		[SerializeField]
		private bool forceUpdateWeights = true;

		[Tooltip("Will process the Overlay pose. Keep it on most of the time.")]
		[SerializeField]
		private bool alwaysAnimatePoses = true;

		private const ushort PlayableSortingPriority = 900;

		private Animator _animator;

		private KRigComponent _rigComponent;

		private AnimationLayerMixerPlayable _playableMixer;

		private NativeArray<BlendStreamAtom> _atoms;

		private PoseJob _poseJob;

		private OverlayJob _overlayJob;

		private LayeringJob _layeringJob;

		private AnimationScriptPlayable _poseJobPlayable;

		private AnimationScriptPlayable _overlayJobPlayable;

		private AnimationScriptPlayable _layeringJobPlayable;

		private bool _isInitialized;

		private float _blendPlayback = 1f;

		private float _blendTime;

		private AnimationCurve _blendCurve;

		private MagicBlendAsset _desiredBlendAsset;

		private float _desiredBlendTime;

		private bool _useBlendCurve;

		private List<int> _blendedIndexes = new List<int>();

		private Dictionary<string, int> _hierarchyMap;

		private RuntimeAnimatorController _cachedController;

		private AnimationPlayableOutput _magicBlendOutput;

		public MagicBlendAsset BlendAsset => blendAsset;

		public void UpdateMagicBlendAsset(MagicBlendAsset newAsset, bool useBlending = false, float blendTime = -1f, bool useCurve = false)
		{
			if (newAsset == null)
			{
				UnityEngine.Debug.LogWarning("MagicBlending: input asset is NULL!");
				return;
			}
			_desiredBlendAsset = newAsset;
			_useBlendCurve = useCurve;
			_desiredBlendTime = blendTime;
			if (!useBlending)
			{
				SetNewAsset();
				if (!alwaysAnimatePoses)
				{
					_poseJob.readPose = true;
					_overlayJob.cachePose = true;
					_poseJobPlayable.SetJobData(_poseJob);
					_overlayJobPlayable.SetJobData(_overlayJob);
				}
			}
			else
			{
				_layeringJob.cachePose = true;
				_layeringJobPlayable.SetJobData(_layeringJob);
			}
		}

		public float GetOverlayTime(bool isNormalized = true)
		{
			Playable input = _overlayJobPlayable.GetInput(0);
			if (!input.IsValid() || !blendAsset.isAnimation)
			{
				return 0f;
			}
			float num = (float)input.GetDuration();
			if (Mathf.Approximately(num, 0f))
			{
				return 0f;
			}
			float num2 = (float)input.GetTime();
			if (!isNormalized)
			{
				return num2;
			}
			return Mathf.Clamp01(num2 / num);
		}

		protected virtual void SetNewAsset()
		{
			blendAsset = _desiredBlendAsset;
			_blendCurve = (_useBlendCurve ? blendAsset.blendCurve : null);
			_blendTime = ((_desiredBlendTime > 0f) ? _desiredBlendTime : blendAsset.blendTime);
			MagicBlendLibrary.ConnectPose(_poseJobPlayable, playableGraph, blendAsset.basePose);
			MagicBlendLibrary.ConnectPose(_overlayJobPlayable, playableGraph, blendAsset.overlayPose);
			if (blendAsset.isAnimation)
			{
				_overlayJobPlayable.GetInput(0).SetSpeed(1.0);
			}
			for (int i = 0; i < _hierarchyMap.Count; i++)
			{
				BlendStreamAtom value = _atoms[i];
				value.baseWeight = (value.additiveWeight = (value.localWeight = 0f));
				_atoms[i] = value;
			}
			_blendedIndexes.Clear();
			foreach (LayeredBlend layeredBlend in blendAsset.layeredBlends)
			{
				foreach (KRigElement item in layeredBlend.layer.elementChain)
				{
					_hierarchyMap.TryGetValue(item.name, out var value2);
					_blendedIndexes.Add(value2);
				}
			}
			UpdateBlendWeights();
		}

		protected virtual void BuildMagicMixer()
		{
			if (_playableMixer.IsValid())
			{
				_playableMixer.DisconnectInput(2);
			}
			else
			{
				_playableMixer = AnimationLayerMixerPlayable.Create(playableGraph, 3);
				InitializeJobs();
				_playableMixer.ConnectInput(0, _poseJobPlayable, 0, 1f);
				_playableMixer.ConnectInput(1, _overlayJobPlayable, 0, 1f);
				_magicBlendOutput.SetSourcePlayable(_playableMixer);
				_magicBlendOutput.SetSortingOrder(900);
			}
			_magicBlendOutput.SetSourcePlayable(_playableMixer);
			_magicBlendOutput.SetSortingOrder(900);
			int outputCount = playableGraph.GetOutputCount();
			int index = 0;
			for (int i = 0; i < outputCount; i++)
			{
				if (!(playableGraph.GetOutput(i).GetSourcePlayable().GetPlayableType() != typeof(AnimatorControllerPlayable)))
				{
					index = i;
				}
			}
			Playable sourcePlayable = playableGraph.GetOutput(index).GetSourcePlayable();
			_layeringJobPlayable.ConnectInput(0, sourcePlayable, 0, 1f);
			_playableMixer.ConnectInput(2, _layeringJobPlayable, 0, 1f);
			if (blendAsset != null)
			{
				UpdateMagicBlendAsset(blendAsset);
			}
		}

		protected virtual void InitializeMagicBlending()
		{
			playableGraph = _animator.playableGraph;
			_atoms = MagicBlendLibrary.SetupBlendAtoms(_animator, _rigComponent);
			_magicBlendOutput = AnimationPlayableOutput.Create(playableGraph, "MagicBlendOutput", _animator);
			BuildMagicMixer();
			playableGraph.SetTimeUpdateMode(DirectorUpdateMode.GameTime);
			playableGraph.Play();
			_isInitialized = true;
		}

		private void InitializeJobs()
		{
			_poseJob = new PoseJob
			{
				atoms = _atoms,
				alwaysAnimate = alwaysAnimatePoses,
				readPose = false
			};
			_poseJobPlayable = AnimationScriptPlayable.Create(playableGraph, _poseJob, 1);
			_overlayJob = new OverlayJob
			{
				atoms = _atoms,
				alwaysAnimate = alwaysAnimatePoses,
				cachePose = false
			};
			_overlayJobPlayable = AnimationScriptPlayable.Create(playableGraph, _overlayJob, 1);
			_layeringJob = new LayeringJob
			{
				atoms = _atoms,
				blendWeight = 1f,
				cachePose = false
			};
			_layeringJobPlayable = AnimationScriptPlayable.Create(playableGraph, _layeringJob, 1);
		}

		private void OnEnable()
		{
			if (_isInitialized)
			{
				BuildMagicMixer();
			}
		}

		private void Start()
		{
			_animator = GetComponent<Animator>();
			_cachedController = _animator.runtimeAnimatorController;
			_rigComponent = GetComponentInChildren<KRigComponent>();
			_hierarchyMap = new Dictionary<string, int>();
			Transform[] rigTransforms = _rigComponent.GetRigTransforms();
			for (int i = 0; i < rigTransforms.Length; i++)
			{
				_hierarchyMap.Add(rigTransforms[i].name, i);
			}
			InitializeMagicBlending();
		}

		protected virtual void UpdateBlendWeights()
		{
			int num = 0;
			foreach (LayeredBlend layeredBlend in blendAsset.layeredBlends)
			{
				foreach (KRigElement item in layeredBlend.layer.elementChain)
				{
					_ = item;
					int index = _blendedIndexes[num] + 1;
					BlendStreamAtom value = _atoms[index];
					value.baseWeight = layeredBlend.baseWeight * blendAsset.globalWeight;
					value.additiveWeight = layeredBlend.additiveWeight * blendAsset.globalWeight;
					value.localWeight = layeredBlend.localWeight * blendAsset.globalWeight;
					_atoms[index] = value;
					num++;
				}
			}
		}

		protected virtual void Update()
		{
			RuntimeAnimatorController runtimeAnimatorController = _animator.runtimeAnimatorController;
			if (_cachedController != runtimeAnimatorController)
			{
				BuildMagicMixer();
			}
			_cachedController = runtimeAnimatorController;
			if (blendAsset == null)
			{
				return;
			}
			if (blendAsset.isAnimation)
			{
				Playable input = _overlayJobPlayable.GetInput(0);
				if (blendAsset.overlayPose.isLooping && input.GetTime() > (double)blendAsset.overlayPose.length)
				{
					input.SetTime(0.0);
				}
			}
			if (forceUpdateWeights)
			{
				UpdateBlendWeights();
			}
			if (!Mathf.Approximately(_blendPlayback, 1f))
			{
				_blendPlayback = Mathf.Clamp01(_blendPlayback + Time.deltaTime / _blendTime);
				_layeringJob.blendWeight = _blendCurve?.Evaluate(_blendPlayback) ?? _blendPlayback;
				_layeringJobPlayable.SetJobData(_layeringJob);
			}
		}

		protected virtual void LateUpdate()
		{
			if (!alwaysAnimatePoses && _poseJob.readPose)
			{
				_poseJob.readPose = false;
				_overlayJob.cachePose = false;
				_poseJobPlayable.SetJobData(_poseJob);
				_overlayJobPlayable.SetJobData(_overlayJob);
			}
			if (_layeringJob.cachePose)
			{
				SetNewAsset();
				_blendPlayback = 0f;
				_layeringJob.cachePose = false;
				_layeringJob.blendWeight = 0f;
				_layeringJobPlayable.SetJobData(_layeringJob);
				if (!alwaysAnimatePoses)
				{
					_poseJob.readPose = true;
					_overlayJob.cachePose = true;
					_poseJobPlayable.SetJobData(_poseJob);
					_overlayJobPlayable.SetJobData(_overlayJob);
				}
			}
		}

		protected virtual void OnDestroy()
		{
			if (playableGraph.IsValid() && playableGraph.IsPlaying())
			{
				playableGraph.Stop();
				playableGraph.Stop();
			}
			if (_atoms.IsCreated)
			{
				_atoms.Dispose();
			}
		}
	}
	public struct PoseJob : IAnimationJob
	{
		[Unity.Collections.ReadOnly]
		public bool alwaysAnimate;

		[Unity.Collections.ReadOnly]
		public bool readPose;

		public NativeArray<BlendStreamAtom> atoms;

		public void ProcessAnimation(AnimationStream stream)
		{
			if (alwaysAnimate || readPose)
			{
				BlendStreamAtom blendStreamAtom = atoms[0];
				KTransform kTransform = new KTransform
				{
					rotation = blendStreamAtom.handle.GetRotation(stream),
					position = blendStreamAtom.handle.GetPosition(stream)
				};
				int length = atoms.Length;
				for (int i = 1; i < length; i++)
				{
					BlendStreamAtom value = atoms[i];
					KTransform worldTransform = new KTransform
					{
						position = value.handle.GetPosition(stream),
						rotation = value.handle.GetRotation(stream)
					};
					worldTransform = kTransform.GetRelativeTransform(worldTransform, useScale: false);
					value.activePose.basePose = worldTransform;
					value.activePose.basePose.position = value.handle.GetLocalPosition(stream);
					atoms[i] = value;
				}
			}
		}

		public void ProcessRootMotion(AnimationStream stream)
		{
		}
	}
	public struct OverlayJob : IAnimationJob
	{
		[Unity.Collections.ReadOnly]
		public bool alwaysAnimate;

		[Unity.Collections.ReadOnly]
		public bool cachePose;

		public NativeArray<BlendStreamAtom> atoms;

		public void ProcessAnimation(AnimationStream stream)
		{
			if (alwaysAnimate || cachePose)
			{
				BlendStreamAtom value = atoms[0];
				atoms[0] = value;
				KTransform kTransform = new KTransform
				{
					rotation = value.handle.GetRotation(stream),
					position = value.handle.GetPosition(stream)
				};
				int length = atoms.Length;
				for (int i = 1; i < length; i++)
				{
					BlendStreamAtom value2 = atoms[i];
					KTransform worldTransform = new KTransform
					{
						rotation = value2.handle.GetRotation(stream),
						position = value2.handle.GetPosition(stream)
					};
					worldTransform = kTransform.GetRelativeTransform(worldTransform, useScale: false);
					value2.activePose.overlayPose = worldTransform;
					value2.activePose.overlayPose.position = value2.handle.GetLocalPosition(stream);
					value2.activePose.localOverlayRotation = value2.handle.GetLocalRotation(stream);
					atoms[i] = value2;
				}
			}
		}

		public void ProcessRootMotion(AnimationStream stream)
		{
		}
	}
	public struct LayeringJob : IAnimationJob
	{
		[Unity.Collections.ReadOnly]
		public float blendWeight;

		[Unity.Collections.ReadOnly]
		public bool cachePose;

		public NativeArray<BlendStreamAtom> atoms;

		public void ProcessAnimation(AnimationStream stream)
		{
			BlendStreamAtom blendStreamAtom = atoms[0];
			KTransform kTransform = new KTransform
			{
				rotation = blendStreamAtom.handle.GetRotation(stream),
				position = blendStreamAtom.handle.GetPosition(stream)
			};
			int length = atoms.Length;
			for (int i = 1; i < length; i++)
			{
				BlendStreamAtom value = atoms[i];
				KTransform worldTransform = new KTransform
				{
					rotation = value.handle.GetRotation(stream),
					position = value.handle.GetPosition(stream),
					scale = Vector3.one
				};
				value.meshStreamPose = kTransform.GetRelativeTransform(worldTransform, useScale: false);
				value.meshStreamPose.position = value.handle.GetLocalPosition(stream);
				value.activePose.additiveWeight = value.additiveWeight;
				value.activePose.baseWeight = value.baseWeight;
				value.activePose.localWeight = value.localWeight;
				atoms[i] = value;
			}
			for (int j = 1; j < length; j++)
			{
				BlendStreamAtom value2 = atoms[j];
				AtomPose blendedAtomPose = value2.GetBlendedAtomPose(blendWeight);
				if (cachePose)
				{
					value2.cachedPose = blendedAtomPose;
					atoms[j] = value2;
				}
				KTransform basePose = blendedAtomPose.basePose;
				KTransform overlayPose = blendedAtomPose.overlayPose;
				Quaternion localOverlayRotation = blendedAtomPose.localOverlayRotation;
				float additiveWeight = blendedAtomPose.additiveWeight;
				float baseWeight = blendedAtomPose.baseWeight;
				float localWeight = blendedAtomPose.localWeight;
				KTransform kTransform2 = new KTransform
				{
					rotation = value2.meshStreamPose.rotation * Quaternion.Inverse(basePose.rotation),
					position = value2.meshStreamPose.position - basePose.position
				};
				Quaternion b = kTransform2.rotation * overlayPose.rotation;
				b = Quaternion.Slerp(overlayPose.rotation, b, additiveWeight);
				b = Quaternion.Slerp(value2.meshStreamPose.rotation, b, baseWeight);
				b = kTransform.rotation * b;
				Vector3 b2 = overlayPose.position + kTransform2.position * additiveWeight;
				b2 = Vector3.Lerp(value2.meshStreamPose.position, b2, baseWeight);
				value2.handle.SetRotation(stream, b);
				b = Quaternion.Slerp(value2.handle.GetLocalRotation(stream), localOverlayRotation, localWeight);
				value2.handle.SetLocalRotation(stream, b);
				b2 = Vector3.Lerp(b2, overlayPose.position, localWeight);
				value2.handle.SetLocalPosition(stream, b2);
			}
		}

		public void ProcessRootMotion(AnimationStream stream)
		{
		}
	}
	public struct AtomPose
	{
		public KTransform basePose;

		public KTransform overlayPose;

		public Quaternion localOverlayRotation;

		public float baseWeight;

		public float additiveWeight;

		public float localWeight;

		public static AtomPose Lerp(AtomPose a, AtomPose b, float alpha)
		{
			return new AtomPose
			{
				basePose = KTransform.Lerp(a.basePose, b.basePose, alpha),
				overlayPose = KTransform.Lerp(a.overlayPose, b.overlayPose, alpha),
				localOverlayRotation = Quaternion.Slerp(a.localOverlayRotation, b.localOverlayRotation, alpha),
				additiveWeight = Mathf.Lerp(a.additiveWeight, b.additiveWeight, alpha),
				baseWeight = Mathf.Lerp(a.baseWeight, b.baseWeight, alpha),
				localWeight = Mathf.Lerp(a.localWeight, b.localWeight, alpha)
			};
		}
	}
	public struct BlendStreamAtom
	{
		[Unity.Collections.ReadOnly]
		public TransformStreamHandle handle;

		[Unity.Collections.ReadOnly]
		public float baseWeight;

		[Unity.Collections.ReadOnly]
		public float additiveWeight;

		[Unity.Collections.ReadOnly]
		public float localWeight;

		public KTransform meshStreamPose;

		public AtomPose activePose;

		public AtomPose cachedPose;

		public AtomPose GetBlendedAtomPose(float blendWeight)
		{
			return AtomPose.Lerp(cachedPose, activePose, blendWeight);
		}
	}
	[Serializable]
	public struct LayeredBlend
	{
		public KRigElementChain layer;

		[Range(0f, 1f)]
		public float baseWeight;

		[Range(0f, 1f)]
		public float additiveWeight;

		[Range(0f, 1f)]
		public float localWeight;
	}
	public class MagicBlendLibrary
	{
		public static NativeArray<BlendStreamAtom> SetupBlendAtoms(Animator animator, KRigComponent rigComponent)
		{
			Transform[] rigTransforms = rigComponent.GetRigTransforms();
			int num = rigTransforms.Length + 1;
			NativeArray<BlendStreamAtom> result = new NativeArray<BlendStreamAtom>(num, Allocator.Persistent);
			for (int i = 0; i < num; i++)
			{
				Transform transform = animator.transform;
				if (i > 0)
				{
					transform = rigTransforms[i - 1];
				}
				result[i] = new BlendStreamAtom
				{
					handle = animator.BindStreamTransform(transform)
				};
			}
			return result;
		}

		public static void ConnectPose(AnimationScriptPlayable playable, PlayableGraph graph, AnimationClip pose)
		{
			if (playable.GetInput(0).IsValid())
			{
				playable.DisconnectInput(0);
			}
			AnimationClipPlayable animationClipPlayable = AnimationClipPlayable.Create(graph, pose);
			animationClipPlayable.SetSpeed(0.0);
			animationClipPlayable.SetApplyFootIK(value: false);
			playable.ConnectInput(0, animationClipPlayable, 0, 1f);
		}
	}
	public class MagicBlendState : StateMachineBehaviour
	{
		[SerializeField]
		private MagicBlendAsset magicBlendAsset;

		private bool _isInitialized;

		private MagicBlending _magicBlending;

		public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			if (!_isInitialized)
			{
				_magicBlending = animator.gameObject.GetComponent<MagicBlending>();
				if (_magicBlending == null)
				{
					return;
				}
				_isInitialized = true;
			}
			float duration = animator.GetAnimatorTransitionInfo(layerIndex).duration;
			_magicBlending.UpdateMagicBlendAsset(magicBlendAsset, useBlending: true, duration);
		}
	}
}
namespace HardSlashes
{
	public class DemoManager : MonoBehaviour
	{
		public TextMesh text_fx_name;

		public GameObject[] prefabs;

		public int index_fx;

		private GameObject current_animation;

		private Ray ray;

		private RaycastHit ray_cast_hit;

		private void Start()
		{
			text_fx_name.text = "[" + (index_fx + 1) + "] " + prefabs[index_fx].name;
			UnityEngine.Object.Destroy(GameObject.Find("Instructions"), 11.5f);
		}

		private void Update()
		{
			if (Input.GetMouseButtonDown(0))
			{
				ray = Camera.main.ScreenPointToRay(Input.mousePosition);
				if (Physics.Raycast(ray.origin, ray.direction, out ray_cast_hit, 1000f))
				{
					Aim();
					current_animation = UnityEngine.Object.Instantiate(prefabs[index_fx], ray_cast_hit.point, base.transform.rotation);
				}
			}
			if (Input.GetKeyDown("z") || Input.GetKeyDown("left"))
			{
				index_fx--;
				if (index_fx <= -1)
				{
					index_fx = prefabs.Length - 1;
				}
				text_fx_name.text = "[" + (index_fx + 1) + "] " + prefabs[index_fx].name;
			}
			if (Input.GetKeyDown("x") || Input.GetKeyDown("right"))
			{
				index_fx++;
				if (index_fx >= prefabs.Length)
				{
					index_fx = 0;
				}
				text_fx_name.text = "[" + (index_fx + 1) + "] " + prefabs[index_fx].name;
			}
			if (Input.GetKeyDown("space"))
			{
				UnityEngine.Debug.Break();
			}
		}

		private void Aim()
		{
			base.transform.LookAt(new Vector3(ray_cast_hit.point.x, 1f, ray_cast_hit.point.z));
			base.transform.eulerAngles = new Vector3(base.transform.eulerAngles.x, base.transform.eulerAngles.y + 180f, base.transform.eulerAngles.z);
		}
	}
	public class SelfDestruct : MonoBehaviour
	{
		public float selfdestruct_in = 4f;

		private void Start()
		{
			if (selfdestruct_in != 0f)
			{
				UnityEngine.Object.Destroy(base.gameObject, selfdestruct_in);
			}
		}
	}
}
namespace FOW.Demos
{
	public class BlinkingRevealer : MonoBehaviour
	{
		public float BlinkCycleTime = 5f;

		public bool RandomOffset = true;

		private void Awake()
		{
			if (RandomOffset)
			{
				BlinkCycleTime += UnityEngine.Random.Range(0f, BlinkCycleTime * 0.5f);
			}
		}

		private void Update()
		{
			if (Time.time % BlinkCycleTime < BlinkCycleTime / 2f)
			{
				if (!base.transform.GetChild(0).gameObject.activeInHierarchy)
				{
					base.transform.GetChild(0).gameObject.SetActive(value: true);
				}
			}
			else if (base.transform.GetChild(0).gameObject.activeInHierarchy)
			{
				base.transform.GetChild(0).gameObject.SetActive(value: false);
			}
		}
	}
	public class FowCharacterDemo : MonoBehaviour
	{
		public float WalkingSpeed = 5f;

		public float RunningMultiplier = 1.65f;

		public float Acceleration = 25f;

		private float yRot;

		private CharacterController cc;

		private bool CursorLocked;

		private Vector2 inputDirection = Vector2.zero;

		private Vector2 velocityXZ = Vector2.zero;

		private Vector3 velocity = Vector3.zero;

		private float speedTarget;

		private void Awake()
		{
			cc = GetComponent<CharacterController>();
			CursorLocked = true;
			Cursor.lockState = CursorLockMode.Locked;
			Cursor.visible = false;
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				CursorLocked = !CursorLocked;
				if (CursorLocked)
				{
					Cursor.visible = false;
					Cursor.lockState = CursorLockMode.Locked;
				}
				else
				{
					Cursor.visible = true;
					Cursor.lockState = CursorLockMode.None;
				}
			}
			if (CursorLocked)
			{
				base.transform.Rotate(0f, Input.GetAxis("Mouse X"), 0f);
				yRot -= Input.GetAxis("Mouse Y");
			}
			yRot = Mathf.Clamp(yRot, -80f, 80f);
			setInput();
			move();
		}

		public void setInput()
		{
			bool[] obj = new bool[5]
			{
				Input.GetKey(KeyCode.W),
				Input.GetKey(KeyCode.A),
				Input.GetKey(KeyCode.S),
				Input.GetKey(KeyCode.D),
				Input.GetKey(KeyCode.LeftShift)
			};
			speedTarget = 0f;
			inputDirection = Vector2.zero;
			if (obj[0])
			{
				inputDirection.y += 1f;
				speedTarget = WalkingSpeed;
			}
			if (obj[1])
			{
				inputDirection.x -= 1f;
				speedTarget = WalkingSpeed;
			}
			if (obj[2])
			{
				inputDirection.y -= 1f;
				speedTarget = WalkingSpeed;
			}
			if (obj[3])
			{
				inputDirection.x += 1f;
				speedTarget = WalkingSpeed;
			}
			if (obj[4])
			{
				speedTarget *= RunningMultiplier;
			}
		}

		private void move()
		{
			if (cc.isGrounded)
			{
				velocity.y = 0f;
			}
			Vector2 vector = new Vector2(base.transform.forward.x, base.transform.forward.z);
			Vector2 vector2 = Vector3.Normalize(new Vector2(base.transform.right.x, base.transform.right.z) * inputDirection.x + vector * inputDirection.y);
			velocityXZ = Vector2.MoveTowards(velocityXZ, vector2.normalized * speedTarget, Time.deltaTime * Acceleration);
			velocity.x = velocityXZ.x * Time.deltaTime;
			velocity.z = velocityXZ.y * Time.deltaTime;
			velocity.y += -9.81f * Time.deltaTime * Time.deltaTime;
			cc.enabled = true;
			cc.Move(velocity);
			cc.enabled = false;
		}
	}
	public class TeamsDemo : MonoBehaviour
	{
		public Text teamText;

		public Color team1Color = Color.blue;

		public List<FogOfWarRevealer> team1Members = new List<FogOfWarRevealer>();

		public Color team2Color = Color.green;

		public List<FogOfWarRevealer> team2Members = new List<FogOfWarRevealer>();

		public Color team3Color = Color.red;

		public List<FogOfWarRevealer> team3Members = new List<FogOfWarRevealer>();

		private int team;

		private void Awake()
		{
			team = 2;
			changeTeams();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				changeTeams();
			}
		}

		private void changeTeams()
		{
			team++;
			team %= 3;
			teamText.text = $"VIEWING AS TEAM {team + 1}";
			foreach (FogOfWarRevealer team1Member in team1Members)
			{
				team1Member.enabled = false;
				team1Member.GetComponent<FogOfWarHider>().enabled = true;
			}
			foreach (FogOfWarRevealer team2Member in team2Members)
			{
				team2Member.enabled = false;
				team2Member.GetComponent<FogOfWarHider>().enabled = true;
			}
			foreach (FogOfWarRevealer team3Member in team3Members)
			{
				team3Member.enabled = false;
				team3Member.GetComponent<FogOfWarHider>().enabled = true;
			}
			switch (team)
			{
			case 0:
				teamText.color = team1Color;
				{
					foreach (FogOfWarRevealer team1Member2 in team1Members)
					{
						team1Member2.enabled = true;
						team1Member2.GetComponent<FogOfWarHider>().enabled = false;
					}
					break;
				}
			case 1:
				teamText.color = team2Color;
				{
					foreach (FogOfWarRevealer team2Member2 in team2Members)
					{
						team2Member2.enabled = true;
						team2Member2.GetComponent<FogOfWarHider>().enabled = false;
					}
					break;
				}
			case 2:
				teamText.color = team3Color;
				{
					foreach (FogOfWarRevealer team3Member2 in team3Members)
					{
						team3Member2.enabled = true;
						team3Member2.GetComponent<FogOfWarHider>().enabled = false;
					}
					break;
				}
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex92
{
	public class AnimationController : MonoBehaviour
	{
		private static readonly int Forward = Animator.StringToHash("Forward");

		private static readonly int Turn = Animator.StringToHash("Turn");

		private static readonly int Ground = Animator.StringToHash("OnGround");

		private static readonly int Crouch = Animator.StringToHash("Crouch");

		private static readonly int Jump = Animator.StringToHash("Jump");

		private static readonly int JumpLeg = Animator.StringToHash("JumpLeg");

		private Character _character;

		private void Awake()
		{
			_character = GetComponentInParent<Character>();
		}

		private void Update()
		{
			float deltaTime = Time.deltaTime;
			Animator animator = _character.GetAnimator();
			Vector3 vector = base.transform.InverseTransformDirection(_character.GetMovementDirection());
			float num = ((_character.useRootMotion && (bool)_character.GetRootMotionController()) ? vector.z : Mathf.InverseLerp(0f, _character.GetMaxSpeed(), _character.GetSpeed()));
			animator.SetFloat(Forward, num, 0.1f, deltaTime);
			animator.SetFloat(Turn, Mathf.Atan2(vector.x, vector.z), 0.1f, deltaTime);
			animator.SetBool(Ground, _character.IsGrounded());
			animator.SetBool(Crouch, _character.IsCrouched());
			if (_character.IsFalling())
			{
				animator.SetFloat(Jump, _character.GetVelocity().y, 0.1f, deltaTime);
			}
			float value = ((Mathf.Repeat(animator.GetCurrentAnimatorStateInfo(0).normalizedTime + 0.2f, 1f) < 0.5f) ? 1f : (-1f)) * num;
			if (_character.IsGrounded())
			{
				animator.SetFloat(JumpLeg, value);
			}
		}
	}
	public class ThirdPersonController : MonoBehaviour
	{
		[Header("Cinemachine")]
		[Tooltip("The CM virtual Camera following the target.")]
		public CinemachineVirtualCamera followCamera;

		[Tooltip("The follow target set in the Cinemachine Virtual Camera that the camera will follow.")]
		public GameObject followTarget;

		[Tooltip("The default distance behind the Follow target.")]
		[SerializeField]
		public float followDistance = 5f;

		[Tooltip("The minimum distance to Follow target.")]
		[SerializeField]
		public float followMinDistance = 2f;

		[Tooltip("The maximum distance to Follow target.")]
		[SerializeField]
		public float followMaxDistance = 10f;

		[Tooltip("How far in degrees can you move the camera up.")]
		public float maxPitch = 80f;

		[Tooltip("How far in degrees can you move the camera down.")]
		public float minPitch = -80f;

		[Space(15f)]
		public bool invertLook = true;

		[Tooltip("Mouse look sensitivity")]
		public Vector2 lookSensitivity = new Vector2(1.5f, 1.25f);

		private Character _character;

		private float _cameraTargetYaw;

		private float _cameraTargetPitch;

		private Cinemachine3rdPersonFollow _cmThirdPersonFollow;

		protected float _followDistanceSmoothVelocity;

		public void AddControlYawInput(float value, float minValue = -180f, float maxValue = 180f)
		{
			if (value != 0f)
			{
				_cameraTargetYaw = MathLib.ClampAngle(_cameraTargetYaw + value, minValue, maxValue);
			}
		}

		public void AddControlPitchInput(float value, float minValue = -80f, float maxValue = 80f)
		{
			if (value != 0f)
			{
				if (invertLook)
				{
					value = 0f - value;
				}
				_cameraTargetPitch = MathLib.ClampAngle(_cameraTargetPitch + value, minValue, maxValue);
			}
		}

		public virtual void AddControlZoomInput(float value)
		{
			followDistance = Mathf.Clamp(followDistance - value, followMinDistance, followMaxDistance);
		}

		private void UpdateCamera()
		{
			followTarget.transform.rotation = Quaternion.Euler(_cameraTargetPitch, _cameraTargetYaw, 0f);
			_cmThirdPersonFollow.CameraDistance = Mathf.SmoothDamp(_cmThirdPersonFollow.CameraDistance, followDistance, ref _followDistanceSmoothVelocity, 0.1f);
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
			_cmThirdPersonFollow = followCamera.GetCinemachineComponent<Cinemachine3rdPersonFollow>();
			if ((bool)_cmThirdPersonFollow)
			{
				_cmThirdPersonFollow.CameraDistance = followDistance;
			}
		}

		private void Start()
		{
			Cursor.lockState = CursorLockMode.Locked;
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
			Vector2 vector3 = new Vector2
			{
				x = Input.GetAxisRaw("Mouse X"),
				y = Input.GetAxisRaw("Mouse Y")
			};
			AddControlYawInput(vector3.x * lookSensitivity.x);
			AddControlPitchInput(vector3.y * lookSensitivity.y, minPitch, maxPitch);
			float axisRaw = Input.GetAxisRaw("Mouse ScrollWheel");
			AddControlZoomInput(axisRaw);
		}

		private void LateUpdate()
		{
			UpdateCamera();
		}
	}
}
namespace ECM2.Walkthrough.Ex91
{
	public class FirstPersonController : MonoBehaviour
	{
		[Header("Cinemachine")]
		[Tooltip("The follow target set in the Cinemachine Virtual Camera that the camera will follow.")]
		public GameObject cameraTarget;

		[Tooltip("How far in degrees can you move the camera up.")]
		public float maxPitch = 80f;

		[Tooltip("How far in degrees can you move the camera down.")]
		public float minPitch = -80f;

		[Space(15f)]
		[Tooltip("Cinemachine Virtual Camera positioned at desired crouched height.")]
		public GameObject crouchedCamera;

		[Tooltip("Cinemachine Virtual Camera positioned at desired un-crouched height.")]
		public GameObject unCrouchedCamera;

		[Space(15f)]
		[Tooltip("Mouse look sensitivity")]
		public Vector2 lookSensitivity = new Vector2(1.5f, 1.25f);

		private Character _character;

		private float _cameraTargetPitch;

		public void AddControlYawInput(float value)
		{
			_character.AddYawInput(value);
		}

		public void AddControlPitchInput(float value, float minValue = -80f, float maxValue = 80f)
		{
			if (value != 0f)
			{
				_cameraTargetPitch = MathLib.ClampAngle(_cameraTargetPitch + value, minValue, maxValue);
				cameraTarget.transform.localRotation = Quaternion.Euler(0f - _cameraTargetPitch, 0f, 0f);
			}
		}

		private void OnCrouched()
		{
			crouchedCamera.SetActive(value: true);
			unCrouchedCamera.SetActive(value: false);
		}

		private void OnUnCrouched()
		{
			crouchedCamera.SetActive(value: false);
			unCrouchedCamera.SetActive(value: true);
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Start()
		{
			Cursor.lockState = CursorLockMode.Locked;
			_character.SetRotationMode(Character.RotationMode.None);
		}

		private void OnEnable()
		{
			_character.Crouched += OnCrouched;
			_character.UnCrouched += OnUnCrouched;
		}

		private void OnDisable()
		{
			_character.Crouched -= OnCrouched;
			_character.UnCrouched -= OnUnCrouched;
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 zero = Vector3.zero;
			zero += _character.GetRightVector() * vector.x;
			zero += _character.GetForwardVector() * vector.y;
			_character.SetMovementDirection(zero);
			Vector2 vector2 = new Vector2
			{
				x = Input.GetAxisRaw("Mouse X"),
				y = Input.GetAxisRaw("Mouse Y")
			};
			AddControlYawInput(vector2.x * lookSensitivity.x);
			AddControlPitchInput(vector2.y * lookSensitivity.y, minPitch, maxPitch);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex81
{
	public class ClickToMove : MonoBehaviour
	{
		public Camera mainCamera;

		public Character character;

		public LayerMask groundMask;

		private NavMeshCharacter _navMeshCharacter;

		private void Awake()
		{
			_navMeshCharacter = character.GetComponent<NavMeshCharacter>();
		}

		private void Update()
		{
			if (Input.GetMouseButton(0) && Physics.Raycast(mainCamera.ScreenPointToRay(Input.mousePosition), out var hitInfo, float.PositiveInfinity, groundMask))
			{
				_navMeshCharacter.MoveToDestination(hitInfo.point);
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex7
{
	public class PlayerController : MonoBehaviour
	{
		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
}
namespace ECM2.Walkthrough.EX74
{
	public class OneWayPlatform : MonoBehaviour
	{
		public Collider platformCollider;

		private void OnTriggerEnter(Collider other)
		{
			if (other.CompareTag("Player"))
			{
				Character component = other.GetComponent<Character>();
				if ((bool)component)
				{
					component.IgnoreCollision(platformCollider);
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.CompareTag("Player"))
			{
				Character component = other.GetComponent<Character>();
				if ((bool)component)
				{
					component.IgnoreCollision(platformCollider, ignore: false);
				}
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex71
{
	[RequireComponent(typeof(Rigidbody))]
	public class KinematicMove : MonoBehaviour
	{
		[SerializeField]
		public float _moveTime = 3f;

		[SerializeField]
		private Vector3 _offset;

		private Rigidbody _rigidbody;

		private Vector3 _startPosition;

		private Vector3 _targetPosition;

		public float moveTime
		{
			get
			{
				return _moveTime;
			}
			set
			{
				_moveTime = Mathf.Max(0.0001f, value);
			}
		}

		public Vector3 offset
		{
			get
			{
				return _offset;
			}
			set
			{
				_offset = value;
			}
		}

		public static float EaseInOut(float time, float duration)
		{
			return -0.5f * (Mathf.Cos(MathF.PI * time / duration) - 1f);
		}

		public void OnValidate()
		{
			moveTime = _moveTime;
		}

		public void Awake()
		{
			_rigidbody = GetComponent<Rigidbody>();
			_rigidbody.isKinematic = true;
			_startPosition = base.transform.position;
			_targetPosition = _startPosition + offset;
		}

		public void FixedUpdate()
		{
			float t = EaseInOut(Mathf.PingPong(Time.time, _moveTime), _moveTime);
			Vector3 position = Vector3.Lerp(_startPosition, _targetPosition, t);
			_rigidbody.MovePosition(position);
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class KinematicRotate : MonoBehaviour
	{
		[SerializeField]
		private float _rotationSpeed = 30f;

		public Vector3 rotationAxis = Vector3.up;

		private Rigidbody _rigidbody;

		private float _angle;

		public float rotationSpeed
		{
			get
			{
				return _rotationSpeed;
			}
			set
			{
				_rotationSpeed = value;
			}
		}

		public float angle
		{
			get
			{
				return _angle;
			}
			set
			{
				_angle = MathLib.ClampAngle(value, 0f, 360f);
			}
		}

		public void OnValidate()
		{
			rotationSpeed = _rotationSpeed;
			rotationAxis = rotationAxis.normalized;
		}

		public void Awake()
		{
			_rigidbody = GetComponent<Rigidbody>();
			_rigidbody.isKinematic = true;
		}

		public void FixedUpdate()
		{
			angle += rotationSpeed * Time.deltaTime;
			Quaternion quaternion = Quaternion.AngleAxis(rotationSpeed * Time.deltaTime, rotationAxis.normalized);
			_rigidbody.MoveRotation(_rigidbody.rotation * quaternion);
		}
	}
}
namespace ECM2.Walkthrough.Ex62
{
	public class ApplyLandingForce : MonoBehaviour
	{
		public float landingForceScale = 1f;

		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.Landed += OnLanded;
		}

		private void OnDisable()
		{
			_character.Landed -= OnLanded;
		}

		private void OnLanded(Vector3 landingVelocity)
		{
			Rigidbody groundRigidbody = _character.characterMovement.groundRigidbody;
			if ((bool)groundRigidbody)
			{
				Vector3 force = _character.GetGravityVector() * (_character.mass * landingVelocity.magnitude * landingForceScale);
				groundRigidbody.AddForceAtPosition(force, _character.position);
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex61
{
	public class Bouncer : MonoBehaviour
	{
		public float launchImpulse = 15f;

		public bool overrideVerticalVelocity;

		public bool overrideLateralVelocity;

		private void OnTriggerEnter(Collider other)
		{
			if (other.CompareTag("Player") && other.TryGetComponent<Character>(out var component))
			{
				component.PauseGroundConstraint();
				component.LaunchCharacter(base.transform.up * launchImpulse, overrideVerticalVelocity, overrideLateralVelocity);
			}
		}
	}
	public class ForceZone : MonoBehaviour
	{
		public Vector3 windDirection = Vector3.up;

		public float windStrength = 20f;

		private void OnTriggerStay(Collider other)
		{
			if (other.CompareTag("Player") && other.TryGetComponent<Character>(out var component))
			{
				Vector3 vector = windDirection.normalized * windStrength;
				Vector3 rhs = -component.GetGravityDirection();
				float num = Vector3.Dot(vector, rhs);
				if (num > 0f && component.IsWalking() && num - component.GetGravityMagnitude() > 0f)
				{
					component.PauseGroundConstraint();
				}
				component.AddForce(vector, ForceMode.Acceleration);
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex52
{
	public class PlayerController : MonoBehaviour
	{
		private Character _character;

		protected void OnCollided(ref CollisionResult collisionResult)
		{
			UnityEngine.Debug.Log("Collided with " + collisionResult.collider.name);
		}

		protected void OnFoundGround(ref FindGroundResult foundGround)
		{
			UnityEngine.Debug.Log("Found " + foundGround.collider.name + " ground");
		}

		protected void OnLanded(Vector3 landingVelocity)
		{
			UnityEngine.Debug.Log($"Landed with {landingVelocity:F4} landing velocity.");
		}

		protected void OnCrouched()
		{
			UnityEngine.Debug.Log("Crouched");
		}

		protected void OnUnCrouched()
		{
			UnityEngine.Debug.Log("UnCrouched");
		}

		protected void OnJumped()
		{
			UnityEngine.Debug.Log("Jumped!");
			_character.notifyJumpApex = true;
		}

		protected void OnReachedJumpApex()
		{
			UnityEngine.Debug.Log($"Apex reached {_character.GetVelocity():F4}");
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.Collided += OnCollided;
			_character.FoundGround += OnFoundGround;
			_character.Landed += OnLanded;
			_character.Crouched += OnCrouched;
			_character.UnCrouched += OnUnCrouched;
			_character.Jumped += OnJumped;
			_character.ReachedJumpApex += OnReachedJumpApex;
		}

		private void OnDisable()
		{
			_character.Collided -= OnCollided;
			_character.FoundGround -= OnFoundGround;
			_character.Landed -= OnLanded;
			_character.Crouched -= OnCrouched;
			_character.UnCrouched -= OnUnCrouched;
			_character.Jumped -= OnJumped;
			_character.ReachedJumpApex -= OnReachedJumpApex;
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex51
{
	public class PlayerCharacter : Character
	{
		protected override void OnCollided(ref CollisionResult collisionResult)
		{
			base.OnCollided(ref collisionResult);
			UnityEngine.Debug.Log("Collided with " + collisionResult.collider.name);
		}

		protected override void OnFoundGround(ref FindGroundResult foundGround)
		{
			base.OnFoundGround(ref foundGround);
			UnityEngine.Debug.Log("Found " + foundGround.collider.name + " ground");
		}

		protected override void OnLanded(Vector3 landingVelocity)
		{
			base.OnLanded(landingVelocity);
			UnityEngine.Debug.Log($"Landed with {landingVelocity:F4} landing velocity.");
		}

		protected override void OnCrouched()
		{
			base.OnCrouched();
			UnityEngine.Debug.Log("Crouched");
		}

		protected override void OnUnCrouched()
		{
			base.OnUnCrouched();
			UnityEngine.Debug.Log("UnCrouched");
		}

		protected override void OnJumped()
		{
			base.OnJumped();
			UnityEngine.Debug.Log("Jumped!");
			base.notifyJumpApex = true;
		}

		protected override void OnReachedJumpApex()
		{
			base.OnReachedJumpApex();
			UnityEngine.Debug.Log($"Apex reached {GetVelocity():F4}");
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)base.camera)
			{
				vector2 = vector2.relativeTo(base.cameraTransform);
			}
			SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				StopJumping();
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex43
{
	public class DashingCharacter : Character
	{
		public enum ECustomMovementMode
		{
			None,
			Dashing
		}

		[Space(15f)]
		[Tooltip("Is the character able to Dash?")]
		public bool canEverDash = true;

		[Tooltip("Dash initial impulse.")]
		public float dashImpulse = 20f;

		[Tooltip("Dash duration in seconds.")]
		public float dashDuration = 0.15f;

		protected float _dashingTime;

		protected bool _dashInputPressed;

		protected bool dashInputPressed => _dashInputPressed;

		public bool IsDashing()
		{
			if (base.movementMode == MovementMode.Custom)
			{
				return base.customMovementMode == 1;
			}
			return false;
		}

		public void Dash()
		{
			_dashInputPressed = true;
		}

		public void StopDashing()
		{
			_dashInputPressed = false;
		}

		public bool IsDashAllowed()
		{
			if (IsCrouched())
			{
				return false;
			}
			if (canEverDash)
			{
				if (!IsWalking())
				{
					return IsFalling();
				}
				return true;
			}
			return false;
		}

		protected virtual void DoDash()
		{
			Vector3 vector = GetMovementDirection();
			if (vector.isZero())
			{
				vector = GetForwardVector();
			}
			Vector3 normalized = vector.onlyXZ().normalized;
			SetVelocity(normalized * dashImpulse);
			SetMovementMode(MovementMode.Custom, 1);
			if (base.rotationMode == RotationMode.OrientRotationToMovement)
			{
				SetRotation(Quaternion.LookRotation(normalized));
			}
		}

		protected virtual void ResetDashState()
		{
			_dashingTime = 0f;
			_dashInputPressed = false;
			SetVelocity(Vector3.zero);
			SetMovementMode(MovementMode.Falling);
		}

		protected virtual void DashingMovementMode(float deltaTime)
		{
			SetMovementDirection(Vector3.zero);
			_dashingTime += deltaTime;
			if (_dashingTime >= dashDuration)
			{
				ResetDashState();
			}
		}

		protected override void OnBeforeSimulationUpdate(float deltaTime)
		{
			base.OnBeforeSimulationUpdate(deltaTime);
			if (!IsDashing() && dashInputPressed && IsDashAllowed())
			{
				DoDash();
			}
		}

		protected override void CustomMovementMode(float deltaTime)
		{
			base.CustomMovementMode(deltaTime);
			if (base.customMovementMode == 1)
			{
				DashingMovementMode(deltaTime);
			}
		}
	}
	public class PlayerController : MonoBehaviour
	{
		private DashingCharacter _character;

		private void Awake()
		{
			_character = GetComponent<DashingCharacter>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
			if (Input.GetKeyDown(KeyCode.E))
			{
				_character.Dash();
			}
			else if (Input.GetKeyUp(KeyCode.E))
			{
				_character.StopDashing();
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex42
{
	public class PlayerController : MonoBehaviour
	{
		private Character _character;

		private SprintAbility _sprintAbility;

		private void Awake()
		{
			_character = GetComponent<Character>();
			_sprintAbility = GetComponent<SprintAbility>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
			if (Input.GetKeyDown(KeyCode.LeftShift))
			{
				_sprintAbility.Sprint();
			}
			else if (Input.GetKeyUp(KeyCode.LeftShift))
			{
				_sprintAbility.StopSprinting();
			}
		}
	}
	public class SprintAbility : MonoBehaviour
	{
		[Space(15f)]
		public float maxSprintSpeed = 10f;

		private Character _character;

		private bool _isSprinting;

		private bool _sprintInputPressed;

		private float _cachedMaxWalkSpeed;

		public void Sprint()
		{
			_sprintInputPressed = true;
		}

		public void StopSprinting()
		{
			_sprintInputPressed = false;
		}

		public bool IsSprinting()
		{
			return _isSprinting;
		}

		private bool CanSprint()
		{
			if (_character.IsWalking())
			{
				return !_character.IsCrouched();
			}
			return false;
		}

		private void CheckSprintInput()
		{
			if (!_isSprinting && _sprintInputPressed && CanSprint())
			{
				_isSprinting = true;
				_cachedMaxWalkSpeed = _character.maxWalkSpeed;
				_character.maxWalkSpeed = maxSprintSpeed;
			}
			else if (_isSprinting && (!_sprintInputPressed || !CanSprint()))
			{
				_isSprinting = false;
				_character.maxWalkSpeed = _cachedMaxWalkSpeed;
			}
		}

		private void OnBeforeSimulationUpdated(float deltaTime)
		{
			CheckSprintInput();
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.BeforeSimulationUpdated += OnBeforeSimulationUpdated;
		}

		private void OnDisable()
		{
			_character.BeforeSimulationUpdated -= OnBeforeSimulationUpdated;
		}
	}
}
namespace ECM2.Walkthrough.Ex41
{
	public class SprintableCharacter : Character
	{
		[Space(15f)]
		public float maxSprintSpeed = 10f;

		private bool _isSprinting;

		private bool _sprintInputPressed;

		public void Sprint()
		{
			_sprintInputPressed = true;
		}

		public void StopSprinting()
		{
			_sprintInputPressed = false;
		}

		public bool IsSprinting()
		{
			return _isSprinting;
		}

		private bool CanSprint()
		{
			if (IsWalking())
			{
				return !IsCrouched();
			}
			return false;
		}

		private void CheckSprintInput()
		{
			if (!_isSprinting && _sprintInputPressed && CanSprint())
			{
				_isSprinting = true;
			}
			else if (_isSprinting && (!_sprintInputPressed || !CanSprint()))
			{
				_isSprinting = false;
			}
		}

		public override float GetMaxSpeed()
		{
			if (!_isSprinting)
			{
				return base.GetMaxSpeed();
			}
			return maxSprintSpeed;
		}

		protected override void OnBeforeSimulationUpdate(float deltaTime)
		{
			base.OnBeforeSimulationUpdate(deltaTime);
			CheckSprintInput();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)base.camera)
			{
				vector2 = vector2.relativeTo(base.cameraTransform);
			}
			SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				StopJumping();
			}
			if (Input.GetKeyDown(KeyCode.LeftShift))
			{
				Sprint();
			}
			else if (Input.GetKeyUp(KeyCode.LeftShift))
			{
				StopSprinting();
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex33
{
	public class RootMotionToggle : MonoBehaviour
	{
		private Character _character;

		private void OnMovementModeChanged(Character.MovementMode prevMovementMode, int prevCustomMovementMode)
		{
			_character.useRootMotion = _character.IsWalking();
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.MovementModeChanged += OnMovementModeChanged;
		}

		private void OnDisable()
		{
			_character.MovementModeChanged -= OnMovementModeChanged;
		}
	}
}
namespace ECM2.Walkthrough.Ex31
{
	public class AnimationController : MonoBehaviour
	{
		private static readonly int Forward = Animator.StringToHash("Forward");

		private static readonly int Turn = Animator.StringToHash("Turn");

		private static readonly int Ground = Animator.StringToHash("OnGround");

		private static readonly int Crouch = Animator.StringToHash("Crouch");

		private static readonly int Jump = Animator.StringToHash("Jump");

		private static readonly int JumpLeg = Animator.StringToHash("JumpLeg");

		private Character _character;

		private void Awake()
		{
			_character = GetComponentInParent<Character>();
		}

		private void Update()
		{
			float deltaTime = Time.deltaTime;
			Animator animator = _character.GetAnimator();
			Vector3 vector = base.transform.InverseTransformDirection(_character.GetMovementDirection());
			float num = ((_character.useRootMotion && (bool)_character.GetRootMotionController()) ? vector.z : Mathf.InverseLerp(0f, _character.GetMaxSpeed(), _character.GetSpeed()));
			animator.SetFloat(Forward, num, 0.1f, deltaTime);
			animator.SetFloat(Turn, Mathf.Atan2(vector.x, vector.z), 0.1f, deltaTime);
			animator.SetBool(Ground, _character.IsGrounded());
			animator.SetBool(Crouch, _character.IsCrouched());
			if (_character.IsFalling())
			{
				animator.SetFloat(Jump, _character.GetVelocity().y, 0.1f, deltaTime);
			}
			float value = ((Mathf.Repeat(animator.GetCurrentAnimatorStateInfo(0).normalizedTime + 0.2f, 1f) < 0.5f) ? 1f : (-1f)) * num;
			if (_character.IsGrounded())
			{
				animator.SetFloat(JumpLeg, value);
			}
		}
	}
	public class PlayerController : MonoBehaviour
	{
		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex22
{
	public class PlayerController : MonoBehaviour
	{
		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
}
namespace ECM2.Walkthrough.Ex21
{
	public class PlayerCharacter : Character
	{
		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)base.camera)
			{
				vector2 = vector2.relativeTo(base.cameraTransform);
			}
			SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				StopJumping();
			}
		}
	}
}
namespace ECM2.Examples
{
	public class CharacterInput : MonoBehaviour
	{
		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
	public class CharacterPause : MonoBehaviour
	{
		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.P))
			{
				_character.Pause(!_character.isPaused);
			}
		}
	}
	public sealed class SimpleCameraController : MonoBehaviour
	{
		[SerializeField]
		private Transform _target;

		[SerializeField]
		private float _distanceToTarget = 10f;

		[SerializeField]
		private float _smoothTime = 0.1f;

		private Vector3 _followVelocity;

		public Transform target
		{
			get
			{
				return _target;
			}
			set
			{
				_target = value;
			}
		}

		public float distanceToTarget
		{
			get
			{
				return _distanceToTarget;
			}
			set
			{
				_distanceToTarget = Mathf.Max(0f, value);
			}
		}

		public void OnValidate()
		{
			distanceToTarget = _distanceToTarget;
		}

		public void Start()
		{
			if (!(_target == null))
			{
				base.transform.position = target.position - base.transform.forward * distanceToTarget;
			}
		}

		public void LateUpdate()
		{
			if (!(_target == null))
			{
				Vector3 vector = target.position - base.transform.forward * distanceToTarget;
				base.transform.position = Vector3.SmoothDamp(base.transform.position, vector, ref _followVelocity, _smoothTime);
			}
		}
	}
}
namespace ECM2.Examples.TwinStickMovement
{
	public class TwinStickCharacter : Character
	{
		private Vector3 _aimDirection;

		public virtual Vector3 GetAimDirection()
		{
			return _aimDirection;
		}

		public virtual void SetAimDirection(Vector3 worldDirection)
		{
			_aimDirection = worldDirection;
		}

		protected override void CustomRotationMode(float deltaTime)
		{
			base.CustomRotationMode(deltaTime);
			Vector3 worldDirection = (_aimDirection.isZero() ? GetMovementDirection() : GetAimDirection());
			RotateTowards(worldDirection, deltaTime);
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)base.camera)
			{
				vector2 = vector2.relativeTo(base.cameraTransform);
			}
			SetMovementDirection(vector2);
			Vector3 aimDirection = Vector3.zero;
			if (Input.GetMouseButton(0) && Physics.Raycast(base.camera.ScreenPointToRay(Input.mousePosition), out var hitInfo, float.PositiveInfinity))
			{
				aimDirection = (hitInfo.point - GetPosition()).onlyXZ().normalized;
			}
			SetAimDirection(aimDirection);
		}
	}
}
namespace ECM2.Examples.ToggleGravityDirection
{
	public class ToggleCharacterGravityDirection : MonoBehaviour
	{
		private Character _character;

		private void RotateCharacterToGravity(float deltaTime)
		{
			Vector3 toDirection = -1f * _character.GetGravityDirection();
			Vector3 upVector = _character.GetUpVector();
			Quaternion rotation = _character.GetRotation();
			Quaternion to = Quaternion.FromToRotation(upVector, toDirection) * rotation;
			rotation = Quaternion.RotateTowards(rotation, to, _character.rotationRate * deltaTime);
			_character.SetRotation(rotation);
		}

		private void OnAfterSimulationUpdated(float deltaTime)
		{
			RotateCharacterToGravity(deltaTime);
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.AfterSimulationUpdated += OnAfterSimulationUpdated;
		}

		private void OnDisable()
		{
			_character.AfterSimulationUpdated -= OnAfterSimulationUpdated;
		}

		private void Update()
		{
			if (_character.IsFalling() && Input.GetKeyDown(KeyCode.E))
			{
				_character.gravityScale *= -1f;
			}
		}
	}
}
namespace ECM2.Examples.ThirdPerson
{
	public class ThirdPersonController : MonoBehaviour
	{
		[Space(15f)]
		public GameObject followTarget;

		[Tooltip("The default distance behind the Follow target.")]
		[SerializeField]
		public float followDistance = 5f;

		[Tooltip("The minimum distance to Follow target.")]
		[SerializeField]
		public float followMinDistance;

		[Tooltip("The maximum distance to Follow target.")]
		[SerializeField]
		public float followMaxDistance = 10f;

		[Space(15f)]
		public bool invertLook = true;

		[Tooltip("Mouse look sensitivity")]
		public Vector2 mouseSensitivity = new Vector2(1f, 1f);

		[Space(15f)]
		[Tooltip("How far in degrees can you move the camera down.")]
		public float minPitch = -80f;

		[Tooltip("How far in degrees can you move the camera up.")]
		public float maxPitch = 80f;

		protected float _cameraYaw;

		protected float _cameraPitch;

		protected float _currentFollowDistance;

		protected float _followDistanceSmoothVelocity;

		protected Character _character;

		public virtual void AddControlYawInput(float value)
		{
			_cameraYaw = MathLib.ClampAngle(_cameraYaw + value, -180f, 180f);
		}

		public virtual void AddControlPitchInput(float value, float minValue = -80f, float maxValue = 80f)
		{
			_cameraPitch = MathLib.ClampAngle(_cameraPitch + value, minValue, maxValue);
		}

		public virtual void AddControlZoomInput(float value)
		{
			followDistance = Mathf.Clamp(followDistance - value, followMinDistance, followMaxDistance);
		}

		protected virtual void UpdateCameraRotation()
		{
			_character.cameraTransform.rotation = Quaternion.Euler(_cameraPitch, _cameraYaw, 0f);
		}

		protected virtual void UpdateCameraPosition()
		{
			Transform cameraTransform = _character.cameraTransform;
			_currentFollowDistance = Mathf.SmoothDamp(_currentFollowDistance, followDistance, ref _followDistanceSmoothVelocity, 0.1f);
			cameraTransform.position = followTarget.transform.position - cameraTransform.forward * _currentFollowDistance;
		}

		protected virtual void UpdateCamera()
		{
			UpdateCameraRotation();
			UpdateCameraPosition();
		}

		protected virtual void Awake()
		{
			_character = GetComponent<Character>();
		}

		protected virtual void Start()
		{
			Cursor.lockState = CursorLockMode.Locked;
			Vector3 eulerAngles = _character.cameraTransform.eulerAngles;
			_cameraPitch = eulerAngles.x;
			_cameraYaw = eulerAngles.y;
			_currentFollowDistance = followDistance;
		}

		protected virtual void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.cameraTransform)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform, _character.GetUpVector());
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
			Vector2 vector3 = new Vector2
			{
				x = Input.GetAxisRaw("Mouse X"),
				y = Input.GetAxisRaw("Mouse Y")
			};
			vector3 *= mouseSensitivity;
			AddControlYawInput(vector3.x);
			AddControlPitchInput(invertLook ? (0f - vector3.y) : vector3.y, minPitch, maxPitch);
			float axisRaw = Input.GetAxisRaw("Mouse ScrollWheel");
			AddControlZoomInput(axisRaw);
		}

		protected virtual void LateUpdate()
		{
			UpdateCamera();
		}
	}
}
namespace ECM2.Examples.Teleport
{
	public class Teleporter : MonoBehaviour
	{
		[Tooltip("The destination teleporter.")]
		public Teleporter destination;

		[Tooltip("If true, the character will orient towards the destination Teleporter forward (yaw only)")]
		public bool OrientWithDestination;

		public bool isTeleporterEnabled { get; set; } = true;

		private void OnTriggerEnter(Collider other)
		{
			if (!(destination == null) && isTeleporterEnabled && other.TryGetComponent<Character>(out var component))
			{
				component.TeleportPosition(destination.transform.position);
				destination.isTeleporterEnabled = false;
				if (OrientWithDestination)
				{
					Vector3 upVector = component.GetUpVector();
					Vector3 vector = destination.transform.forward.projectedOnPlane(upVector);
					Quaternion newRotation = Quaternion.LookRotation(vector, component.GetUpVector());
					component.TeleportRotation(newRotation);
					component.LaunchCharacter(vector * component.GetSpeed(), overrideVerticalVelocity: false, overrideLateralVelocity: true);
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			isTeleporterEnabled = true;
		}
	}
}
namespace ECM2.Examples.SlopeSpeedModifier
{
	public class MyCharacter : Character
	{
		public override float GetMaxSpeed()
		{
			float maxSpeed = base.GetMaxSpeed();
			float signedSlopeAngle = GetSignedSlopeAngle();
			float num = ((signedSlopeAngle > 0f) ? (1f - Mathf.InverseLerp(0f, 90f, signedSlopeAngle)) : (1f + Mathf.InverseLerp(0f, 90f, 0f - signedSlopeAngle)));
			return maxSpeed * num;
		}

		private void OnGUI()
		{
			GUI.Label(new Rect(10f, 10f, 400f, 20f), $"Slope angle: {GetSignedSlopeAngle():F2} maxSpeed: {GetMaxSpeed():F2} ");
		}
	}
}
namespace ECM2.Examples.Slide
{
	public class PlayerCharacter : Character
	{
		private enum ECustomMovementMode
		{
			Sliding = 1
		}

		[Space(15f)]
		public float slideImpulse = 20f;

		public float slideDownAcceleration = 20f;

		public override float GetMaxSpeed()
		{
			if (!IsSliding())
			{
				return base.GetMaxSpeed();
			}
			return base.maxWalkSpeed;
		}

		public override float GetMaxAcceleration()
		{
			if (!IsSliding())
			{
				return base.GetMaxAcceleration();
			}
			return base.maxAcceleration * 0.1f;
		}

		public override bool IsWalking()
		{
			if (!IsSliding())
			{
				return base.IsWalking();
			}
			return true;
		}

		public bool IsSliding()
		{
			if (base.movementMode == MovementMode.Custom)
			{
				return base.customMovementMode == 1;
			}
			return false;
		}

		protected virtual bool CanSlide()
		{
			if (!IsGrounded())
			{
				return false;
			}
			float sqrMagnitude = base.velocity.sqrMagnitude;
			float num = base.maxWalkSpeedCrouched * base.maxWalkSpeedCrouched;
			return sqrMagnitude >= num * 1.02f;
		}

		protected virtual Vector3 CalcSlideDirection()
		{
			Vector3 vector = GetMovementDirection();
			if (vector.isZero())
			{
				vector = GetVelocity();
			}
			else if (vector.isZero())
			{
				vector = GetForwardVector();
			}
			return ConstrainInputVector(vector).normalized;
		}

		protected virtual void CheckSlideInput()
		{
			bool flag = IsSliding();
			bool flag2 = base.crouchInputPressed;
			if (!flag && flag2 && CanSlide())
			{
				SetMovementMode(MovementMode.Custom, 1);
			}
			else if (flag && (!flag2 || !CanSlide()))
			{
				SetMovementMode(MovementMode.Walking);
			}
		}

		protected override void OnMovementModeChanged(MovementMode prevMovementMode, int prevCustomMode)
		{
			base.OnMovementModeChanged(prevMovementMode, prevCustomMode);
			if (IsSliding())
			{
				Vector3 vector = CalcSlideDirection();
				base.characterMovement.velocity += vector * slideImpulse;
				SetRotationMode(RotationMode.None);
			}
			if (prevMovementMode == MovementMode.Custom && prevCustomMode == 1)
			{
				SetRotationMode(RotationMode.OrientRotationToMovement);
				if (IsFalling())
				{
					Vector3 onNormal = -GetGravityDirection();
					Vector3 vector2 = Vector3.Project(base.velocity, onNormal);
					Vector3 vector3 = Vector3.ClampMagnitude(base.velocity - vector2, base.maxWalkSpeed);
					base.characterMovement.velocity = vector3 + vector2;
				}
			}
		}

		protected override void OnBeforeSimulationUpdate(float deltaTime)
		{
			base.OnBeforeSimulationUpdate(deltaTime);
			CheckSlideInput();
		}

		protected virtual void SlidingMovementMode(float deltaTime)
		{
			Vector3 desiredVelocity = Vector3.Project(GetDesiredVelocity(), GetRightVector());
			base.characterMovement.velocity = CalcVelocity(base.characterMovement.velocity, desiredVelocity, base.groundFriction * 0.2f, isFluid: false, deltaTime);
			Vector3 normalized = Vector3.ProjectOnPlane(GetGravityDirection(), base.characterMovement.groundNormal).normalized;
			base.characterMovement.velocity += slideDownAcceleration * deltaTime * normalized;
			if (base.applyStandingDownwardForce)
			{
				ApplyDownwardsForce();
			}
		}

		protected override void CustomMovementMode(float deltaTime)
		{
			base.CustomMovementMode(deltaTime);
			if (base.customMovementMode == 1)
			{
				SlidingMovementMode(deltaTime);
			}
		}
	}
}
namespace ECM2.Examples.SideScrolling
{
	public class SideScrollingCharacter : Character
	{
		protected override void Awake()
		{
			base.Awake();
			SetRotationMode(RotationMode.None);
		}

		private void Update()
		{
			float axisRaw = Input.GetAxisRaw("Horizontal");
			SetMovementDirection(Vector3.right * axisRaw);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				StopJumping();
			}
			if (axisRaw != 0f)
			{
				SetYaw(axisRaw * 90f);
			}
		}
	}
}
namespace ECM2.Examples.PlanetWalk
{
	public class PlayerCharacter : Character
	{
		[Space(15f)]
		public Transform planetTransform;

		protected override void UpdateRotation(float deltaTime)
		{
			base.UpdateRotation(deltaTime);
			SetGravityVector((planetTransform.position - GetPosition()).normalized * GetGravityMagnitude());
			Vector3 toDirection = GetGravityDirection() * -1f;
			Quaternion quaternion = Quaternion.FromToRotation(GetUpVector(), toDirection) * GetRotation();
			SetRotation(quaternion);
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 zero = Vector3.zero;
			zero += Vector3.right * vector.x;
			zero += Vector3.forward * vector.y;
			zero = zero.relativeTo(base.cameraTransform, GetUpVector());
			SetMovementDirection(zero);
			if (Input.GetButton("Jump"))
			{
				Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				StopJumping();
			}
		}
	}
	public class ThirdPersonController : ECM2.Examples.ThirdPerson.ThirdPersonController
	{
		private Vector3 _cameraForward = Vector3.forward;

		public override void AddControlYawInput(float value)
		{
			Vector3 up = followTarget.transform.up;
			_cameraForward = Quaternion.Euler(up * value) * _cameraForward;
		}

		protected override void UpdateCameraRotation()
		{
			Vector3 normal = followTarget.transform.up;
			Vector3.OrthoNormalize(ref normal, ref _cameraForward);
			_character.cameraTransform.rotation = Quaternion.LookRotation(_cameraForward, normal) * Quaternion.Euler(_cameraPitch, 0f, 0f);
		}
	}
}
namespace ECM2.Examples.OrientToGround
{
	public class CharacterOrientToGround : MonoBehaviour, IColliderFilter
	{
		public float maxSlopeAngle = 30f;

		public float alignRate = 10f;

		public float rayOffset = 0.1f;

		public LayerMask groundMask = 1;

		[Space(15f)]
		public bool drawRays = true;

		private readonly RaycastHit[] _hits = new RaycastHit[8];

		private Character _character;

		public bool Filter(Collider otherCollider)
		{
			CharacterMovement characterMovement = _character.GetCharacterMovement();
			if (otherCollider == characterMovement.collider)
			{
				return true;
			}
			return false;
		}

		private Vector3 ComputeAverageNormal()
		{
			CharacterMovement characterMovement = _character.GetCharacterMovement();
			Vector3 up = Vector3.up;
			Vector3 vector = _character.GetPosition() + up * (characterMovement.height * 0.5f);
			Vector3 direction = -up;
			float height = characterMovement.height;
			LayerMask layerMask = groundMask;
			Vector3 vector2 = Vector3.zero;
			float num = 0f - rayOffset;
			float num2 = 0f - rayOffset;
			int num3 = 0;
			for (int i = 0; i < 3; i++)
			{
				num2 = 0f - rayOffset;
				for (int j = 0; j < 3; j++)
				{
					if (CollisionDetection.Raycast(vector + new Vector3(num, 0f, num2), direction, height, layerMask, QueryTriggerInteraction.Ignore, out var closestHit, _hits, this) > 0 && Vector3.Angle(closestHit.normal, up) < maxSlopeAngle)
					{
						vector2 += closestHit.normal;
						if (drawRays)
						{
							UnityEngine.Debug.DrawRay(closestHit.point, closestHit.normal, Color.yellow);
						}
						num3++;
					}
					num2 += rayOffset;
				}
				num += rayOffset;
			}
			if (num3 > 0)
			{
				vector2 /= (float)num3;
			}
			else
			{
				vector2 = up;
			}
			if (drawRays)
			{
				UnityEngine.Debug.DrawRay(_character.GetPosition(), vector2 * 2f, Color.green);
			}
			return vector2;
		}

		private void OnAfterSimulationUpdated(float deltaTime)
		{
			Vector3 toDirection = (_character.IsWalking() ? ComputeAverageNormal() : Vector3.up);
			Quaternion rotation = _character.GetRotation();
			Quaternion quaternion = Quaternion.FromToRotation(rotation * Vector3.up, toDirection);
			rotation = Quaternion.Slerp(rotation, quaternion * rotation, alignRate * deltaTime);
			_character.SetRotation(rotation);
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.AfterSimulationUpdated += OnAfterSimulationUpdated;
		}

		private void OnDisable()
		{
			_character.AfterSimulationUpdated -= OnAfterSimulationUpdated;
		}
	}
}
namespace ECM2.Examples.Ladders
{
	public class CharacterInput : MonoBehaviour
	{
		private Character _character;

		private LadderClimbAbility _ladderClimbAbility;

		private void Awake()
		{
			_character = GetComponent<Character>();
			_ladderClimbAbility = GetComponent<LadderClimbAbility>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
			if (Input.GetKeyDown(KeyCode.E))
			{
				_ladderClimbAbility.Climb();
			}
			else if (Input.GetKeyUp(KeyCode.E))
			{
				_ladderClimbAbility.StopClimbing();
			}
		}
	}
	public sealed class Ladder : MonoBehaviour
	{
		[Header("Ladder Path")]
		public float PathLength = 10f;

		public Vector3 PathOffset = new Vector3(0f, 0f, -0.5f);

		[Header("Anchor Points")]
		public Transform TopPoint;

		public Transform BottomPoint;

		public Vector3 bottomAnchorPoint => base.transform.position + base.transform.TransformVector(PathOffset);

		public Vector3 topAnchorPoint => bottomAnchorPoint + base.transform.up * PathLength;

		public Vector3 ClosestPointOnPath(Vector3 position, out float pathPosition)
		{
			Vector3 vector = topAnchorPoint - bottomAnchorPoint;
			float num = Vector3.Dot(position - bottomAnchorPoint, vector.normalized);
			if (num > 0f)
			{
				if (num <= vector.magnitude)
				{
					pathPosition = 0f;
					return bottomAnchorPoint + vector.normalized * num;
				}
				pathPosition = num - vector.magnitude;
				return topAnchorPoint;
			}
			pathPosition = num;
			return bottomAnchorPoint;
		}

		private void OnDrawGizmos()
		{
			Gizmos.color = Color.yellow;
			Gizmos.DrawLine(bottomAnchorPoint, topAnchorPoint);
			if (!(BottomPoint == null) && !(TopPoint == null))
			{
				Gizmos.DrawWireCube(BottomPoint.position, Vector3.one * 0.25f);
				Gizmos.DrawWireCube(TopPoint.position, Vector3.one * 0.25f);
			}
		}
	}
	public class LadderClimbAbility : MonoBehaviour
	{
		public enum CustomMovementMode
		{
			Climbing = 1
		}

		public enum ClimbingState
		{
			None,
			Grabbing,
			Grabbed,
			Releasing
		}

		public float climbingSpeed = 5f;

		public float grabbingTime = 0.25f;

		public LayerMask ladderMask;

		private Character _character;

		private Ladder _activeLadder;

		private float _ladderPathPosition;

		private Vector3 _ladderStartPosition;

		private Vector3 _ladderTargetPosition;

		private Quaternion _ladderStartRotation;

		private Quaternion _ladderTargetRotation;

		private float _ladderTime;

		private ClimbingState _climbingState;

		private Character.RotationMode _previousRotationMode;

		public bool IsClimbing()
		{
			if (_character.movementMode == Character.MovementMode.Custom)
			{
				return _character.customMovementMode == 1;
			}
			return false;
		}

		private bool CanClimb()
		{
			if (_character.IsCrouched())
			{
				return false;
			}
			int overlapCount;
			Collider[] array = _character.characterMovement.OverlapTest(ladderMask, QueryTriggerInteraction.Collide, out overlapCount);
			if (overlapCount == 0)
			{
				return false;
			}
			if (!array[0].TryGetComponent<Ladder>(out var component))
			{
				return false;
			}
			_activeLadder = component;
			return true;
		}

		public void Climb()
		{
			if (!IsClimbing() && CanClimb())
			{
				_character.SetMovementMode(Character.MovementMode.Custom, 1);
				_ladderStartPosition = _character.GetPosition();
				_ladderTargetPosition = _activeLadder.ClosestPointOnPath(_ladderStartPosition, out _ladderPathPosition);
				_ladderStartRotation = _character.GetRotation();
				_ladderTargetRotation = _activeLadder.transform.rotation;
			}
		}

		public void StopClimbing()
		{
			if (IsClimbing() && _climbingState == ClimbingState.Grabbed)
			{
				_climbingState = ClimbingState.Releasing;
				_ladderStartPosition = _character.GetPosition();
				_ladderStartRotation = _character.GetRotation();
				_ladderTargetPosition = _ladderStartPosition;
				_ladderTargetRotation = _activeLadder.BottomPoint.rotation;
			}
		}

		private void ClimbingMovementMode(float deltaTime)
		{
			Vector3 velocity = Vector3.zero;
			switch (_climbingState)
			{
			case ClimbingState.Grabbing:
			case ClimbingState.Releasing:
				_ladderTime += deltaTime;
				if (_ladderTime <= grabbingTime)
				{
					velocity = (Vector3.Lerp(_ladderStartPosition, _ladderTargetPosition, _ladderTime / grabbingTime) - base.transform.position) / deltaTime;
					break;
				}
				_ladderTime = 0f;
				if (_climbingState == ClimbingState.Grabbing)
				{
					_climbingState = ClimbingState.Grabbed;
				}
				else if (_climbingState == ClimbingState.Releasing)
				{
					_character.SetMovementMode(Character.MovementMode.Falling);
				}
				break;
			case ClimbingState.Grabbed:
				_activeLadder.ClosestPointOnPath(_character.GetPosition(), out _ladderPathPosition);
				if (Mathf.Abs(_ladderPathPosition) < 0.05f)
				{
					Vector3 movementDirection = _character.GetMovementDirection();
					velocity = _activeLadder.transform.up * (movementDirection.z * climbingSpeed);
					break;
				}
				_climbingState = ClimbingState.Releasing;
				_ladderStartPosition = _character.GetPosition();
				_ladderStartRotation = _character.GetRotation();
				if (_ladderPathPosition > 0f)
				{
					_ladderTargetPosition = _activeLadder.TopPoint.position;
					_ladderTargetRotation = _activeLadder.TopPoint.rotation;
				}
				else if (_ladderPathPosition < 0f)
				{
					_ladderTargetPosition = _activeLadder.BottomPoint.position;
					_ladderTargetRotation = _activeLadder.BottomPoint.rotation;
				}
				break;
			}
			_character.SetVelocity(velocity);
		}

		private void OnMovementModeChanged(Character.MovementMode prevMovementMode, int prevCustomMovementMode)
		{
			if (IsClimbing())
			{
				_climbingState = ClimbingState.Grabbing;
				_character.StopJumping();
				_character.EnableGroundConstraint(enable: false);
				_previousRotationMode = _character.rotationMode;
				_character.SetRotationMode(Character.RotationMode.Custom);
			}
			if (prevMovementMode == Character.MovementMode.Custom && prevCustomMovementMode == 1)
			{
				_climbingState = ClimbingState.None;
				_character.EnableGroundConstraint(enable: true);
				_character.SetRotationMode(_previousRotationMode);
			}
		}

		private void OnCustomMovementModeUpdated(float deltaTime)
		{
			if (IsClimbing())
			{
				ClimbingMovementMode(deltaTime);
			}
		}

		private void OnCustomRotationModeUpdated(float deltaTime)
		{
			if (IsClimbing() && (_climbingState == ClimbingState.Grabbing || _climbingState == ClimbingState.Releasing))
			{
				Quaternion rotation = Quaternion.Slerp(_ladderStartRotation, _ladderTargetRotation, _ladderTime / grabbingTime);
				_character.SetRotation(rotation);
			}
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.MovementModeChanged += OnMovementModeChanged;
			_character.CustomMovementModeUpdated += OnCustomMovementModeUpdated;
			_character.CustomRotationModeUpdated += OnCustomRotationModeUpdated;
		}

		private void OnDisable()
		{
			_character.MovementModeChanged -= OnMovementModeChanged;
			_character.CustomMovementModeUpdated -= OnCustomMovementModeUpdated;
			_character.CustomRotationModeUpdated -= OnCustomRotationModeUpdated;
		}
	}
}
namespace ECM2.Examples.Jump
{
	public class CharacterInput : MonoBehaviour
	{
		private Character _character;

		private JumpAbility _jumpAbility;

		private void Awake()
		{
			_character = GetComponent<Character>();
			_jumpAbility = GetComponent<JumpAbility>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_jumpAbility.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_jumpAbility.StopJumping();
			}
		}
	}
	public class JumpAbility : MonoBehaviour
	{
		[Space(15f)]
		[Tooltip("Is the character able to jump ?")]
		[SerializeField]
		private bool _canEverJump;

		[Tooltip("Can jump while crouching ?")]
		[SerializeField]
		private bool _jumpWhileCrouching;

		[Tooltip("The max number of jumps the Character can perform.")]
		[SerializeField]
		private int _jumpMaxCount;

		[Tooltip("Initial velocity (instantaneous vertical velocity) when jumping.")]
		[SerializeField]
		private float _jumpImpulse;

		[Tooltip("The maximum time (in seconds) to hold the jump. eg: Variable height jump.")]
		[SerializeField]
		private float _jumpMaxHoldTime;

		[Tooltip("How early before hitting the ground you can trigger a jump (in seconds).")]
		[SerializeField]
		private float _jumpPreGroundedTime;

		[Tooltip("How long after leaving the ground you can trigger a jump (in seconds).")]
		[SerializeField]
		private float _jumpPostGroundedTime;

		private Character _character;

		protected bool _jumpButtonPressed;

		protected float _jumpButtonHeldDownTime;

		protected float _jumpHoldTime;

		protected int _jumpCount;

		protected bool _isJumping;

		public bool canEverJump
		{
			get
			{
				return _canEverJump;
			}
			set
			{
				_canEverJump = value;
			}
		}

		public bool jumpWhileCrouching
		{
			get
			{
				return _jumpWhileCrouching;
			}
			set
			{
				_jumpWhileCrouching = value;
			}
		}

		public int jumpMaxCount
		{
			get
			{
				return _jumpMaxCount;
			}
			set
			{
				_jumpMaxCount = Mathf.Max(1, value);
			}
		}

		public float jumpImpulse
		{
			get
			{
				return _jumpImpulse;
			}
			set
			{
				_jumpImpulse = Mathf.Max(0f, value);
			}
		}

		public float jumpMaxHoldTime
		{
			get
			{
				return _jumpMaxHoldTime;
			}
			set
			{
				_jumpMaxHoldTime = Mathf.Max(0f, value);
			}
		}

		public float jumpPreGroundedTime
		{
			get
			{
				return _jumpPreGroundedTime;
			}
			set
			{
				_jumpPreGroundedTime = Mathf.Max(0f, value);
			}
		}

		public float jumpPostGroundedTime
		{
			get
			{
				return _jumpPostGroundedTime;
			}
			set
			{
				_jumpPostGroundedTime = Mathf.Max(0f, value);
			}
		}

		public bool jumpButtonPressed => _jumpButtonPressed;

		public float jumpButtonHeldDownTime => _jumpButtonHeldDownTime;

		public int jumpCount => _jumpCount;

		public float jumpHoldTime => _jumpHoldTime;

		public virtual bool IsJumping()
		{
			return _isJumping;
		}

		public void Jump()
		{
			_jumpButtonPressed = true;
		}

		public void StopJumping()
		{
			_jumpButtonPressed = false;
			_jumpButtonHeldDownTime = 0f;
			_isJumping = false;
			_jumpHoldTime = 0f;
		}

		public virtual int GetJumpCount()
		{
			return _jumpCount;
		}

		public virtual bool CanJump()
		{
			if (!canEverJump)
			{
				return false;
			}
			if (_character.IsCrouched() && !jumpWhileCrouching)
			{
				return false;
			}
			if (jumpMaxCount == 0 || _jumpCount >= jumpMaxCount)
			{
				return false;
			}
			if (_jumpCount == 0)
			{
				bool flag = _character.IsWalking() || (_character.IsFalling() && jumpPostGroundedTime > 0f && _character.fallingTime < jumpPostGroundedTime);
				if (_character.IsFalling() && !flag)
				{
					flag = jumpMaxCount > 1;
					if (flag)
					{
						_jumpCount++;
					}
				}
				return flag;
			}
			return _character.IsFalling();
		}

		protected virtual Vector3 CalcJumpImpulse()
		{
			Vector3 vector = -_character.GetGravityDirection();
			float num = Mathf.Max(Vector3.Dot(_character.GetVelocity(), vector), jumpImpulse);
			return vector * num;
		}

		protected virtual void DoJump(float deltaTime)
		{
			if (_jumpButtonPressed)
			{
				_jumpButtonHeldDownTime += deltaTime;
			}
			if (_jumpButtonPressed && !IsJumping() && (!(jumpPreGroundedTime > 0f) || _jumpButtonHeldDownTime <= jumpPreGroundedTime) && CanJump())
			{
				_character.SetMovementMode(Character.MovementMode.Falling);
				_character.PauseGroundConstraint();
				_character.LaunchCharacter(CalcJumpImpulse(), overrideVerticalVelocity: true);
				_jumpCount++;
				_isJumping = true;
			}
		}

		protected virtual void Jumping(float deltaTime)
		{
			if (!canEverJump)
			{
				if (IsJumping())
				{
					StopJumping();
				}
				return;
			}
			DoJump(deltaTime);
			if (IsJumping() && _jumpButtonPressed && jumpMaxHoldTime > 0f && _jumpHoldTime < jumpMaxHoldTime)
			{
				Vector3 gravityVector = _character.GetGravityVector();
				float magnitude = gravityVector.magnitude;
				Vector3 obj = ((magnitude > 0f) ? (gravityVector / magnitude) : Vector3.zero);
				float t = Mathf.InverseLerp(0f, jumpMaxHoldTime, _jumpHoldTime);
				float num = Mathf.LerpUnclamped(magnitude, 0f, t);
				Vector3 force = -obj * num;
				_character.AddForce(force);
				_jumpHoldTime += deltaTime;
			}
		}

		protected virtual void OnMovementModeChanged(Character.MovementMode prevMovementMode, int prevCustomMode)
		{
			if (_character.IsWalking())
			{
				_jumpCount = 0;
			}
			else if (_character.IsFlying() || _character.IsSwimming())
			{
				StopJumping();
			}
		}

		protected virtual void Reset()
		{
			_canEverJump = true;
			_jumpWhileCrouching = true;
			_jumpMaxCount = 1;
			_jumpImpulse = 5f;
		}

		protected virtual void OnValidate()
		{
			jumpMaxCount = _jumpMaxCount;
			jumpImpulse = _jumpImpulse;
			jumpMaxHoldTime = _jumpMaxHoldTime;
			jumpPreGroundedTime = _jumpPreGroundedTime;
			jumpPostGroundedTime = _jumpPostGroundedTime;
		}

		protected virtual void Awake()
		{
			_character = GetComponent<Character>();
		}

		protected virtual void OnEnable()
		{
			_character.MovementModeChanged += OnMovementModeChanged;
			_character.BeforeSimulationUpdated += Jumping;
		}

		protected virtual void OnDisable()
		{
			_character.BeforeSimulationUpdated -= Jumping;
			_character.MovementModeChanged -= OnMovementModeChanged;
		}

		protected virtual void Start()
		{
			_character.canEverJump = false;
		}
	}
}
namespace ECM2.Examples.Glide
{
	public class GlideAbility : MonoBehaviour
	{
		public bool canEverGlide = true;

		public float maxFallSpeedGliding = 1f;

		private Character _character;

		protected bool _glideInputPressed;

		protected bool _isGliding;

		public bool glideInputPressed => _glideInputPressed;

		public virtual bool IsGliding()
		{
			return _isGliding;
		}

		public virtual void Glide()
		{
			_glideInputPressed = true;
		}

		public virtual void StopGliding()
		{
			_glideInputPressed = false;
		}

		protected virtual bool IsGlideAllowed()
		{
			if (canEverGlide)
			{
				return _character.IsFalling();
			}
			return false;
		}

		protected virtual bool CanGlide()
		{
			bool flag = IsGlideAllowed();
			if (flag)
			{
				Vector3 rhs = -_character.GetGravityDirection();
				flag = Vector3.Dot(_character.GetVelocity(), rhs) < 0f;
			}
			return flag;
		}

		protected virtual void CheckGlideInput()
		{
			if (!_isGliding && _glideInputPressed && CanGlide())
			{
				_isGliding = true;
				_character.maxFallSpeed = maxFallSpeedGliding;
			}
			else if (_isGliding && (!_glideInputPressed || !CanGlide()))
			{
				_isGliding = false;
				_character.maxFallSpeed = 40f;
			}
		}

		private void OnBeforeCharacterSimulationUpdated(float deltaTime)
		{
			CheckGlideInput();
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.BeforeSimulationUpdated += OnBeforeCharacterSimulationUpdated;
		}

		private void OnDisable()
		{
			_character.BeforeSimulationUpdated -= OnBeforeCharacterSimulationUpdated;
		}
	}
	public class PlayerController : MonoBehaviour
	{
		private Character _character;

		private GlideAbility _glideAbility;

		private void Awake()
		{
			_character = GetComponent<Character>();
			_glideAbility = GetComponent<GlideAbility>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 vector2 = Vector3.zero;
			vector2 += Vector3.right * vector.x;
			vector2 += Vector3.forward * vector.y;
			if ((bool)_character.camera)
			{
				vector2 = vector2.relativeTo(_character.cameraTransform);
			}
			_character.SetMovementDirection(vector2);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_glideAbility.Glide();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_glideAbility.StopGliding();
			}
		}
	}
}
namespace ECM2.Examples.FirstPerson
{
	public class FirstPersonCharacter : Character
	{
		[Tooltip("The first person camera parent.")]
		public GameObject cameraParent;

		private float _cameraPitch;

		public virtual void AddControlYawInput(float value)
		{
			if (value != 0f)
			{
				AddYawInput(value);
			}
		}

		public virtual void AddControlPitchInput(float value, float minPitch = -80f, float maxPitch = 80f)
		{
			if (value != 0f)
			{
				_cameraPitch = MathLib.ClampAngle(_cameraPitch + value, minPitch, maxPitch);
			}
		}

		protected virtual void UpdateCameraParentRotation()
		{
			cameraParent.transform.localRotation = Quaternion.Euler(_cameraPitch, 0f, 0f);
		}

		protected virtual void LateUpdate()
		{
			UpdateCameraParentRotation();
		}

		protected override void Reset()
		{
			base.Reset();
			SetRotationMode(RotationMode.None);
		}
	}
	public class FirstPersonCharacterInput : MonoBehaviour
	{
		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 zero = Vector3.zero;
			zero += _character.GetRightVector() * vector.x;
			zero += _character.GetForwardVector() * vector.y;
			_character.SetMovementDirection(zero);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
	public class FirstPersonCharacterLookInput : MonoBehaviour
	{
		[Space(15f)]
		public bool invertLook = true;

		[Tooltip("Mouse look sensitivity")]
		public Vector2 mouseSensitivity = new Vector2(1f, 1f);

		[Space(15f)]
		[Tooltip("How far in degrees can you move the camera down.")]
		public float minPitch = -80f;

		[Tooltip("How far in degrees can you move the camera up.")]
		public float maxPitch = 80f;

		private FirstPersonCharacter _character;

		private void Awake()
		{
			_character = GetComponent<FirstPersonCharacter>();
		}

		private void Start()
		{
			Cursor.lockState = CursorLockMode.Locked;
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Mouse X"),
				y = Input.GetAxisRaw("Mouse Y")
			};
			vector *= mouseSensitivity;
			_character.AddControlYawInput(vector.x);
			_character.AddControlPitchInput(invertLook ? (0f - vector.y) : vector.y);
		}
	}
}
namespace ECM2.Examples.FirstPersonSwim
{
	public class CharacterInput : MonoBehaviour
	{
		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 zero = Vector3.zero;
			if (_character.IsSwimming())
			{
				zero += _character.GetRightVector() * vector.x;
				Vector3 vector2 = (_character.camera ? _character.cameraTransform.forward : _character.GetForwardVector());
				zero += vector2 * vector.y;
				if (_character.jumpInputPressed)
				{
					if (_character.CalcImmersionDepth() > 0.65f)
					{
						zero += _character.GetUpVector();
					}
					else
					{
						_character.SetMovementMode(Character.MovementMode.Falling);
						_character.LaunchCharacter(_character.GetUpVector() * 9f, overrideVerticalVelocity: true);
					}
				}
			}
			else
			{
				zero += _character.GetRightVector() * vector.x;
				zero += _character.GetForwardVector() * vector.y;
			}
			_character.SetMovementDirection(zero);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
}
namespace ECM2.Examples.FirstPersonFly
{
	public class CharacterInput : MonoBehaviour
	{
		private Character _character;

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void Update()
		{
			Vector2 vector = new Vector2
			{
				x = Input.GetAxisRaw("Horizontal"),
				y = Input.GetAxisRaw("Vertical")
			};
			Vector3 zero = Vector3.zero;
			if (_character.IsFlying())
			{
				zero += _character.GetRightVector() * vector.x;
				Vector3 vector2 = (_character.camera ? _character.cameraTransform.forward : _character.GetForwardVector());
				zero += vector2 * vector.y;
				if (_character.jumpInputPressed)
				{
					zero += Vector3.up;
				}
			}
			else
			{
				zero += _character.GetRightVector() * vector.x;
				zero += _character.GetForwardVector() * vector.y;
			}
			_character.SetMovementDirection(zero);
			if (Input.GetKeyDown(KeyCode.LeftControl) || Input.GetKeyDown(KeyCode.C))
			{
				_character.Crouch();
			}
			else if (Input.GetKeyUp(KeyCode.LeftControl) || Input.GetKeyUp(KeyCode.C))
			{
				_character.UnCrouch();
			}
			if (Input.GetButtonDown("Jump"))
			{
				_character.Jump();
			}
			else if (Input.GetButtonUp("Jump"))
			{
				_character.StopJumping();
			}
		}
	}
	public class FlyAbility : MonoBehaviour
	{
		public bool canEverFly = true;

		private Character _character;

		private bool IsFlyAllowed()
		{
			if (canEverFly)
			{
				return _character.IsFalling();
			}
			return false;
		}

		protected virtual bool CanFly()
		{
			bool flag = IsFlyAllowed();
			if (flag)
			{
				Vector3 rhs = -_character.GetGravityDirection();
				flag = Vector3.Dot(_character.GetVelocity(), rhs) < 0f;
			}
			return flag;
		}

		private void OnCollided(ref CollisionResult collisionResult)
		{
			if (_character.IsFlying() && collisionResult.isWalkable)
			{
				_character.SetMovementMode(Character.MovementMode.Falling);
			}
		}

		private void OnBeforeSimulationUpdated(float deltaTime)
		{
			bool num = _character.IsFlying();
			bool jumpInputPressed = _character.jumpInputPressed;
			if (!num && jumpInputPressed && CanFly())
			{
				_character.SetMovementMode(Character.MovementMode.Flying);
			}
		}

		private void Awake()
		{
			_character = GetComponent<Character>();
		}

		private void OnEnable()
		{
			_character.Collided += OnCollided;
			_character.BeforeSimulationUpdated += OnBeforeSimulationUpdated;
		}

		private void OnDisable()
		{
			_character.Collided -= OnCollided;
			_character.BeforeSimulationUpdated -= OnBeforeSimulationUpdated;
		}
	}
}
