using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using AOT;
using Bilibili.BDS;
using CameraSystems;
using Cinemachine;
using Cinemachine.PostFX;
using Cinemachine.Utility;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Plugins.Options;
using Dialogues;
using Drawing;
using Duckov;
using Duckov.Achievements;
using Duckov.Aquariums;
using Duckov.Bitcoins;
using Duckov.BlackMarkets;
using Duckov.BlackMarkets.UI;
using Duckov.Buffs;
using Duckov.Buildings;
using Duckov.Buildings.UI;
using Duckov.Crops;
using Duckov.Crops.UI;
using Duckov.Economy;
using Duckov.Economy.UI;
using Duckov.Endowment;
using Duckov.Endowment.UI;
using Duckov.ItemUsage;
using Duckov.MasterKeys;
using Duckov.MasterKeys.UI;
using Duckov.MiniGames;
using Duckov.MiniGames.BubblePoppers;
using Duckov.MiniGames.GoldMiner;
using Duckov.MiniGames.GoldMiner.UI;
using Duckov.MiniGames.SnakeForces;
using Duckov.MiniMaps;
using Duckov.MiniMaps.UI;
using Duckov.Modding;
using Duckov.NoteIndexs;
using Duckov.Options;
using Duckov.Options.UI;
using Duckov.PerkTrees;
using Duckov.Quests;
using Duckov.Quests.Conditions;
using Duckov.Quests.Relations;
using Duckov.Quests.Tasks;
using Duckov.Quests.UI;
using Duckov.Rules;
using Duckov.Rules.UI;
using Duckov.Scenes;
using Duckov.Tasks;
using Duckov.UI;
using Duckov.UI.Animations;
using Duckov.UI.DialogueBubbles;
using Duckov.UI.SavesRestore;
using Duckov.Utilities;
using Duckov.Weathers;
using Duckvo.Beacons;
using ECM2;
using EPOOutline;
using Eflatun.SceneReference;
using FMOD;
using FMOD.Studio;
using FMODUnity;
using FOW;
using FX;
using HorizonBasedAmbientOcclusion.Universal;
using ItemStatsSystem;
using ItemStatsSystem.Data;
using ItemStatsSystem.Items;
using ItemStatsSystem.Stats;
using LeTai.TrueShadow;
using LeTai.TrueShadow.PluginInterfaces;
using MiniExcelLibs;
using NodeCanvas.BehaviourTrees;
using NodeCanvas.DialogueTrees;
using NodeCanvas.Framework;
using NodeCanvas.StateMachines;
using ParadoxNotion;
using ParadoxNotion.Design;
using Pathfinding;
using Saves;
using Shapes;
using Sirenix.OdinInspector;
using Sirenix.Utilities;
using Soda;
using SodaCraft.Localizations;
using SodaCraft.StringUtilities;
using Steamworks;
using SymmetryBreakStudio.TastyGrassShader;
using TMPro;
using UI;
using UI_Spline_Renderer;
using Umbra;
using Unity.Mathematics;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;
using UnityEngine.Playables;
using UnityEngine.Pool;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.SocialPlatforms;
using UnityEngine.Splines;
using UnityEngine.UI;
using UnityEngine.UI.ProceduralImage;
using UnityEngine.UIElements;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
[ExecuteInEditMode]
public class SodaPointLight : MonoBehaviour
{
	[SerializeField]
	private Renderer lightRenderer;

	[SerializeField]
	[Range(0f, 1f)]
	private float hardness = 0.5f;

	[SerializeField]
	[Range(1f, 5f)]
	private float fallOff = 1f;

	[FormerlySerializedAs("dayColor")]
	[SerializeField]
	[ColorUsage(false, true)]
	private Color lightColor = Color.white;

	public bool enviromentTint;

	private int lightColorID = Shader.PropertyToID("_LightColor");

	private int hardnessID = Shader.PropertyToID("_Hardness");

	private int fallOffID = Shader.PropertyToID("_FallOff");

	private int enviromentTintID = Shader.PropertyToID("_EnviromentTintOn");

	private MaterialPropertyBlock block;

	public float FallOff
	{
		get
		{
			return fallOff;
		}
		set
		{
			fallOff = value;
			SyncToLight();
		}
	}

	public float Hardness
	{
		get
		{
			return hardness;
		}
		set
		{
			hardness = value;
			SyncToLight();
		}
	}

	public Color LightColor
	{
		get
		{
			return lightColor;
		}
		set
		{
			lightColor = value;
			SyncToLight();
		}
	}

	private void Awake()
	{
		SyncToLight();
	}

	private void SyncToLight()
	{
		if (block == null)
		{
			block = new MaterialPropertyBlock();
		}
		block.SetFloat(hardnessID, hardness);
		block.SetFloat(fallOffID, fallOff);
		block.SetColor(lightColorID, LightColor);
		block.SetFloat(enviromentTintID, enviromentTint ? 1f : 0f);
		if ((bool)lightRenderer)
		{
			lightRenderer.SetPropertyBlock(block);
		}
	}

	private void OnValidate()
	{
		SyncToLight();
	}

	private void OnDrawGizmosSelected()
	{
		_ = base.transform.lossyScale;
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Color color = lightColor;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(Vector3.zero, 1f);
	}
}
public class CustomFaceData : ScriptableObject
{
	public string prefabsPath = "Assets/CustomFace/CustomFacePrefabs";

	public string info;

	[SerializeField]
	private CustomFacePartCollection hairs;

	[SerializeField]
	private CustomFacePartCollection eyes;

	[SerializeField]
	private CustomFacePartCollection mouths;

	[SerializeField]
	private CustomFacePartCollection eyebrows;

	[SerializeField]
	private CustomFacePartCollection decorations;

	[SerializeField]
	private CustomFacePartCollection tails;

	[SerializeField]
	private CustomFacePartCollection foots;

	[SerializeField]
	private CustomFacePartCollection wings;

	[SerializeField]
	private CustomFacePreset defaultPreset;

	public CustomFacePartCollection Hairs => hairs;

	public CustomFacePartCollection Eyes => eyes;

	public CustomFacePartCollection Mouths => mouths;

	public CustomFacePartCollection Eyebrows => eyebrows;

	public CustomFacePartCollection Decorations => decorations;

	public CustomFacePartCollection Tails => tails;

	public CustomFacePartCollection Foots => foots;

	public CustomFacePartCollection Wings => wings;

	public CustomFacePreset DefaultPreset => defaultPreset;
}
[Serializable]
public class CustomFacePartCollection
{
	[SerializeField]
	private List<CustomFacePartMeta> parts;

	public int totalCount => parts.Count;

	public void Clear()
	{
		parts.Clear();
	}

	public CustomFacePart GetNextOrPrevPrefab(int currentID, int direction)
	{
		int num = parts.FindIndex((CustomFacePartMeta part) => part.id == currentID);
		num = ((num != -1) ? (num + direction) : 0);
		if (num < 0)
		{
			num = parts.Count - 1;
		}
		else if (num >= parts.Count)
		{
			num = 0;
		}
		return parts[num].part;
	}

	public CustomFacePart GetPartPrefab(int id)
	{
		int num = parts.FindIndex((CustomFacePartMeta part) => part.id == id);
		if (num < 0)
		{
			return parts[0].part;
		}
		return parts[num].part;
	}

	public void Sort()
	{
		parts.Sort((CustomFacePartMeta a, CustomFacePartMeta b) => a.id.CompareTo(b.id));
	}

	public void AddNewCollection(CustomFacePart newPart)
	{
		CustomFacePartMeta item = new CustomFacePartMeta
		{
			part = newPart,
			id = newPart.id
		};
		parts.Add(item);
	}
}
[Serializable]
public struct CustomFacePartMeta
{
	public int id;

	public CustomFacePart part;
}
public enum CustomFacePartTypes
{
	hair,
	eye,
	eyebrow,
	mouth,
	tail,
	foot,
	wing
}
public class CustomFaceInstance : MonoBehaviour
{
	public Renderer[] mainRenderers;

	public CustomFaceHeadSetting headSetting;

	public Transform headJoint;

	public Transform foreheadJoint;

	public float foreheadDefaultHeight = 0.19f;

	public Transform helmatSocket;

	public Transform faceMaskSocket;

	public float helmatSocketYoffset = -0.2f;

	public Transform hairSocket;

	[SerializeField]
	public CustomFacePartUtility hairPart;

	[SerializeField]
	public CustomFacePartUtility eyePart;

	[SerializeField]
	public CustomFacePartUtility eyebrowPart;

	[SerializeField]
	public CustomFacePartUtility mouthPart;

	[SerializeField]
	public CustomFacePartUtility tailPart;

	[SerializeField]
	public CustomFacePartUtility wingLPart;

	[SerializeField]
	public CustomFacePartUtility wingRPart;

	[SerializeField]
	public CustomFacePartUtility footRPart;

	[SerializeField]
	public CustomFacePartUtility footLPart;

	public Transform leftHandSocket;

	public Transform righthandSocket;

	private MaterialPropertyBlock mainBlock;

	[SerializeField]
	private CharacterSubVisuals subvisuals;

	[SerializeField]
	private CustomFaceSettingData convertedData;

	private CustomFaceData data => GameplayDataSettings.CustomFaceData;

	public event Action OnLoadFaceData;

	private void TestConvert()
	{
		convertedData = ConvertToSaveData();
	}

	public void AddRendererToSubVisual(Renderer renderer)
	{
		if ((bool)subvisuals)
		{
			subvisuals.AddRenderer(renderer);
		}
	}

	private (CustomFacePartUtility, CustomFacePartUtility, CustomFacePartCollection) GetDataByPartType(CustomFacePartTypes type)
	{
		CustomFacePartUtility item = null;
		CustomFacePartUtility item2 = null;
		CustomFacePartCollection item3 = null;
		switch (type)
		{
		case CustomFacePartTypes.hair:
			item = hairPart;
			item3 = data.Hairs;
			break;
		case CustomFacePartTypes.eye:
			item = eyePart;
			item3 = data.Eyes;
			break;
		case CustomFacePartTypes.eyebrow:
			item = eyebrowPart;
			item3 = data.Eyebrows;
			break;
		case CustomFacePartTypes.mouth:
			item = mouthPart;
			item3 = data.Mouths;
			break;
		case CustomFacePartTypes.tail:
			item = tailPart;
			item3 = data.Tails;
			break;
		case CustomFacePartTypes.foot:
			item = footLPart;
			item2 = footRPart;
			item3 = data.Foots;
			break;
		case CustomFacePartTypes.wing:
			item = wingLPart;
			item2 = wingRPart;
			item3 = data.Wings;
			break;
		}
		return (item, item2, item3);
	}

	public CustomFacePart SwitchPart(CustomFacePartTypes type, CustomFaceInstance parent, int direction)
	{
		var (customFacePartUtility, customFacePartUtility2, customFacePartCollection) = GetDataByPartType(type);
		if (customFacePartUtility == null || customFacePartCollection == null || customFacePartCollection.totalCount <= 0)
		{
			return null;
		}
		CustomFacePart nextOrPrevPrefab = customFacePartCollection.GetNextOrPrevPrefab(customFacePartUtility.GetCurrentPartID(), direction);
		if (!nextOrPrevPrefab)
		{
			return null;
		}
		CustomFacePart result = SwitchOnePartInternal(customFacePartUtility, nextOrPrevPrefab, parent, mirror: false);
		if (customFacePartUtility2 != null)
		{
			SwitchOnePartInternal(customFacePartUtility2, nextOrPrevPrefab, parent, mirror: true);
		}
		return result;
	}

	private CustomFacePart ChangePart(CustomFacePartTypes type, CustomFaceInstance parent, int id)
	{
		var (customFacePartUtility, customFacePartUtility2, customFacePartCollection) = GetDataByPartType(type);
		if (customFacePartUtility == null || customFacePartCollection == null || customFacePartCollection.totalCount <= 0)
		{
			return null;
		}
		CustomFacePart partPrefab = customFacePartCollection.GetPartPrefab(id);
		if (!partPrefab)
		{
			return null;
		}
		CustomFacePart result = SwitchOnePartInternal(customFacePartUtility, partPrefab, parent, mirror: false);
		if (customFacePartUtility2 != null)
		{
			SwitchOnePartInternal(customFacePartUtility2, partPrefab, parent, mirror: true);
		}
		return result;
	}

	private CustomFacePart SwitchOnePartInternal(CustomFacePartUtility part, CustomFacePart pfb, CustomFaceInstance parent, bool mirror)
	{
		CustomFacePart customFacePart = InstantiatePartFromPrefab(pfb);
		customFacePart.mirror = mirror;
		part.ChangePart(customFacePart);
		part.RefreshThisPart();
		if ((bool)parent)
		{
			foreach (Renderer renderer in customFacePart.renderers)
			{
				parent.AddRendererToSubVisual(renderer);
			}
		}
		return customFacePart;
	}

	private CustomFacePart InstantiatePartFromPrefab(CustomFacePart pfb)
	{
		if (!pfb)
		{
			return null;
		}
		CustomFacePart result = null;
		if (Application.isPlaying)
		{
			result = UnityEngine.Object.Instantiate(pfb);
		}
		return result;
	}

	public void RefreshAll()
	{
		UpdateHead();
		hairPart.RefreshThisPart();
		eyePart.RefreshThisPart();
		eyebrowPart.partInfo.heightOffset = eyePart.partInfo.height;
		if ((bool)faceMaskSocket)
		{
			faceMaskSocket.localPosition = (eyePart.partInfo.height + eyePart.partInfo.heightOffset) * Vector3.up;
		}
		eyebrowPart.RefreshThisPart();
		mouthPart.RefreshThisPart();
		tailPart.RefreshThisPart();
		footLPart.RefreshThisPart();
		footRPart.RefreshThisPart();
		wingLPart.RefreshThisPart();
		wingRPart.RefreshThisPart();
		SetMainColor();
	}

	private void OnValidate()
	{
		RefreshAll();
	}

	private void LateUpdate()
	{
		UpdateHead();
		UpdateHands();
	}

	private void UpdateHands()
	{
		CustomFacePart partInstance = wingLPart.PartInstance;
		if ((bool)partInstance && (bool)partInstance.centerObject)
		{
			CustomFacePart partInstance2 = wingRPart.PartInstance;
			partInstance.centerObject.transform.position = leftHandSocket.transform.position;
			partInstance.centerObject.transform.rotation = leftHandSocket.transform.rotation;
			partInstance2.centerObject.transform.position = righthandSocket.transform.position;
			partInstance2.centerObject.transform.rotation = righthandSocket.transform.rotation;
		}
	}

	private void UpdateHead()
	{
		if ((bool)foreheadJoint)
		{
			foreheadJoint.localPosition = Vector3.up * (foreheadDefaultHeight + headSetting.foreheadHeight);
			foreheadJoint.localScale = Vector3.one + Vector3.up * (headSetting.foreheadRound - 1f);
			headJoint.localScale = Vector3.one * (headSetting.headScaleOffset + 1f);
			if ((bool)hairSocket)
			{
				hairSocket.localPosition = foreheadJoint.localPosition;
			}
			if ((bool)helmatSocket)
			{
				helmatSocket.localPosition = foreheadJoint.localPosition + Vector3.up * helmatSocketYoffset;
			}
		}
	}

	private void SetMainColor()
	{
		if (mainBlock == null)
		{
			mainBlock = new MaterialPropertyBlock();
		}
		mainBlock.SetColor("_Tint", headSetting.mainColor);
		Renderer[] array = mainRenderers;
		foreach (Renderer renderer in array)
		{
			if ((bool)renderer)
			{
				renderer.SetPropertyBlock(mainBlock);
			}
		}
	}

	public CustomFaceSettingData ConvertToSaveData()
	{
		return new CustomFaceSettingData
		{
			headSetting = headSetting,
			hairID = hairPart.GetCurrentPartID(),
			hairInfo = hairPart.partInfo,
			eyeID = eyePart.GetCurrentPartID(),
			eyeInfo = eyePart.partInfo,
			eyebrowID = eyebrowPart.GetCurrentPartID(),
			eyebrowInfo = eyebrowPart.partInfo,
			mouthID = mouthPart.GetCurrentPartID(),
			mouthInfo = mouthPart.partInfo,
			tailID = tailPart.GetCurrentPartID(),
			tailInfo = tailPart.partInfo,
			footID = footLPart.GetCurrentPartID(),
			footInfo = footLPart.partInfo,
			wingID = wingLPart.GetCurrentPartID(),
			wingInfo = wingLPart.partInfo
		};
	}

	public void LoadFromData(CustomFaceSettingData saveData)
	{
		headSetting = saveData.headSetting;
		hairPart.partInfo = saveData.hairInfo;
		eyePart.partInfo = saveData.eyeInfo;
		eyebrowPart.partInfo = saveData.eyebrowInfo;
		mouthPart.partInfo = saveData.mouthInfo;
		tailPart.partInfo = saveData.tailInfo;
		footLPart.partInfo = saveData.footInfo;
		footRPart.partInfo = saveData.footInfo;
		wingLPart.partInfo = saveData.wingInfo;
		wingRPart.partInfo = saveData.wingInfo;
		ChangePart(CustomFacePartTypes.hair, this, saveData.hairID);
		ChangePart(CustomFacePartTypes.eye, this, saveData.eyeID);
		ChangePart(CustomFacePartTypes.eyebrow, this, saveData.eyebrowID);
		ChangePart(CustomFacePartTypes.mouth, this, saveData.mouthID);
		ChangePart(CustomFacePartTypes.tail, this, saveData.tailID);
		ChangePart(CustomFacePartTypes.foot, this, saveData.footID);
		ChangePart(CustomFacePartTypes.wing, this, saveData.wingID);
		RefreshAll();
		this.OnLoadFaceData?.Invoke();
	}
}
[Serializable]
public class CustomFacePartUtility
{
	public CustomFaceInstance parent;

	public CustomFacePartTypes partType;

	public CustomFacePartInfo partInfo;

	public Transform socket;

	private CustomFacePart facePartInstance;

	public CustomFacePart PartInstance => facePartInstance;

	public int GetCurrentPartID()
	{
		if (facePartInstance != null)
		{
			return facePartInstance.id;
		}
		return -1;
	}

	public string GetCurrentPartName()
	{
		if (facePartInstance != null)
		{
			return facePartInstance.id.ToString();
		}
		return "Empty";
	}

	public void ChangePart(CustomFacePart newInstance)
	{
		if ((bool)facePartInstance)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(facePartInstance.gameObject);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(facePartInstance.gameObject);
			}
		}
		facePartInstance = newInstance;
		newInstance.transform.SetParent(socket);
		newInstance.transform.localPosition = Vector3.zero;
		newInstance.transform.localRotation = Quaternion.identity;
	}

	public void RefreshThisPart()
	{
		if ((bool)facePartInstance)
		{
			facePartInstance.SetInfo(partInfo, parent);
		}
	}
}
[Serializable]
public struct CustomFaceHeadSetting
{
	public Color mainColor;

	[Range(-0.4f, 0.4f)]
	public float headScaleOffset;

	[Range(0f, 4f)]
	public float foreheadHeight;

	[Range(0.4f, 4f)]
	public float foreheadRound;
}
[Serializable]
public struct CustomFaceSettingData
{
	[HideInInspector]
	public bool savedSetting;

	public CustomFaceHeadSetting headSetting;

	public int hairID;

	public CustomFacePartInfo hairInfo;

	public int eyeID;

	public CustomFacePartInfo eyeInfo;

	public int eyebrowID;

	public CustomFacePartInfo eyebrowInfo;

	public int mouthID;

	public CustomFacePartInfo mouthInfo;

	public int tailID;

	public CustomFacePartInfo tailInfo;

	public int footID;

	public CustomFacePartInfo footInfo;

	public int wingID;

	public CustomFacePartInfo wingInfo;

	public string DataToJson()
	{
		return Regex.Replace(JsonUtility.ToJson(this, prettyPrint: false), "\\d+\\.\\d+", (Match match) => float.Parse(match.Value).ToString("0.###"));
	}

	public static bool JsonToData(string jsonData, out CustomFaceSettingData data)
	{
		try
		{
			data = JsonUtility.FromJson<CustomFaceSettingData>(jsonData);
		}
		catch (Exception)
		{
			UnityEngine.Debug.LogError("捏脸参数违法");
			data = default(CustomFaceSettingData);
			return false;
		}
		return true;
	}
}
public class CustomFacePart : MonoBehaviour
{
	public int id;

	public bool mirror;

	public Transform centerObject;

	public Transform leftObject;

	public Transform rightObject;

	public List<Renderer> customColorRenderers;

	public List<Renderer> renderers;

	public string customColorKey = "_Tint";

	private CustomFaceInstance parent;

	private MaterialPropertyBlock block;

	public CustomFaceInstance Parent => parent;

	private void CollectRenders()
	{
		renderers.Clear();
		MeshRenderer[] componentsInChildren = base.transform.GetComponentsInChildren<MeshRenderer>();
		SkinnedMeshRenderer[] componentsInChildren2 = base.transform.GetComponentsInChildren<SkinnedMeshRenderer>();
		renderers.AddRange(componentsInChildren);
		renderers.AddRange(componentsInChildren2);
	}

	public void SetInfo(CustomFacePartInfo info, CustomFaceInstance _parent)
	{
		parent = _parent;
		if (mirror)
		{
			base.transform.localScale = new Vector3(-1f, 1f, 1f);
		}
		else
		{
			base.transform.localScale = Vector3.one;
		}
		Quaternion quaternion = Quaternion.Euler(0f, 0f - info.leftRightAngle, 0f);
		Quaternion quaternion2 = Quaternion.Euler(0f, 0f - info.leftRightAngle - info.distanceAngle, 0f);
		Quaternion quaternion3 = Quaternion.Euler(0f, 0f - info.leftRightAngle + info.distanceAngle, 0f);
		if ((bool)centerObject)
		{
			Vector3 vector = quaternion * Vector3.forward;
			centerObject.localPosition = vector * info.radius + Vector3.up * (info.height + info.heightOffset);
			centerObject.localRotation = Quaternion.LookRotation(vector);
			centerObject.localRotation = Quaternion.Euler(0f, 0f, info.twist) * centerObject.localRotation;
			centerObject.localScale = Vector3.one * info.scale;
		}
		if ((bool)leftObject)
		{
			Vector3 vector2 = quaternion2 * Vector3.forward;
			leftObject.localPosition = vector2 * info.radius + Vector3.up * (info.height + info.heightOffset);
			leftObject.localRotation = Quaternion.LookRotation(vector2, Vector3.up);
			leftObject.localRotation = Quaternion.AngleAxis(info.twist, vector2) * leftObject.localRotation;
			leftObject.localScale = Vector3.one * info.scale;
		}
		if ((bool)rightObject)
		{
			Vector3 vector3 = quaternion3 * Vector3.forward;
			rightObject.localPosition = vector3 * info.radius + Vector3.up * (info.height + info.heightOffset);
			rightObject.localRotation = Quaternion.LookRotation(vector3, Vector3.up);
			rightObject.localRotation = Quaternion.AngleAxis(0f - info.twist, vector3) * rightObject.localRotation;
			rightObject.localScale = Vector3.one * info.scale;
		}
		if (block == null)
		{
			block = new MaterialPropertyBlock();
		}
		info.color.a = 1f;
		block.SetColor(customColorKey, info.color);
		foreach (Renderer customColorRenderer in customColorRenderers)
		{
			if ((bool)customColorRenderer)
			{
				customColorRenderer.SetPropertyBlock(block);
			}
		}
	}
}
[Serializable]
public struct CustomFacePartInfo
{
	public float radius;

	public Color color;

	public float height;

	public float heightOffset;

	public float scale;

	public float twist;

	[Range(0f, 90f)]
	public float distanceAngle;

	[Range(-90f, 90f)]
	public float leftRightAngle;
}
public class CustomFacePreset : ScriptableObject
{
	public CustomFaceSettingData settings;

	private void CopyJsonToClipBoard()
	{
		GUIUtility.systemCopyBuffer = DataToJson();
	}

	private void PastyFromJsonData()
	{
		if (CustomFaceSettingData.JsonToData(GUIUtility.systemCopyBuffer, out var data))
		{
			settings = data;
		}
	}

	private string DataToJson()
	{
		return Regex.Replace(JsonUtility.ToJson(settings, prettyPrint: false), "\\d+\\.\\d+", (Match match) => float.Parse(match.Value).ToString("0.###"));
	}
}
public class TestArmRenderer : MonoBehaviour
{
	public LineRenderer[] lineRenderers;

	public Transform[] joints;

	private void Awake()
	{
		LineRenderer[] array = lineRenderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].useWorldSpace = true;
		}
	}

	private void LateUpdate()
	{
		DrawLine(lineRenderers[0], joints[0], joints[1]);
		DrawLine(lineRenderers[1], joints[1], joints[2]);
		DrawLine(lineRenderers[2], joints[3], joints[4]);
		DrawLine(lineRenderers[3], joints[4], joints[5]);
	}

	private void DrawLine(LineRenderer lineRenderer, Transform start, Transform end)
	{
		lineRenderer.positionCount = 2;
		lineRenderer.SetPosition(0, start.position);
		lineRenderer.SetPosition(1, end.position);
	}
}
public class CustomFaceLoadSaveButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public Color selectedColor;

	public Color unselectedColor;

	public UnityEngine.UI.Image image;

	public CustomFaceSaveLoad master;

	public int index;

	public TextMeshProUGUI text;

	private void Awake()
	{
	}

	public void Init(CustomFaceSaveLoad _master, int _index, string name)
	{
		text.text = name;
		master = _master;
		index = _index;
	}

	public void SetSelection(bool selected)
	{
		image.color = (selected ? selectedColor : unselectedColor);
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		master.SetSlotAndLoad(index);
	}
}
public class CustomFaceSaveLoad : MonoBehaviour
{
	public CustomFaceInstance instance;

	public CustomFaceLoadSaveButton buttonPfb;

	public Transform slotButtonParent;

	private List<CustomFaceLoadSaveButton> slotButtons;

	private int currentSlot;

	private CustomFaceData faceData => GameplayDataSettings.CustomFaceData;

	private void Awake()
	{
		slotButtons = new List<CustomFaceLoadSaveButton>();
		for (int i = 0; i < 5; i++)
		{
			CustomFaceLoadSaveButton item = CreateAButton(i, i.ToString(), slotButtonParent);
			slotButtons.Add(item);
		}
		buttonPfb.gameObject.SetActive(value: false);
		SetSlotAndLoad(0);
	}

	private CustomFaceLoadSaveButton CreateAButton(int index, string name, Transform parent)
	{
		CustomFaceLoadSaveButton customFaceLoadSaveButton = UnityEngine.Object.Instantiate(buttonPfb);
		customFaceLoadSaveButton.Init(this, index, name);
		customFaceLoadSaveButton.transform.SetParent(parent, worldPositionStays: false);
		return customFaceLoadSaveButton;
	}

	public void SetSlotAndLoad(int slot)
	{
		currentSlot = slot;
		UpdateSelection();
		LoadData(slot);
	}

	private void UpdateSelection()
	{
		foreach (CustomFaceLoadSaveButton slotButton in slotButtons)
		{
			slotButton.SetSelection(slotButton.index == currentSlot);
		}
	}

	private void LoadData(int slot)
	{
		if (!ES3.KeyExists($"CustomFaceData_{slot}"))
		{
			LoadDefault();
			return;
		}
		CustomFaceSettingData saveData = (CustomFaceSettingData)ES3.Load($"CustomFaceData_{slot}");
		instance.LoadFromData(saveData);
	}

	public void LoadDefault()
	{
		CustomFaceSettingData settings = faceData.DefaultPreset.settings;
		instance.LoadFromData(settings);
	}

	public void SaveDataToCurrentSlot()
	{
		SaveData(currentSlot);
	}

	private void SaveData(int slot)
	{
		CustomFaceSettingData value = instance.ConvertToSaveData();
		ES3.Save($"CustomFaceData_{slot}", value);
	}
}
public class CustomFaceSlider : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Slider slider;

	[SerializeField]
	private TMP_InputField valueField;

	[SerializeField]
	private string valueFormat = "0.##";

	[SerializeField]
	private TextLocalizor nameText;

	private CustomFaceUI master;

	public float Value => slider.value;

	private void Awake()
	{
		slider.onValueChanged.AddListener(OnSliderValueChanged);
		valueField.onEndEdit.AddListener(OnEndEditField);
	}

	private void Start()
	{
		RefreshFieldText();
	}

	private void OnEndEditField(string str)
	{
		if (float.TryParse(str, out var result))
		{
			result = Mathf.Clamp(result, slider.minValue, slider.maxValue);
			slider.SetValueWithoutNotify(result);
			master.SetDirty();
		}
		RefreshFieldText();
	}

	private void OnDestroy()
	{
		slider.onValueChanged.RemoveListener(OnSliderValueChanged);
	}

	public void Init(float minValue, float maxValue, CustomFaceUI _master, string nameKey)
	{
		master = _master;
		SetMinMaxValue(minValue, maxValue);
		SetNameKey(nameKey);
	}

	private void OnSliderValueChanged(float _value)
	{
		valueField.SetTextWithoutNotify(_value.ToString(valueFormat));
		master.SetDirty();
	}

	public void SetNameKey(string _nameKey)
	{
		nameText.Key = _nameKey;
	}

	public void SetMinMaxValue(float min, float max)
	{
		slider.minValue = min;
		slider.maxValue = max;
	}

	public void SetValue(float value)
	{
		slider.value = value;
	}

	private void RefreshFieldText()
	{
		valueField.SetTextWithoutNotify(slider.value.ToString(valueFormat));
	}
}
public class CustomFaceTabs : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public CustomFaceUI master;

	public List<GameObject> panels;

	public ProceduralImage background;

	public Color normalColor;

	public Color selectedColor;

	public void OnPointerClick(PointerEventData eventData)
	{
		master.SelectTab(this);
	}

	public void SetSelectVisual(bool selected)
	{
		background.color = (selected ? selectedColor : normalColor);
	}
}
public class CustomFaceUI : MonoBehaviour
{
	private static CustomFaceUI activeView;

	public List<CustomFaceTabs> tabs;

	public List<GameObject> panels;

	private CustomFaceInstance faceInstance;

	[SerializeField]
	private float rotateSpeed = 15f;

	public CustomFaceUIColorPicker skinColorPicker;

	public CustomFaceSlider headSizeSlider;

	public CustomFaceSlider headHeightSlider;

	public CustomFaceSlider headRoundnessSlider;

	public CustomFaceUISwitch hairSwitch;

	public CustomFaceUIColorPicker hairColorPicker;

	public CustomFaceUISwitch eyeSwitch;

	public CustomFaceUIColorPicker eyeColorPicker;

	public CustomFaceSlider eyeDistanceSlider;

	public CustomFaceSlider eyeHeightSlider;

	public CustomFaceSlider eyeSizeSlider;

	public CustomFaceSlider eyeTwistSlider;

	public CustomFaceUISwitch eyebrowSwitch;

	public CustomFaceUIColorPicker eyebrowColorPicker;

	public CustomFaceSlider eyebrowDistanceSlider;

	public CustomFaceSlider eyebrowHeightSlider;

	public CustomFaceSlider eyebrowSizeSlider;

	public CustomFaceSlider eyebrowTwistSlider;

	public CustomFaceUISwitch mouthSwitch;

	public CustomFaceUIColorPicker mouthColorPicker;

	public CustomFaceSlider mouthSizeSlider;

	public CustomFaceSlider mouthHeightSlider;

	public CustomFaceSlider mouthLeftRightSlider;

	public CustomFaceSlider mouthTwistSlider;

	public CustomFaceUISwitch wingSwitch;

	public CustomFaceUIColorPicker wingColorPicker;

	public CustomFaceSlider wingSizeSlider;

	public CustomFaceUISwitch tailSwitch;

	public CustomFaceUIColorPicker tailColorPicker;

	public CustomFaceSlider tailSizeSlider;

	public CustomFaceUISwitch footSwitch;

	public CustomFaceSlider footSizeSlider;

	private bool dirty;

	public bool canControl;

	public List<CustomFacePreset> presets;

	public static CustomFaceUI ActiveView
	{
		get
		{
			if ((bool)activeView && activeView.gameObject.activeInHierarchy)
			{
				return activeView;
			}
			activeView = null;
			return null;
		}
	}

	public static event Action OnCustomUIViewChanged;

	private event Action onLoadValues;

	public void SetFace(CustomFaceInstance face)
	{
		if (faceInstance != null)
		{
			faceInstance.OnLoadFaceData -= OnLoadFaceData;
		}
		faceInstance = face;
		faceInstance.OnLoadFaceData += OnLoadFaceData;
		Init();
	}

	private void OnLoadFaceData()
	{
		LoadValues();
	}

	private void Start()
	{
	}

	private void OnDestroy()
	{
		if (faceInstance != null)
		{
			faceInstance.OnLoadFaceData -= OnLoadFaceData;
		}
		if (activeView == this)
		{
			activeView = null;
		}
		CustomFaceUI.OnCustomUIViewChanged?.Invoke();
	}

	private void OnEnable()
	{
		SelectTab(tabs[0]);
		activeView = this;
		CustomFaceUI.OnCustomUIViewChanged?.Invoke();
	}

	private void OnDisable()
	{
		if (activeView == this)
		{
			activeView = null;
		}
		CustomFaceUI.OnCustomUIViewChanged?.Invoke();
	}

	private void Init()
	{
		skinColorPicker.Init(this, "UI_CustomFace_SkinColor");
		headSizeSlider.Init(0.6f, 1.4f, this, "UI_CustomFace_HeadSize");
		headHeightSlider.Init(0f, 0.6f, this, "UI_CustomFace_HeadHeight");
		headRoundnessSlider.Init(0.35f, 1f, this, "UI_CustomFace_HeadRoundness");
		hairSwitch.Init(this, CustomFacePartTypes.hair, "UI_CustomFace_HairType");
		hairColorPicker.Init(this, "UI_CustomFace_HairColor");
		eyeSwitch.Init(this, CustomFacePartTypes.eye, "UI_CustomFace_EyeType");
		eyeColorPicker.Init(this, "UI_CustomFace_EyeColor");
		eyeDistanceSlider.Init(0f, 90f, this, "UI_CustomFace_EyeSpace");
		eyeHeightSlider.Init(-0.3f, 0.3f, this, "UI_CustomFace_EyeHeight");
		eyeSizeSlider.Init(0.3f, 4f, this, "UI_CustomFace_EyeSize");
		eyeTwistSlider.Init(-90f, 90f, this, "UI_CustomFace_EyeRotate");
		eyebrowSwitch.Init(this, CustomFacePartTypes.eyebrow, "UI_CustomFace_EyebrowType");
		eyebrowColorPicker.Init(this, "UI_CustomFace_EyebrowColor");
		eyebrowDistanceSlider.Init(0f, 90f, this, "UI_CustomFace_EyebrowSpace");
		eyebrowHeightSlider.Init(-0.3f, 0.3f, this, "UI_CustomFace_EyebrowHeight");
		eyebrowSizeSlider.Init(0.3f, 4f, this, "UI_CustomFace_EyebrowSize");
		eyebrowTwistSlider.Init(-90f, 90f, this, "UI_CustomFace_EyebrowRotate");
		mouthSwitch.Init(this, CustomFacePartTypes.mouth, "UI_CustomFace_MouthType");
		mouthColorPicker.Init(this, "UI_CustomFace_MouthColor");
		mouthSizeSlider.Init(0.3f, 4f, this, "UI_CustomFace_MouthSize");
		mouthHeightSlider.Init(-0.3f, 0.3f, this, "UI_CustomFace_MouthHeight");
		mouthLeftRightSlider.Init(-50f, 50f, this, "UI_CustomFace_MouthOffset");
		mouthTwistSlider.Init(-90f, 90f, this, "UI_CustomFace_MouthRotate");
		wingSwitch.Init(this, CustomFacePartTypes.wing, "UI_CustomFace_WingType");
		wingColorPicker.Init(this, "UI_CustomFace_WingColor");
		wingSizeSlider.Init(0.5f, 2f, this, "UI_CustomFace_WingSize");
		tailSwitch.Init(this, CustomFacePartTypes.tail, "UI_CustomFace_TailType");
		tailColorPicker.Init(this, "UI_CustomFace_TailColor");
		tailSizeSlider.Init(0.3f, 2f, this, "UI_CustomFace_TailSize");
		footSwitch.Init(this, CustomFacePartTypes.foot, "UI_CustomFace_FootType");
		footSizeSlider.Init(0.5f, 1.5f, this, "UI_CustomFace_FootSize");
		LoadValues();
		foreach (CustomFaceTabs tab in tabs)
		{
			tab.master = this;
		}
	}

	private void LoadValues()
	{
		skinColorPicker.SetColor(faceInstance.headSetting.mainColor);
		headSizeSlider.SetValue(1f + faceInstance.headSetting.headScaleOffset);
		headHeightSlider.SetValue(faceInstance.headSetting.foreheadHeight);
		headRoundnessSlider.SetValue(faceInstance.headSetting.foreheadRound);
		hairSwitch.SetName(faceInstance.hairPart.GetCurrentPartName());
		hairColorPicker.SetColor(faceInstance.hairPart.partInfo.color);
		eyeSwitch.SetName(faceInstance.eyePart.GetCurrentPartName());
		eyeColorPicker.SetColor(faceInstance.eyePart.partInfo.color);
		eyeDistanceSlider.SetValue(faceInstance.eyePart.partInfo.distanceAngle);
		eyeHeightSlider.SetValue(faceInstance.eyePart.partInfo.height);
		eyeSizeSlider.SetValue(faceInstance.eyePart.partInfo.scale);
		eyeTwistSlider.SetValue(faceInstance.eyePart.partInfo.twist);
		eyebrowSwitch.SetName(faceInstance.eyebrowPart.GetCurrentPartName());
		eyebrowColorPicker.SetColor(faceInstance.eyebrowPart.partInfo.color);
		eyebrowDistanceSlider.SetValue(faceInstance.eyebrowPart.partInfo.distanceAngle);
		eyebrowHeightSlider.SetValue(faceInstance.eyebrowPart.partInfo.height);
		eyebrowSizeSlider.SetValue(faceInstance.eyebrowPart.partInfo.scale);
		eyebrowTwistSlider.SetValue(faceInstance.eyebrowPart.partInfo.twist);
		mouthSwitch.SetName(faceInstance.mouthPart.GetCurrentPartName());
		mouthColorPicker.SetColor(faceInstance.mouthPart.partInfo.color);
		mouthSizeSlider.SetValue(faceInstance.mouthPart.partInfo.scale);
		mouthHeightSlider.SetValue(faceInstance.mouthPart.partInfo.height);
		mouthLeftRightSlider.SetValue(faceInstance.mouthPart.partInfo.leftRightAngle);
		mouthTwistSlider.SetValue(faceInstance.mouthPart.partInfo.twist);
		wingSwitch.SetName(faceInstance.wingLPart.GetCurrentPartName());
		wingColorPicker.SetColor(faceInstance.wingLPart.partInfo.color);
		wingSizeSlider.SetValue(faceInstance.wingLPart.partInfo.scale);
		tailSwitch.SetName(faceInstance.tailPart.GetCurrentPartName());
		tailColorPicker.SetColor(faceInstance.tailPart.partInfo.color);
		tailSizeSlider.SetValue(faceInstance.tailPart.partInfo.scale);
		footSwitch.SetName(faceInstance.footLPart.GetCurrentPartName());
		footSizeSlider.SetValue(faceInstance.footLPart.partInfo.scale);
	}

	public void SelectTab(CustomFaceTabs tab)
	{
		foreach (GameObject panel in panels)
		{
			panel.SetActive(tab.panels.Contains(panel));
		}
		foreach (CustomFaceTabs tab2 in tabs)
		{
			tab2.SetSelectVisual(tab == tab2);
		}
	}

	public void SetDirty()
	{
		dirty = true;
	}

	private void LateUpdate()
	{
		if (dirty && (bool)faceInstance)
		{
			RefreshInfos();
			dirty = false;
		}
	}

	public void RefreshInfos()
	{
		if (!(faceInstance == null))
		{
			faceInstance.headSetting.mainColor = skinColorPicker.CurrentColor;
			faceInstance.headSetting.headScaleOffset = headSizeSlider.Value - 1f;
			faceInstance.headSetting.foreheadHeight = headHeightSlider.Value;
			faceInstance.headSetting.foreheadRound = headRoundnessSlider.Value;
			faceInstance.hairPart.partInfo.color = hairColorPicker.CurrentColor;
			faceInstance.eyePart.partInfo.color = eyeColorPicker.CurrentColor;
			faceInstance.eyePart.partInfo.distanceAngle = eyeDistanceSlider.Value;
			faceInstance.eyePart.partInfo.height = eyeHeightSlider.Value;
			faceInstance.eyePart.partInfo.scale = eyeSizeSlider.Value;
			faceInstance.eyePart.partInfo.twist = eyeTwistSlider.Value;
			faceInstance.eyebrowPart.partInfo.color = eyebrowColorPicker.CurrentColor;
			faceInstance.eyebrowPart.partInfo.distanceAngle = eyebrowDistanceSlider.Value;
			faceInstance.eyebrowPart.partInfo.height = eyebrowHeightSlider.Value;
			faceInstance.eyebrowPart.partInfo.scale = eyebrowSizeSlider.Value;
			faceInstance.eyebrowPart.partInfo.twist = eyebrowTwistSlider.Value;
			faceInstance.mouthPart.partInfo.color = mouthColorPicker.CurrentColor;
			faceInstance.mouthPart.partInfo.scale = mouthSizeSlider.Value;
			faceInstance.mouthPart.partInfo.height = mouthHeightSlider.Value;
			faceInstance.mouthPart.partInfo.leftRightAngle = mouthLeftRightSlider.Value;
			faceInstance.mouthPart.partInfo.twist = mouthTwistSlider.Value;
			faceInstance.wingLPart.partInfo.color = wingColorPicker.CurrentColor;
			faceInstance.wingRPart.partInfo.color = wingColorPicker.CurrentColor;
			faceInstance.wingLPart.partInfo.scale = wingSizeSlider.Value;
			faceInstance.wingRPart.partInfo.scale = wingSizeSlider.Value;
			faceInstance.tailPart.partInfo.color = tailColorPicker.CurrentColor;
			faceInstance.tailPart.partInfo.scale = tailSizeSlider.Value;
			faceInstance.footLPart.partInfo.scale = footSizeSlider.Value;
			faceInstance.footRPart.partInfo.scale = footSizeSlider.Value;
			faceInstance.RefreshAll();
		}
	}

	public string SwitchPart(CustomFacePartTypes type, int direction)
	{
		if (faceInstance == null)
		{
			return "";
		}
		CustomFacePart customFacePart = faceInstance.SwitchPart(type, faceInstance, direction);
		if (customFacePart == null)
		{
			return "";
		}
		return customFacePart.id.ToString();
	}

	public void SaveToMainCharacter()
	{
		if ((bool)faceInstance && canControl)
		{
			CustomFaceSettingData setting = faceInstance.ConvertToSaveData();
			LevelManager.Instance.CustomFaceManager.SaveSettingToMainCharacter(setting);
		}
	}

	public void OnDrag(PointerEventData eventData)
	{
		if (!(faceInstance == null) && eventData.button == PointerEventData.InputButton.Left)
		{
			float angle = (0f - eventData.delta.x) * rotateSpeed * Time.deltaTime;
			faceInstance.transform.Rotate(Vector3.up, angle);
		}
	}

	public void RandomPreset()
	{
		faceInstance.LoadFromData(presets.GetRandom().settings);
	}
}
public class CustomFaceUIColorPicker : MonoBehaviour
{
	public CustomFaceUI master;

	public CustomFaceUIColorPickerButton singleButton;

	public Transform buttonParent;

	public TextLocalizor titleText;

	public GimpPalette gimpPalette;

	public UnityEngine.UI.Image colorDisplay;

	public UnityEngine.UI.Button pickerToggleBtn;

	private List<CustomFaceUIColorPickerButton> buttons;

	private bool created;

	private Color currentColor;

	public IEnumerable<Color> colors
	{
		get
		{
			GimpPalette.Entry[] entries = gimpPalette.entries;
			for (int i = 0; i < entries.Length; i++)
			{
				GimpPalette.Entry entry = entries[i];
				yield return entry.color;
			}
		}
	}

	public Color CurrentColor => currentColor;

	public event Action<Color> OnSetColor;

	private void Awake()
	{
		pickerToggleBtn.onClick.AddListener(OnPickToggleBtnClicked);
	}

	private void OnPickToggleBtnClicked()
	{
		buttonParent.gameObject.SetActive(!buttonParent.gameObject.activeSelf);
	}

	public void Init(CustomFaceUI _master, string titleKey)
	{
		master = _master;
		titleText.Key = titleKey;
		if (buttons == null)
		{
			buttons = new List<CustomFaceUIColorPickerButton>();
		}
		if (!created)
		{
			foreach (Color color2 in colors)
			{
				Color color = new Color(color2.r, color2.g, color2.b, 1f);
				CustomFaceUIColorPickerButton customFaceUIColorPickerButton = UnityEngine.Object.Instantiate(singleButton, buttonParent);
				customFaceUIColorPickerButton.Init(this, color);
				customFaceUIColorPickerButton.transform.SetParent(buttonParent);
				buttons.Add(customFaceUIColorPickerButton);
			}
			singleButton.gameObject.SetActive(value: false);
			created = true;
		}
		UpdateSelection();
		buttonParent.gameObject.SetActive(value: false);
	}

	private void UpdateSelection()
	{
		if (buttons == null || buttons.Count < 1)
		{
			return;
		}
		foreach (CustomFaceUIColorPickerButton button in buttons)
		{
			button.SetSelection(button.Color.CompareRGB(currentColor));
		}
	}

	public void SetColor(Color _color)
	{
		currentColor = _color;
		master.SetDirty();
		UpdateSelection();
		currentColor.a = 1f;
		colorDisplay.color = currentColor;
		buttonParent.gameObject.SetActive(value: false);
	}
}
public class CustomFaceUIColorPickerButton : MonoBehaviour
{
	private CustomFaceUIColorPicker master;

	private Color color;

	public UnityEngine.UI.Button button;

	public UnityEngine.UI.Image selectedFrameImage;

	public Color Color => color;

	public void Init(CustomFaceUIColorPicker _master, Color _color)
	{
		master = _master;
		color = _color;
		ColorBlock colors = button.colors;
		colors.normalColor = color;
		colors.highlightedColor = color;
		colors.selectedColor = color;
		button.colors = colors;
	}

	private void Awake()
	{
		button.onClick.AddListener(OnClick);
	}

	private void OnClick()
	{
		master.SetColor(color);
	}

	public void SetSelection(bool selected)
	{
		selectedFrameImage.gameObject.SetActive(selected);
	}
}
public class CustomFaceUIPart : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class CustomFaceUISwitch : MonoBehaviour
{
	public TextLocalizor titleText;

	public TextMeshProUGUI nameText;

	public UnityEngine.UI.Button leftButton;

	public UnityEngine.UI.Button rightButton;

	public CustomFaceUI master;

	public CustomFacePartTypes type;

	private void Awake()
	{
		leftButton.onClick.AddListener(OnLeftClick);
		rightButton.onClick.AddListener(OnRightClick);
	}

	public void Init(CustomFaceUI _master, CustomFacePartTypes partType, string title)
	{
		master = _master;
		type = partType;
		titleText.Key = title;
	}

	private void OnLeftClick()
	{
		Switch(-1);
	}

	private void OnRightClick()
	{
		Switch(1);
	}

	public void SetName(string name)
	{
		nameText.text = name;
	}

	private void Switch(int direction)
	{
		string text = master.SwitchPart(type, direction);
		nameText.text = text;
	}
}
public class Interact_CustomFace : InteractableBase
{
	public GameObject activePart;

	public CustomFaceUI customFaceUI;

	public CanvasGroupFade fade;

	public CustomFaceInstance customFaceInstance;

	public UnityEvent OnCustomFaceUiClosedEvent;

	[LocalizationKey("UIText")]
	public string OnCopyNotificationKey;

	[LocalizationKey("UIText")]
	public string OnPastySuccessNotificationKey;

	[LocalizationKey("UIText")]
	public string OnPastyFailedNotificationKey;

	public static event Action OnCustomFaceStartEvent;

	public static event Action OnCustomFaceFinishedEvent;

	protected override void Awake()
	{
		base.Awake();
		activePart.SetActive(value: false);
		customFaceUI.SetFace(customFaceInstance);
		fade.gameObject.SetActive(value: false);
	}

	protected override void OnInteractStart(CharacterMainControl interactCharacter)
	{
		Show().Forget();
	}

	protected override void OnInteractStop()
	{
		UnityEngine.Debug.Log("Stop custom face");
		Hide().Forget();
	}

	private async UniTaskVoid Show()
	{
		await BlackScreen.ShowAndReturnTask(null, 1f, 0.25f);
		if (!base.Interacting)
		{
			BlackScreen.HideAndReturnTask(null, 0f, 0.25f).Forget();
			return;
		}
		Interact_CustomFace.OnCustomFaceStartEvent?.Invoke();
		activePart.SetActive(value: true);
		InputManager.DisableInput(activePart);
		fade.Show().Forget();
		customFaceUI.canControl = true;
		customFaceInstance.LoadFromData(LevelManager.Instance.CustomFaceManager.LoadMainCharacterSetting());
		CharacterMainControl.Main.characterModel.gameObject.SetActive(value: false);
		LevelManager.Instance.PetCharacter.characterModel.gameObject.SetActive(value: false);
		await UniTask.WaitForSeconds(0.5f, ignoreTimeScale: true);
		await BlackScreen.HideAndReturnTask(null, 0f, 0.25f);
	}

	private async UniTaskVoid Hide()
	{
		Interact_CustomFace.OnCustomFaceFinishedEvent?.Invoke();
		await BlackScreen.ShowAndReturnTask(null, 0f, 0.25f);
		activePart.SetActive(value: false);
		InputManager.ActiveInput(activePart);
		customFaceUI.canControl = false;
		fade.Hide().Forget();
		CharacterMainControl.Main.characterModel.gameObject.SetActive(value: true);
		LevelManager.Instance.PetCharacter.characterModel.gameObject.SetActive(value: true);
		LevelManager.Instance.RefreshMainCharacterFace();
		CharacterMainControl.Main.SetAimPoint(customFaceInstance.transform.position + customFaceInstance.transform.forward * 100f);
		await UniTask.WaitForSeconds(0.5f, ignoreTimeScale: true);
		OnCustomFaceUiClosedEvent?.Invoke();
		await BlackScreen.HideAndReturnTask(null, 1f, 0.25f);
	}

	public void CopyToClipboard()
	{
		GUIUtility.systemCopyBuffer = customFaceInstance.ConvertToSaveData().DataToJson();
		NotificationText.Push(OnCopyNotificationKey.ToPlainText());
	}

	public void PastyDataAndApply()
	{
		if (CustomFaceSettingData.JsonToData(GUIUtility.systemCopyBuffer, out var data))
		{
			customFaceInstance.LoadFromData(data);
			NotificationText.Push(OnPastySuccessNotificationKey.ToPlainText());
		}
		else
		{
			NotificationText.Push(OnPastyFailedNotificationKey.ToPlainText());
		}
	}
}
public class AccessoryBase : MonoBehaviour
{
	public string socketName;

	protected Item selfItem;

	protected DuckovItemAgent parentAgent;

	public void Init(DuckovItemAgent _parentAgent, Item _selfItem)
	{
		if (_parentAgent == null || _selfItem == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		parentAgent = _parentAgent;
		selfItem = _selfItem;
		Transform socket = parentAgent.GetSocket(socketName, createNew: true);
		base.transform.SetParent(socket);
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = Quaternion.identity;
		OnInit();
	}

	protected virtual void OnInit()
	{
	}
}
public class Accessory_Lazer : AccessoryBase
{
	[SerializeField]
	private LineRenderer lineRenderer;

	[SerializeField]
	private GameObject hitMarker;

	private CharacterMainControl character;

	private Vector3[] localPoints;

	private RaycastHit[] raycastHits = new RaycastHit[4];

	private LayerMask hitLayers;

	protected override void OnInit()
	{
		hitLayers = (int)GameplayDataSettings.Layers.damageReceiverLayerMask | (int)GameplayDataSettings.Layers.wallLayerMask | (int)GameplayDataSettings.Layers.groundLayerMask | (int)GameplayDataSettings.Layers.fowBlockLayers | (int)GameplayDataSettings.Layers.halfObsticleLayer;
		HideHitMarker();
		lineRenderer.enabled = false;
	}

	private void Update()
	{
		if (character == null)
		{
			if (parentAgent == null || parentAgent.Holder == null)
			{
				return;
			}
			character = parentAgent.Holder;
		}
		bool flag = character.IsAiming();
		if (flag != lineRenderer.enabled)
		{
			lineRenderer.enabled = flag;
		}
		if (flag)
		{
			if (localPoints == null)
			{
				localPoints = new Vector3[2];
				lineRenderer.useWorldSpace = false;
				localPoints[0] = Vector3.zero;
			}
			Vector3 position = lineRenderer.transform.position;
			Vector3 currentAimPoint = character.GetCurrentAimPoint();
			Vector3 zero = Vector3.zero;
			zero = ((!(Vector3.Distance(character.transform.position, currentAimPoint) > 2f) || !character.IsMainCharacter) ? (lineRenderer.transform.position + character.CurrentAimDirection.normalized * character.GetAimRange()) : (lineRenderer.transform.position + (character.GetCurrentAimPoint() - lineRenderer.transform.position).normalized * character.GetAimRange()));
			if (CheckObsticle(position, zero, out var hitPoint))
			{
				ShowHitMarker(hitPoint);
				zero = hitPoint;
			}
			else
			{
				HideHitMarker();
			}
			localPoints[1] = lineRenderer.transform.InverseTransformPoint(zero);
			lineRenderer.SetPositions(localPoints);
		}
		else
		{
			HideHitMarker();
		}
	}

	private void ShowHitMarker(Vector3 point)
	{
		if (!hitMarker.activeSelf)
		{
			hitMarker.SetActive(value: true);
		}
		hitMarker.transform.position = point;
	}

	private void HideHitMarker()
	{
		if (hitMarker.activeSelf)
		{
			hitMarker.SetActive(value: false);
		}
	}

	private bool CheckObsticle(Vector3 startPoint, Vector3 endPoint, out Vector3 hitPoint)
	{
		bool flag = character.HasNearByHalfObsticle();
		Vector3 vector = endPoint - startPoint;
		float magnitude = vector.magnitude;
		vector.Normalize();
		int num = Physics.SphereCastNonAlloc(startPoint, 0.15f, vector, raycastHits, magnitude, hitLayers, QueryTriggerInteraction.Ignore);
		if (num > 0)
		{
			_ = Vector3.zero;
			float num2 = float.MaxValue;
			bool flag2 = false;
			for (int i = 0; i < num; i++)
			{
				RaycastHit raycastHit = raycastHits[i];
				DamageReceiver component = raycastHit.collider.GetComponent<DamageReceiver>();
				if (flag && (GameplayDataSettings.LayersData.IsLayerInLayerMask(raycastHit.collider.gameObject.layer, GameplayDataSettings.Layers.halfObsticleLayer) || ((bool)component && component.isHalfObsticle)))
				{
					continue;
				}
				if ((bool)component && (bool)component.health)
				{
					CharacterMainControl characterMainControl = component.health.TryGetCharacter();
					if (characterMainControl != null && (bool)characterMainControl.characterModel && characterMainControl.characterModel.invisable)
					{
						continue;
					}
				}
				if (!(raycastHit.collider.gameObject == character.mainDamageReceiver.gameObject) && raycastHit.distance != 0f)
				{
					flag2 = true;
					if (raycastHit.distance < num2)
					{
						_ = raycastHit.point;
						num2 = raycastHit.distance;
					}
				}
			}
			if (flag2)
			{
				hitPoint = startPoint + vector * num2;
				return true;
			}
		}
		hitPoint = Vector3.zero;
		return false;
	}
}
public class AT_InteractWithMainCharacter : ActionTask
{
	public InteractableBase interactable;

	protected override void OnExecute()
	{
		base.OnExecute();
		interactable.InteractWithMainCharacter();
		EndAction();
	}
}
public class GetCurrentPosition : ActionTask<Transform>
{
	public BBParameter<Vector3> positionResult;

	protected override void OnExecute()
	{
		if (base.agent != null)
		{
			positionResult.value = base.agent.position;
		}
		EndAction(success: true);
	}
}
public class AICharacterController : MonoBehaviour
{
	public DamageReceiver searchedEnemy;

	public InteractablePickup searchedPickup;

	private DamageReceiver cachedSearchedEnemy;

	private CharacterMainControl characterMainControl;

	[SerializeField]
	private AI_PathControl pathControl;

	public CharacterSpawnerGroup group;

	public CharacterMainControl leader;

	public AICharacterController leaderAI;

	public bool shootCanMove;

	public bool defaultWeaponOut;

	private float updateValueTimer = 1f;

	public float patrolTurnSpeed = 200f;

	public float combatTurnSpeed = 1000f;

	private Stat rotateSpeedStat;

	public bool hasSkill;

	public SkillBase skillPfb;

	public SkillBase skillInstance;

	public Vector2 skillCoolTimeRange;

	[Range(0.01f, 1f)]
	public float skillSuccessChance = 1f;

	public float nextReleaseSkillTimeMarker = -1f;

	private float noticeTimeMarker;

	public bool noticed;

	public float sightDistance = 20f;

	public float forceTracePlayerDistance;

	public float sightAngle = 100f;

	public float baseReactionTime = 0.2f;

	public float nightReactionTimeFactor = 1.5f;

	public float reactionTime = 0.2f;

	public float shootDelay = 0.2f;

	public float scatterMultiIfTargetRunning = 4f;

	public float scatterMultiIfOffScreen = 4f;

	public Vector2 shootTimeRange = Vector2.one;

	public Vector2 shootTimeSpaceRange = Vector2.one;

	public Vector2 combatMoveTimeRange = new Vector2(1f, 3f);

	public bool canDash;

	public Vector2 dashCoolTimeRange;

	private Vector3 noticeFromPos;

	[ItemTypeID]
	public int wantItem;

	private Vector3 noticeFromDirection;

	private float combatWithTargetTimer;

	private bool weaponOut;

	private CharacterMainControl noticeFromCharacter;

	public float hearingAbility = 1f;

	public float traceTargetChance = 1f;

	public Transform aimTarget;

	private bool aimingRuningMainCharacter;

	public float patrolRange;

	public Vector3 patrolPosition;

	public float combatMoveRange;

	public float forgetTime = 8f;

	public bool canTalk = true;

	public bool alert;

	public BehaviourTree patrolTree;

	public BehaviourTree alertTree;

	public BehaviourTree combatTree;

	public BehaviourTree combat_Attack_Tree;

	[HideInInspector]
	public float hurtTimeMarker;

	[HideInInspector]
	public DamageInfo lastDamageInfo;

	public bool hasObsticleToTarget;

	public GameObject hideIfFoundEnemy;

	private Modifier scatterMultiplierModifier;

	private Stat scatterMultiplierStat;

	private float scatterModifierMultiplier = 1f;

	public float itemSkillChance = 0.3f;

	public float itemSkillCoolTime = 6f;

	private GameCamera gameCamera;

	public GameObject foundDangerObject;

	private List<ItemSetting_Skill> skillsOnItem = new List<ItemSetting_Skill>();

	private List<Item> drugItems = new List<Item>();

	public CharacterMainControl CharacterMainControl => characterMainControl;

	public Vector3 NoticeFromPos => noticeFromPos;

	public Vector3 NoticeFromDirection => noticeFromDirection;

	public CharacterMainControl NoticeFromCharacter
	{
		get
		{
			if (!noticed)
			{
				return null;
			}
			return noticeFromCharacter;
		}
	}

	public void Init(CharacterMainControl _characterMainControl, Vector3 patrolCenter, AudioManager.VoiceType voiceType = AudioManager.VoiceType.Duck, AudioManager.FootStepMaterialType footStepMatType = AudioManager.FootStepMaterialType.organic)
	{
		patrolPosition = patrolCenter;
		characterMainControl = _characterMainControl;
		pathControl.controller = characterMainControl;
		base.transform.SetParent(characterMainControl.transform, worldPositionStays: false);
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = Quaternion.identity;
		characterMainControl.Health.OnHurtEvent.AddListener(OnHurt);
		if ((bool)_characterMainControl)
		{
			_characterMainControl.AudioVoiceType = voiceType;
			_characterMainControl.FootStepMaterialType = footStepMatType;
		}
		scatterMultiplierStat = _characterMainControl.CharacterItem.GetStat("GunScatterMultiplier");
		rotateSpeedStat = characterMainControl.CharacterItem.GetStat("TurnSpeed");
		scatterMultiplierModifier = new Modifier(ModifierType.PercentageMultiply, scatterModifierMultiplier, this);
		scatterMultiplierStat.AddModifier(scatterMultiplierModifier);
		if (hasSkill && !skillInstance && (bool)skillPfb)
		{
			skillInstance = UnityEngine.Object.Instantiate(skillPfb, base.transform);
			skillInstance.transform.localPosition = Vector3.zero;
			characterMainControl.SetSkill(SkillTypes.characterSkill, skillInstance, skillInstance.gameObject);
		}
	}

	public float NightReactionTimeMultiplier()
	{
		return 1f;
	}

	public void AddItemSkill(ItemSetting_Skill skill)
	{
		skillsOnItem.Add(skill);
	}

	public ItemSetting_Skill GetItemSkill(bool random)
	{
		if (skillsOnItem.Count > 0 && random)
		{
			int index = UnityEngine.Random.Range(0, skillsOnItem.Count);
			ItemSetting_Skill itemSetting_Skill = skillsOnItem[index];
			if ((bool)itemSetting_Skill)
			{
				return itemSetting_Skill;
			}
			skillsOnItem.RemoveAt(index);
		}
		if (skillsOnItem.Count > 0)
		{
			int num = 0;
			if (num < skillsOnItem.Count)
			{
				ItemSetting_Skill itemSetting_Skill2 = skillsOnItem[num];
				if (itemSetting_Skill2 == null || itemSetting_Skill2.Item == null)
				{
					skillsOnItem.RemoveAt(num);
					num--;
				}
				return itemSetting_Skill2;
			}
		}
		return null;
	}

	public void CheckAndAddDrugItem(Item targetItem)
	{
		if ((bool)targetItem.GetComponent<Drug>())
		{
			drugItems.Add(targetItem);
		}
	}

	public Item GetDrugItem()
	{
		if (drugItems.Count > 0)
		{
			int num = 0;
			if (num < drugItems.Count)
			{
				Item item = drugItems[num];
				if (item == null)
				{
					drugItems.RemoveAt(num);
					num--;
				}
				return item;
			}
		}
		return null;
	}

	private void Update()
	{
		if (!LevelManager.LevelInited)
		{
			return;
		}
		bool flag = searchedEnemy != null;
		if ((bool)aimTarget)
		{
			characterMainControl.SetAimPoint(aimTarget.transform.position + Vector3.up * 0.5f);
		}
		if (!gameCamera)
		{
			gameCamera = GameCamera.Instance;
		}
		updateValueTimer -= Time.deltaTime;
		if (updateValueTimer <= 0f)
		{
			updateValueTimer = 1f;
			bool isInDoor = MultiSceneCore.Instance.GetSubSceneInfo().IsInDoor;
			if (TimeOfDayController.Instance.AtNight && !isInDoor)
			{
				reactionTime = baseReactionTime * nightReactionTimeFactor;
			}
			else
			{
				reactionTime = baseReactionTime;
			}
			if (rotateSpeedStat != null)
			{
				if (flag)
				{
					rotateSpeedStat.BaseValue = combatTurnSpeed;
				}
				else
				{
					rotateSpeedStat.BaseValue = patrolTurnSpeed;
				}
			}
		}
		float num = 1f;
		if ((bool)aimTarget && (bool)CharacterMainControl.Main && aimTarget.gameObject == CharacterMainControl.Main.mainDamageReceiver.gameObject)
		{
			if (CharacterMainControl.Main.Running)
			{
				num = scatterMultiIfTargetRunning;
			}
			if ((bool)characterMainControl && (bool)gameCamera && gameCamera.IsOffScreen(characterMainControl.transform.position))
			{
				num = Mathf.Max(num, scatterMultiIfOffScreen);
			}
		}
		if (num != scatterModifierMultiplier)
		{
			scatterModifierMultiplier = num;
			scatterMultiplierModifier.Value = num;
		}
		if (group != null && group.hasLeader)
		{
			leaderAI = group.LeaderAI;
			if ((bool)leaderAI)
			{
				leader = leaderAI.characterMainControl;
			}
		}
		if (leader != null)
		{
			patrolPosition = leader.transform.position;
			UnityEngine.Debug.DrawLine(base.transform.position, patrolPosition + Vector3.up * 2f, Color.magenta);
		}
		if (forceTracePlayerDistance > 0.5f && CharacterMainControl.Main != null && Vector3.Distance(base.transform.position, CharacterMainControl.Main.transform.position) < forceTracePlayerDistance)
		{
			searchedEnemy = CharacterMainControl.Main.mainDamageReceiver;
		}
		if ((bool)leaderAI)
		{
			if ((bool)leaderAI.searchedEnemy && !flag)
			{
				searchedEnemy = leaderAI.searchedEnemy;
				flag = true;
			}
			else if (!leaderAI.searchedEnemy && (bool)searchedEnemy)
			{
				leaderAI.searchedEnemy = searchedEnemy;
			}
		}
		if (flag && characterMainControl != null && searchedEnemy.Team == characterMainControl.Team)
		{
			searchedEnemy = null;
			flag = false;
		}
		if (searchedEnemy != cachedSearchedEnemy)
		{
			combatWithTargetTimer = 0f;
			cachedSearchedEnemy = searchedEnemy;
		}
		else
		{
			combatWithTargetTimer += Time.deltaTime;
		}
		if ((defaultWeaponOut || flag) && !weaponOut)
		{
			TakeOutWeapon();
		}
		if (hideIfFoundEnemy != null && !flag != hideIfFoundEnemy.activeSelf)
		{
			hideIfFoundEnemy.SetActive(!flag);
		}
	}

	public void SetNoticedToTarget(DamageReceiver target)
	{
		if ((bool)target)
		{
			noticeFromCharacter = target.health.TryGetCharacter();
			noticeTimeMarker = Time.time;
			noticeFromDirection = (target.transform.position - base.transform.position).normalized;
			noticeFromPos = target.transform.position;
		}
	}

	private void OnEnable()
	{
		AIMainBrain.OnSoundSpawned += OnSound;
	}

	private void OnDisable()
	{
		AIMainBrain.OnSoundSpawned -= OnSound;
	}

	private void OnDestroy()
	{
		AIMainBrain.OnSoundSpawned -= OnSound;
		if ((bool)characterMainControl)
		{
			characterMainControl.Health.OnHurtEvent.RemoveListener(OnHurt);
		}
		if (scatterMultiplierStat != null)
		{
			scatterMultiplierStat.RemoveAllModifiersFromSource(this);
		}
	}

	private void OnSound(AISound sound)
	{
		switch (sound.soundType)
		{
		case SoundTypes.unknowNoise:
			if (sound.fromTeam == characterMainControl.Team)
			{
				return;
			}
			break;
		case SoundTypes.combatSound:
			if (sound.fromTeam == characterMainControl.Team)
			{
				return;
			}
			break;
		case SoundTypes.grenadeDropSound:
			if ((bool)sound.fromObject)
			{
				foundDangerObject = sound.fromObject;
			}
			break;
		}
		Vector3 pos = sound.pos;
		pos.y = 0f;
		Vector3 position = base.transform.position;
		position.y = 0f;
		if (Vector3.Distance(position, pos) < sound.radius * hearingAbility)
		{
			noticed = true;
			noticeFromCharacter = sound.fromCharacter;
			noticeTimeMarker = Time.time;
			noticeFromDirection = (pos - position).normalized;
			noticeFromPos = sound.pos;
		}
	}

	private void OnHurt(DamageInfo dmgInfo)
	{
		if (!dmgInfo.isFromBuffOrEffect)
		{
			noticed = true;
			lastDamageInfo = dmgInfo;
			noticeFromCharacter = dmgInfo.fromCharacter;
			noticeTimeMarker = Time.time;
			hurtTimeMarker = Time.time;
			noticeFromDirection = dmgInfo.damageNormal;
			if ((bool)noticeFromCharacter)
			{
				noticeFromPos = noticeFromCharacter.transform.position;
			}
			else
			{
				noticeFromPos = base.transform.position + noticeFromDirection * 3f;
			}
		}
	}

	public bool IsHurt(float timeThreshold, int damageThreshold, ref DamageInfo dmgInfo)
	{
		dmgInfo = lastDamageInfo;
		if (Time.time - hurtTimeMarker < timeThreshold)
		{
			return lastDamageInfo.finalDamage >= (float)damageThreshold;
		}
		return false;
	}

	public bool isNoticing(float timeThreshold)
	{
		if (!noticed)
		{
			return false;
		}
		return Time.time - noticeTimeMarker < timeThreshold;
	}

	public void MoveToPos(Vector3 pos)
	{
		if ((bool)pathControl && (bool)pathControl.controller)
		{
			pathControl.MoveToPos(pos);
		}
	}

	public bool HasPath()
	{
		return pathControl.path != null;
	}

	public bool WaitingForPathResult()
	{
		return pathControl.WaitingForPathResult;
	}

	public void StopMove()
	{
		pathControl.StopMove();
	}

	public bool IsMoving()
	{
		return pathControl.Moving;
	}

	public bool ReachedEndOfPath()
	{
		return pathControl.ReachedEndOfPath;
	}

	public void SetTarget(Transform _aimTarget)
	{
		aimTarget = _aimTarget;
	}

	public void SetAimInput(Vector3 aimInput, AimTypes aimType)
	{
		characterMainControl.SetAimPoint(characterMainControl.transform.position + aimInput * 1000f);
		characterMainControl.SetAimType(aimType);
	}

	public void PutBackWeapon()
	{
		if (!(characterMainControl.CurrentHoldItemAgent == null))
		{
			characterMainControl.agentHolder.ChangeHoldItem(null);
			weaponOut = false;
		}
	}

	public void TakeOutWeapon()
	{
		bool flag = characterMainControl.SwitchToFirstAvailableWeapon();
		weaponOut = flag;
	}
}
public class PetAI : MonoBehaviour
{
	[HideInInspector]
	public CharacterMainControl master;

	public AICharacterController selfAiCharacterController;

	public bool setMainCharacterAsMaster;

	public bool standBy;

	public Vector3 standByPos = Vector3.zero;

	private bool statInited;

	private Stat walkSpeedStat;

	private Stat runSpeedStat;

	private CharacterMainControl selfCharacter;

	private float distanceToMaster;

	private void Start()
	{
		if (setMainCharacterAsMaster)
		{
			SetMaster(CharacterMainControl.Main);
		}
	}

	public void SetMaster(CharacterMainControl _master)
	{
		if ((bool)_master)
		{
			master = _master;
			_master.OnSetPositionEvent -= OnMainCharacterSetPosition;
			_master.OnSetPositionEvent += OnMainCharacterSetPosition;
		}
	}

	private void SyncSpeed()
	{
		if ((bool)master)
		{
			if (distanceToMaster > 10f)
			{
				walkSpeedStat.BaseValue = master.CharacterWalkSpeed + 2f;
				runSpeedStat.BaseValue = master.CharacterRunSpeed + 2f;
			}
			else if (distanceToMaster < 8f)
			{
				walkSpeedStat.BaseValue = master.CharacterWalkSpeed;
				runSpeedStat.BaseValue = master.CharacterRunSpeed;
			}
		}
	}

	private void InitStats()
	{
		if ((bool)selfCharacter)
		{
			Item characterItem = selfCharacter.CharacterItem;
			if ((bool)characterItem)
			{
				statInited = true;
				walkSpeedStat = characterItem.Stats["WalkSpeed"];
				runSpeedStat = characterItem.Stats["RunSpeed"];
			}
		}
	}

	private void OnDestroy()
	{
		if (master != null)
		{
			master.OnSetPositionEvent -= OnMainCharacterSetPosition;
		}
	}

	private void Awake()
	{
	}

	private void Update()
	{
		if (!selfCharacter && (bool)selfAiCharacterController)
		{
			selfCharacter = selfAiCharacterController.CharacterMainControl;
		}
		if (master != null)
		{
			if (!statInited)
			{
				InitStats();
			}
			distanceToMaster = Vector3.Distance(base.transform.position, master.transform.position);
			SyncSpeed();
			if (!standBy && distanceToMaster > 40f)
			{
				SetPosition(master.transform.position + Vector3.forward * 0.4f + Vector3.up * 0.5f);
			}
		}
	}

	private void OnMainCharacterSetPosition(CharacterMainControl character, Vector3 targetPos)
	{
		if ((bool)master && master.IsMainCharacter && !LevelManager.Instance.IsBaseLevel)
		{
			SetPosition(targetPos + Vector3.forward * 0.4f + Vector3.up * 0.5f);
		}
	}

	private void SetPosition(Vector3 targetPos)
	{
		selfAiCharacterController.CharacterMainControl.SetPosition(targetPos);
	}

	public void SetStandBy(bool _standBy, Vector3 pos)
	{
		standBy = _standBy;
		standByPos = pos;
	}
}
public class AudioEventProxy : MonoBehaviour
{
	public bool playOnAwake;

	[SerializeField]
	private string eventName;

	private void Awake()
	{
		if (playOnAwake)
		{
			Post();
		}
	}

	public void Post()
	{
		if (base.gameObject.activeInHierarchy)
		{
			AudioManager.Post(eventName, base.gameObject);
		}
	}
}
public class BaseBGMSelector : MonoBehaviour
{
	[Serializable]
	public struct Entry
	{
		public string switchName;

		public string musicName;

		public string author;
	}

	[SerializeField]
	private string switchGroupName = "BGM";

	[SerializeField]
	private DialogueBubbleProxy proxy;

	public Entry[] entries;

	private int index;

	private const string savekey = "BaseBGMSelector";

	private bool waitForStinger;

	[LocalizationKey("Default")]
	private string BGMInfoFormatKey
	{
		get
		{
			return "BGMInfoFormat";
		}
		set
		{
		}
	}

	private string BGMInfoFormat => BGMInfoFormatKey.ToPlainText();

	private void Awake()
	{
		SavesSystem.OnCollectSaveData += Save;
		Load();
		waitForStinger = true;
	}

	private void OnDestroy()
	{
		SavesSystem.OnCollectSaveData -= Save;
	}

	private void Update()
	{
		if (waitForStinger && LevelManager.AfterInit && !AudioManager.IsStingerPlaying)
		{
			waitForStinger = false;
			Set(index);
		}
	}

	private void Load(bool play = false)
	{
		index = SavesSystem.Load<int>("BaseBGMSelector");
		Set(index, showInfo: false, play);
	}

	private void Save()
	{
		SavesSystem.Save("BaseBGMSelector", index);
	}

	public void Set(int index, bool showInfo = false, bool play = true)
	{
		waitForStinger = false;
		if (index < 0 || index >= entries.Length)
		{
			int num = index;
			index = Mathf.Clamp(index, 0, entries.Length - 1);
			UnityEngine.Debug.LogError($"Index {num} Out Of Range,clampped to {index}");
		}
		Entry entry = entries[index];
		AudioManager.StopBGM();
		if (play)
		{
			AudioManager.PlayBGM(entry.switchName);
		}
		if (showInfo)
		{
			string text = BGMInfoFormat.Format(new
			{
				name = entry.musicName,
				author = entry.author,
				index = index + 1
			});
			proxy.Pop(text, 200f);
		}
	}

	public void Set(string switchName)
	{
		int num = GetIndex(switchName);
		if (num >= 0)
		{
			Set(num);
		}
	}

	public int GetIndex(string switchName)
	{
		for (int i = 0; i < entries.Length; i++)
		{
			if (entries[i].switchName == switchName)
			{
				return i;
			}
		}
		return -1;
	}

	public void SetNext()
	{
		index++;
		if (index >= entries.Length)
		{
			index = 0;
		}
		Set(index, showInfo: true);
	}

	public void SetPrevious()
	{
		index--;
		if (index < 0)
		{
			index = entries.Length - 1;
		}
		Set(index, showInfo: true);
	}
}
public class LoopSoundWithObject : MonoBehaviour
{
	public string sfx;

	private FMOD.Studio.EventInstance? eventInstance;

	private bool stoped = true;

	private void Start()
	{
		eventInstance = AudioManager.Post(sfx, base.gameObject);
		stoped = false;
	}

	public void Stop()
	{
		if (!stoped)
		{
			stoped = true;
			if (eventInstance.HasValue)
			{
				eventInstance.Value.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
			}
		}
	}

	private void OnDestroy()
	{
		Stop();
	}

	private void OnDisable()
	{
		Stop();
	}
}
public class PlayEventOnAwake : MonoBehaviour
{
	[SerializeField]
	private string sfx;

	private void Awake()
	{
		AudioManager.Post(sfx, base.gameObject);
	}
}
public class PlayHurtEventProxy : MonoBehaviour
{
	[SerializeField]
	private string critSfx;

	[SerializeField]
	private string nonCritSfx;

	public void Play(bool crit)
	{
		if (crit)
		{
			AudioManager.Post(critSfx, base.gameObject);
		}
		else
		{
			AudioManager.Post(nonCritSfx, base.gameObject);
		}
	}
}
public class SfxOnClick : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private string sfx;

	public void OnPointerClick(PointerEventData eventData)
	{
		AudioManager.Post(sfx);
	}
}
public class CameraArm : MonoBehaviour
{
	public bool volumeInfluence;

	public float pitch;

	public float yaw;

	public float distance;

	public static float globalPitch = 55f;

	public static float globalYaw = -30f;

	public static float globalDistance = -45f;

	public Transform pitchRoot;

	public Transform yawRoot;

	public CinemachineVirtualCamera virtualCamera;

	public GameCamera gameCamera;

	private static bool topDownView = false;

	public Volume topDownViewVolume;

	private void Update()
	{
		if (volumeInfluence)
		{
			pitch = Mathf.Lerp(pitch, globalPitch, 5f * Time.deltaTime);
			yaw = Mathf.Lerp(yaw, globalYaw, 2f * Time.deltaTime);
			distance = Mathf.Lerp(distance, globalDistance, 2f * Time.deltaTime);
		}
		UpdateArm();
		if (topDownView != topDownViewVolume.enabled)
		{
			topDownViewVolume.enabled = topDownView;
		}
	}

	public static void ToggleView()
	{
		topDownView = !topDownView;
	}

	private void UpdateArm()
	{
		pitchRoot.transform.localRotation = Quaternion.Euler(pitch, yaw, 0f);
		virtualCamera.transform.localPosition = new Vector3(0f, 0f, 0f - distance);
		virtualCamera.transform.localRotation = Quaternion.identity;
	}

	private void OnValidate()
	{
		UpdateArm();
	}
}
public class GameCamera : MonoBehaviour
{
	public enum CameraAimingTypes
	{
		normal,
		bounds
	}

	public Camera renderCamera;

	public CinemachineVirtualCamera mainVCam;

	public CameraArm mianCameraArm;

	public CharacterMainControl target;

	public CinemachineBrain brain;

	public float defaultFOV = 20f;

	public float adsFOV = 15f;

	public Transform mainCamDepthPoint;

	private float currentFov;

	public static Action<GameCamera, CharacterMainControl> OnCameraPosUpdate;

	private Vector3 virtualTarget;

	private float offsetFromTargetX;

	private float offsetFromTargetZ;

	public Transform volumeProxy;

	private DepthOfField dofComponent;

	private float adsValue;

	private bool adsChanging;

	private float defaultAimOffset = 5f;

	private float maxAimOffset = 999f;

	private ItemAgent_Gun gun;

	private InputManager inputManager;

	private Vector3 cameraForwardVector;

	private Vector3 cameraRightVector;

	private float defaultAimOffsetDistanceFactor = 0.5f;

	private float aimOffsetDistanceFactor;

	private CameraAimingTypes cameraAimingType;

	private float lerpSpeed = 12f;

	public static GameCamera Instance => LevelManager.Instance?.GameCamera;

	private bool sickProtectModeOn => DisableCameraOffset.disableCameraOffset;

	private void Start()
	{
		currentFov = mainVCam.m_Lens.FieldOfView;
		if (!dofComponent && (bool)mainVCam)
		{
			VolumeProfile profile = mainVCam.GetComponent<CinemachineVolumeSettings>().m_Profile;
			if ((bool)profile)
			{
				profile.TryGet<DepthOfField>(out dofComponent);
			}
		}
	}

	private void Update()
	{
		if ((bool)target)
		{
			volumeProxy.position = target.transform.position;
			mainCamDepthPoint.position = target.GetCurrentAimPoint();
			gun = target.GetGun();
			if (!inputManager)
			{
				inputManager = LevelManager.Instance.InputManager;
			}
		}
	}

	private void LateUpdate()
	{
		if ((bool)target)
		{
			float num = adsValue;
			if ((bool)gun)
			{
				adsValue = target.AdsValue;
				maxAimOffset = Mathf.Lerp(sickProtectModeOn ? 0f : defaultAimOffset, defaultAimOffset * gun.ADSAimDistanceFactor, adsValue);
				aimOffsetDistanceFactor = Mathf.Lerp(defaultAimOffsetDistanceFactor, defaultAimOffsetDistanceFactor * gun.ADSAimDistanceFactor, adsValue);
			}
			else
			{
				adsValue = Mathf.MoveTowards(adsValue, target.IsInAdsInput ? 1f : 0f, Time.deltaTime * 10f);
				maxAimOffset = Mathf.Lerp(sickProtectModeOn ? 0f : defaultAimOffset, defaultAimOffset * 1.25f, adsValue);
				aimOffsetDistanceFactor = Mathf.Lerp(defaultAimOffsetDistanceFactor, defaultAimOffsetDistanceFactor, adsValue);
			}
			adsChanging = num != adsValue;
			UpdateFov(Time.deltaTime);
			UpdatePosition(Time.deltaTime);
		}
	}

	public void UpdateFov(float deltaTime)
	{
		float num = Mathf.Lerp(defaultFOV, adsFOV, adsValue);
		if (currentFov != num)
		{
			currentFov = num;
			mainVCam.m_Lens.FieldOfView = currentFov;
		}
	}

	public void ForceSyncPos()
	{
		UpdatePosition(1f);
	}

	public void SetTarget(CharacterMainControl _target)
	{
		target = _target;
	}

	private void UpdateCameraVectors()
	{
		cameraForwardVector = renderCamera.transform.forward;
		cameraForwardVector.y = 0f;
		cameraForwardVector.Normalize();
		cameraRightVector = renderCamera.transform.right;
		cameraRightVector.y = 0f;
		cameraRightVector.Normalize();
	}

	public void UpdatePosition(float deltaTime)
	{
		UpdateCameraVectors();
		if (!target)
		{
			return;
		}
		if ((bool)inputManager)
		{
			switch (cameraAimingType)
			{
			case CameraAimingTypes.normal:
				UpdateAimOffsetNormal(deltaTime);
				break;
			case CameraAimingTypes.bounds:
				UpdateAimOffsetUsingBound(deltaTime);
				break;
			}
		}
		Vector3 vector = cameraForwardVector * offsetFromTargetZ + cameraRightVector * offsetFromTargetX;
		virtualTarget = target.transform.position + vector + Vector3.up * 0.5f;
		Vector3.Distance(base.transform.position, virtualTarget);
		_ = 20f;
		base.transform.position = virtualTarget;
		OnCameraPosUpdate?.Invoke(this, target);
		if ((bool)dofComponent)
		{
			dofComponent.focusDistance.value = Vector3.Distance(renderCamera.transform.position, target.transform.position) - 1.5f;
		}
	}

	private void UpdateAimOffsetNormal(float deltaTime)
	{
		float num = Mathf.InverseLerp(20f, 50f, mianCameraArm.pitch);
		lerpSpeed = Mathf.MoveTowards(lerpSpeed, inputManager.TriggerInput ? 1.5f : 12f, Time.deltaTime * 1f);
		lerpSpeed = Mathf.Lerp(1.5f, lerpSpeed, num);
		if (!InputManager.InputActived)
		{
			offsetFromTargetX = Mathf.Lerp(offsetFromTargetX, 0f, Time.unscaledDeltaTime * lerpSpeed);
			offsetFromTargetZ = Mathf.Lerp(offsetFromTargetZ, 0f, Time.unscaledDeltaTime * lerpSpeed);
			return;
		}
		Vector2 mousePos = inputManager.MousePos;
		Vector2 vector = new Vector2((float)Screen.width * 0.5f, (float)Screen.height * 0.5f);
		Vector3 vector2 = ScreenPointToCharacterPlane(vector);
		Vector3 vector3 = ScreenPointToCharacterPlane(new Vector2(vector.x, Screen.height));
		Vector3 vector4 = ScreenPointToCharacterPlane(new Vector2(vector.x, 0f));
		Vector3.Distance(vector3, vector4);
		Vector3 vector5 = ScreenPointToCharacterPlane(mousePos);
		Vector3 vector6 = (vector3 + vector4) * 0.5f;
		vector6 = Vector3.MoveTowards(vector2, vector6, 5f * num);
		float num2 = Vector3.Distance(vector6, vector2);
		Vector3 lhs = Vector3.ClampMagnitude(vector5 - vector6, maxAimOffset) * num;
		float num3 = Vector3.Dot(lhs, cameraRightVector);
		float num4 = Vector3.Dot(lhs, cameraForwardVector);
		offsetFromTargetX = Mathf.Lerp(offsetFromTargetX, Mathf.Clamp(num3 * aimOffsetDistanceFactor, 0f - maxAimOffset, maxAimOffset), deltaTime * lerpSpeed);
		offsetFromTargetZ = Mathf.Lerp(offsetFromTargetZ, Mathf.Clamp(num4 * aimOffsetDistanceFactor, 0f - maxAimOffset, maxAimOffset) - num2, deltaTime * lerpSpeed);
	}

	private void UpdateAimOffsetUsingBound(float deltaTime)
	{
		if (!inputManager.TriggerInput)
		{
			float num = 20f;
			Vector2 mousePos = inputManager.MousePos;
			Vector2 zero = Vector2.zero;
			int num2 = (int)((float)Screen.height * 0.05f);
			if (mousePos.x < (float)num2)
			{
				zero += Vector2.left;
			}
			else if (mousePos.x > (float)(Screen.width - num2))
			{
				zero += Vector2.right;
			}
			if (mousePos.y < (float)num2)
			{
				zero += Vector2.down;
			}
			else if (mousePos.y > (float)(Screen.height - num2))
			{
				zero += Vector2.up;
			}
			if (!InputManager.InputActived)
			{
				zero = Vector2.zero;
			}
			if (!Application.isFocused)
			{
				zero = Vector2.zero;
			}
			if (zero.x != 0f)
			{
				offsetFromTargetX += zero.x * deltaTime * num;
				offsetFromTargetX = Mathf.Clamp(offsetFromTargetX, 0f - maxAimOffset, maxAimOffset);
			}
			if (zero.y != 0f)
			{
				offsetFromTargetZ += zero.y * deltaTime * num;
				offsetFromTargetZ = Mathf.Clamp(offsetFromTargetZ, 0f - maxAimOffset, maxAimOffset);
			}
		}
	}

	private Vector3 ScreenPointToCharacterPlane(Vector3 screenPoint)
	{
		Plane plane = new Plane(Vector3.up, target.transform.position + Vector3.up * 0.5f);
		Ray ray = renderCamera.ScreenPointToRay(screenPoint);
		if (plane.Raycast(ray, out var enter))
		{
			return ray.GetPoint(enter);
		}
		return Vector3.zero;
	}

	public bool IsOffScreen(Vector3 woorldPos)
	{
		Vector3 vector = Camera.main.WorldToScreenPoint(woorldPos);
		if (!(vector.x <= 0f) && !(vector.x >= (float)Screen.width) && !(vector.y <= 0f))
		{
			return vector.y >= (float)Screen.height;
		}
		return true;
	}
}
public class HideIfSickFriendly : MonoBehaviour
{
	public List<GameObject> hideList = new List<GameObject>();

	private bool sickFriendly;

	private void Start()
	{
		Sync();
		OptionsManager.OnOptionsChanged += OnOptionsChanged;
	}

	private void OnDestroy()
	{
		OptionsManager.OnOptionsChanged -= OnOptionsChanged;
	}

	private void OnOptionsChanged(string option)
	{
		Sync();
	}

	private void Sync()
	{
		bool disableCameraOffset = DisableCameraOffset.disableCameraOffset;
		if (sickFriendly != disableCameraOffset)
		{
			sickFriendly = disableCameraOffset;
		}
		foreach (GameObject hide in hideList)
		{
			if ((bool)hide)
			{
				hide.SetActive(!sickFriendly);
			}
		}
	}
}
public class AI_PathControl : MonoBehaviour
{
	public Seeker seeker;

	public CharacterMainControl controller;

	public Pathfinding.Path path;

	public float nextWaypointDistance = 3f;

	private int currentWaypoint;

	private bool reachedEndOfPath;

	public float stopDistance = 0.2f;

	private bool moving;

	private bool waitingForPathResult;

	public bool ReachedEndOfPath => reachedEndOfPath;

	public bool Moving => moving;

	public bool WaitingForPathResult => waitingForPathResult;

	public void Start()
	{
	}

	public void MoveToPos(Vector3 pos)
	{
		reachedEndOfPath = false;
		path = null;
		seeker.StartPath(base.transform.position, pos, OnPathComplete);
		waitingForPathResult = true;
	}

	public void OnPathComplete(Pathfinding.Path p)
	{
		if (!p.error)
		{
			path = p;
			currentWaypoint = 0;
			moving = true;
		}
		waitingForPathResult = false;
	}

	public void Update()
	{
		moving = path != null;
		if (path == null)
		{
			return;
		}
		reachedEndOfPath = false;
		float num;
		while (true)
		{
			num = Vector3.Distance(base.transform.position, path.vectorPath[currentWaypoint]);
			if (!(num < nextWaypointDistance))
			{
				break;
			}
			if (currentWaypoint + 1 < path.vectorPath.Count)
			{
				currentWaypoint++;
				continue;
			}
			reachedEndOfPath = true;
			break;
		}
		Vector3 normalized = (path.vectorPath[currentWaypoint] - base.transform.position).normalized;
		if (reachedEndOfPath)
		{
			float num2 = Mathf.Sqrt(num / nextWaypointDistance);
			controller.SetMoveInput(normalized * num2);
			if (num < stopDistance)
			{
				path = null;
				controller.SetMoveInput(Vector2.zero);
			}
		}
		else
		{
			controller.SetMoveInput(normalized);
		}
	}

	public void StopMove()
	{
		path = null;
		controller.SetMoveInput(Vector3.zero);
		waitingForPathResult = false;
	}
}
public class Breakable : MonoBehaviour
{
	private enum BreakableStates
	{
		normal,
		danger,
		breaked
	}

	public bool save;

	public string saveKey;

	public HealthSimpleBase simpleHealth;

	public int dangerHealth = 50;

	public bool createExplosion;

	public float explosionRadius;

	public DamageInfo explosionDamageInfo;

	private BreakableStates breakableState;

	public GameObject normalVisual;

	public GameObject dangerVisual;

	public GameObject breakedVisual;

	public GameObject mainCollider;

	public GameObject dangerFx;

	public string SaveKey => "Breakable_" + saveKey;

	private void Awake()
	{
		normalVisual.SetActive(value: true);
		if ((bool)dangerVisual)
		{
			dangerVisual.SetActive(value: false);
		}
		if ((bool)breakedVisual)
		{
			breakedVisual.SetActive(value: false);
		}
		simpleHealth.OnHurtEvent += OnHurt;
		simpleHealth.OnDeadEvent += OnDead;
		bool flag = false;
		if (save)
		{
			flag = SavesSystem.Load<bool>(SaveKey);
		}
		if (flag)
		{
			breakableState = BreakableStates.danger;
			normalVisual.SetActive(value: false);
			if ((bool)dangerVisual)
			{
				dangerVisual.SetActive(value: false);
			}
			if ((bool)breakedVisual)
			{
				breakedVisual.SetActive(value: true);
			}
			if ((bool)simpleHealth && (bool)simpleHealth.dmgReceiver)
			{
				simpleHealth.dmgReceiver.gameObject.SetActive(value: false);
			}
		}
		else if ((bool)mainCollider)
		{
			mainCollider.SetActive(value: true);
		}
	}

	private void OnValidate()
	{
	}

	private void OnHurt(DamageInfo dmgInfo)
	{
		switch (breakableState)
		{
		case BreakableStates.normal:
			if (simpleHealth.HealthValue <= (float)dangerHealth)
			{
				breakableState = BreakableStates.danger;
				if ((bool)dangerVisual)
				{
					normalVisual.SetActive(value: false);
					dangerVisual.SetActive(value: true);
				}
				if ((bool)dangerFx)
				{
					UnityEngine.Object.Instantiate(dangerFx, base.transform.position, base.transform.rotation);
				}
			}
			break;
		case BreakableStates.danger:
		case BreakableStates.breaked:
			break;
		}
	}

	private void OnDead(DamageInfo dmgInfo)
	{
		explosionDamageInfo.fromCharacter = dmgInfo.fromCharacter;
		normalVisual.SetActive(value: false);
		if ((bool)dangerVisual)
		{
			dangerVisual.SetActive(value: false);
		}
		if ((bool)breakedVisual)
		{
			breakedVisual.SetActive(value: true);
		}
		if ((bool)mainCollider)
		{
			mainCollider.SetActive(value: false);
		}
		breakableState = BreakableStates.breaked;
		if (createExplosion)
		{
			LevelManager.Instance.ExplosionManager.CreateExplosion(base.transform.position, explosionRadius, explosionDamageInfo);
		}
		if (save)
		{
			SavesSystem.Save("Breakable_", saveKey, value: true);
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (createExplosion)
		{
			Gizmos.color = Color.yellow;
			Gizmos.DrawWireSphere(base.transform.position, explosionRadius);
		}
	}
}
public class CA_Attack : CharacterActionBase, IProgress
{
	private float attackActionTime = 0.25f;

	private ItemAgent_MeleeWeapon meleeWeapon;

	private float dealDamageTime = 0.1f;

	private bool damageDealed;

	private float lastAttackTime = -999f;

	private float cd = -1f;

	private bool slashFxSpawned;

	private float slashFxDelayTime;

	public bool DamageDealed => damageDealed;

	public event Action OnAttack;

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.Attack;
	}

	public override bool CanMove()
	{
		return true;
	}

	public override bool CanRun()
	{
		return false;
	}

	public override bool CanUseHand()
	{
		return false;
	}

	public override bool CanControlAim()
	{
		return true;
	}

	public Duckov.Progress GetProgress()
	{
		Duckov.Progress result = default(Duckov.Progress);
		if (base.Running)
		{
			result.inProgress = true;
			result.total = attackActionTime;
			result.current = actionTimer;
		}
		else
		{
			result.inProgress = false;
		}
		return result;
	}

	public override bool IsReady()
	{
		if (Time.time - lastAttackTime < cd)
		{
			return false;
		}
		meleeWeapon = characterController.GetMeleeWeapon();
		if (meleeWeapon == null)
		{
			return false;
		}
		if (meleeWeapon.StaminaCost > characterController.CurrentStamina)
		{
			return false;
		}
		return !base.Running;
	}

	protected override bool OnStart()
	{
		if (!characterController.CurrentHoldItemAgent)
		{
			return false;
		}
		meleeWeapon = characterController.GetMeleeWeapon();
		if (!meleeWeapon)
		{
			return false;
		}
		characterController.UseStamina(meleeWeapon.StaminaCost);
		dealDamageTime = meleeWeapon.DealDamageTime;
		damageDealed = false;
		this.OnAttack?.Invoke();
		CreateAttackSound();
		lastAttackTime = Time.time;
		cd = 1f / meleeWeapon.AttackSpeed;
		slashFxDelayTime = meleeWeapon.slashFxDelayTime;
		slashFxSpawned = false;
		return true;
	}

	private void CreateAttackSound()
	{
		AudioManager.Post("SFX/Combat/Melee/attack_" + meleeWeapon.SoundKey.ToLower(), base.gameObject);
	}

	protected override void OnStop()
	{
	}

	protected override void OnUpdateAction(float deltaTime)
	{
		if ((!(actionTimer > attackActionTime) && base.Running && !(meleeWeapon == null)) || !StopAction())
		{
			if (!slashFxSpawned && base.ActionTimer > slashFxDelayTime && (bool)meleeWeapon && (bool)meleeWeapon.slashFx)
			{
				slashFxSpawned = true;
				Vector3 position = characterController.transform.position;
				position.y = meleeWeapon.transform.position.y;
				UnityEngine.Object.Instantiate(meleeWeapon.slashFx, position, Quaternion.LookRotation(characterController.modelRoot.forward, Vector3.up)).transform.SetParent(base.transform);
			}
			if (!damageDealed && base.ActionTimer > dealDamageTime)
			{
				damageDealed = true;
				meleeWeapon.CheckAndDealDamage();
			}
		}
	}
}
public class CA_Carry : CharacterActionBase, IProgress
{
	[HideInInspector]
	public Carriable carryTarget;

	private Carriable carringTarget;

	public Vector3 carryPoint = new Vector3(0f, 1f, 0.8f);

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.Whatever;
	}

	public override bool CanMove()
	{
		return true;
	}

	public override bool CanRun()
	{
		return false;
	}

	public override bool CanUseHand()
	{
		return false;
	}

	public override bool CanControlAim()
	{
		return true;
	}

	public override bool IsReady()
	{
		return carryTarget != null;
	}

	public float GetWeight()
	{
		if (!base.Running)
		{
			return 0f;
		}
		if (!carringTarget)
		{
			return 0f;
		}
		return carringTarget.GetWeight();
	}

	public Duckov.Progress GetProgress()
	{
		return new Duckov.Progress
		{
			inProgress = false,
			total = 1f,
			current = 1f
		};
	}

	protected override bool OnStart()
	{
		characterController.ChangeHoldItem(null);
		carryTarget.Take(this);
		carringTarget = carryTarget;
		return true;
	}

	protected override void OnUpdateAction(float deltaTime)
	{
		if (characterController.CurrentHoldItemAgent != null)
		{
			StopAction();
		}
		if ((bool)carryTarget)
		{
			carryTarget.OnCarriableUpdate(deltaTime);
		}
	}

	protected override void OnStop()
	{
		carryTarget.Drop();
		carringTarget = null;
	}
}
public class CA_Dash : CharacterActionBase, IProgress
{
	private float dashSpeed;

	private bool dashCanControl;

	public AnimationCurve speedCurve;

	public float dashTime;

	public float coolTime = 0.5f;

	private Vector3 dashDirection;

	public float staminaCost = 10f;

	private float lastEndTime = -999f;

	[SerializeField]
	private string overrideSFX;

	private string sfx
	{
		get
		{
			if (string.IsNullOrWhiteSpace(overrideSFX))
			{
				return "Char/Footstep/dash";
			}
			return overrideSFX;
		}
	}

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.Dash;
	}

	public override bool CanMove()
	{
		return false;
	}

	public override bool CanRun()
	{
		return false;
	}

	public override bool CanUseHand()
	{
		return dashCanControl;
	}

	public override bool CanControlAim()
	{
		return dashCanControl;
	}

	public Duckov.Progress GetProgress()
	{
		Duckov.Progress result = default(Duckov.Progress);
		if (base.Running)
		{
			result.inProgress = true;
			result.total = dashTime;
			result.current = actionTimer;
		}
		else
		{
			result.inProgress = false;
		}
		return result;
	}

	public override bool IsReady()
	{
		if (Time.time - lastEndTime < coolTime)
		{
			return false;
		}
		return !base.Running;
	}

	protected override bool OnStart()
	{
		if (characterController.CurrentStamina < staminaCost)
		{
			return false;
		}
		characterController.UseStamina(staminaCost);
		dashSpeed = characterController.DashSpeed;
		dashCanControl = characterController.DashCanControl;
		if (characterController.MoveInput.magnitude > 0f)
		{
			dashDirection = characterController.MoveInput.normalized;
		}
		else
		{
			dashDirection = characterController.CurrentAimDirection;
		}
		characterController.SetForceMoveVelocity(dashSpeed * speedCurve.Evaluate(0f) * dashDirection);
		if (!dashCanControl)
		{
			characterController.movementControl.ForceTurnTo(dashDirection);
		}
		AudioManager.Post(sfx, base.gameObject);
		return true;
	}

	protected override void OnStop()
	{
		characterController.SetForceMoveVelocity(characterController.CharacterRunSpeed * dashDirection);
		lastEndTime = Time.time;
	}

	protected override void OnUpdateAction(float deltaTime)
	{
		if ((!(actionTimer > dashTime) && base.Running) || !StopAction())
		{
			characterController.SetForceMoveVelocity(dashSpeed * speedCurve.Evaluate(Mathf.Clamp01(actionTimer / dashTime)) * dashDirection);
		}
	}
}
public class CA_Interact : CharacterActionBase, IProgress
{
	private InteractableBase masterInteractableAround;

	private int interactIndexInGroup;

	private InteractableBase interactingTarget;

	private LayerMask interactLayers;

	private InteractableBase minDistanceInteractable;

	private Collider[] colliders;

	private Duckov.Progress progress;

	public InteractableBase MasterInteractableAround => masterInteractableAround;

	public InteractableBase InteractTarget
	{
		get
		{
			if ((bool)masterInteractableAround)
			{
				return masterInteractableAround.GetInteractableInGroup(interactIndexInGroup);
			}
			return null;
		}
	}

	public int InteractIndexInGroup => interactIndexInGroup;

	public InteractableBase InteractingTarget => interactingTarget;

	private void Awake()
	{
		interactLayers = 1 << LayerMask.NameToLayer("Interactable");
		colliders = new Collider[5];
	}

	public void SearchInteractableAround()
	{
		if (!characterController.IsMainCharacter)
		{
			return;
		}
		InteractableBase interactableBase = masterInteractableAround;
		int num = Physics.OverlapSphereNonAlloc(base.transform.position + Vector3.up * 0.5f + characterController.CurrentAimDirection * 0.2f, 0.3f, colliders, interactLayers);
		if (num <= 0)
		{
			masterInteractableAround = null;
			return;
		}
		float num2 = 999f;
		float num3 = 0f;
		minDistanceInteractable = null;
		for (int i = 0; i < num; i++)
		{
			Collider collider = colliders[i];
			num3 = Vector3.Distance(base.transform.position, collider.transform.position);
			if (num3 < num2)
			{
				InteractableBase interactableBase2 = null;
				if (masterInteractableAround == null || masterInteractableAround.gameObject != collider.gameObject)
				{
					interactableBase2 = collider.GetComponent<InteractableBase>();
				}
				else if (masterInteractableAround != null && masterInteractableAround.gameObject == collider.gameObject)
				{
					interactableBase2 = masterInteractableAround;
				}
				if (!(interactableBase2 == null) && interactableBase2.CheckInteractable())
				{
					minDistanceInteractable = interactableBase2;
					num2 = num3;
				}
			}
		}
		masterInteractableAround = minDistanceInteractable;
		if (interactableBase != masterInteractableAround || interactableBase == null)
		{
			interactIndexInGroup = 0;
		}
	}

	public void SwitchInteractable(int dir)
	{
		if (MasterInteractableAround == null || !MasterInteractableAround.interactableGroup)
		{
			interactIndexInGroup = 0;
			return;
		}
		interactIndexInGroup += dir;
		int num = 1;
		if (MasterInteractableAround.interactableGroup)
		{
			num = MasterInteractableAround.GetInteractableList().Count;
		}
		if (interactIndexInGroup >= num)
		{
			interactIndexInGroup = 0;
		}
		else if (interactIndexInGroup < 0)
		{
			interactIndexInGroup = num - 1;
		}
	}

	public void SetInteractableTarget(InteractableBase interactable)
	{
		masterInteractableAround = interactable;
		interactIndexInGroup = 0;
	}

	protected override bool OnStart()
	{
		InteractableBase interactTarget = InteractTarget;
		if (!interactTarget)
		{
			return false;
		}
		if (interactTarget.StartInteract(characterController))
		{
			interactingTarget = interactTarget;
			return true;
		}
		return false;
	}

	protected override void OnUpdateAction(float deltaTime)
	{
		if (interactingTarget == null)
		{
			StopAction();
		}
		else if (!interactingTarget.Interacting)
		{
			StopAction();
		}
		else
		{
			interactingTarget.UpdateInteract(characterController, deltaTime);
		}
	}

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.Interact;
	}

	public override bool CanMove()
	{
		return false;
	}

	protected override void OnStop()
	{
		if ((bool)interactingTarget && interactingTarget.Interacting)
		{
			interactingTarget.InternalStopInteract();
		}
	}

	public override bool CanRun()
	{
		return false;
	}

	public override bool CanUseHand()
	{
		return false;
	}

	public override bool CanControlAim()
	{
		return false;
	}

	public override bool IsReady()
	{
		if (!base.Running)
		{
			return InteractTarget != null;
		}
		return false;
	}

	public Duckov.Progress GetProgress()
	{
		if (interactingTarget != null)
		{
			progress = interactingTarget.GetProgress();
		}
		else
		{
			progress.inProgress = false;
		}
		return progress;
	}
}
public class CA_Reload : CharacterActionBase, IProgress
{
	public ItemAgent_Gun currentGun;

	public Item preferedBulletToReload;

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.Reload;
	}

	public override bool CanMove()
	{
		return true;
	}

	public override bool CanRun()
	{
		return true;
	}

	public override bool CanUseHand()
	{
		return false;
	}

	public override bool CanControlAim()
	{
		return true;
	}

	public override bool IsReady()
	{
		currentGun = characterController.agentHolder.CurrentHoldGun;
		if (!currentGun)
		{
			return false;
		}
		if (currentGun.IsReloading())
		{
			return false;
		}
		return true;
	}

	protected override bool OnStart()
	{
		currentGun = null;
		if (!characterController || !characterController.CurrentHoldItemAgent)
		{
			return false;
		}
		currentGun = characterController.agentHolder.CurrentHoldGun;
		currentGun.GunItemSetting.PreferdBulletsToLoad = preferedBulletToReload;
		preferedBulletToReload = null;
		if (currentGun != null && currentGun.BeginReload())
		{
			return true;
		}
		return false;
	}

	protected override void OnStop()
	{
		if (currentGun != null)
		{
			currentGun.CancleReload();
		}
	}

	public bool GetGunReloadable()
	{
		if (currentGun == null)
		{
			currentGun = characterController.agentHolder.CurrentHoldGun;
			return false;
		}
		if (base.Running)
		{
			return false;
		}
		if (currentGun.IsFull())
		{
			return false;
		}
		return true;
	}

	public override bool CanEditInventory()
	{
		return true;
	}

	protected override void OnUpdateAction(float deltaTime)
	{
		if (currentGun == null)
		{
			StopAction();
		}
		else if (!currentGun.IsReloading())
		{
			StopAction();
		}
	}

	public Duckov.Progress GetProgress()
	{
		if (currentGun != null)
		{
			return currentGun.GetReloadProgress();
		}
		return new Duckov.Progress
		{
			inProgress = false
		};
	}
}
public enum SkillTypes
{
	itemSkill,
	characterSkill
}
public class CA_Skill : CharacterActionBase, IProgress
{
	[SerializeField]
	public CharacterSkillKeeper holdItemSkillKeeper;

	[SerializeField]
	public CharacterSkillKeeper characterSkillKeeper;

	private SkillTypes skillTypeToRelease;

	private CharacterSkillKeeper currentRunningSkillKeeper;

	public SkillBase CurrentRunningSkill
	{
		get
		{
			if (!base.Running || currentRunningSkillKeeper == null)
			{
				return null;
			}
			return currentRunningSkillKeeper.Skill;
		}
	}

	public CharacterSkillKeeper GetSkillKeeper(SkillTypes skillType)
	{
		return skillType switch
		{
			SkillTypes.itemSkill => holdItemSkillKeeper, 
			SkillTypes.characterSkill => characterSkillKeeper, 
			_ => null, 
		};
	}

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.Skills;
	}

	public override bool CanControlAim()
	{
		return true;
	}

	public override bool CanEditInventory()
	{
		return false;
	}

	public override bool CanMove()
	{
		if (CurrentRunningSkill != null)
		{
			return CurrentRunningSkill.SkillContext.movableWhileAim;
		}
		return true;
	}

	public override bool CanRun()
	{
		return false;
	}

	public override bool CanUseHand()
	{
		return false;
	}

	public override bool IsReady()
	{
		if (base.Running)
		{
			return false;
		}
		return true;
	}

	public bool IsSkillHasEnoughStaminaAndCD(SkillBase skill)
	{
		if (characterController.CurrentStamina < skill.staminaCost)
		{
			return false;
		}
		if (Time.time - skill.LastReleaseTime < skill.coolDownTime)
		{
			return false;
		}
		return true;
	}

	protected override bool OnStart()
	{
		CharacterSkillKeeper skillKeeper = GetSkillKeeper(skillTypeToRelease);
		if (skillKeeper != null && skillKeeper.CheckSkillAndBinding())
		{
			if (skillKeeper.Skill != null)
			{
				if (!IsSkillHasEnoughStaminaAndCD(skillKeeper.Skill))
				{
					return false;
				}
				_ = skillKeeper.Skill.SkillContext;
			}
			currentRunningSkillKeeper = skillKeeper;
			UnityEngine.Debug.Log($"skillType is {skillTypeToRelease}");
			return true;
		}
		return false;
	}

	public void SetNextSkillType(SkillTypes skillType)
	{
		if (!base.Running)
		{
			skillTypeToRelease = skillType;
		}
	}

	public bool SetSkillOfType(SkillTypes skillType, SkillBase _skill, GameObject _bindingObject)
	{
		CharacterSkillKeeper skillKeeper = GetSkillKeeper(skillType);
		if (skillKeeper == null)
		{
			return false;
		}
		if (base.Running && skillKeeper == currentRunningSkillKeeper)
		{
			StopAction();
		}
		skillKeeper.SetSkill(_skill, _bindingObject);
		return true;
	}

	public bool ReleaseSkill(SkillTypes skillType)
	{
		if (!base.Running)
		{
			return false;
		}
		if (CurrentRunningSkill == null)
		{
			StopAction();
			return false;
		}
		if (skillType != skillTypeToRelease)
		{
			StopAction();
			return false;
		}
		if (!IsSkillHasEnoughStaminaAndCD(CurrentRunningSkill))
		{
			return false;
		}
		if (actionTimer < CurrentRunningSkill.SkillContext.skillReadyTime)
		{
			StopAction();
			return false;
		}
		Vector3 currentSkillAimPoint = characterController.GetCurrentSkillAimPoint();
		SkillReleaseContext releaseContext = new SkillReleaseContext
		{
			releasePoint = currentSkillAimPoint
		};
		CurrentRunningSkill.ReleaseSkill(releaseContext, characterController);
		currentRunningSkillKeeper = null;
		StopAction();
		return true;
	}

	protected override void OnStop()
	{
		currentRunningSkillKeeper = null;
	}

	protected override void OnUpdateAction(float deltaTime)
	{
		if (currentRunningSkillKeeper == null || !currentRunningSkillKeeper.CheckSkillAndBinding())
		{
			StopAction();
		}
	}

	public Duckov.Progress GetProgress()
	{
		Duckov.Progress result = default(Duckov.Progress);
		SkillBase currentRunningSkill = CurrentRunningSkill;
		if (currentRunningSkill != null)
		{
			result.total = currentRunningSkill.SkillContext.skillReadyTime;
			result.current = actionTimer;
			result.inProgress = result.progress < 1f;
		}
		else
		{
			result.inProgress = false;
		}
		return result;
	}
}
public class CA_UseItem : CharacterActionBase, IProgress
{
	private Item item;

	public IAgentUsable agentUsable;

	public bool hasSound;

	public string actionSound;

	public string useSound;

	private FMOD.Studio.EventInstance? soundInstance;

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.usingItem;
	}

	public override bool CanMove()
	{
		return true;
	}

	public override bool CanRun()
	{
		return false;
	}

	public override bool CanUseHand()
	{
		return false;
	}

	public override bool CanControlAim()
	{
		return true;
	}

	public override bool IsReady()
	{
		return true;
	}

	protected override bool OnStart()
	{
		agentUsable = null;
		bool flag = false;
		if (item.AgentUtilities.ActiveAgent == null)
		{
			if (characterController.ChangeHoldItem(item) && characterController.CurrentHoldItemAgent != null)
			{
				agentUsable = characterController.CurrentHoldItemAgent as IAgentUsable;
				flag = true;
			}
		}
		else if (item.AgentUtilities.ActiveAgent == characterController.CurrentHoldItemAgent)
		{
			flag = true;
		}
		if (flag)
		{
			PostActionSound();
		}
		return flag;
	}

	protected override void OnStop()
	{
		StopSound();
		characterController.SwitchToWeaponBeforeUse();
		if (item != null && !item.IsBeingDestroyed && item.GetRoot() != characterController.CharacterItem && !characterController.PickupItem(item))
		{
			item.Drop(characterController, createRigidbody: true);
		}
	}

	public void SetUseItem(Item _item)
	{
		item = _item;
		hasSound = false;
		UsageUtilities component = item.GetComponent<UsageUtilities>();
		if ((bool)component)
		{
			hasSound = component.hasSound;
			actionSound = component.actionSound;
			useSound = component.useSound;
		}
	}

	protected override void OnUpdateAction(float deltaTime)
	{
		if (item == null)
		{
			StopAction();
		}
		else if (characterController.CurrentHoldItemAgent == null || characterController.CurrentHoldItemAgent.Item == null || characterController.CurrentHoldItemAgent.Item != item)
		{
			UnityEngine.Debug.Log("拿的不统一");
			StopAction();
		}
		else if (base.ActionTimer > characterController.CurrentHoldItemAgent.Item.UseTime)
		{
			OnFinish();
			UnityEngine.Debug.Log("Use Finished");
			StopAction();
		}
	}

	private void OnFinish()
	{
		item.Use(characterController);
		PostUseSound();
		if (item.Stackable)
		{
			item.StackCount -= 1;
		}
		else if (item.UseDurability)
		{
			if (item.Durability <= 0f && !item.IsBeingDestroyed)
			{
				item.DestroyTree();
			}
		}
		else
		{
			item.DestroyTree();
		}
	}

	public Duckov.Progress GetProgress()
	{
		Duckov.Progress result = default(Duckov.Progress);
		if (item != null && base.Running)
		{
			result.inProgress = true;
			result.total = item.UseTime;
			result.current = actionTimer;
			return result;
		}
		result.inProgress = false;
		return result;
	}

	private void OnDestroy()
	{
		StopSound();
	}

	private void OnDisable()
	{
		StopSound();
	}

	private void PostActionSound()
	{
		if (hasSound)
		{
			soundInstance = AudioManager.Post(actionSound, base.gameObject);
		}
	}

	private void PostUseSound()
	{
		if (hasSound)
		{
			AudioManager.Post(useSound, base.gameObject);
		}
	}

	private void StopSound()
	{
		if (soundInstance.HasValue)
		{
			soundInstance.Value.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
		}
	}
}
public abstract class CharacterActionBase : MonoBehaviour
{
	public enum ActionPriorities
	{
		Whatever,
		Reload,
		Attack,
		usingItem,
		Dash,
		Skills,
		Fishing,
		Interact
	}

	private bool running;

	protected float actionTimer;

	public bool progressHUD = true;

	public CharacterMainControl characterController;

	public bool Running => running;

	public float ActionTimer => actionTimer;

	public abstract ActionPriorities ActionPriority();

	public abstract bool CanMove();

	public abstract bool CanRun();

	public abstract bool CanUseHand();

	public abstract bool CanControlAim();

	public virtual bool CanEditInventory()
	{
		return false;
	}

	public void UpdateAction(float deltaTime)
	{
		actionTimer += deltaTime;
		OnUpdateAction(deltaTime);
	}

	protected virtual void OnUpdateAction(float deltaTime)
	{
	}

	protected virtual bool OnStart()
	{
		return true;
	}

	public virtual bool IsStopable()
	{
		return true;
	}

	protected virtual void OnStop()
	{
	}

	public abstract bool IsReady();

	public bool StartActionByCharacter(CharacterMainControl _character)
	{
		if (!IsReady())
		{
			return false;
		}
		characterController = _character;
		if (OnStart())
		{
			actionTimer = 0f;
			running = true;
			return true;
		}
		return false;
	}

	public bool StopAction()
	{
		if (!running)
		{
			return true;
		}
		if (IsStopable())
		{
			running = false;
			OnStop();
			return true;
		}
		return false;
	}
}
public class CharacterAnimationControl : MonoBehaviour
{
	public CharacterMainControl characterMainControl;

	public CharacterModel characterModel;

	public Animator animator;

	public float attackTime = 0.3f;

	private int attackLayer = -1;

	private bool attacking;

	private float attackTimer;

	private bool hasAnimationIfDashCanControl;

	public AnimationCurve attackLayerWeightCurve;

	private int hash_MoveSpeed = Animator.StringToHash("MoveSpeed");

	private int hash_MoveDirX = Animator.StringToHash("MoveDirX");

	private int hash_MoveDirY = Animator.StringToHash("MoveDirY");

	private int hash_RightHandOut = Animator.StringToHash("RightHandOut");

	private int hash_HandState = Animator.StringToHash("HandState");

	private int hash_Dashing = Animator.StringToHash("Dashing");

	private int hash_Attack = Animator.StringToHash("Attack");

	private HashSet<int> animatorHashes = new HashSet<int>();

	private float weight;

	private DuckovItemAgent holdAgent;

	private void InitHash()
	{
		AnimatorControllerParameter[] parameters = animator.parameters;
		foreach (AnimatorControllerParameter animatorControllerParameter in parameters)
		{
			animatorHashes.Add(animatorControllerParameter.nameHash);
		}
	}

	private void SetAnimatorBool(int hash, bool value)
	{
		if (animatorHashes.Contains(hash))
		{
			animator.SetBool(hash, value);
		}
	}

	private void SetAnimatorFloat(int hash, float value)
	{
		if (animatorHashes.Contains(hash))
		{
			animator.SetFloat(hash, value);
		}
	}

	private void SetAnimatorInteger(int hash, int value)
	{
		if (animatorHashes.Contains(hash))
		{
			animator.SetInteger(hash, value);
		}
	}

	private void SetAnimatorTrigger(int hash)
	{
		if (animatorHashes.Contains(hash))
		{
			animator.SetTrigger(hash);
		}
	}

	private void Awake()
	{
		if (!characterModel)
		{
			characterModel = GetComponent<CharacterModel>();
		}
		characterModel.OnCharacterSetEvent += OnCharacterSet;
		if ((bool)characterModel.characterMainControl)
		{
			characterMainControl = characterModel.characterMainControl;
		}
		characterModel.OnAttackOrShootEvent += OnAttack;
		InitHash();
	}

	private void OnDestroy()
	{
		if ((bool)characterModel)
		{
			characterModel.OnCharacterSetEvent -= OnCharacterSet;
			characterModel.OnAttackOrShootEvent -= OnAttack;
		}
	}

	private void OnCharacterSet()
	{
		characterMainControl = characterModel.characterMainControl;
	}

	private void Start()
	{
		if (attackLayer < 0)
		{
			attackLayer = animator.GetLayerIndex("MeleeAttack");
		}
	}

	private void SetAttackLayerWeight(float weight)
	{
		if (attackLayer >= 0)
		{
			animator.SetLayerWeight(attackLayer, weight);
		}
	}

	private void Update()
	{
		if ((bool)characterMainControl)
		{
			SetAnimatorFloat(hash_MoveSpeed, characterMainControl.AnimationMoveSpeedValue);
			Vector2 animationLocalMoveDirectionValue = characterMainControl.AnimationLocalMoveDirectionValue;
			SetAnimatorFloat(hash_MoveDirX, animationLocalMoveDirectionValue.x);
			SetAnimatorFloat(hash_MoveDirY, animationLocalMoveDirectionValue.y);
			bool value = true;
			if (characterMainControl.CurrentHoldItemAgent == null)
			{
				value = false;
			}
			else if (!characterMainControl.CurrentHoldItemAgent.gameObject.activeSelf)
			{
				value = false;
			}
			else if (characterMainControl.reloadAction.Running)
			{
				value = false;
			}
			SetAnimatorBool(hash_RightHandOut, value);
			bool flag = characterMainControl.Dashing;
			if (flag && !hasAnimationIfDashCanControl && characterMainControl.DashCanControl)
			{
				flag = false;
			}
			SetAnimatorBool(hash_Dashing, flag);
			int value2 = 0;
			if (!holdAgent)
			{
				holdAgent = characterMainControl.CurrentHoldItemAgent;
			}
			if (holdAgent != null)
			{
				value2 = (int)holdAgent.handAnimationType;
			}
			SetAnimatorInteger(hash_HandState, value2);
			UpdateAttackLayerWeight();
		}
	}

	private void UpdateAttackLayerWeight()
	{
		if (!attacking)
		{
			if (weight > 0f)
			{
				weight = 0f;
				SetAttackLayerWeight(weight);
			}
			return;
		}
		attackTimer += Time.deltaTime;
		weight = attackLayerWeightCurve.Evaluate(attackTimer / attackTime);
		if (attackTimer >= attackTime)
		{
			attacking = false;
			weight = 0f;
		}
		SetAttackLayerWeight(weight);
	}

	public void OnAttack()
	{
		if (!characterMainControl || !holdAgent || holdAgent.handAnimationType != HandheldAnimationType.meleeWeapon)
		{
			attacking = false;
			return;
		}
		attacking = true;
		if (attackLayer < 0)
		{
			attackLayer = animator.GetLayerIndex("MeleeAttack");
		}
		SetAnimatorTrigger(hash_Attack);
		attackTimer = 0f;
	}
}
public class CharacterAnimationControl_MagicBlend : MonoBehaviour
{
	public CharacterMainControl characterMainControl;

	public CharacterModel characterModel;

	public Animator animator;

	public float attackTime = 0.3f;

	private int attackLayer = -1;

	private bool attacking;

	private float attackTimer;

	private DuckovItemAgent holdAgent;

	private ItemAgent_Gun gunAgent;

	public AnimationCurve attackLayerWeightCurve;

	private int hash_MoveSpeed = Animator.StringToHash("MoveSpeed");

	private int hash_MoveDirX = Animator.StringToHash("MoveDirX");

	private int hash_MoveDirY = Animator.StringToHash("MoveDirY");

	private int hash_Dashing = Animator.StringToHash("Dashing");

	private int hash_Attack = Animator.StringToHash("Attack");

	private int hash_HandState = Animator.StringToHash("HandState");

	private int hash_GunReady = Animator.StringToHash("GunReady");

	private float weight;

	private void Awake()
	{
		if (!characterModel)
		{
			characterModel = GetComponent<CharacterModel>();
		}
		characterModel.OnCharacterSetEvent += OnCharacterSet;
		if ((bool)characterModel.characterMainControl)
		{
			characterMainControl = characterModel.characterMainControl;
		}
		characterModel.OnAttackOrShootEvent += OnAttack;
	}

	private void OnDestroy()
	{
		if ((bool)characterModel)
		{
			characterModel.OnCharacterSetEvent -= OnCharacterSet;
			characterModel.OnAttackOrShootEvent -= OnAttack;
		}
	}

	private void OnCharacterSet()
	{
		characterMainControl = characterModel.characterMainControl;
	}

	private void Start()
	{
		if (attackLayer < 0)
		{
			attackLayer = animator.GetLayerIndex("MeleeAttack");
		}
		animator.SetLayerWeight(attackLayer, 0f);
	}

	private void Update()
	{
		if (!characterMainControl)
		{
			return;
		}
		animator.SetFloat(hash_MoveSpeed, characterMainControl.AnimationMoveSpeedValue);
		Vector2 animationLocalMoveDirectionValue = characterMainControl.AnimationLocalMoveDirectionValue;
		animator.SetFloat(hash_MoveDirX, animationLocalMoveDirectionValue.x);
		animator.SetFloat(hash_MoveDirY, animationLocalMoveDirectionValue.y);
		int value = 0;
		if (!holdAgent || !holdAgent.isActiveAndEnabled)
		{
			holdAgent = characterMainControl.CurrentHoldItemAgent;
		}
		else
		{
			value = (int)holdAgent.handAnimationType;
		}
		if (characterMainControl.carryAction.Running)
		{
			value = -1;
		}
		animator.SetInteger(hash_HandState, value);
		if (holdAgent != null && gunAgent == null)
		{
			gunAgent = holdAgent as ItemAgent_Gun;
		}
		bool value2 = false;
		if (gunAgent != null)
		{
			value2 = true;
			if (gunAgent.IsReloading() || gunAgent.BulletCount <= 0)
			{
				value2 = false;
			}
		}
		animator.SetBool(hash_GunReady, value2);
		bool dashing = characterMainControl.Dashing;
		animator.SetBool(hash_Dashing, dashing);
		UpdateAttackLayerWeight();
	}

	private void UpdateAttackLayerWeight()
	{
		if (!attacking)
		{
			if (weight > 0f)
			{
				weight = 0f;
				animator.SetLayerWeight(attackLayer, weight);
			}
			return;
		}
		attackTimer += Time.deltaTime;
		weight = attackLayerWeightCurve.Evaluate(attackTimer / attackTime);
		if (attackTimer >= attackTime)
		{
			attacking = false;
			weight = 0f;
		}
		animator.SetLayerWeight(attackLayer, weight);
	}

	public void OnAttack()
	{
		attacking = true;
		if (attackLayer < 0)
		{
			attackLayer = animator.GetLayerIndex("MeleeAttack");
		}
		animator.SetTrigger(hash_Attack);
		attackTimer = 0f;
	}
}
public class CharacterEquipmentController : MonoBehaviour
{
	[SerializeField]
	private CharacterMainControl characterMainControl;

	private Item characterItem;

	public static int equipmentModelHash = "EquipmentModel".GetHashCode();

	public static int armorHash = "Armor".GetHashCode();

	public static int helmatHash = "Helmat".GetHashCode();

	public static int faceMaskHash = "FaceMask".GetHashCode();

	public static int backpackHash = "Backpack".GetHashCode();

	public static int headsetHash = "Headset".GetHashCode();

	private Slot armorSlot;

	private Slot helmatSlot;

	private Slot backpackSlot;

	private Slot faceMaskSlot;

	private Slot headsetSlot;

	public event Action<Slot> OnHelmatSlotContentChanged;

	public event Action<Slot> OnFaceMaskSlotContentChanged;

	public void SetItem(Item _item)
	{
		characterItem = _item;
		armorSlot = characterItem.Slots.GetSlot(armorHash);
		helmatSlot = characterItem.Slots.GetSlot(helmatHash);
		faceMaskSlot = characterItem.Slots.GetSlot(faceMaskHash);
		backpackSlot = characterItem.Slots.GetSlot(backpackHash);
		headsetSlot = characterItem.Slots.GetSlot(headsetHash);
		armorSlot.onSlotContentChanged += ChangeArmorModel;
		helmatSlot.onSlotContentChanged += ChangeHelmatModel;
		faceMaskSlot.onSlotContentChanged += ChangeFaceMaskModel;
		backpackSlot.onSlotContentChanged += ChangeBackpackModel;
		headsetSlot.onSlotContentChanged += ChangeHeadsetModel;
		if (armorSlot?.Content != null)
		{
			ChangeArmorModel(armorSlot);
		}
		if (helmatSlot?.Content != null)
		{
			ChangeHelmatModel(helmatSlot);
		}
		if (faceMaskSlot?.Content != null)
		{
			ChangeFaceMaskModel(faceMaskSlot);
		}
		if (backpackSlot?.Content != null)
		{
			ChangeBackpackModel(backpackSlot);
		}
		if (headsetSlot?.Content != null)
		{
			ChangeHeadsetModel(headsetSlot);
		}
	}

	private void OnDestroy()
	{
		if (armorSlot != null)
		{
			armorSlot.onSlotContentChanged -= ChangeArmorModel;
		}
		if (helmatSlot != null)
		{
			helmatSlot.onSlotContentChanged -= ChangeHelmatModel;
		}
		if (backpackSlot != null)
		{
			backpackSlot.onSlotContentChanged -= ChangeBackpackModel;
		}
		if (faceMaskSlot != null)
		{
			faceMaskSlot.onSlotContentChanged -= ChangeFaceMaskModel;
		}
	}

	private void ChangeArmorModel(Slot slot)
	{
		if (!(characterMainControl.characterModel == null))
		{
			Transform armorSocket = characterMainControl.characterModel.ArmorSocket;
			ChangeEquipmentModel(slot, armorSocket);
		}
	}

	private void ChangeHelmatModel(Slot slot)
	{
		this.OnHelmatSlotContentChanged?.Invoke(slot);
		if (!(characterMainControl.characterModel == null))
		{
			Transform helmatSocket = characterMainControl.characterModel.HelmatSocket;
			ChangeEquipmentModel(slot, helmatSocket);
		}
	}

	private void ChangeHeadsetModel(Slot slot)
	{
		if (!(characterMainControl.characterModel == null))
		{
			Transform helmatSocket = characterMainControl.characterModel.HelmatSocket;
			ChangeEquipmentModel(slot, helmatSocket);
		}
	}

	private void ChangeBackpackModel(Slot slot)
	{
		if (!(characterMainControl.characterModel == null))
		{
			Transform backpackSocket = characterMainControl.characterModel.BackpackSocket;
			ChangeEquipmentModel(slot, backpackSocket);
		}
	}

	private void ChangeFaceMaskModel(Slot slot)
	{
		this.OnFaceMaskSlotContentChanged?.Invoke(slot);
		if (!(characterMainControl.characterModel == null))
		{
			Transform faceMaskSocket = characterMainControl.characterModel.FaceMaskSocket;
			ChangeEquipmentModel(slot, faceMaskSocket);
		}
	}

	private void ChangeEquipmentModel(Slot slot, Transform socket)
	{
		if (slot != null && !(slot.Content == null))
		{
			ItemAgent itemAgent = slot.Content.AgentUtilities.CreateAgent(equipmentModelHash, ItemAgent.AgentTypes.equipment);
			if (itemAgent == null)
			{
				UnityEngine.Debug.LogError("生成的装备Item没有装备agent，Item名称：" + slot.Content.gameObject.name);
			}
			if (itemAgent != null)
			{
				itemAgent.transform.SetParent(socket, worldPositionStays: false);
				itemAgent.transform.localRotation = Quaternion.identity;
				itemAgent.transform.localPosition = Vector3.zero;
			}
		}
	}

	private bool IsSlotRequireTag(Slot slot, Tag tag)
	{
		return slot.requireTags.Any((Tag e) => e.Hash == tag.Hash);
	}
}
public class CharacterItemControl : MonoBehaviour
{
	public CharacterMainControl characterMainControl;

	private Inventory inventory => characterMainControl.CharacterItem.Inventory;

	public bool PickupItem(Item item)
	{
		if (item == null)
		{
			return false;
		}
		if (inventory != null)
		{
			item.AgentUtilities.ReleaseActiveAgent();
			item.Detach();
			bool flag = false;
			bool? flag2 = characterMainControl.CharacterItem.TryPlug(item, emptyOnly: true);
			if ((flag2.HasValue && flag2.Value) || ((!characterMainControl.IsMainCharacter) ? characterMainControl.CharacterItem.Inventory.AddAndMerge(item) : ItemUtilities.SendToPlayerCharacterInventory(item)))
			{
				return true;
			}
		}
		item.Drop(base.transform.position, createRigidbody: true, Vector3.forward, 360f);
		return false;
	}
}
public enum AimTypes
{
	normalAim,
	characterSkill,
	handheldSkill
}
public class CharacterMainControl : MonoBehaviour
{
	public enum WeightStates
	{
		light,
		normal,
		heavy,
		superHeavy,
		overWeight
	}

	public CharacterRandomPreset characterPreset;

	private AudioManager.VoiceType audioVoiceType;

	private AudioManager.FootStepMaterialType footStepMaterialType;

	[SerializeField]
	private Teams team;

	private Item characterItem;

	public Movement movementControl;

	public ItemAgentHolder agentHolder;

	public CA_Carry carryAction;

	public CharacterModel characterModel;

	private bool hidden;

	public InteractableLootbox deadLootBoxPrefab;

	public Transform modelRoot;

	private Vector3 moveInput;

	private bool runInput;

	private bool adsInput;

	private const float defaultAimRange = 8f;

	private AimTypes aimType;

	private float disableTriggerTimer;

	public List<Buff.BuffExclusiveTags> buffResist;

	private Vector3 inputAimPoint;

	private CharacterActionBase currentAction;

	public CA_Reload reloadAction;

	public CA_Skill skillAction;

	public CA_UseItem useItemAction;

	public static Action<CharacterMainControl, Inventory, int> OnMainCharacterInventoryChangedEvent;

	public static Action<CharacterMainControl, Slot> OnMainCharacterSlotContentChangedEvent;

	private int relatedScene;

	[SerializeField]
	private Health health;

	[SerializeField]
	private CharacterItemControl itemControl;

	public CA_Interact interactAction;

	[SerializeField]
	private CharacterEquipmentController equipmentController;

	public static Action<CharacterMainControl, DuckovItemAgent> OnMainCharacterChangeHoldItemAgentEvent;

	[SerializeField]
	private CharacterBuffManager buffManager;

	private int holdWeaponBeforeUse;

	public CA_Dash dashAction;

	public CA_Attack attackAction;

	public DamageReceiver mainDamageReceiver;

	private HashSet<GameObject> nearByHalfObsticles;

	private List<Item> weaponsTemp = new List<Item>();

	private int weaponSwitchIndex;

	private WeightStates weightState = WeightStates.normal;

	private int meleeWeaponSlotHash = "MeleeWeapon".GetHashCode();

	private int primWeaponSlotHash = "PrimaryWeapon".GetHashCode();

	private int secWeaponSlotHash = "SecondaryWeapon".GetHashCode();

	private float staminaRecoverTimer;

	private float variableTickTimer;

	public const float weightThreshold_Light = 0.25f;

	public const float weightThreshold_Heavy = 0.5f;

	public const float weightThreshold_superWeight = 0.75f;

	private string hideShowRecorder;

	private int walkSpeedHash = "WalkSpeed".GetHashCode();

	private int walkAccHash = "WalkAcc".GetHashCode();

	private int runSpeedHash = "RunSpeed".GetHashCode();

	private int stormProtectionHash = "StormProtection".GetHashCode();

	private int waterEnergyRecoverMultiplierHash = "WaterEnergyRecoverMultiplier".GetHashCode();

	private int gunDistanceMultiplierHash = "GunDistanceMultiplier".GetHashCode();

	private int moveabilityHash = "Moveability".GetHashCode();

	private int runAccHash = "RunAcc".GetHashCode();

	private int turnSpeedHash = "TurnSpeed".GetHashCode();

	private int aimTurnSpeedHash = "AimTurnSpeed".GetHashCode();

	private int dashSpeedHash = "DashSpeed".GetHashCode();

	private int dashCanControlHash = "DashCanControl".GetHashCode();

	private int PetCapcityHash = "PetCapcity".GetHashCode();

	private int maxStaminaHash = "Stamina".GetHashCode();

	private float currentStamina;

	private int staminaDrainRateHash = "StaminaDrainRate".GetHashCode();

	private int staminaRecoverRateHash = "StaminaRecoverRate".GetHashCode();

	private int staminaRecoverTimeHash = "StaminaRecoverTime".GetHashCode();

	private int visableDistanceFactorHash = "VisableDistanceFactor".GetHashCode();

	private int maxWeightHash = "MaxWeight".GetHashCode();

	private int foodGainHash = "FoodGain".GetHashCode();

	private int healGainHash = "HealGain".GetHashCode();

	private int maxEnergyHash = "MaxEnergy".GetHashCode();

	private int energyCostPerMinHash = "EnergyCost".GetHashCode();

	private int currentEnergyHash = "CurrentEnergy".GetHashCode();

	private int maxWaterHash = "MaxWater".GetHashCode();

	private int waterCostPerMinHash = "WaterCost".GetHashCode();

	private bool starve;

	private bool thirsty;

	private int currentWaterHash = "CurrentWater".GetHashCode();

	private int NightVisionAbilityHash = "NightVisionAbility".GetHashCode();

	private int NightVisionTypeHash = "NightVisionType".GetHashCode();

	private int HearingAbilityHash = "HearingAbility".GetHashCode();

	private int SoundVisableHash = "SoundVisable".GetHashCode();

	private int viewAngleHash = "ViewAngle".GetHashCode();

	private int viewDistanceHash = "ViewDistance".GetHashCode();

	private int senseRangeHash = "SenseRange".GetHashCode();

	private static int meleeDamageMultiplierHash = "MeleeDamageMultiplier".GetHashCode();

	private static int meleeCritRateGainHash = "MeleeCritRateGain".GetHashCode();

	private static int meleeCritDamageGainHash = "MeleeCritDamageGain".GetHashCode();

	private static int gunDamageMultiplierHash = "GunDamageMultiplier".GetHashCode();

	private static int reloadSpeedGainHash = "ReloadSpeedGain".GetHashCode();

	private static int gunCritRateGainHash = "GunCritRateGain".GetHashCode();

	private static int gunBulletSpeedMultiplierHash = "BulletSpeedMultiplier".GetHashCode();

	private static int gunCritDamageGainHash = "GunCritDamageGain".GetHashCode();

	private static int recoilControlHash = "RecoilControl".GetHashCode();

	private static int GunScatterMultiplierHash = "GunScatterMultiplier".GetHashCode();

	private static int InventoryCapacityHash = "InventoryCapacity".GetHashCode();

	private static int GasMaskHash = "GasMask".GetHashCode();

	private int walkSoundRangeHash = "WalkSoundRange".GetHashCode();

	private int runSoundRangeHash = "RunSoundRange".GetHashCode();

	private static int flashLightHash = "FlashLight".GetHashCode();

	public AudioManager.VoiceType AudioVoiceType
	{
		get
		{
			return audioVoiceType;
		}
		set
		{
			audioVoiceType = value;
			if (base.gameObject.activeInHierarchy)
			{
				AudioManager.SetVoiceType(base.gameObject, audioVoiceType);
			}
		}
	}

	public AudioManager.FootStepMaterialType FootStepMaterialType
	{
		get
		{
			return footStepMaterialType;
		}
		set
		{
			footStepMaterialType = value;
		}
	}

	public static CharacterMainControl Main
	{
		get
		{
			if (LevelManager.Instance == null)
			{
				return null;
			}
			return LevelManager.Instance.MainCharacter;
		}
	}

	public Teams Team => team;

	public Item CharacterItem => characterItem;

	public DuckovItemAgent CurrentHoldItemAgent => agentHolder.CurrentHoldItemAgent;

	public bool Hidden => hidden;

	public Transform CurrentUsingAimSocket
	{
		get
		{
			if (agentHolder.CurrentUsingSocket == null || GetMeleeWeapon() != null)
			{
				return base.transform;
			}
			return agentHolder.CurrentUsingSocket;
		}
	}

	public Transform RightHandSocket
	{
		get
		{
			if ((bool)characterModel && (bool)characterModel.RightHandSocket)
			{
				return characterModel.RightHandSocket;
			}
			return null;
		}
	}

	public Vector3 CurrentAimDirection => modelRoot.forward;

	public Vector3 CurrentMoveDirection => movementControl.CurrentMoveDirectionXZ;

	public float AnimationMoveSpeedValue => movementControl.GetMoveAnimationValue();

	public Vector2 AnimationLocalMoveDirectionValue => movementControl.GetLocalMoveDirectionAnimationValue();

	public bool Running => movementControl.Running;

	public bool IsOnGround => movementControl.IsOnGround;

	public Vector3 Velocity => movementControl.Velocity;

	public bool ThermalOn
	{
		get
		{
			int num = Mathf.RoundToInt(NightVisionType);
			return GameManager.NightVision.nightVisionTypes[num].thermalOn;
		}
	}

	public bool IsInAdsInput
	{
		get
		{
			if (!adsInput)
			{
				return false;
			}
			if (CurrentAction != null && CurrentAction.Running)
			{
				return false;
			}
			if (Running)
			{
				return false;
			}
			return true;
		}
	}

	public float AdsValue
	{
		get
		{
			ItemAgent_Gun gun = GetGun();
			if ((bool)gun)
			{
				return gun.AdsValue;
			}
			if (CurrentAction != null && CurrentAction.Running)
			{
				return 0f;
			}
			if (Running)
			{
				return 0f;
			}
			return adsInput ? 1 : 0;
		}
	}

	public AimTypes AimType => aimType;

	public bool NeedToSearchTarget
	{
		get
		{
			if (InputManager.InputDevice != InputManager.InputDevices.touch)
			{
				return false;
			}
			if ((bool)GetGun() || (bool)GetMeleeWeapon())
			{
				return true;
			}
			return false;
		}
	}

	public CharacterActionBase CurrentAction => currentAction;

	public Health Health => health;

	public Vector3 MoveInput => movementControl.MoveInput;

	public CharacterEquipmentController EquipmentController => equipmentController;

	public bool Dashing
	{
		get
		{
			if (dashAction != null)
			{
				return dashAction.Running;
			}
			return false;
		}
	}

	public bool IsMainCharacter
	{
		get
		{
			if (LevelManager.Instance == null)
			{
				return false;
			}
			return LevelManager.Instance.MainCharacter == this;
		}
	}

	public float CharacterWalkSpeed
	{
		get
		{
			float floatStatValue = GetFloatStatValue(walkSpeedHash);
			floatStatValue *= CharacterMoveability;
			ItemAgent_Gun gun = GetGun();
			if ((bool)gun)
			{
				float moveSpeedMultiplier = gun.MoveSpeedMultiplier;
				if (moveSpeedMultiplier > 0f)
				{
					floatStatValue *= moveSpeedMultiplier;
				}
			}
			else
			{
				ItemAgent_MeleeWeapon meleeWeapon = GetMeleeWeapon();
				if ((bool)meleeWeapon)
				{
					float moveSpeedMultiplier2 = meleeWeapon.MoveSpeedMultiplier;
					if (moveSpeedMultiplier2 > 0f)
					{
						floatStatValue *= moveSpeedMultiplier2;
					}
				}
			}
			return floatStatValue;
		}
	}

	public float AdsWalkSpeedMultiplier
	{
		get
		{
			ItemAgent_Gun gun = GetGun();
			if ((bool)gun)
			{
				return gun.AdsWalkSpeedMultiplier;
			}
			return 0.5f;
		}
	}

	public float CharacterOriginWalkSpeed
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStat(walkSpeedHash).BaseValue;
			}
			return 0f;
		}
	}

	public float CharacterRunSpeed
	{
		get
		{
			float floatStatValue = GetFloatStatValue(runSpeedHash);
			floatStatValue *= CharacterMoveability;
			ItemAgent_Gun gun = GetGun();
			if ((bool)gun)
			{
				float moveSpeedMultiplier = gun.MoveSpeedMultiplier;
				if (moveSpeedMultiplier > 0f)
				{
					floatStatValue *= moveSpeedMultiplier;
				}
			}
			else
			{
				ItemAgent_MeleeWeapon meleeWeapon = GetMeleeWeapon();
				if ((bool)meleeWeapon)
				{
					float moveSpeedMultiplier2 = meleeWeapon.MoveSpeedMultiplier;
					if (moveSpeedMultiplier2 > 0f)
					{
						floatStatValue *= moveSpeedMultiplier2;
					}
				}
			}
			return floatStatValue;
		}
	}

	public float StormProtection => GetFloatStatValue(stormProtectionHash);

	public float WaterEnergyRecoverMultiplier => GetFloatStatValue(waterEnergyRecoverMultiplierHash);

	public float GunDistanceMultiplier => GetFloatStatValue(gunDistanceMultiplierHash);

	public float CharacterMoveability => GetFloatStatValue(moveabilityHash);

	public float CharacterRunAcc => GetFloatStatValue(runAccHash);

	public float CharacterTurnSpeed => GetFloatStatValue(turnSpeedHash) * CharacterMoveability;

	public float CharacterAimTurnSpeed => GetFloatStatValue(aimTurnSpeedHash) * CharacterMoveability;

	public float DashSpeed => GetFloatStatValue(dashSpeedHash);

	public int PetCapcity => Mathf.RoundToInt(GetFloatStatValue(PetCapcityHash));

	public bool DashCanControl
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(dashCanControlHash) > 0f;
			}
			return true;
		}
		set
		{
			characterItem.GetStat(dashCanControlHash).BaseValue = (value ? 1 : 0);
		}
	}

	public float MaxStamina
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(maxStaminaHash);
			}
			return 0f;
		}
	}

	public float CurrentStamina => currentStamina;

	public float StaminaDrainRate
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(staminaDrainRateHash);
			}
			return 0f;
		}
	}

	public float StaminaRecoverRate
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(staminaRecoverRateHash);
			}
			return 0f;
		}
	}

	public float StaminaRecoverTime
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(staminaRecoverTimeHash);
			}
			return 0f;
		}
	}

	public float CharacterWalkAcc => GetFloatStatValue(walkAccHash);

	public float VisableDistanceFactor => GetFloatStatValue(visableDistanceFactorHash);

	public float MaxWeight
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(maxWeightHash);
			}
			return 0f;
		}
	}

	public float FoodGain
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(foodGainHash);
			}
			return 0f;
		}
	}

	public float HealGain
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(healGainHash);
			}
			return 0f;
		}
	}

	public float MaxEnergy
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(maxEnergyHash);
			}
			return 0f;
		}
	}

	public float EnergyCostPerMin
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(energyCostPerMinHash);
			}
			return 0f;
		}
	}

	public float CurrentEnergy
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.Variables.GetFloat(currentEnergyHash);
			}
			return 0f;
		}
		set
		{
			if ((bool)characterItem)
			{
				characterItem.Variables.SetFloat(currentEnergyHash, value);
			}
		}
	}

	public float MaxWater
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(maxWaterHash);
			}
			return 0f;
		}
	}

	public float WaterCostPerMin
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(waterCostPerMinHash);
			}
			return 0f;
		}
	}

	public float CurrentWater
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.Variables.GetFloat(currentWaterHash);
			}
			return 0f;
		}
		set
		{
			if ((bool)characterItem)
			{
				characterItem.Variables.SetFloat(currentWaterHash, value);
			}
		}
	}

	public float NightVisionAbility => GetFloatStatValue(NightVisionAbilityHash);

	public float NightVisionType => GetFloatStatValue(NightVisionTypeHash);

	public float HearingAbility => GetFloatStatValue(HearingAbilityHash);

	public float SoundVisable => GetFloatStatValue(SoundVisableHash);

	public float ViewAngle => GetFloatStatValue(viewAngleHash);

	public float ViewDistance => GetFloatStatValue(viewDistanceHash);

	public float SenseRange => GetFloatStatValue(senseRangeHash);

	public float MeleeDamageMultiplier
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(meleeDamageMultiplierHash);
			}
			return 0f;
		}
	}

	public float MeleeCritRateGain
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(meleeCritRateGainHash);
			}
			return 0f;
		}
	}

	public float MeleeCritDamageGain
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(meleeCritDamageGainHash);
			}
			return 0f;
		}
	}

	public float GunDamageMultiplier
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(gunDamageMultiplierHash);
			}
			return 0f;
		}
	}

	public float ReloadSpeedGain
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(reloadSpeedGainHash);
			}
			return 0f;
		}
	}

	public float GunCritRateGain
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(gunCritRateGainHash);
			}
			return 0f;
		}
	}

	public float GunCritDamageGain
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(gunCritDamageGainHash);
			}
			return 0f;
		}
	}

	public float GunBulletSpeedMultiplier
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(gunBulletSpeedMultiplierHash);
			}
			return 1f;
		}
	}

	public float RecoilControl
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(recoilControlHash);
			}
			return 1f;
		}
	}

	public float GunScatterMultiplier
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(GunScatterMultiplierHash);
			}
			return 1f;
		}
	}

	public float InventoryCapacity
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(InventoryCapacityHash);
			}
			return 16f;
		}
	}

	public bool HasGasMask
	{
		get
		{
			float num = 0f;
			if ((bool)characterItem)
			{
				num = characterItem.GetStatValue(GasMaskHash);
			}
			return num > 0.1f;
		}
	}

	public float WalkSoundRange
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(walkSoundRangeHash);
			}
			return 0f;
		}
	}

	public float RunSoundRange
	{
		get
		{
			if ((bool)characterItem)
			{
				return characterItem.GetStatValue(runSoundRangeHash);
			}
			return 0f;
		}
	}

	public bool FlashLight
	{
		get
		{
			if ((bool)CurrentHoldItemAgent)
			{
				return CurrentHoldItemAgent.Item.GetStatValue(flashLightHash) > 0f;
			}
			return false;
		}
	}

	public string SoundKey => "Default";

	public event Action<Teams> OnTeamChanged;

	public event Action<CharacterMainControl, Vector3> OnSetPositionEvent;

	public event Action<DamageInfo> BeforeCharacterSpawnLootOnDead;

	public static event Action<Item> OnMainCharacterStartUseItem;

	public event Action<CharacterActionBase> OnActionStartEvent;

	public event Action<CharacterActionBase> OnActionProgressFinishEvent;

	public event Action<DuckovItemAgent> OnHoldAgentChanged;

	public event Action<DuckovItemAgent> OnShootEvent;

	public event Action TryCatchFishInputEvent;

	public event Action<DuckovItemAgent> OnAttackEvent;

	public event Action OnSkillStartReleaseEvent;

	public float GetAimRange()
	{
		float result = 8f;
		switch (aimType)
		{
		case AimTypes.normalAim:
		{
			ItemAgent_Gun gun = GetGun();
			if (gun != null)
			{
				result = gun.BulletDistance;
				result -= 0.4f;
				break;
			}
			ItemAgent_MeleeWeapon meleeWeapon = GetMeleeWeapon();
			if (meleeWeapon != null)
			{
				result = meleeWeapon.AttackRange;
			}
			break;
		}
		case AimTypes.characterSkill:
		{
			SkillBase skill3 = skillAction.characterSkillKeeper.Skill;
			if ((bool)skill3)
			{
				result = skill3.SkillContext.castRange;
			}
			break;
		}
		case AimTypes.handheldSkill:
		{
			ItemSetting_Skill skill = agentHolder.Skill;
			if ((bool)skill)
			{
				SkillBase skill2 = skill.Skill;
				if ((bool)skill2)
				{
					result = skill2.SkillContext.castRange;
				}
			}
			break;
		}
		}
		return result;
	}

	public Vector3 GetCurrentAimPoint()
	{
		return inputAimPoint;
	}

	public Vector3 GetCurrentSkillAimPoint()
	{
		SkillBase currentRunningSkill = skillAction.CurrentRunningSkill;
		if (!currentRunningSkill)
		{
			return inputAimPoint;
		}
		float castRange = currentRunningSkill.SkillContext.castRange;
		float y = inputAimPoint.y;
		Vector3 vector = inputAimPoint - base.transform.position;
		vector.y = 0f;
		float num = vector.magnitude;
		vector.Normalize();
		if (num > castRange)
		{
			num = castRange;
		}
		Vector3 result = base.transform.position + vector * num;
		result.y = y;
		return result;
	}

	private void OnMainCharacterInventoryChanged(Inventory inventory, int index)
	{
		ItemUtilities.NotifyPlayerItemOperation();
		OnMainCharacterInventoryChangedEvent?.Invoke(this, inventory, index);
	}

	private void OnMainCharacterSlotContentChanged(Item item, Slot slot)
	{
		OnMainCharacterSlotContentChangedEvent?.Invoke(this, slot);
		CheckTakeoutWeaponWhileEquip(slot);
	}

	private void CheckTakeoutWeaponWhileEquip(Slot slot)
	{
		if (!(slot.Content == null) && !(CurrentHoldItemAgent != null) && slot.Content.Tags.Contains("Weapon"))
		{
			agentHolder.ChangeHoldItem(slot.Content);
		}
	}

	public void SwitchWeapon(int dir)
	{
		weaponsTemp.Clear();
		weaponSwitchIndex = -1;
		Item item = null;
		if (CurrentHoldItemAgent != null)
		{
			item = CurrentHoldItemAgent.Item;
		}
		Item content = PrimWeaponSlot().Content;
		if ((bool)content)
		{
			weaponsTemp.Add(content);
			if (item == content)
			{
				weaponSwitchIndex = weaponsTemp.Count - 1;
			}
		}
		content = SecWeaponSlot().Content;
		if ((bool)content)
		{
			weaponsTemp.Add(content);
			if (item == content)
			{
				weaponSwitchIndex = weaponsTemp.Count - 1;
			}
		}
		content = MeleeWeaponSlot().Content;
		if ((bool)content)
		{
			weaponsTemp.Add(content);
			if (item == content)
			{
				weaponSwitchIndex = weaponsTemp.Count - 1;
			}
		}
		if (weaponsTemp.Count > 0)
		{
			weaponSwitchIndex -= dir;
			if (weaponSwitchIndex < 0)
			{
				weaponSwitchIndex = weaponsTemp.Count - 1;
			}
			if (weaponSwitchIndex >= weaponsTemp.Count)
			{
				weaponSwitchIndex = 0;
			}
			ChangeHoldItem(weaponsTemp[weaponSwitchIndex]);
		}
	}

	public bool CanEditInventory()
	{
		if ((bool)currentAction && currentAction.Running && !currentAction.CanEditInventory())
		{
			return false;
		}
		return true;
	}

	public void SetMoveInput(Vector3 moveInput)
	{
		movementControl.SetMoveInput(moveInput);
	}

	public Slot MeleeWeaponSlot()
	{
		return GetSlot(meleeWeaponSlotHash);
	}

	public Slot PrimWeaponSlot()
	{
		return GetSlot(primWeaponSlotHash);
	}

	public Slot SecWeaponSlot()
	{
		return GetSlot(secWeaponSlotHash);
	}

	public Slot GetSlot(int hash)
	{
		if (characterItem == null)
		{
			return null;
		}
		return characterItem.Slots.GetSlot(hash);
	}

	private void Awake()
	{
		nearByHalfObsticles = new HashSet<GameObject>();
		agentHolder.OnHoldAgentChanged += OnChangeItemAgentChangedFunc;
	}

	private void StoreHoldWeaponBeforeUse()
	{
		if ((bool)agentHolder.CurrentHoldItemAgent)
		{
			Item item = agentHolder.CurrentHoldItemAgent.Item;
			if (item == MeleeWeaponSlot().Content)
			{
				holdWeaponBeforeUse = -1;
			}
			else if (item == PrimWeaponSlot().Content)
			{
				holdWeaponBeforeUse = 0;
			}
			else if (item == SecWeaponSlot().Content)
			{
				holdWeaponBeforeUse = 1;
			}
		}
	}

	public bool SwitchToFirstAvailableWeapon()
	{
		if (SwitchToWeapon(0))
		{
			return true;
		}
		if (SwitchToWeapon(1))
		{
			return true;
		}
		return SwitchToWeapon(-1);
	}

	public bool SwitchToWeapon(int index)
	{
		Slot slot = null;
		if (index == -1)
		{
			slot = MeleeWeaponSlot();
		}
		switch (index)
		{
		case 0:
			slot = PrimWeaponSlot();
			break;
		case 1:
			slot = SecWeaponSlot();
			break;
		}
		if (slot == null)
		{
			return false;
		}
		Item content = slot.Content;
		if (content == null)
		{
			return false;
		}
		ChangeHoldItem(content);
		return true;
	}

	public void ToggleNightVision()
	{
		Item faceMaskItem = GetFaceMaskItem();
		if ((bool)faceMaskItem)
		{
			ItemSetting_NightVision component = faceMaskItem.GetComponent<ItemSetting_NightVision>();
			if ((bool)component)
			{
				component.ToggleNightVison();
			}
		}
	}

	public void Dash()
	{
		if (!(dashAction == null) && (!attackAction.Running || attackAction.DamageDealed) && StartAction(dashAction) && !DashCanControl && disableTriggerTimer < 0.6f)
		{
			disableTriggerTimer = 0.6f;
		}
	}

	public void TryCatchFishInput()
	{
		if ((bool)currentAction && currentAction.Running)
		{
			Action_FishingV2 action_FishingV = currentAction as Action_FishingV2;
			if ((bool)action_FishingV)
			{
				action_FishingV.TryCatch();
			}
		}
	}

	public bool HasNearByHalfObsticle()
	{
		if (nearByHalfObsticles.Count <= 0)
		{
			return false;
		}
		foreach (GameObject nearByHalfObsticle in nearByHalfObsticles)
		{
			if (nearByHalfObsticle != null)
			{
				return true;
			}
		}
		return false;
	}

	public void SwitchToWeaponBeforeUse()
	{
		SwitchToWeapon(holdWeaponBeforeUse);
		holdWeaponBeforeUse = -1;
	}

	public void SetForceMoveVelocity(Vector3 _velocity)
	{
		movementControl.SetForceMoveVelocity(_velocity);
	}

	public void SetAimPoint(Vector3 _aimPoint)
	{
		inputAimPoint = _aimPoint;
	}

	public bool Attack()
	{
		if (GetMeleeWeapon() == null)
		{
			return false;
		}
		if (!attackAction.IsReady())
		{
			return false;
		}
		bool result = StartAction(attackAction);
		Action<DuckovItemAgent> action = this.OnAttackEvent;
		if (action != null)
		{
			action(GetMeleeWeapon());
			return result;
		}
		return result;
	}

	public void SetAimType(AimTypes _aimType)
	{
		aimType = _aimType;
	}

	public void SetRunInput(bool _runInput)
	{
		runInput = _runInput;
	}

	public void SetAdsInput(bool _adsInput)
	{
		adsInput = _adsInput;
	}

	public bool TryToReload(Item preferedBulletToLoad = null)
	{
		reloadAction.preferedBulletToReload = preferedBulletToLoad;
		bool num = StartAction(reloadAction);
		if (!num)
		{
			reloadAction.preferedBulletToReload = null;
		}
		return num;
	}

	public bool SetSkill(SkillTypes skillType, SkillBase skill, GameObject bindingObject)
	{
		return skillAction.SetSkillOfType(skillType, skill, bindingObject);
	}

	public bool StartSkillAim(SkillTypes skillType)
	{
		if (skillAction.Running)
		{
			return false;
		}
		skillAction.SetNextSkillType(skillType);
		return StartAction(skillAction);
	}

	public bool ReleaseSkill(SkillTypes skillType)
	{
		this.OnSkillStartReleaseEvent?.Invoke();
		return skillAction.ReleaseSkill(skillType);
	}

	public bool CancleSkill()
	{
		return skillAction.StopAction();
	}

	public SkillBase GetCurrentRunningSkill()
	{
		if (!skillAction.Running)
		{
			return null;
		}
		return skillAction.CurrentRunningSkill;
	}

	public bool GetGunReloadable()
	{
		return reloadAction.GetGunReloadable();
	}

	public bool CanUseHand()
	{
		if (currentAction != null && !currentAction.CanUseHand())
		{
			return false;
		}
		return true;
	}

	public bool CanControlAim()
	{
		if (currentAction != null && !currentAction.CanControlAim())
		{
			return false;
		}
		return true;
	}

	public bool StartAction(CharacterActionBase newAction)
	{
		if (!newAction.IsReady())
		{
			return false;
		}
		bool flag = true;
		if ((bool)currentAction && currentAction.Running)
		{
			flag = newAction.ActionPriority() > currentAction.ActionPriority() && currentAction.StopAction();
		}
		if (flag)
		{
			currentAction = null;
			if (newAction.StartActionByCharacter(this))
			{
				currentAction = newAction;
				this.OnActionStartEvent?.Invoke(currentAction);
				return true;
			}
		}
		return false;
	}

	public void SwitchHoldAgentInSlot(int slotHash)
	{
		ChangeHoldItem(characterItem.Slots.GetSlot(slotHash)?.Content);
	}

	public void SwitchInteractSelection(int dir)
	{
		interactAction.SwitchInteractable(dir);
	}

	public void SetTeam(Teams _team)
	{
		team = _team;
		health.team = team;
		this.OnTeamChanged?.Invoke(_team);
		if (Main == this)
		{
			characterItem.Inventory.onContentChanged -= OnMainCharacterInventoryChanged;
			characterItem.Inventory.onContentChanged += OnMainCharacterInventoryChanged;
			characterItem.onSlotContentChanged -= OnMainCharacterSlotContentChanged;
			characterItem.onSlotContentChanged += OnMainCharacterSlotContentChanged;
		}
		if ((bool)characterModel)
		{
			characterModel.SyncHiddenToMainCharacter();
		}
	}

	public ItemAgent_Gun GetGun()
	{
		return agentHolder.CurrentHoldGun;
	}

	public ItemAgent_MeleeWeapon GetMeleeWeapon()
	{
		return agentHolder.CurrentHoldMeleeWeapon;
	}

	public bool ChangeHoldItem(Item item)
	{
		if (!CanEditInventory())
		{
			return false;
		}
		if (agentHolder.CurrentHoldItemAgent != null && item == agentHolder.CurrentHoldItemAgent.Item)
		{
			return false;
		}
		agentHolder.ChangeHoldItem(item);
		return true;
	}

	private void OnChangeItemAgentChangedFunc(DuckovItemAgent agent)
	{
		this.OnHoldAgentChanged?.Invoke(agent);
		if (IsMainCharacter)
		{
			OnMainCharacterChangeHoldItemAgentEvent?.Invoke(this, agent);
		}
	}

	private void Update()
	{
		if (LevelManager.LevelInited)
		{
			interactAction.SearchInteractableAround();
			UpdateAction(Time.deltaTime);
			movementControl.UpdateMovement();
			UpdateStats(Time.deltaTime);
			TickVariables(Time.deltaTime, 1f);
			if (IsMainCharacter)
			{
				UpdateThirstyAndStarve();
				UpdateWeightState();
			}
			disableTriggerTimer -= Time.deltaTime;
		}
	}

	private void LateUpdate()
	{
		UpdateInventoryCapacity();
	}

	public void SetItem(Item _item)
	{
		if (!(_item == null))
		{
			characterItem = _item;
			_item.transform.SetParent(base.transform, worldPositionStays: false);
			currentStamina = MaxStamina;
			health.SetItemAndCharacter(_item, this);
			health.OnDeadEvent.AddListener(OnDead);
			equipmentController.SetItem(_item);
			_item.Inventory.SetCapacity(Mathf.RoundToInt(InventoryCapacity));
			health.Init();
		}
	}

	private void UpdateInventoryCapacity()
	{
		if (LevelManager.Instance.MainCharacter != this || characterItem == null || characterItem.Inventory == null || characterItem.Inventory.Loading)
		{
			return;
		}
		int num = Mathf.RoundToInt(InventoryCapacity);
		int capacity = characterItem.Inventory.Capacity;
		if (capacity == num)
		{
			return;
		}
		characterItem.Inventory.SetCapacity(num);
		if (capacity <= num)
		{
			return;
		}
		int count = characterItem.Inventory.Content.Count;
		if (count < num)
		{
			return;
		}
		List<Item> list = new List<Item>();
		for (int i = num; i < count; i++)
		{
			Item item = characterItem.Inventory.Content[i];
			if (item != null)
			{
				list.Add(item);
				item.Detach();
			}
		}
		foreach (Item item2 in list)
		{
			if (!characterItem.Inventory.AddAndMerge(item2))
			{
				item2.Drop(base.transform.position, createRigidbody: true, Vector3.forward, 360f);
			}
		}
	}

	private void OnDead(DamageInfo dmgInfo)
	{
		if (LevelManager.Instance.MainCharacter != this)
		{
			Quaternion rotation = Quaternion.identity;
			if ((bool)characterModel)
			{
				rotation = characterModel.transform.rotation;
			}
			if ((bool)dmgInfo.fromCharacter && dmgInfo.fromCharacter.IsMainCharacter && (bool)characterPreset && characterPreset.nameKey != "")
			{
				SavesCounter.AddKillCount(characterPreset.nameKey);
			}
			this.BeforeCharacterSpawnLootOnDead?.Invoke(dmgInfo);
			InteractableLootbox.CreateFromItem(characterItem, base.transform.position + Vector3.up * 0.1f, rotation, moveToMainScene: true, deadLootBoxPrefab, IsMainCharacter);
		}
		if (relatedScene != -1)
		{
			SetActiveByPlayerDistance.Unregister(base.gameObject, relatedScene);
		}
	}

	public void Trigger(bool trigger, bool triggerThisFrame, bool releaseThisFrame)
	{
		if (Running || disableTriggerTimer > 0f)
		{
			trigger = false;
			triggerThisFrame = false;
		}
		else if (trigger && CharacterMoveability > 0.5f)
		{
			movementControl.ForceSetAimDirectionToAimPoint();
		}
		agentHolder.SetTrigger(trigger, triggerThisFrame, releaseThisFrame);
	}

	public bool CanMove()
	{
		if (currentAction != null && !currentAction.CanMove())
		{
			return false;
		}
		if (CharacterWalkSpeed <= 0f)
		{
			return false;
		}
		return true;
	}

	public void PopText(string text, float speed = -1f)
	{
		if (LevelManager.LevelInited && (bool)Main && !(Vector3.Distance(base.transform.position, Main.transform.position) > 55f))
		{
			float yOffset = 2f;
			if ((bool)characterModel && (bool)characterModel.HelmatSocket)
			{
				yOffset = Vector3.Distance(base.transform.position, characterModel.HelmatSocket.position) + 0.5f;
			}
			DialogueBubblesManager.Show(text, base.transform, yOffset, needInteraction: false, skippable: false, speed).Forget();
		}
	}

	public bool CanRun()
	{
		if (currentAction != null && !currentAction.CanRun())
		{
			return false;
		}
		float num = currentStamina / MaxStamina;
		if (num < 0.2f && !Running)
		{
			return false;
		}
		if (num <= 0f)
		{
			return false;
		}
		return runInput;
	}

	public bool IsAiming()
	{
		if (!movementControl.Running && (currentAction == null || !currentAction.Running || currentAction.CanControlAim()))
		{
			return true;
		}
		return false;
	}

	public void DestroyCharacter()
	{
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public void TriggerShootEvent(DuckovItemAgent shootByAgent)
	{
		this.OnShootEvent?.Invoke(shootByAgent);
	}

	public void SetCharacterModel(CharacterModel _characterModel)
	{
		bool flag = true;
		if (characterModel != null)
		{
			flag = false;
			UnityEngine.Object.Destroy(characterModel.gameObject);
		}
		characterModel = _characterModel;
		_characterModel.OnMainCharacterSetted(this);
		_characterModel.transform.SetParent(modelRoot, worldPositionStays: false);
		_characterModel.transform.localPosition = Vector3.zero;
		_characterModel.transform.localRotation = quaternion.identity;
		Transform helmatSocket = _characterModel.HelmatSocket;
		if ((bool)helmatSocket)
		{
			HeadCollider headCollider = UnityEngine.Object.Instantiate(GameplayDataSettings.Prefabs.HeadCollider, helmatSocket);
			headCollider.transform.localPosition = Vector3.zero;
			headCollider.transform.localScale = Vector3.one;
			headCollider.Init(this);
			CapsuleCollider component = mainDamageReceiver.GetComponent<CapsuleCollider>();
			if ((bool)component)
			{
				float num = (component.height = headCollider.transform.localScale.y * 0.5f + headCollider.transform.position.y - base.transform.position.y + 0.5f);
				component.center = Vector3.up * num * 0.5f;
			}
		}
		if (!LevelManager.LevelInited || flag || !(characterItem != null))
		{
			return;
		}
		foreach (Slot slot in characterItem.Slots)
		{
			if ((bool)slot.Content)
			{
				slot.ForceInvokeSlotContentChangedEvent();
			}
		}
	}

	private void OnDestroy()
	{
		if ((bool)characterItem && (bool)characterItem.Inventory)
		{
			characterItem.Inventory.onContentChanged -= OnMainCharacterInventoryChanged;
		}
		if ((bool)characterItem)
		{
			characterItem.DestroyTree();
		}
		if ((bool)health)
		{
			health.OnDeadEvent.RemoveListener(OnDead);
		}
		if (relatedScene != -1)
		{
			SetActiveByPlayerDistance.Unregister(base.gameObject, relatedScene);
		}
	}

	private void UpdateAction(float deltaTime)
	{
		if ((bool)currentAction)
		{
			currentAction.UpdateAction(deltaTime);
			if ((bool)currentAction && !currentAction.Running)
			{
				currentAction = null;
			}
		}
	}

	private void UpdateStats(float deltaTime)
	{
		if (movementControl.Running)
		{
			UseStamina(StaminaDrainRate * deltaTime);
			return;
		}
		staminaRecoverTimer += deltaTime;
		if (staminaRecoverTimer >= StaminaRecoverTime)
		{
			currentStamina = Mathf.MoveTowards(currentStamina, MaxStamina, StaminaRecoverRate * deltaTime);
		}
	}

	public void TickVariables(float deltaTime, float tickTime)
	{
		variableTickTimer += deltaTime;
		if (variableTickTimer < tickTime)
		{
			return;
		}
		variableTickTimer = 0f;
		if (!IsMainCharacter)
		{
			return;
		}
		float currentEnergy = CurrentEnergy;
		if (!LevelManager.Instance.IsRaidMap || health.Invincible)
		{
			currentEnergy += 10f * WaterEnergyRecoverMultiplier * tickTime / 60f;
			if (currentEnergy < MaxEnergy * 0.25f)
			{
				currentEnergy = MaxEnergy * 0.25f;
			}
			else if (currentEnergy > MaxEnergy)
			{
				currentEnergy = MaxEnergy;
			}
		}
		else
		{
			currentEnergy -= EnergyCostPerMin * tickTime / 60f;
			if (currentEnergy < 0f)
			{
				currentEnergy = 0f;
			}
		}
		CurrentEnergy = currentEnergy;
		float currentWater = CurrentWater;
		if (!LevelManager.Instance.IsRaidMap || health.Invincible)
		{
			currentWater += 10f * WaterEnergyRecoverMultiplier * tickTime / 60f;
			if (currentWater < MaxWater * 0.25f)
			{
				currentWater = MaxWater * 0.25f;
			}
			else if (currentWater > MaxWater)
			{
				currentWater = MaxWater;
			}
		}
		else
		{
			currentWater -= WaterCostPerMin * tickTime / 60f;
			if (currentWater < 0f)
			{
				currentWater = 0f;
			}
		}
		CurrentWater = currentWater;
	}

	public void UpdateThirstyAndStarve()
	{
		if (CurrentWater <= 0f != thirsty)
		{
			thirsty = !thirsty;
			if (thirsty)
			{
				AddBuff(GameplayDataSettings.Buffs.Thirsty, this);
			}
			else
			{
				RemoveBuffsByTag(Buff.BuffExclusiveTags.Thirsty, removeOneLayer: false);
			}
		}
		if (CurrentEnergy <= 0f != starve)
		{
			starve = !starve;
			if (starve)
			{
				AddBuff(GameplayDataSettings.Buffs.Starve, this);
			}
			else
			{
				RemoveBuffsByTag(Buff.BuffExclusiveTags.Starve, removeOneLayer: false);
			}
		}
	}

	public void UpdateWeightState()
	{
		float num = CharacterItem.TotalWeight;
		if (carryAction.Running)
		{
			num += carryAction.GetWeight();
		}
		float num2 = num / MaxWeight;
		WeightStates weightStates = WeightStates.light;
		if (!LevelManager.Instance.IsRaidMap)
		{
			weightStates = WeightStates.normal;
		}
		else if (num2 > 1f)
		{
			weightStates = WeightStates.overWeight;
		}
		else if (num2 > 0.75f)
		{
			weightStates = WeightStates.superHeavy;
		}
		else if (num2 > 0.25f)
		{
			weightStates = WeightStates.normal;
		}
		if (weightStates != weightState)
		{
			weightState = weightStates;
			RemoveBuffsByTag(Buff.BuffExclusiveTags.Weight, removeOneLayer: false);
			switch (weightStates)
			{
			case WeightStates.light:
				AddBuff(GameplayDataSettings.Buffs.Weight_Light, this);
				break;
			case WeightStates.heavy:
				AddBuff(GameplayDataSettings.Buffs.Weight_Heavy, this);
				break;
			case WeightStates.superHeavy:
				AddBuff(GameplayDataSettings.Buffs.Weight_SuperHeavy, this);
				break;
			case WeightStates.overWeight:
				AddBuff(GameplayDataSettings.Buffs.Weight_Overweight, this);
				break;
			case WeightStates.normal:
				break;
			}
		}
	}

	public bool PickupItem(Item item)
	{
		if (health.IsDead)
		{
			return false;
		}
		item.Inspected = true;
		return itemControl.PickupItem(item);
	}

	public InteractableBase GetInteractableTargetToInteract()
	{
		if ((bool)currentAction && currentAction.ActionPriority() >= interactAction.ActionPriority())
		{
			return null;
		}
		return interactAction.InteractTarget;
	}

	public void Interact(InteractableBase _target)
	{
		if (!currentAction || currentAction.ActionPriority() < interactAction.ActionPriority())
		{
			interactAction.SetInteractableTarget(_target);
			Interact();
		}
	}

	public void Interact()
	{
		if (!health.IsDead)
		{
			if (carryAction.Running)
			{
				carryAction.StopAction();
			}
			else if (!currentAction && GetInteractableTargetToInteract() != null)
			{
				StartAction(interactAction);
			}
		}
	}

	public void AddHealth(float healthValue)
	{
		health.AddHealth(healthValue * (1f + HealGain));
	}

	public void SetRelatedScene(int _relatedScene, bool setActiveByPlayerDistance = true)
	{
		relatedScene = _relatedScene;
		if ((bool)MultiSceneCore.Instance)
		{
			MultiSceneCore.MoveToActiveWithScene(base.gameObject, _relatedScene);
			if (setActiveByPlayerDistance)
			{
				SetActiveByPlayerDistance.Register(base.gameObject, relatedScene);
			}
		}
	}

	public void Carry(Carriable target)
	{
		if ((bool)carryAction && (!(currentAction != null) || !currentAction.Running))
		{
			carryAction.carryTarget = target;
			StartAction(carryAction);
		}
	}

	public void AddEnergy(float energyValue)
	{
		float currentEnergy = CurrentEnergy;
		currentEnergy += energyValue * (1f + FoodGain);
		if (currentEnergy > MaxEnergy)
		{
			currentEnergy = MaxEnergy;
		}
		if (currentEnergy < 0f)
		{
			currentEnergy = 0f;
		}
		CurrentEnergy = currentEnergy;
	}

	public void AddWater(float waterValue)
	{
		float currentWater = CurrentWater;
		currentWater += waterValue * (1f + FoodGain);
		if (currentWater > MaxWater)
		{
			currentWater = MaxWater;
		}
		if (currentWater < 0f)
		{
			currentWater = 0f;
		}
		CurrentWater = currentWater;
	}

	public void DropAllItems()
	{
		if (characterItem == null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		if (characterItem.Inventory != null)
		{
			foreach (Item item in characterItem.Inventory)
			{
				if ((!IsMainCharacter || !item.Tags.Contains(GameplayDataSettings.Tags.DontDropOnDeadInSlot)) && (!IsMainCharacter || !item.Sticky))
				{
					list.Add(item);
				}
			}
		}
		foreach (Slot slot in characterItem.Slots)
		{
			if (slot.Content != null && (!IsMainCharacter || !slot.Content.Tags.Contains(GameplayDataSettings.Tags.DontDropOnDeadInSlot)) && (!IsMainCharacter || !slot.Content.Sticky))
			{
				list.Add(slot.Content);
			}
		}
		foreach (Item item2 in list)
		{
			if (!IsMainCharacter || !item2.Sticky)
			{
				item2.Drop(base.transform.position, createRigidbody: true, Vector3.forward, 360f);
			}
		}
	}

	public void DestroyAllItem()
	{
		if (characterItem == null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		if (characterItem.Inventory != null)
		{
			foreach (Item item in characterItem.Inventory)
			{
				list.Add(item);
			}
		}
		foreach (Slot slot in characterItem.Slots)
		{
			if (slot.Content != null && (!IsMainCharacter || !slot.Content.Tags.Contains(GameplayDataSettings.Tags.DontDropOnDeadInSlot)) && (!IsMainCharacter || !slot.Content.Sticky))
			{
				list.Add(slot.Content);
			}
		}
		foreach (Item item2 in list)
		{
			if (!IsMainCharacter || !item2.Sticky)
			{
				item2.DestroyTree();
			}
		}
	}

	public void DestroyItemsThatNeededToBeDestriedInBase()
	{
		if (characterItem == null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		if (characterItem.Inventory != null)
		{
			foreach (Item item in characterItem.Inventory)
			{
				list.Add(item);
			}
		}
		foreach (Slot slot in characterItem.Slots)
		{
			if (slot.Content != null)
			{
				list.Add(slot.Content);
			}
		}
		foreach (Item item2 in list)
		{
			if (item2.Tags.Contains("DestroyInBase"))
			{
				item2.DestroyTree();
			}
		}
	}

	public void AddSubVisuals(CharacterSubVisuals subVisuals)
	{
		if ((bool)characterModel)
		{
			characterModel.AddSubVisuals(subVisuals);
		}
	}

	public void RemoveVisual(CharacterSubVisuals subVisuals)
	{
		if ((bool)characterModel)
		{
			characterModel.RemoveVisual(subVisuals);
		}
	}

	public void Hide()
	{
		if (!hidden)
		{
			hidden = true;
			if ((bool)characterModel)
			{
				characterModel.SyncHiddenToMainCharacter();
			}
		}
	}

	public void Show()
	{
		health?.RequestHealthBar();
		if (hidden)
		{
			hidden = false;
			if ((bool)characterModel)
			{
				characterModel.SyncHiddenToMainCharacter();
			}
		}
	}

	private void OnEnable()
	{
		if (IsMainCharacter && (bool)health)
		{
			health.showHealthBar = true;
			health.RequestHealthBar();
		}
		AudioManager.SetVoiceType(base.gameObject, audioVoiceType);
	}

	public bool IsNearByHalfObsticle(GameObject target)
	{
		if (target == null || nearByHalfObsticles.Count == 0)
		{
			return false;
		}
		return nearByHalfObsticles.Contains(target);
	}

	public GameObject[] GetNearByHalfObsticles()
	{
		nearByHalfObsticles.RemoveWhere((GameObject go) => go == null);
		return nearByHalfObsticles.ToArray();
	}

	public void AddnearByHalfObsticles(List<GameObject> objs)
	{
		foreach (GameObject obj in objs)
		{
			if (!(obj == null) && !nearByHalfObsticles.Contains(obj))
			{
				nearByHalfObsticles.Add(obj);
			}
		}
	}

	public void RemoveNearByHalfObsticles(List<GameObject> objs)
	{
		foreach (GameObject obj in objs)
		{
			if (!(obj == null) && nearByHalfObsticles.Contains(obj))
			{
				nearByHalfObsticles.Remove(obj);
			}
		}
	}

	public void UseItem(Item item)
	{
		if (IsMainCharacter && !item.UsageUtilities.IsUsable(item, this))
		{
			NotificationText.Push("UI_Item_NotUsable".ToPlainText());
			return;
		}
		StoreHoldWeaponBeforeUse();
		if (item.GetRoot() != characterItem)
		{
			UnityEngine.Debug.Log("pick fail");
			item.Detach();
			item.AgentUtilities.ReleaseActiveAgent();
			item.transform.SetParent(base.transform);
		}
		if (interactAction.Running && interactAction.InteractingTarget is InteractableLootbox)
		{
			interactAction.StopAction();
		}
		useItemAction.SetUseItem(item);
		bool flag = StartAction(useItemAction);
		UnityEngine.Debug.Log($"UseItemSuccess:{flag}");
		if (flag && IsMainCharacter)
		{
			CharacterMainControl.OnMainCharacterStartUseItem?.Invoke(item);
		}
	}

	public CharacterBuffManager GetBuffManager()
	{
		return buffManager;
	}

	public void AddBuff(Buff buffPrefab, CharacterMainControl fromWho = null, int overrideWeaponID = 0)
	{
		if (!buffPrefab || buffResist.Contains(buffPrefab.ExclusiveTag))
		{
			return;
		}
		Buff.BuffExclusiveTags exclusiveTag = buffPrefab.ExclusiveTag;
		if (exclusiveTag != Buff.BuffExclusiveTags.NotExclusive)
		{
			Buff buffByTag = buffManager.GetBuffByTag(exclusiveTag);
			if (buffByTag != null && buffByTag.ID != buffPrefab.ID)
			{
				if (buffByTag.ExclusiveTagPriority > buffPrefab.ExclusiveTagPriority)
				{
					return;
				}
				if (buffByTag.ExclusiveTagPriority == buffPrefab.ExclusiveTagPriority && buffByTag.LimitedLifeTime && buffPrefab.LimitedLifeTime && buffByTag.CurrentLifeTime > buffPrefab.TotalLifeTime)
				{
					buffByTag.fromWho = fromWho;
					if (overrideWeaponID > 0)
					{
						buffByTag.fromWeaponID = overrideWeaponID;
					}
					return;
				}
				buffManager.RemoveBuff(buffByTag, oneLayer: false);
			}
		}
		buffManager.AddBuff(buffPrefab, fromWho, overrideWeaponID);
	}

	public void RemoveBuff(int buffID, bool removeOneLayer)
	{
		buffManager.RemoveBuff(buffID, removeOneLayer);
	}

	public void RemoveBuffsByTag(Buff.BuffExclusiveTags tag, bool removeOneLayer)
	{
		buffManager.RemoveBuffsByTag(tag, removeOneLayer);
	}

	public bool HasBuff(int buffID)
	{
		return buffManager.HasBuff(buffID);
	}

	public void SetPosition(Vector3 pos)
	{
		movementControl.ForceSetPosition(pos);
		this.OnSetPositionEvent?.Invoke(this, pos);
	}

	public Item GetArmorItem()
	{
		return characterItem.Slots["Armor"]?.Content;
	}

	public Item GetHelmatItem()
	{
		return characterItem.Slots["Helmat"]?.Content;
	}

	public Item GetFaceMaskItem()
	{
		return characterItem.Slots["FaceMask"]?.Content;
	}

	public static float WeaponRepairLossFactor()
	{
		if (!Main || Main.characterItem == null)
		{
			return 1f;
		}
		return Main.characterItem.Constants.GetFloat("WeaponRepairLossFactor", 1f);
	}

	public static float EquipmentRepairLossFactor()
	{
		if (!Main || Main.characterItem == null)
		{
			return 1f;
		}
		return Main.characterItem.Constants.GetFloat("EquipmentRepairLossFactor", 1f);
	}

	private float GetFloatStatValue(int hash)
	{
		if ((bool)characterItem)
		{
			return characterItem.GetStatValue(hash);
		}
		return 0f;
	}

	public void UseStamina(float value)
	{
		if ((bool)LevelManager.Instance && !LevelManager.Instance.IsBaseLevel && !(value <= 0f))
		{
			staminaRecoverTimer = 0f;
			currentStamina -= value;
			if (currentStamina < 0f)
			{
				currentStamina = 0f;
			}
		}
	}
}
public class CharacterModel : MonoBehaviour
{
	public CharacterMainControl characterMainControl;

	public bool invisable;

	[SerializeField]
	private Transform lefthandSocket;

	[SerializeField]
	private Transform rightHandSocket;

	private Quaternion defaultRightHandLocalRotation;

	[SerializeField]
	private HurtVisual hurtVisual;

	[SerializeField]
	private Transform armorSocket;

	[SerializeField]
	private Transform helmatSocket;

	[SerializeField]
	private Transform faceSocket;

	[SerializeField]
	private Transform backpackSocket;

	[SerializeField]
	private Transform meleeWeaponSocket;

	[SerializeField]
	private Transform popTextSocket;

	[SerializeField]
	private List<CharacterSubVisuals> subVisuals;

	[SerializeField]
	private List<Renderer> renderers;

	[SerializeField]
	private CustomFaceInstance customFace;

	public bool autoSyncRightHandRotation = true;

	public float damageReceiverRadius = 0.45f;

	private int showHairHash = "ShowHair".GetHashCode();

	private int showMouthHash = "ShowMouth".GetHashCode();

	private bool helmatShowMouth = true;

	private bool helmatShowHair = true;

	private bool faceMaskShowHair = true;

	private bool faceMaskShowMouth = true;

	private bool destroied;

	public Transform LefthandSocket => lefthandSocket;

	public Transform RightHandSocket => rightHandSocket;

	public Transform ArmorSocket => armorSocket;

	public Transform HelmatSocket => helmatSocket;

	public Transform FaceMaskSocket
	{
		get
		{
			if ((bool)faceSocket)
			{
				return faceSocket;
			}
			return helmatSocket;
		}
	}

	public Transform BackpackSocket => backpackSocket;

	public Transform MeleeWeaponSocket => meleeWeaponSocket;

	public Transform PopTextSocket => popTextSocket;

	public CustomFaceInstance CustomFace => customFace;

	public bool Hidden => characterMainControl.Hidden;

	public event Action<CharacterModel> OnDestroyEvent;

	public event Action OnCharacterSetEvent;

	public event Action OnAttackOrShootEvent;

	private void Awake()
	{
		defaultRightHandLocalRotation = rightHandSocket.localRotation;
	}

	private void Start()
	{
		CharacterSubVisuals component = GetComponent<CharacterSubVisuals>();
		if (component != null)
		{
			if (subVisuals.Contains(component))
			{
				RemoveVisual(component);
			}
			AddSubVisuals(component);
		}
	}

	private void LateUpdate()
	{
		if (autoSyncRightHandRotation)
		{
			SyncRightHandRotation();
		}
	}

	public void OnMainCharacterSetted(CharacterMainControl _characterMainControl)
	{
		characterMainControl = _characterMainControl;
		if (!characterMainControl)
		{
			return;
		}
		if ((bool)characterMainControl.attackAction)
		{
			characterMainControl.attackAction.OnAttack += OnAttack;
		}
		characterMainControl.OnShootEvent += OnShoot;
		characterMainControl.EquipmentController.OnHelmatSlotContentChanged += OnHelmatSlotContentChange;
		characterMainControl.EquipmentController.OnFaceMaskSlotContentChanged += OnFaceMaskSlotContentChange;
		if (_characterMainControl.mainDamageReceiver != null)
		{
			CapsuleCollider component = _characterMainControl.mainDamageReceiver.GetComponent<CapsuleCollider>();
			if (component != null)
			{
				component.radius = damageReceiverRadius;
				if (damageReceiverRadius <= 0f)
				{
					component.enabled = false;
				}
			}
		}
		this.OnCharacterSetEvent?.Invoke();
		hurtVisual.SetHealth(_characterMainControl.Health);
	}

	private void CharacterMainControl_OnShootEvent(DuckovItemAgent obj)
	{
		throw new NotImplementedException();
	}

	private void OnHelmatSlotContentChange(Slot slot)
	{
		if (slot != null)
		{
			helmatShowHair = slot.Content == null || slot.Content.Constants.GetBool(showHairHash);
			helmatShowMouth = slot.Content == null || slot.Content.Constants.GetBool(showMouthHash, defaultResult: true);
			if ((bool)customFace && (bool)customFace.hairSocket)
			{
				customFace.hairSocket.gameObject.SetActive(helmatShowHair && faceMaskShowHair);
			}
			if ((bool)customFace && (bool)customFace.mouthPart.socket)
			{
				customFace.mouthPart.socket.gameObject.SetActive(helmatShowMouth && faceMaskShowMouth);
			}
		}
	}

	private void OnFaceMaskSlotContentChange(Slot slot)
	{
		if (slot != null)
		{
			faceMaskShowHair = slot.Content == null || slot.Content.Constants.GetBool(showHairHash, defaultResult: true);
			faceMaskShowMouth = slot.Content == null || slot.Content.Constants.GetBool(showMouthHash, defaultResult: true);
			if ((bool)customFace && (bool)customFace.hairSocket)
			{
				customFace.hairSocket.gameObject.SetActive(helmatShowHair && faceMaskShowHair);
			}
			if ((bool)customFace && (bool)customFace.mouthPart.socket)
			{
				customFace.mouthPart.socket.gameObject.SetActive(helmatShowMouth && faceMaskShowMouth);
			}
		}
	}

	private void OnDestroy()
	{
		if (destroied)
		{
			return;
		}
		destroied = true;
		this.OnDestroyEvent?.Invoke(this);
		if ((bool)characterMainControl)
		{
			if ((bool)characterMainControl.attackAction)
			{
				characterMainControl.attackAction.OnAttack -= OnAttack;
			}
			characterMainControl.OnShootEvent -= OnShoot;
			characterMainControl.EquipmentController.OnHelmatSlotContentChanged -= OnHelmatSlotContentChange;
			characterMainControl.EquipmentController.OnFaceMaskSlotContentChanged -= OnFaceMaskSlotContentChange;
		}
	}

	private void SyncRightHandRotation()
	{
		if ((bool)characterMainControl)
		{
			bool flag = true;
			if (characterMainControl.Running)
			{
				flag = false;
			}
			Quaternion to = ((!flag) ? (rightHandSocket.parent.transform.rotation * defaultRightHandLocalRotation) : Quaternion.LookRotation(characterMainControl.CurrentAimDirection, Vector3.up));
			float maxDegreesDelta = 999f;
			if (0 == 0)
			{
				maxDegreesDelta = 360f * Time.deltaTime;
			}
			rightHandSocket.rotation = Quaternion.RotateTowards(rightHandSocket.rotation, to, maxDegreesDelta);
		}
	}

	public void AddSubVisuals(CharacterSubVisuals visuals)
	{
		visuals.mainModel = this;
		if (!subVisuals.Contains(visuals))
		{
			subVisuals.Add(visuals);
			renderers.AddRange(visuals.renderers);
			hurtVisual.SetRenderers(renderers);
			visuals.SetRenderersHidden(Hidden);
		}
	}

	public void RemoveVisual(CharacterSubVisuals _subVisuals)
	{
		subVisuals.Remove(_subVisuals);
		foreach (Renderer renderer in _subVisuals.renderers)
		{
			renderers.Remove(renderer);
		}
		hurtVisual.SetRenderers(renderers);
	}

	public void SyncHiddenToMainCharacter()
	{
		bool renderersHidden = Hidden;
		if (!Team.IsEnemy(Teams.player, characterMainControl.Team))
		{
			renderersHidden = false;
		}
		if (subVisuals.Count <= 0)
		{
			return;
		}
		foreach (CharacterSubVisuals subVisual in subVisuals)
		{
			if (!(subVisual == null))
			{
				subVisual.SetRenderersHidden(renderersHidden);
			}
		}
	}

	public void SetFaceFromPreset(CustomFacePreset preset)
	{
		if (!(preset == null) && (bool)customFace)
		{
			customFace.LoadFromData(preset.settings);
		}
	}

	public void SetFaceFromData(CustomFaceSettingData data)
	{
		if ((bool)customFace)
		{
			customFace.LoadFromData(data);
		}
	}

	private void OnAttack()
	{
		this.OnAttackOrShootEvent?.Invoke();
	}

	public void ForcePlayAttackAnimation()
	{
		OnAttack();
	}

	private void OnShoot(DuckovItemAgent agent)
	{
		this.OnAttackOrShootEvent?.Invoke();
	}
}
public class CharacterSceneControl : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class CharacterSoundMaker : MonoBehaviour
{
	public enum FootStepTypes
	{
		walkLight,
		walkHeavy,
		runLight,
		runHeavy
	}

	public CharacterMainControl characterMainControl;

	private float moveSoundTimer;

	public float walkSoundFrequence = 4f;

	public float runSoundFrequence = 7f;

	public static Action<Vector3, FootStepTypes, CharacterMainControl> OnFootStepSound;

	public float walkSoundDistance
	{
		get
		{
			if (!characterMainControl)
			{
				return 0f;
			}
			return characterMainControl.WalkSoundRange;
		}
	}

	public float runSoundDistance
	{
		get
		{
			if (!characterMainControl)
			{
				return 0f;
			}
			return characterMainControl.RunSoundRange;
		}
	}

	private void Update()
	{
		if (characterMainControl.movementControl.Velocity.magnitude < 0.5f)
		{
			moveSoundTimer = 0f;
			return;
		}
		moveSoundTimer += Time.deltaTime;
		bool running = characterMainControl.Running;
		float num = 1f / (running ? runSoundFrequence : walkSoundFrequence);
		if (!(moveSoundTimer >= num))
		{
			return;
		}
		moveSoundTimer = 0f;
		if (characterMainControl.IsInAdsInput || !characterMainControl.CharacterItem)
		{
			return;
		}
		bool flag = characterMainControl.CharacterItem.TotalWeight / characterMainControl.MaxWeight >= 0.75f;
		AISound sound = new AISound
		{
			pos = base.transform.position,
			fromTeam = characterMainControl.Team,
			soundType = SoundTypes.unknowNoise,
			fromObject = characterMainControl.gameObject,
			fromCharacter = characterMainControl
		};
		if (characterMainControl.Running)
		{
			if (runSoundDistance > 0f)
			{
				sound.radius = runSoundDistance * (flag ? 1.5f : 1f);
				OnFootStepSound?.Invoke(base.transform.position, flag ? FootStepTypes.runHeavy : FootStepTypes.runLight, characterMainControl);
			}
		}
		else if (walkSoundDistance > 0f)
		{
			sound.radius = walkSoundDistance * (flag ? 1.5f : 1f);
			OnFootStepSound?.Invoke(base.transform.position, flag ? FootStepTypes.walkHeavy : FootStepTypes.walkLight, characterMainControl);
		}
		AIMainBrain.MakeSound(sound);
	}
}
public class CharacterSubVisuals : MonoBehaviour
{
	private CharacterMainControl character;

	public List<Renderer> renderers;

	public List<ParticleSystem> particles;

	public List<Light> lights;

	public List<SodaPointLight> sodaPointLights;

	private int hiddenLayer;

	private int showLayer;

	private int sodaLightShowLayer;

	private bool hidden;

	private bool layerInited;

	public bool logWhenSetVisual;

	public CharacterModel mainModel;

	public bool debug;

	private void InitLayers()
	{
		if (!layerInited)
		{
			layerInited = true;
			hiddenLayer = LayerMask.NameToLayer("SpecialCamera");
			showLayer = LayerMask.NameToLayer("Character");
			sodaLightShowLayer = LayerMask.NameToLayer("SodaLight");
		}
	}

	private void SetRenderers()
	{
		renderers.Clear();
		particles.Clear();
		lights.Clear();
		sodaPointLights.Clear();
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			ParticleSystem component = renderer.GetComponent<ParticleSystem>();
			if ((bool)component)
			{
				particles.Add(component);
				continue;
			}
			SodaPointLight component2 = renderer.GetComponent<SodaPointLight>();
			if ((bool)component2)
			{
				sodaPointLights.Add(component2);
			}
			else
			{
				renderers.Add(renderer);
			}
		}
		Light[] componentsInChildren2 = GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light item in componentsInChildren2)
		{
			lights.Add(item);
		}
	}

	public void AddRenderer(Renderer renderer)
	{
		if (!(renderer == null) && !renderers.Contains(renderer))
		{
			InitLayers();
			int layer = (hidden ? hiddenLayer : showLayer);
			renderer.gameObject.layer = layer;
			renderers.Add(renderer);
			if ((bool)character)
			{
				character.RemoveVisual(this);
				character.AddSubVisuals(this);
			}
		}
	}

	public void SetRenderersHidden(bool _hidden)
	{
		hidden = _hidden;
		InitLayers();
		int layer = (_hidden ? hiddenLayer : showLayer);
		int num = renderers.Count;
		for (int i = 0; i < num; i++)
		{
			if (renderers[i] == null)
			{
				renderers.RemoveAt(i);
				i--;
				num--;
			}
			else
			{
				renderers[i].gameObject.layer = layer;
			}
		}
		int num2 = particles.Count;
		for (int j = 0; j < num2; j++)
		{
			if (particles[j] == null)
			{
				particles.RemoveAt(j);
				j--;
				num2--;
			}
			else
			{
				particles[j].gameObject.layer = layer;
			}
		}
		int num3 = lights.Count;
		for (int k = 0; k < num3; k++)
		{
			Light light = lights[k];
			if (light == null)
			{
				lights.RemoveAt(k);
				k--;
				num3--;
				continue;
			}
			light.gameObject.layer = layer;
			if (hidden)
			{
				light.cullingMask = 0;
			}
			else
			{
				light.cullingMask = -1;
			}
		}
		int layer2 = (_hidden ? hiddenLayer : sodaLightShowLayer);
		int num4 = sodaPointLights.Count;
		for (int l = 0; l < sodaPointLights.Count; l++)
		{
			if (sodaPointLights[l] == null)
			{
				sodaPointLights.RemoveAt(l);
				l--;
				num4--;
			}
			else
			{
				sodaPointLights[l].gameObject.layer = layer2;
			}
		}
	}

	private void OnTransformParentChanged()
	{
		CharacterMainControl componentInParent = GetComponentInParent<CharacterMainControl>(includeInactive: true);
		SetCharacter(componentInParent);
	}

	public void SetCharacter(CharacterMainControl newCharacter)
	{
		if (newCharacter != null)
		{
			newCharacter.AddSubVisuals(this);
			character = newCharacter;
		}
	}

	private void OnDestroy()
	{
		if (character != null)
		{
			character.RemoveVisual(this);
		}
	}
}
public class HalfObsticle : MonoBehaviour
{
	public Outlinable outline;

	public HealthSimpleBase health;

	public List<GameObject> parts;

	public GameObject defaultVisuals;

	public GameObject deadVisuals;

	public Collider airWallCollider;

	private bool dead;

	private void Awake()
	{
		outline.enabled = false;
		defaultVisuals.SetActive(value: true);
		deadVisuals.SetActive(value: false);
		health.OnDeadEvent += Dead;
		if ((bool)airWallCollider)
		{
			airWallCollider.gameObject.SetActive(value: true);
		}
	}

	private void OnValidate()
	{
	}

	public void Dead(DamageInfo dmgInfo)
	{
		if (!dead)
		{
			dead = true;
			defaultVisuals.SetActive(value: false);
			deadVisuals.SetActive(value: true);
		}
	}

	public void OnTriggerEnter(Collider other)
	{
		CharacterMainControl component = other.GetComponent<CharacterMainControl>();
		if ((bool)component)
		{
			component.AddnearByHalfObsticles(parts);
			if (component.IsMainCharacter)
			{
				outline.enabled = true;
			}
		}
	}

	public void OnTriggerExit(Collider other)
	{
		CharacterMainControl component = other.GetComponent<CharacterMainControl>();
		if ((bool)component)
		{
			component.RemoveNearByHalfObsticles(parts);
			if (component.IsMainCharacter)
			{
				outline.enabled = false;
			}
		}
	}
}
public class HalfObsticleTrigger : MonoBehaviour
{
	public HalfObsticle parent;

	private void OnTriggerEnter(Collider other)
	{
		parent.OnTriggerEnter(other);
	}

	private void OnTriggerExit(Collider other)
	{
		parent.OnTriggerExit(other);
	}
}
public class HeadCollider : MonoBehaviour
{
	private CharacterMainControl character;

	[SerializeField]
	private SphereCollider sphereCollider;

	public void Init(CharacterMainControl _character)
	{
		character = _character;
		character.OnTeamChanged += OnSetTeam;
	}

	private void OnDestroy()
	{
		if ((bool)character)
		{
			character.OnTeamChanged -= OnSetTeam;
		}
	}

	private void OnSetTeam(Teams team)
	{
		bool flag = Team.IsEnemy(Teams.player, team);
		sphereCollider.enabled = flag;
	}

	private void OnDrawGizmos()
	{
		Color yellow = Color.yellow;
		yellow.a = 0.3f;
		Gizmos.color = yellow;
		Gizmos.DrawSphere(base.transform.position, sphereCollider.radius * base.transform.lossyScale.x);
	}
}
public class Health : MonoBehaviour
{
	public Teams team;

	public bool hasSoul = true;

	private Item item;

	private int maxHealthHash = "MaxHealth".GetHashCode();

	private float lastMaxHealth;

	private bool _showHealthBar;

	[SerializeField]
	private int defaultMaxHealth;

	private float _currentHealth;

	public UnityEvent<Health> OnHealthChange;

	public UnityEvent<Health> OnMaxHealthChange;

	public UnityEvent<DamageInfo> OnDeadEvent;

	public UnityEvent<DamageInfo> OnHurtEvent;

	public float healthBarHeight = 2f;

	private bool isDead;

	public bool autoInit = true;

	[SerializeField]
	private bool DestroyOnDead = true;

	[SerializeField]
	private float DeadDestroyDelay = 0.5f;

	private bool inited;

	private bool invincible;

	private bool hasCharacter = true;

	private CharacterMainControl characterCached;

	private int bodyArmorHash = "BodyArmor".GetHashCode();

	private int headArmorHash = "HeadArmor".GetHashCode();

	private int Hash_ElementFactor_Physics = "ElementFactor_Physics".GetHashCode();

	private int Hash_ElementFactor_Fire = "ElementFactor_Fire".GetHashCode();

	private int Hash_ElementFactor_Poison = "ElementFactor_Poison".GetHashCode();

	private int Hash_ElementFactor_Electricity = "ElementFactor_Electricity".GetHashCode();

	private int Hash_ElementFactor_Space = "ElementFactor_Space".GetHashCode();

	public bool showHealthBar
	{
		get
		{
			return _showHealthBar;
		}
		set
		{
			_showHealthBar = value;
		}
	}

	public bool Hidden
	{
		get
		{
			if ((bool)TryGetCharacter())
			{
				return characterCached.Hidden;
			}
			return false;
		}
	}

	public float MaxHealth
	{
		get
		{
			float num = 0f;
			num = ((!item) ? ((float)defaultMaxHealth) : item.GetStatValue(maxHealthHash));
			if (!Mathf.Approximately(lastMaxHealth, num))
			{
				lastMaxHealth = num;
				OnMaxHealthChange?.Invoke(this);
			}
			return num;
		}
	}

	public bool IsMainCharacterHealth
	{
		get
		{
			if (LevelManager.Instance == null)
			{
				return false;
			}
			if (LevelManager.Instance.MainCharacter == null)
			{
				return false;
			}
			if (LevelManager.Instance.MainCharacter != TryGetCharacter())
			{
				return false;
			}
			return true;
		}
	}

	public float CurrentHealth
	{
		get
		{
			return _currentHealth;
		}
		set
		{
			float currentHealth = _currentHealth;
			_currentHealth = value;
			if (_currentHealth != currentHealth)
			{
				OnHealthChange?.Invoke(this);
			}
		}
	}

	public bool IsDead => isDead;

	public bool Invincible => invincible;

	public float BodyArmor
	{
		get
		{
			if ((bool)item)
			{
				return item.GetStatValue(bodyArmorHash);
			}
			return 0f;
		}
	}

	public float HeadArmor
	{
		get
		{
			if ((bool)item)
			{
				return item.GetStatValue(headArmorHash);
			}
			return 0f;
		}
	}

	public static event Action<Health, DamageInfo> OnHurt;

	public static event Action<Health, DamageInfo> OnDead;

	public static event Action<Health> OnRequestHealthBar;

	public CharacterMainControl TryGetCharacter()
	{
		if (characterCached != null)
		{
			return characterCached;
		}
		if (!hasCharacter)
		{
			return null;
		}
		if (!item)
		{
			hasCharacter = false;
			return null;
		}
		characterCached = item.GetCharacterMainControl();
		if (!characterCached)
		{
			hasCharacter = true;
		}
		return characterCached;
	}

	public float ElementFactor(ElementTypes type)
	{
		float num = 1f;
		if (!item)
		{
			return num;
		}
		Weather currentWeather = TimeOfDayController.Instance.CurrentWeather;
		bool isBaseLevel = LevelManager.Instance.IsBaseLevel;
		switch (type)
		{
		case ElementTypes.physics:
			num = item.GetStat(Hash_ElementFactor_Physics).Value;
			break;
		case ElementTypes.fire:
			num = item.GetStat(Hash_ElementFactor_Fire).Value;
			if (!isBaseLevel && currentWeather == Weather.Rainy)
			{
				num -= 0.15f;
			}
			break;
		case ElementTypes.poison:
			num = item.GetStat(Hash_ElementFactor_Poison).Value;
			break;
		case ElementTypes.electricity:
			num = item.GetStat(Hash_ElementFactor_Electricity).Value;
			if (!isBaseLevel && currentWeather == Weather.Rainy)
			{
				num += 0.2f;
			}
			break;
		case ElementTypes.space:
			num = item.GetStat(Hash_ElementFactor_Space).Value;
			break;
		}
		return num;
	}

	private void Start()
	{
		if (autoInit)
		{
			Init();
		}
	}

	public void SetItemAndCharacter(Item _item, CharacterMainControl _character)
	{
		item = _item;
		if ((bool)_character)
		{
			hasCharacter = true;
			characterCached = _character;
		}
	}

	public void Init()
	{
		if (CurrentHealth <= 0f)
		{
			CurrentHealth = MaxHealth;
		}
	}

	public void AddBuff(Buff buffPfb, CharacterMainControl fromWho, int overrideFromWeaponID = 0)
	{
		TryGetCharacter()?.AddBuff(buffPfb, fromWho, overrideFromWeaponID);
	}

	private void Update()
	{
	}

	public bool Hurt(DamageInfo damageInfo)
	{
		if (MultiSceneCore.Instance != null && MultiSceneCore.Instance.IsLoading)
		{
			return false;
		}
		if (invincible)
		{
			return false;
		}
		if (isDead)
		{
			return false;
		}
		if (damageInfo.buff != null && UnityEngine.Random.Range(0f, 1f) < damageInfo.buffChance)
		{
			AddBuff(damageInfo.buff, damageInfo.fromCharacter, damageInfo.fromWeaponItemID);
		}
		bool flag = LevelManager.Rule.AdvancedDebuffMode;
		if (LevelManager.Instance.IsBaseLevel)
		{
			flag = false;
		}
		float num = 0.2f;
		float num2 = 0.12f;
		CharacterMainControl characterMainControl = TryGetCharacter();
		if (!IsMainCharacterHealth)
		{
			num = 0.1f;
			num2 = 0.1f;
		}
		if (flag && UnityEngine.Random.Range(0f, 1f) < damageInfo.bleedChance * num)
		{
			AddBuff(GameplayDataSettings.Buffs.BoneCrackBuff, damageInfo.fromCharacter, damageInfo.fromWeaponItemID);
		}
		else if (flag && UnityEngine.Random.Range(0f, 1f) < damageInfo.bleedChance * num2)
		{
			AddBuff(GameplayDataSettings.Buffs.WoundBuff, damageInfo.fromCharacter, damageInfo.fromWeaponItemID);
		}
		else if (UnityEngine.Random.Range(0f, 1f) < damageInfo.bleedChance)
		{
			if (flag)
			{
				AddBuff(GameplayDataSettings.Buffs.UnlimitBleedBuff, damageInfo.fromCharacter, damageInfo.fromWeaponItemID);
			}
			else
			{
				AddBuff(GameplayDataSettings.Buffs.BleedSBuff, damageInfo.fromCharacter, damageInfo.fromWeaponItemID);
			}
		}
		bool flag2 = UnityEngine.Random.Range(0f, 1f) < damageInfo.critRate;
		damageInfo.crit = (flag2 ? 1 : 0);
		if (!damageInfo.ignoreDifficulty && team == Teams.player)
		{
			damageInfo.damageValue *= LevelManager.Rule.DamageFactor_ToPlayer;
		}
		float num3 = damageInfo.damageValue * (flag2 ? damageInfo.critDamageFactor : 1f);
		if (damageInfo.damageType != DamageTypes.realDamage && !damageInfo.ignoreArmor)
		{
			float num4 = (flag2 ? HeadArmor : BodyArmor);
			if ((bool)characterMainControl && LevelManager.Instance.IsRaidMap)
			{
				Item item = (flag2 ? characterMainControl.GetHelmatItem() : characterMainControl.GetArmorItem());
				if ((bool)item)
				{
					item.Durability = Mathf.Max(0f, item.Durability - damageInfo.armorBreak);
				}
			}
			float num5 = 1f;
			if (num4 > 0f)
			{
				num5 = 2f / (Mathf.Clamp(num4 - damageInfo.armorPiercing, 0f, 999f) + 2f);
			}
			if ((bool)characterMainControl && !characterMainControl.IsMainCharacter && (bool)damageInfo.fromCharacter && !damageInfo.fromCharacter.IsMainCharacter)
			{
				CharacterRandomPreset characterPreset = damageInfo.fromCharacter.characterPreset;
				CharacterRandomPreset characterPreset2 = characterMainControl.characterPreset;
				if ((bool)characterPreset && (bool)characterPreset2)
				{
					num5 *= characterPreset.aiCombatFactor / characterPreset2.aiCombatFactor;
				}
			}
			num3 *= num5;
		}
		if (damageInfo.elementFactors.Count <= 0)
		{
			damageInfo.elementFactors.Add(new ElementFactor(ElementTypes.physics, 1f));
		}
		float num6 = 0f;
		foreach (ElementFactor elementFactor in damageInfo.elementFactors)
		{
			float factor = elementFactor.factor;
			float num7 = ElementFactor(elementFactor.elementType);
			float num8 = num3 * factor * num7;
			if (num8 < 1f && num8 > 0f && num7 > 0f && factor > 0f)
			{
				num8 = 1f;
			}
			if (num8 > 0f && !Hidden && (bool)PopText.instance)
			{
				GameplayDataSettings.UIStyleData.DisplayElementDamagePopTextLook elementDamagePopTextLook = GameplayDataSettings.UIStyle.GetElementDamagePopTextLook(elementFactor.elementType);
				float size = (flag2 ? elementDamagePopTextLook.critSize : elementDamagePopTextLook.normalSize);
				Color color = elementDamagePopTextLook.color;
				PopText.Pop(num8.ToString("F1"), damageInfo.damagePoint + Vector3.up * 2f, color, size, flag2 ? GameplayDataSettings.UIStyle.CritPopSprite : null);
			}
			num6 += num8;
		}
		damageInfo.finalDamage = num6;
		if (CurrentHealth < damageInfo.finalDamage)
		{
			damageInfo.finalDamage = CurrentHealth + 1f;
		}
		CurrentHealth -= damageInfo.finalDamage;
		OnHurtEvent?.Invoke(damageInfo);
		Health.OnHurt?.Invoke(this, damageInfo);
		if (isDead)
		{
			return true;
		}
		if (CurrentHealth <= 0f)
		{
			bool flag3 = true;
			if (!LevelManager.Instance.IsRaidMap)
			{
				flag3 = false;
			}
			if (!flag3)
			{
				SetHealth(1f);
			}
		}
		if (CurrentHealth <= 0f)
		{
			CurrentHealth = 0f;
			isDead = true;
			if (LevelManager.Instance.MainCharacter != TryGetCharacter())
			{
				DestroyOnDelay().Forget();
			}
			if (this.item != null && team != Teams.player && (bool)damageInfo.fromCharacter && damageInfo.fromCharacter.IsMainCharacter)
			{
				EXPManager.AddExp(this.item.GetInt("Exp"));
			}
			OnDeadEvent?.Invoke(damageInfo);
			Health.OnDead?.Invoke(this, damageInfo);
			base.gameObject.SetActive(value: false);
			if ((bool)damageInfo.fromCharacter && damageInfo.fromCharacter.IsMainCharacter)
			{
				UnityEngine.Debug.Log("Killed by maincharacter");
			}
		}
		return true;
	}

	public void RequestHealthBar()
	{
		if (showHealthBar && LevelManager.LevelInited)
		{
			Health.OnRequestHealthBar?.Invoke(this);
		}
	}

	public async UniTask DestroyOnDelay()
	{
		await UniTask.WaitForSeconds(DeadDestroyDelay);
		if (base.gameObject != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void AddHealth(float healthValue)
	{
		CurrentHealth = Mathf.Min(MaxHealth, CurrentHealth + healthValue);
	}

	public void SetHealth(float healthValue)
	{
		CurrentHealth = Mathf.Min(MaxHealth, healthValue);
	}

	public void SetInvincible(bool value)
	{
		invincible = value;
	}
}
public class HealthSimpleBase : MonoBehaviour
{
	public Teams team;

	public bool onlyReceiveExplosion;

	public float maxHealthValue = 250f;

	private float healthValue;

	public DamageReceiver dmgReceiver;

	public float damageMultiplierIfNotMainCharacter = 1f;

	public float HealthValue => healthValue;

	public event Action<DamageInfo> OnHurtEvent;

	public static event Action<HealthSimpleBase, DamageInfo> OnSimpleHealthHit;

	public event Action<DamageInfo> OnDeadEvent;

	public static event Action<HealthSimpleBase, DamageInfo> OnSimpleHealthDead;

	private void Awake()
	{
		healthValue = maxHealthValue;
		dmgReceiver.OnHurtEvent.AddListener(OnHurt);
	}

	private void OnHurt(DamageInfo dmgInfo)
	{
		if (!onlyReceiveExplosion || dmgInfo.isExplosion)
		{
			float num = 1f;
			bool flag = UnityEngine.Random.Range(0f, 1f) <= dmgInfo.critRate;
			dmgInfo.crit = (flag ? 1 : 0);
			if (!dmgInfo.fromCharacter || !dmgInfo.fromCharacter.IsMainCharacter)
			{
				num = damageMultiplierIfNotMainCharacter;
			}
			healthValue -= (flag ? dmgInfo.critDamageFactor : 1f) * dmgInfo.damageValue * num;
			this.OnHurtEvent?.Invoke(dmgInfo);
			HealthSimpleBase.OnSimpleHealthHit?.Invoke(this, dmgInfo);
			if (healthValue <= 0f)
			{
				Dead(dmgInfo);
			}
		}
	}

	private void Dead(DamageInfo dmgInfo)
	{
		dmgReceiver.OnDead(dmgInfo);
		this.OnDeadEvent?.Invoke(dmgInfo);
		HealthSimpleBase.OnSimpleHealthDead?.Invoke(this, dmgInfo);
	}
}
public class HurtVisual : MonoBehaviour
{
	public bool useSimpleHealth;

	public HealthSimpleBase simpleHealth;

	private Health health;

	[SerializeField]
	private GameObject hitFX;

	[SerializeField]
	private GameObject hitFX_NoBlood;

	[SerializeField]
	private GameObject deadFx;

	[SerializeField]
	private GameObject deadFx_NoBlood;

	public List<Renderer> renderers;

	public static readonly int hurtHash = Shader.PropertyToID("_HurtValue");

	private MaterialPropertyBlock materialPropertyBlock;

	public float hurtCoolSpeed = 8f;

	public float hurtValueMultiplier = 1f;

	private float hurtValue;

	public GameObject HitFx
	{
		get
		{
			if (!GameManager.BloodFxOn && hitFX_NoBlood != null)
			{
				return hitFX_NoBlood;
			}
			return hitFX;
		}
	}

	public GameObject DeadFx
	{
		get
		{
			if (!GameManager.BloodFxOn && deadFx_NoBlood != null)
			{
				return deadFx_NoBlood;
			}
			return deadFx;
		}
	}

	public void SetHealth(Health _health)
	{
		if (!useSimpleHealth)
		{
			if (health != null)
			{
				health.OnHurtEvent.RemoveListener(OnHurt);
				health.OnDeadEvent.RemoveListener(OnDead);
			}
			health = _health;
			_health.OnHurtEvent.AddListener(OnHurt);
			_health.OnDeadEvent.AddListener(OnDead);
			Init();
		}
	}

	private void Awake()
	{
		if (useSimpleHealth && simpleHealth != null)
		{
			simpleHealth.OnHurtEvent += OnHurt;
			simpleHealth.OnDeadEvent += OnDead;
		}
	}

	private void Init()
	{
	}

	private void Update()
	{
		if (hurtValue > 0f)
		{
			SetRendererValue(hurtValue);
			hurtValue -= Time.unscaledDeltaTime * hurtCoolSpeed;
			if (hurtValue <= 0f)
			{
				SetRendererValue(0f);
			}
		}
	}

	private void OnHurt(DamageInfo dmgInfo)
	{
		bool flag = (bool)health && health.Hidden;
		if ((bool)HitFx && !flag)
		{
			PlayHurtEventProxy component = UnityEngine.Object.Instantiate(HitFx, dmgInfo.damagePoint, Quaternion.LookRotation(dmgInfo.damageNormal)).GetComponent<PlayHurtEventProxy>();
			if ((bool)component)
			{
				component.Play(dmgInfo.crit > 0);
			}
		}
		hurtValue = 1f;
		SetRendererValue(hurtValue);
	}

	private void SetRendererValue(float value)
	{
		int count = renderers.Count;
		for (int i = 0; i < count; i++)
		{
			if (!(renderers[i] == null))
			{
				if (materialPropertyBlock == null)
				{
					materialPropertyBlock = new MaterialPropertyBlock();
				}
				renderers[i].GetPropertyBlock(materialPropertyBlock);
				materialPropertyBlock.SetFloat(hurtHash, value * hurtValueMultiplier);
				renderers[i].SetPropertyBlock(materialPropertyBlock);
			}
		}
	}

	private void OnDead(DamageInfo dmgInfo)
	{
		if ((bool)DeadFx)
		{
			PlayHurtEventProxy component = UnityEngine.Object.Instantiate(DeadFx, base.transform.position, base.transform.rotation).GetComponent<PlayHurtEventProxy>();
			if ((bool)component)
			{
				component.Play(dmgInfo.crit > 0);
			}
		}
	}

	private void OnDestroy()
	{
		if ((bool)health)
		{
			health.OnHurtEvent.RemoveListener(OnHurt);
			health.OnDeadEvent.RemoveListener(OnDead);
		}
	}

	private void AutoSet()
	{
		renderers = GetComponentsInChildren<Renderer>(includeInactive: true).ToList();
		renderers.RemoveAll((Renderer e) => e == null || e.GetComponent<ParticleSystem>() != null);
	}

	public void SetRenderers(List<Renderer> _renderers)
	{
		renderers = _renderers;
	}
}
public class ItemAgentHolder : MonoBehaviour
{
	public CharacterMainControl characterController;

	private DuckovItemAgent currentHoldItemAgent;

	private Transform _currentUsingSocketCache;

	private static int handheldHash = "Handheld".GetHashCode();

	private ItemAgent_Gun _gunRef;

	private ItemAgent_MeleeWeapon _meleeRef;

	private ItemSetting_Skill _skillRef;

	private bool holdStady;

	private float holdStadyTime = 0.15f;

	private float holdStadyTimer;

	public DuckovItemAgent CurrentHoldItemAgent => currentHoldItemAgent;

	public Transform CurrentUsingSocket
	{
		get
		{
			if (!currentHoldItemAgent)
			{
				_currentUsingSocketCache = null;
			}
			return _currentUsingSocketCache;
		}
	}

	public ItemAgent_Gun CurrentHoldGun
	{
		get
		{
			if ((bool)_gunRef && (bool)currentHoldItemAgent && _gunRef.gameObject == currentHoldItemAgent.gameObject)
			{
				return _gunRef;
			}
			_gunRef = null;
			return null;
		}
	}

	public ItemAgent_MeleeWeapon CurrentHoldMeleeWeapon
	{
		get
		{
			if ((bool)_meleeRef && (bool)currentHoldItemAgent && _meleeRef.gameObject == currentHoldItemAgent.gameObject)
			{
				return _meleeRef;
			}
			_meleeRef = null;
			return null;
		}
	}

	public ItemSetting_Skill Skill => _skillRef;

	public event Action<DuckovItemAgent> OnHoldAgentChanged;

	public DuckovItemAgent ChangeHoldItem(Item item)
	{
		DestroyCurrentItemAgent();
		if (item == null)
		{
			this.OnHoldAgentChanged?.Invoke(null);
			return null;
		}
		ItemAgent itemAgent = item.CreateHandheldAgent();
		if (itemAgent == null)
		{
			this.OnHoldAgentChanged?.Invoke(null);
			return null;
		}
		currentHoldItemAgent = itemAgent as DuckovItemAgent;
		if (currentHoldItemAgent == null)
		{
			UnityEngine.Object.Destroy(itemAgent.gameObject);
			this.OnHoldAgentChanged?.Invoke(null);
			return null;
		}
		currentHoldItemAgent.SetHolder(characterController);
		Transform transform;
		switch (currentHoldItemAgent.handheldSocket)
		{
		case HandheldSocketTypes.normalHandheld:
			transform = characterController.characterModel.RightHandSocket;
			break;
		case HandheldSocketTypes.meleeWeapon:
			transform = characterController.characterModel.MeleeWeaponSocket;
			break;
		case HandheldSocketTypes.leftHandSocket:
			transform = characterController.characterModel.LefthandSocket;
			if (transform == null)
			{
				transform = characterController.characterModel.RightHandSocket;
			}
			break;
		default:
			transform = characterController.characterModel.RightHandSocket;
			break;
		}
		currentHoldItemAgent.transform.SetParent(transform, worldPositionStays: false);
		_currentUsingSocketCache = transform;
		currentHoldItemAgent.transform.localPosition = Vector3.zero;
		currentHoldItemAgent.transform.localRotation = Quaternion.identity;
		currentHoldItemAgent.Item.onItemTreeChanged += OnAgentItemTreeChanged;
		_gunRef = currentHoldItemAgent as ItemAgent_Gun;
		_meleeRef = currentHoldItemAgent as ItemAgent_MeleeWeapon;
		if (!IsSkillItem(item))
		{
			_skillRef = null;
		}
		else
		{
			_skillRef = item.GetComponent<ItemSetting_Skill>();
		}
		if ((bool)_skillRef)
		{
			characterController.SetSkill(SkillTypes.itemSkill, _skillRef.Skill, itemAgent.gameObject);
		}
		else
		{
			characterController.SetSkill(SkillTypes.itemSkill, null, null);
		}
		holdStadyTimer = 0f;
		holdStady = false;
		itemAgent.gameObject.SetActive(value: false);
		this.OnHoldAgentChanged?.Invoke(currentHoldItemAgent);
		return currentHoldItemAgent;
	}

	public void SetTrigger(bool trigger, bool triggerThisFrame, bool releaseThisFrame)
	{
		if ((bool)currentHoldItemAgent && characterController.CanUseHand() && CurrentHoldGun != null)
		{
			CurrentHoldGun.SetTrigger(trigger, triggerThisFrame, releaseThisFrame);
		}
	}

	private void OnDestroy()
	{
		if ((bool)currentHoldItemAgent)
		{
			currentHoldItemAgent.Item.onItemTreeChanged -= OnAgentItemTreeChanged;
		}
	}

	private void DestroyCurrentItemAgent()
	{
		_skillRef = null;
		if (!(currentHoldItemAgent == null))
		{
			if (currentHoldItemAgent.Item != null)
			{
				currentHoldItemAgent.Item.onItemTreeChanged -= OnAgentItemTreeChanged;
				currentHoldItemAgent.Item.AgentUtilities.ReleaseActiveAgent();
			}
			currentHoldItemAgent = null;
		}
	}

	private void OnAgentItemTreeChanged(Item item)
	{
		if (item == null || currentHoldItemAgent == null || currentHoldItemAgent.Item != item || item.GetCharacterItem() != characterController.CharacterItem)
		{
			DestroyCurrentItemAgent();
		}
	}

	private bool IsSkillItem(Item item)
	{
		if (item == null)
		{
			return false;
		}
		return item.GetBool("IsSkill");
	}

	private void Update()
	{
		if (currentHoldItemAgent != null && !holdStady)
		{
			holdStadyTimer += Time.deltaTime;
			if (holdStadyTimer > holdStadyTime)
			{
				holdStady = true;
				currentHoldItemAgent.gameObject.SetActive(value: true);
			}
		}
	}
}
public class Movement : MonoBehaviour
{
	public CharacterMainControl characterController;

	[SerializeField]
	private CharacterMovement characterMovement;

	public Vector3 targetAimDirection;

	private Vector3 moveInput;

	private bool running;

	private bool moving;

	private Vector3 currentMoveDirectionXZ;

	public bool forceMove;

	public Vector3 forceMoveVelocity;

	private const float movingInputThreshold = 0.02f;

	public float walkSpeed => characterController.CharacterWalkSpeed * (characterController.IsInAdsInput ? characterController.AdsWalkSpeedMultiplier : 1f);

	public float originWalkSpeed => characterController.CharacterOriginWalkSpeed;

	public float runSpeed => characterController.CharacterRunSpeed;

	public float walkAcc => characterController.CharacterWalkAcc;

	public float runAcc => characterController.CharacterRunAcc;

	public float turnSpeed => characterController.CharacterTurnSpeed;

	public float aimTurnSpeed => characterController.CharacterAimTurnSpeed;

	public Vector3 MoveInput => moveInput;

	public bool Running => running;

	public bool Moving => moving;

	public bool IsOnGround => characterMovement.isOnGround;

	public bool StandStill
	{
		get
		{
			if (!moving)
			{
				return characterMovement.velocity.magnitude < 0.1f;
			}
			return false;
		}
	}

	private bool checkCanMove => characterController.CanMove();

	private bool checkCanRun => characterController.CanRun();

	public Vector3 CurrentMoveDirectionXZ => currentMoveDirectionXZ;

	public Transform rotationRoot => characterController.modelRoot;

	public Vector3 Velocity => characterMovement.velocity;

	private void Awake()
	{
		characterMovement.constrainToGround = true;
	}

	public void SetMoveInput(Vector3 _moveInput)
	{
		_moveInput.y = 0f;
		moveInput = _moveInput;
		moving = false;
		if (checkCanMove && moveInput.magnitude > 0.02f)
		{
			moving = true;
		}
	}

	public void SetForceMoveVelocity(Vector3 _forceMoveVelocity)
	{
		forceMove = true;
		forceMoveVelocity = _forceMoveVelocity;
	}

	public void SetAimDirection(Vector3 _aimDirection)
	{
		targetAimDirection = _aimDirection;
		targetAimDirection.y = 0f;
		targetAimDirection.Normalize();
	}

	public void SetAimDirectionToTarget(Vector3 targetPoint, Transform aimHandler)
	{
		Vector3 position = base.transform.position;
		position.y = 0f;
		Vector3 position2 = aimHandler.position;
		position2.y = 0f;
		targetPoint.y = 0f;
		float num = Vector3.Distance(position, targetPoint);
		float num2 = Vector3.Distance(position, position2);
		if (!(num < num2 + 0.25f))
		{
			float num3 = Mathf.Asin(num2 / num) * 57.29578f;
			targetAimDirection = Quaternion.Euler(0f, 0f - num3, 0f) * (targetPoint - position).normalized;
		}
	}

	private void UpdateAiming()
	{
		Vector3 currentAimPoint = characterController.GetCurrentAimPoint();
		currentAimPoint.y = base.transform.position.y;
		if (Vector3.Distance(currentAimPoint, base.transform.position) > 0.6f && characterController.IsAiming() && characterController.CanControlAim())
		{
			SetAimDirectionToTarget(currentAimPoint, characterController.CurrentUsingAimSocket);
		}
		else if (Moving)
		{
			SetAimDirection(CurrentMoveDirectionXZ);
		}
	}

	public void UpdateMovement()
	{
		bool flag = checkCanRun;
		bool flag2 = checkCanMove;
		if (moveInput.magnitude <= 0.02f || !flag2)
		{
			moving = false;
			running = false;
		}
		else
		{
			moving = true;
		}
		if (!flag)
		{
			running = false;
		}
		if (moving && flag)
		{
			running = true;
		}
		if (!forceMove)
		{
			UpdateNormalMove();
		}
		else
		{
			UpdateForceMove();
			forceMove = false;
		}
		UpdateAiming();
		UpdateRotation(Time.deltaTime);
		characterMovement.velocity += Physics.gravity * Time.deltaTime;
		characterMovement.Move(characterMovement.velocity, Time.deltaTime);
	}

	private void Update()
	{
	}

	public void ForceSetPosition(Vector3 Pos)
	{
		characterMovement.PauseGroundConstraint(1f);
		characterMovement.SetPosition(Pos);
		characterMovement.velocity = Vector3.zero;
	}

	private void UpdateNormalMove()
	{
		Vector3 velocity = characterMovement.velocity;
		Vector3 target = Vector3.zero;
		float num = walkAcc;
		if (moving)
		{
			target = moveInput * (running ? runSpeed : walkSpeed);
			num = (running ? runAcc : walkAcc);
		}
		target.y = velocity.y;
		velocity = Vector3.MoveTowards(velocity, target, num * Time.deltaTime);
		Vector3 vector = velocity;
		vector.y = 0f;
		if (vector.magnitude > 0.02f)
		{
			currentMoveDirectionXZ = vector.normalized;
		}
		characterMovement.velocity = velocity;
	}

	private void UpdateForceMove()
	{
		Vector3 velocity = characterMovement.velocity;
		Vector3 vector = forceMoveVelocity;
		_ = walkAcc;
		vector.y = velocity.y;
		velocity = vector;
		Vector3 vector2 = velocity;
		vector2.y = 0f;
		if (vector2.magnitude > 0.02f)
		{
			currentMoveDirectionXZ = vector2.normalized;
		}
		characterMovement.velocity = velocity;
	}

	public void ForceTurnTo(Vector3 direction)
	{
		targetAimDirection = direction.normalized;
		Quaternion rotation = Quaternion.Euler(0f, Quaternion.LookRotation(targetAimDirection, Vector3.up).eulerAngles.y, 0f);
		rotationRoot.rotation = rotation;
	}

	private void UpdateRotation(float deltaTime)
	{
		if (targetAimDirection.magnitude < 0.1f)
		{
			targetAimDirection = rotationRoot.forward;
		}
		float num = turnSpeed;
		if (characterController.IsAiming() && characterController.IsMainCharacter)
		{
			num = aimTurnSpeed;
		}
		if (targetAimDirection.magnitude > 0.1f)
		{
			Quaternion to = Quaternion.Euler(0f, Quaternion.LookRotation(targetAimDirection, Vector3.up).eulerAngles.y, 0f);
			rotationRoot.rotation = Quaternion.RotateTowards(rotationRoot.rotation, to, num * deltaTime);
		}
	}

	public void ForceSetAimDirectionToAimPoint()
	{
		UpdateRotation(99999f);
	}

	public float GetMoveAnimationValue()
	{
		float num = 0f;
		float magnitude = characterMovement.velocity.magnitude;
		if (moving && running)
		{
			num = Mathf.InverseLerp(walkSpeed, runSpeed, magnitude) + 1f;
			num *= walkSpeed / originWalkSpeed;
		}
		else
		{
			num = Mathf.Clamp01(magnitude / walkSpeed);
			num *= walkSpeed / originWalkSpeed;
		}
		if (walkSpeed <= 0f)
		{
			num = 0f;
		}
		return num;
	}

	public Vector2 GetLocalMoveDirectionAnimationValue()
	{
		Vector2 up = Vector2.up;
		if (!StandStill)
		{
			Vector3 direction = currentMoveDirectionXZ;
			Vector3 vector = rotationRoot.InverseTransformDirection(direction);
			up.x = vector.x;
			up.y = vector.z;
		}
		return up;
	}

	private void FixedUpdate()
	{
	}
}
public class CheatingManager : MonoBehaviour
{
	private static CheatingManager _instance;

	private bool isInvincible;

	private bool typing;

	private int typingID;

	private int lockedItem;

	public static CheatingManager Instance => _instance;

	private void Awake()
	{
		_instance = this;
		CheatMode.Activate();
	}

	private void Update()
	{
		if (!CheatMode.Active || !CharacterMainControl.Main)
		{
			return;
		}
		if (Keyboard.current != null && Keyboard.current.leftCtrlKey.isPressed && Keyboard.current.equalsKey.wasPressedThisFrame)
		{
			ToggleInvincible();
		}
		if (Keyboard.current != null && Keyboard.current.numpadMultiplyKey.wasPressedThisFrame)
		{
			typing = !typing;
			if (typing)
			{
				typingID = 0;
				LogCurrentTypingID();
			}
			else
			{
				LockItem();
			}
		}
		UpdateTyping();
		if (Keyboard.current != null && typing && Keyboard.current.backspaceKey.wasPressedThisFrame && typingID > 0)
		{
			typingID /= 10;
			LogCurrentTypingID();
		}
		if (Keyboard.current != null && Keyboard.current.leftCtrlKey.isPressed && Mouse.current.backButton.wasPressedThisFrame)
		{
			CheatMove();
		}
		if (Keyboard.current != null && Keyboard.current.leftAltKey.isPressed && Keyboard.current.sKey.wasPressedThisFrame)
		{
			SleepView.Instance.Open();
		}
		if (Keyboard.current != null && Keyboard.current.numpadPlusKey.wasPressedThisFrame)
		{
			if (typing)
			{
				LockItem();
				typing = false;
			}
			CreateItem(lockedItem);
		}
		if (Keyboard.current != null && Keyboard.current.numpadMinusKey.wasPressedThisFrame)
		{
			int displayingItemID = ItemHoveringUI.DisplayingItemID;
			if (displayingItemID > 0)
			{
				SetTypedItem(displayingItemID);
				CreateItem(lockedItem);
			}
		}
	}

	private void UpdateTyping()
	{
		if (Keyboard.current != null && Keyboard.current.numpad0Key.wasPressedThisFrame)
		{
			TypeOne(0);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad1Key.wasPressedThisFrame)
		{
			TypeOne(1);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad2Key.wasPressedThisFrame)
		{
			TypeOne(2);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad3Key.wasPressedThisFrame)
		{
			TypeOne(3);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad4Key.wasPressedThisFrame)
		{
			TypeOne(4);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad5Key.wasPressedThisFrame)
		{
			TypeOne(5);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad6Key.wasPressedThisFrame)
		{
			TypeOne(6);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad7Key.wasPressedThisFrame)
		{
			TypeOne(7);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad8Key.wasPressedThisFrame)
		{
			TypeOne(8);
		}
		else if (Keyboard.current != null && Keyboard.current.numpad9Key.wasPressedThisFrame)
		{
			TypeOne(9);
		}
	}

	private void LogCurrentTypingID()
	{
		if (typingID <= 0)
		{
			CharacterMainControl.Main.PopText("_", 999f);
			return;
		}
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(typingID);
		if (metaData.id > 0)
		{
			CharacterMainControl.Main.PopText($" {typingID}_  ({metaData.DisplayName})", 999f);
		}
		else
		{
			CharacterMainControl.Main.PopText($"{typingID}_", 999f);
		}
	}

	private void TypeOne(int i)
	{
		typingID = typingID * 10 + i;
		LogCurrentTypingID();
	}

	private void SetTypedItem(int id)
	{
		typingID = id;
		LockItem();
	}

	private void LockItem()
	{
		typing = false;
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(typingID);
		if (metaData.id <= 0)
		{
			CharacterMainControl.Main.PopText("没有这个物品。", 999f);
			return;
		}
		lockedItem = typingID;
		CharacterMainControl.Main.PopText(metaData.DisplayName + " 已选定", 999f);
	}

	public void CreateItem(int id, int quantity = 1)
	{
		if (ItemAssetsCollection.GetMetaData(id).id <= 0)
		{
			CharacterMainControl.Main.PopText("没有这个物品。", 999f);
		}
		else
		{
			CreateItemAsync(id, quantity).Forget();
		}
	}

	private async UniTaskVoid CreateItemAsync(int id, int quantity = 1)
	{
		while (quantity > 0)
		{
			Item item = await ItemAssetsCollection.InstantiateAsync(id);
			int maxStackCount = item.MaxStackCount;
			if (quantity > maxStackCount)
			{
				item.StackCount = maxStackCount;
				quantity -= maxStackCount;
			}
			else
			{
				item.StackCount = quantity;
				quantity = 0;
			}
			ItemUtilities.SendToPlayer(item);
		}
	}

	private void ToggleTypeing()
	{
	}

	public void ToggleInvincible()
	{
		isInvincible = !isInvincible;
		CharacterMainControl.Main.Health.SetInvincible(isInvincible);
		CharacterMainControl.Main.PopText(isInvincible ? "我无敌了" : "我不无敌了");
	}

	public void CheatMove()
	{
		Vector2 vector = Mouse.current.position.ReadValue();
		Ray ray = LevelManager.Instance.GameCamera.renderCamera.ScreenPointToRay(vector);
		LayerMask layerMask = (int)GameplayDataSettings.Layers.wallLayerMask | (int)GameplayDataSettings.Layers.groundLayerMask;
		if (Physics.Raycast(ray, out var hitInfo, 100f, layerMask, QueryTriggerInteraction.Ignore))
		{
			CharacterMainControl.Main.SetPosition(hitInfo.point);
		}
	}
}
public enum DamageTypes
{
	normal = 0,
	realDamage = 2
}
[Serializable]
public struct DamageInfo
{
	public DamageTypes damageType;

	public bool isFromBuffOrEffect;

	public float damageValue;

	public bool ignoreArmor;

	public bool ignoreDifficulty;

	public float critDamageFactor;

	public float critRate;

	public float armorPiercing;

	[SerializeField]
	public List<ElementFactor> elementFactors;

	public bool isExplosion;

	public float armorBreak;

	public float finalDamage;

	public CharacterMainControl fromCharacter;

	public DamageReceiver toDamageReceiver;

	[HideInInspector]
	public Vector3 damagePoint;

	[HideInInspector]
	public Vector3 damageNormal;

	public int crit;

	[ItemTypeID]
	public int fromWeaponItemID;

	public float buffChance;

	public Buff buff;

	public float bleedChance;

	public string GenerateDescription()
	{
		string text = "";
		string text2 = "";
		string text3 = "";
		if (fromCharacter != null)
		{
			if (fromCharacter.IsMainCharacter)
			{
				text = "DeathReason_Self".ToPlainText();
			}
			else if (fromCharacter.characterPreset != null)
			{
				text = fromCharacter.characterPreset.DisplayName;
			}
		}
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(fromWeaponItemID);
		if (metaData.id > 0)
		{
			text2 = metaData.DisplayName;
		}
		if (isExplosion)
		{
			text2 = "DeathReason_Explosion".ToPlainText();
		}
		if (crit > 0)
		{
			text3 = "DeathReason_Critical".ToPlainText();
		}
		bool flag = string.IsNullOrEmpty(text);
		bool flag2 = string.IsNullOrEmpty(text2);
		if (flag && flag2)
		{
			return "?";
		}
		if (flag)
		{
			return text2;
		}
		if (flag2)
		{
			return text;
		}
		return text + " (" + text2 + ") " + text3;
	}

	public DamageInfo(CharacterMainControl fromCharacter = null)
	{
		damageValue = 0f;
		critDamageFactor = 1f;
		ignoreArmor = false;
		critRate = 0f;
		armorBreak = 0f;
		armorPiercing = 0f;
		this.fromCharacter = fromCharacter;
		toDamageReceiver = null;
		damagePoint = Vector3.zero;
		damageNormal = Vector3.up;
		elementFactors = new List<ElementFactor>();
		crit = -1;
		damageType = DamageTypes.normal;
		buffChance = 0f;
		buff = null;
		finalDamage = 0f;
		isFromBuffOrEffect = false;
		fromWeaponItemID = 0;
		isExplosion = false;
		bleedChance = 0f;
		ignoreDifficulty = false;
	}
}
public enum ElementTypes
{
	physics,
	fire,
	poison,
	electricity,
	space
}
[Serializable]
public struct ElementFactor
{
	public ElementTypes elementType;

	public float factor;

	public ElementFactor(ElementTypes _type, float _factor)
	{
		elementType = _type;
		factor = _factor;
	}
}
public class DamageReceiver : MonoBehaviour
{
	public bool useSimpleHealth;

	public Health health;

	public HealthSimpleBase simpleHealth;

	public bool isHalfObsticle;

	public UnityEvent<DamageInfo> OnHurtEvent;

	public UnityEvent<DamageInfo> OnDeadEvent;

	public Teams Team
	{
		get
		{
			if (!useSimpleHealth && (bool)health)
			{
				return health.team;
			}
			if (useSimpleHealth && (bool)simpleHealth)
			{
				return simpleHealth.team;
			}
			return Teams.all;
		}
	}

	public bool IsMainCharacter
	{
		get
		{
			if (!useSimpleHealth && (bool)health)
			{
				return health.IsMainCharacterHealth;
			}
			return false;
		}
	}

	public bool IsDead
	{
		get
		{
			if (!health)
			{
				return false;
			}
			return health.IsDead;
		}
	}

	private void Start()
	{
		base.gameObject.layer = LayerMask.NameToLayer("DamageReceiver");
		if ((bool)health)
		{
			health.OnDeadEvent.AddListener(OnDead);
		}
	}

	private void OnDestroy()
	{
		if ((bool)health)
		{
			health.OnDeadEvent.RemoveListener(OnDead);
		}
	}

	public bool Hurt(DamageInfo damageInfo)
	{
		damageInfo.toDamageReceiver = this;
		OnHurtEvent?.Invoke(damageInfo);
		if ((bool)health)
		{
			health.Hurt(damageInfo);
		}
		return true;
	}

	public bool AddBuff(Buff buffPfb, CharacterMainControl fromWho)
	{
		if (useSimpleHealth)
		{
			return false;
		}
		if (!health)
		{
			return false;
		}
		CharacterMainControl characterMainControl = health.TryGetCharacter();
		if (!characterMainControl)
		{
			return false;
		}
		characterMainControl.AddBuff(buffPfb, fromWho);
		return true;
	}

	public void OnDead(DamageInfo dmgInfo)
	{
		base.gameObject.SetActive(value: false);
		OnDeadEvent?.Invoke(dmgInfo);
	}
}
public class Grenade : MonoBehaviour
{
	public bool hasCollideSound;

	public string collideSound;

	public int makeSoundCount = 3;

	private float makeSoundTimeMarker = -1f;

	public float damageRange;

	public bool isDangerForAi = true;

	public bool isLandmine;

	public float landmineTriggerRange;

	private bool landmineActived;

	private bool landmineTriggerd;

	public ExplosionFxTypes fxType;

	public GameObject fx;

	public Animator animator;

	[SerializeField]
	private Rigidbody rb;

	private int groundLayer;

	public bool delayFromCollide;

	public float delayTime = 1f;

	public bool createExplosion = true;

	public float explosionShakeStrength = 1f;

	public DamageInfo damageInfo;

	private bool bindAgent;

	private ItemAgent bindedAgent;

	private float lifeTimer;

	private float delayTimer;

	private Teams selfTeam;

	public GameObject createOnExlode;

	public float destroyDelay;

	public UnityEvent onExplodeEvent;

	private bool exploded;

	private bool canHurtSelf;

	private bool collide;

	private bool needCustomFx => fxType == ExplosionFxTypes.custom;

	private void OnCollisionEnter(Collision collision)
	{
		if (!collide)
		{
			collide = true;
		}
		Vector3 velocity = rb.velocity;
		velocity.x *= 0.5f;
		velocity.z *= 0.5f;
		rb.velocity = velocity;
		rb.angularVelocity *= 0.3f;
		if (makeSoundCount > 0 && Time.time - makeSoundTimeMarker > 0.3f)
		{
			makeSoundCount--;
			makeSoundTimeMarker = Time.time;
			AISound sound = new AISound
			{
				fromObject = base.gameObject,
				pos = base.transform.position
			};
			if ((bool)damageInfo.fromCharacter)
			{
				sound.fromTeam = damageInfo.fromCharacter.Team;
			}
			else
			{
				sound.fromTeam = Teams.all;
			}
			sound.soundType = SoundTypes.unknowNoise;
			if (isDangerForAi)
			{
				sound.soundType = SoundTypes.grenadeDropSound;
			}
			sound.radius = 20f;
			AIMainBrain.MakeSound(sound);
			if (hasCollideSound && collideSound != "")
			{
				AudioManager.Post(collideSound, base.gameObject);
			}
		}
	}

	public void BindAgent(ItemAgent _agent)
	{
		bindAgent = true;
		bindedAgent = _agent;
		bindedAgent.transform.SetParent(base.transform, worldPositionStays: false);
		bindedAgent.transform.localPosition = Vector3.zero;
		bindedAgent.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		lifeTimer += Time.deltaTime;
		if (!delayFromCollide || collide)
		{
			delayTimer += Time.deltaTime;
		}
		if (bindAgent)
		{
			if (bindedAgent == null)
			{
				UnityEngine.Debug.Log("bind  null destroied");
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else if (lifeTimer > 0.5f && !bindedAgent.gameObject.activeInHierarchy)
			{
				bindedAgent.gameObject.SetActive(value: true);
			}
		}
		else if (!exploded && delayTimer > delayTime)
		{
			exploded = true;
			if (!isLandmine)
			{
				Explode();
			}
			else
			{
				ActiveLandmine().Forget();
			}
		}
	}

	private void Explode()
	{
		if (createExplosion)
		{
			damageInfo.isExplosion = true;
			LevelManager.Instance.ExplosionManager.CreateExplosion(base.transform.position, damageRange, damageInfo, fxType, explosionShakeStrength, canHurtSelf);
		}
		if (createExplosion && needCustomFx && fx != null)
		{
			UnityEngine.Object.Instantiate(fx, base.transform.position, Quaternion.identity);
		}
		if ((bool)createOnExlode)
		{
			UnityEngine.Object.Instantiate(createOnExlode, base.transform.position, Quaternion.identity);
		}
		onExplodeEvent?.Invoke();
		if (rb != null)
		{
			rb.constraints = (RigidbodyConstraints)10;
		}
		if (destroyDelay <= 0f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else if (destroyDelay < 999f)
		{
			DestroyOverTime().Forget();
		}
	}

	private async UniTask DestroyOverTime()
	{
		await UniTask.WaitForSeconds(destroyDelay);
		if (!(base.gameObject == null))
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private async UniTask ActiveLandmine()
	{
		if (!landmineActived)
		{
			landmineActived = true;
			if ((bool)animator)
			{
				animator.SetBool("Actived", value: true);
			}
			OnTriggerEnterEvent trigger = new GameObject().AddComponent<OnTriggerEnterEvent>();
			SphereCollider sphereCollider = trigger.gameObject.AddComponent<SphereCollider>();
			sphereCollider.transform.SetParent(base.transform, worldPositionStays: false);
			sphereCollider.transform.localPosition = Vector3.zero;
			sphereCollider.isTrigger = true;
			sphereCollider.radius = landmineTriggerRange;
			trigger.filterByTeam = true;
			trigger.selfTeam = selfTeam;
			trigger.Init();
			await UniTask.WaitForEndOfFrame(this);
			trigger.DoOnTriggerEnter.AddListener(OnLinemineTriggerd);
		}
	}

	private void OnLinemineTriggerd()
	{
		if (!landmineTriggerd)
		{
			landmineTriggerd = true;
			Explode();
		}
	}

	public void SetWeaponIdInfo(int typeId)
	{
		damageInfo.fromWeaponItemID = typeId;
	}

	public void Launch(Vector3 startPoint, Vector3 velocity, CharacterMainControl fromCharacter, bool canHurtSelf)
	{
		this.canHurtSelf = canHurtSelf;
		groundLayer = LayerMask.NameToLayer("Ground");
		rb.position = startPoint;
		base.transform.position = startPoint;
		rb.velocity = velocity;
		Vector3 angularVelocity = (UnityEngine.Random.insideUnitSphere + Vector3.one) * 7f;
		angularVelocity.y = 0f;
		rb.angularVelocity = angularVelocity;
		if (fromCharacter != null)
		{
			Collider component = fromCharacter.GetComponent<Collider>();
			Collider component2 = GetComponent<Collider>();
			selfTeam = fromCharacter.Team;
			IgnoreCollisionForSeconds(component, component2, 0.5f).Forget();
		}
	}

	private async UniTask IgnoreCollisionForSeconds(Collider col1, Collider col2, float ignoreTime)
	{
		if (col1 != null && col2 != null)
		{
			Physics.IgnoreCollision(col1, col2, ignore: true);
		}
		await UniTask.WaitForSeconds(ignoreTime);
		if (col1 != null && col2 != null)
		{
			Physics.IgnoreCollision(col1, col2, ignore: false);
		}
	}
}
public class Projectile : MonoBehaviour
{
	public ProjectileContext context;

	public float radius;

	private float traveledDistance;

	private List<RaycastHit> hits;

	private LayerMask hitLayers;

	private Vector3 hitPoint;

	private Vector3 hitNormal;

	private bool dead;

	private bool overMaxDistance;

	[SerializeField]
	private GameObject hitFx;

	private Vector3 direction;

	private Vector3 velocity;

	private float gravity;

	[HideInInspector]
	public List<GameObject> damagedObjects;

	public static Action<Vector3> OnBulletFlyByCharacter;

	private bool flyThroughCharacterSoundPlayed;

	private bool firstFrame = true;

	private Vector3 startPoint;

	private UnityEngine.Pool.ObjectPool<Projectile> pool;

	[SerializeField]
	private TrailRenderer trail;

	[FormerlySerializedAs("spin")]
	public Transform randomRotate;

	private bool inited;

	private DamageReceiver _dmgReceiverTemp;

	private float _distanceThisFrame;

	private int _hitCount;

	public void SetPool(UnityEngine.Pool.ObjectPool<Projectile> _pool)
	{
		pool = _pool;
	}

	private void Release()
	{
		if (pool == null)
		{
			UnityEngine.Debug.Log("Destroy");
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			pool.Release(this);
		}
	}

	private void Awake()
	{
		if (!inited)
		{
			inited = true;
			Init();
		}
	}

	public void Init()
	{
		inited = true;
		damagedObjects = new List<GameObject>();
		damagedObjects.Clear();
		traveledDistance = 0f;
		dead = false;
		overMaxDistance = false;
		flyThroughCharacterSoundPlayed = false;
		firstFrame = true;
		hitLayers = (int)GameplayDataSettings.Layers.damageReceiverLayerMask | (int)GameplayDataSettings.Layers.wallLayerMask | (int)GameplayDataSettings.Layers.groundLayerMask;
		if ((bool)trail)
		{
			trail.Clear();
		}
		if ((bool)randomRotate)
		{
			randomRotate.localRotation = Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(0f, 360f));
		}
	}

	private void Update()
	{
		if (dead)
		{
			Release();
			return;
		}
		UpdateMoveAndCheck();
		if (dead)
		{
			if (firstFrame && (bool)trail)
			{
				trail.Clear();
			}
			if (context.explosionRange > 0f)
			{
				DamageInfo dmgInfo = new DamageInfo(context.fromCharacter);
				dmgInfo.damageValue = context.explosionDamage;
				dmgInfo.fromWeaponItemID = context.fromWeaponItemID;
				dmgInfo.armorPiercing = context.armorPiercing;
				LevelManager.Instance.ExplosionManager.CreateExplosion(base.transform.position, context.explosionRange, dmgInfo);
			}
			Release();
		}
		UpdateFlyThroughSound();
		firstFrame = false;
	}

	private void UpdateFlyThroughSound()
	{
		if (dead || context.team == Teams.player || flyThroughCharacterSoundPlayed || CharacterMainControl.Main == null || velocity.magnitude < 9f)
		{
			return;
		}
		Vector3 lhs = CharacterMainControl.Main.transform.position - base.transform.position;
		lhs.y = 0f;
		if (!(lhs.magnitude > 5f))
		{
			lhs.Normalize();
			if (!(Vector3.Dot(lhs, velocity) > 0f))
			{
				flyThroughCharacterSoundPlayed = true;
				OnBulletFlyByCharacter?.Invoke(base.transform.position);
			}
		}
	}

	public void Init(ProjectileContext _context)
	{
		Init();
		context = _context;
		direction = context.direction;
		velocity = context.speed * direction;
		gravity = Mathf.Abs(context.gravity);
		UpdateAimDirection();
	}

	private void UpdateMoveAndCheck()
	{
		if (firstFrame)
		{
			startPoint = base.transform.position;
		}
		float num = Time.deltaTime;
		if (num > 0.04f)
		{
			num = 0.04f;
		}
		velocity.y -= num * gravity;
		direction = velocity.normalized;
		UpdateAimDirection();
		_distanceThisFrame = velocity.magnitude * num;
		if (_distanceThisFrame + traveledDistance > context.distance)
		{
			_distanceThisFrame = context.distance - traveledDistance;
			overMaxDistance = true;
		}
		Vector3 origin = base.transform.position - base.transform.forward * 0.1f;
		if (firstFrame && context.firstFrameCheck)
		{
			origin = context.firstFrameCheckStartPoint;
		}
		hits = Physics.SphereCastAll(origin, radius, direction, _distanceThisFrame + 0.3f, hitLayers, QueryTriggerInteraction.Ignore).ToList();
		int count = hits.Count;
		if (count > 0)
		{
			hits.Sort((RaycastHit a, RaycastHit b) => (a.distance > b.distance) ? 1 : 0);
			for (int num2 = 0; num2 < count; num2++)
			{
				RaycastHit raycastHit = hits[num2];
				hitPoint = raycastHit.point;
				if (raycastHit.distance <= 0f)
				{
					hitPoint = raycastHit.collider.transform.position;
				}
				if (damagedObjects.Contains(hits[num2].collider.gameObject) || (context.ignoreHalfObsticle && GameplayDataSettings.LayersData.IsLayerInLayerMask(hits[num2].collider.gameObject.layer, GameplayDataSettings.Layers.halfObsticleLayer)))
				{
					continue;
				}
				damagedObjects.Add(hits[num2].collider.gameObject);
				if (((int)GameplayDataSettings.Layers.damageReceiverLayerMask & (1 << hits[num2].collider.gameObject.layer)) != 0)
				{
					_dmgReceiverTemp = hits[num2].collider.GetComponent<DamageReceiver>();
					if (_dmgReceiverTemp.Team == context.team || (_dmgReceiverTemp.isHalfObsticle && context.ignoreHalfObsticle))
					{
						continue;
					}
				}
				else
				{
					_dmgReceiverTemp = null;
				}
				if ((bool)_dmgReceiverTemp)
				{
					bool flag = true;
					if (_dmgReceiverTemp.Team == context.team)
					{
						flag = false;
					}
					else if ((bool)_dmgReceiverTemp.health)
					{
						CharacterMainControl characterMainControl = _dmgReceiverTemp.health.TryGetCharacter();
						if ((bool)characterMainControl && _dmgReceiverTemp.health.TryGetCharacter().Dashing)
						{
							flag = false;
						}
						else if ((bool)characterMainControl && characterMainControl == context.fromCharacter)
						{
							flag = false;
						}
					}
					if (flag)
					{
						DamageInfo damageInfo = new DamageInfo(context.fromCharacter);
						damageInfo.damageValue = context.damage;
						if (context.halfDamageDistance > 0f && Vector3.Distance(startPoint, hitPoint) > context.halfDamageDistance)
						{
							damageInfo.damageValue *= 0.5f;
						}
						damageInfo.critDamageFactor = context.critDamageFactor;
						damageInfo.critRate = context.critRate;
						damageInfo.armorPiercing = context.armorPiercing;
						damageInfo.armorBreak = context.armorBreak;
						damageInfo.elementFactors.Add(new ElementFactor(ElementTypes.physics, context.element_Physics));
						damageInfo.elementFactors.Add(new ElementFactor(ElementTypes.fire, context.element_Fire));
						damageInfo.elementFactors.Add(new ElementFactor(ElementTypes.poison, context.element_Poison));
						damageInfo.elementFactors.Add(new ElementFactor(ElementTypes.electricity, context.element_Electricity));
						damageInfo.elementFactors.Add(new ElementFactor(ElementTypes.space, context.element_Space));
						damageInfo.damagePoint = hitPoint;
						damageInfo.buffChance = context.buffChance;
						damageInfo.buff = context.buff;
						damageInfo.bleedChance = context.bleedChance;
						damageInfo.damageType = DamageTypes.normal;
						damageInfo.fromWeaponItemID = context.fromWeaponItemID;
						damageInfo.damageNormal = raycastHit.normal.normalized;
						_dmgReceiverTemp.Hurt(damageInfo);
						_dmgReceiverTemp.AddBuff(GameplayDataSettings.Buffs.Pain, context.fromCharacter);
						context.penetrate--;
						if (context.penetrate < 0)
						{
							base.transform.position = hitPoint;
							dead = true;
							break;
						}
					}
					continue;
				}
				dead = true;
				base.transform.position = hitPoint;
				Vector3 normal = raycastHit.normal;
				if ((bool)hitFx)
				{
					UnityEngine.Object.Instantiate(hitFx, hitPoint, Quaternion.LookRotation(normal, Vector3.up));
				}
				else
				{
					UnityEngine.Object.Instantiate(GameplayDataSettings.Prefabs.BulletHitObsticleFx, hitPoint, Quaternion.LookRotation(normal, Vector3.up));
				}
				break;
			}
		}
		if (overMaxDistance)
		{
			dead = true;
		}
		if (!dead)
		{
			base.transform.position += direction * _distanceThisFrame;
			traveledDistance += _distanceThisFrame;
		}
	}

	private void UpdateAimDirection()
	{
		base.transform.rotation = Quaternion.LookRotation(direction, Vector3.up);
	}
}
public struct ProjectileContext
{
	public Vector3 direction;

	public bool firstFrameCheck;

	public Vector3 firstFrameCheckStartPoint;

	public float halfDamageDistance;

	public float distance;

	public float speed;

	public Teams team;

	public int penetrate;

	public float damage;

	public float critDamageFactor;

	public float critRate;

	public float armorPiercing;

	public float armorBreak;

	public float element_Physics;

	public float element_Fire;

	public float element_Poison;

	public float element_Electricity;

	public float element_Space;

	public CharacterMainControl fromCharacter;

	public float gravity;

	public float explosionRange;

	public float explosionDamage;

	public float buffChance;

	public Buff buff;

	public float bleedChance;

	public bool ignoreHalfObsticle;

	[ItemTypeID]
	public int fromWeaponItemID;
}
public enum Teams
{
	player = 0,
	scav = 1,
	usec = 3,
	bear = 4,
	middle = 5,
	lab = 6,
	all = 7,
	wolf = 8
}
public class Team
{
	public static bool IsEnemy(Teams selfTeam, Teams targetTeam)
	{
		switch (selfTeam)
		{
		case Teams.middle:
			return false;
		case Teams.all:
			return true;
		default:
			if (targetTeam == Teams.middle)
			{
				return false;
			}
			return selfTeam != targetTeam;
		}
	}
}
public class ADSAimMarker : MonoBehaviour
{
	[HideInInspector]
	public ADSAimMarker selfPrefab;

	public bool hideNormalCrosshair = true;

	public AimMarker parentAimMarker;

	public RectTransform aimMarkerUI;

	public RectTransform followUI;

	public UnityEngine.CanvasGroup canvasGroup;

	public float followSpeed;

	public float followMaxDistance = 30f;

	private float adsValue = -1f;

	private float canvasAlpha;

	public Vector2 adsAlphaRemap = new Vector2(0f, 1f);

	public List<ProceduralImage> proceduralImages;

	private List<UnityEngine.CanvasGroup> proceduralImageCanvasGroups;

	public List<PunchReceiver> shootPunchReceivers;

	public List<SingleCrosshair> crosshairs;

	public Graphic sniperRoundRenderer;

	public Graphic followSniperRoundRenderer;

	private float scatter;

	private float minScatter;

	private RectTransform selfRect;

	private int sniperCenterShaderHash = Shader.PropertyToID("_RoundCenter");

	public float CanvasAlpha => canvasAlpha;

	public void CollectCrosshairs()
	{
		crosshairs.Clear();
		SingleCrosshair[] componentsInChildren = GetComponentsInChildren<SingleCrosshair>();
		foreach (SingleCrosshair item in componentsInChildren)
		{
			crosshairs.Add(item);
		}
	}

	private void Awake()
	{
		proceduralImageCanvasGroups = new List<UnityEngine.CanvasGroup>();
		for (int i = 0; i < proceduralImages.Count; i++)
		{
			proceduralImageCanvasGroups.Add(proceduralImages[i].GetComponent<UnityEngine.CanvasGroup>());
		}
		selfRect = GetComponent<RectTransform>();
	}

	private void LateUpdate()
	{
		if ((bool)selfRect)
		{
			selfRect.localScale = Vector3.one;
		}
		followUI.position = Vector3.Lerp(followUI.position, aimMarkerUI.position, Time.deltaTime * followSpeed);
		if (Vector3.Distance(followUI.position, aimMarkerUI.position) > followMaxDistance)
		{
			followUI.position = Vector3.MoveTowards(aimMarkerUI.position, followUI.position, followMaxDistance);
		}
		foreach (SingleCrosshair crosshair in crosshairs)
		{
			if ((bool)crosshair)
			{
				crosshair.UpdateScatter(scatter);
			}
		}
		SetSniperRenderer();
	}

	public void SetAimMarkerPos(Vector3 pos)
	{
		aimMarkerUI.position = pos;
	}

	public void OnShoot()
	{
		foreach (PunchReceiver shootPunchReceiver in shootPunchReceivers)
		{
			if ((bool)shootPunchReceiver)
			{
				shootPunchReceiver.Punch();
			}
		}
	}

	public void SetScatter(float _currentScatter, float _minScatter)
	{
		scatter = _currentScatter;
		minScatter = _minScatter;
	}

	public void SetAdsValue(float _adsValue)
	{
		adsValue = _adsValue;
		canvasAlpha = _adsValue;
		if (adsAlphaRemap.y > adsAlphaRemap.x)
		{
			canvasAlpha = Mathf.Clamp01((_adsValue - adsAlphaRemap.x) / (adsAlphaRemap.y - adsAlphaRemap.x));
		}
		this.canvasGroup.alpha = canvasAlpha;
		for (int i = 0; i < proceduralImages.Count; i++)
		{
			ProceduralImage proceduralImage = proceduralImages[i];
			if ((bool)proceduralImage)
			{
				float num = Mathf.Clamp(scatter - minScatter, 0f, 10f) * 2f;
				proceduralImage.FalloffDistance = Mathf.Lerp(25f, 1f, canvasAlpha) + num;
				UnityEngine.CanvasGroup canvasGroup = proceduralImageCanvasGroups[i];
				if ((bool)canvasGroup)
				{
					canvasGroup.alpha = Mathf.Clamp(1f - (num - 2f) / 15f, 0.3f, 1f);
				}
			}
		}
	}

	private void SetSniperRenderer()
	{
		if ((bool)sniperRoundRenderer)
		{
			Vector2 vector = RectTransformUtility.WorldToScreenPoint(null, aimMarkerUI.position) / new Vector2(Screen.width, Screen.height);
			sniperRoundRenderer.material.SetVector(sniperCenterShaderHash, vector);
		}
		if ((bool)followSniperRoundRenderer)
		{
			Vector2 vector2 = RectTransformUtility.WorldToScreenPoint(null, followUI.position) / new Vector2(Screen.width, Screen.height);
			followSniperRoundRenderer.material.SetVector(sniperCenterShaderHash, vector2);
		}
	}
}
public class AimMarker : MonoBehaviour
{
	public RectTransform aimMarkerUI;

	public List<UnityEngine.UI.Image> aimMarkerImages;

	public RectTransform left;

	public RectTransform right;

	public RectTransform up;

	public RectTransform down;

	private float scatter;

	private float minScatter;

	public UnityEngine.CanvasGroup rootCanvasGroup;

	public UnityEngine.CanvasGroup normalAimCanvasGroup;

	public Animator aimMarkerAnimator;

	public ActionProgressHUD reloadProgressBar;

	public UnityEvent onShoot;

	private ADSAimMarker currentAdsAimMarker;

	[SerializeField]
	private ADSAimMarker defaultAdsAimMarker;

	private readonly int inProgressHash = Animator.StringToHash("InProgress");

	private readonly int killMarkerHash = Animator.StringToHash("KillMarkerShow");

	[SerializeField]
	private TextMeshProUGUI distanceText;

	[SerializeField]
	private TrueShadow distanceGlow;

	[SerializeField]
	private Color distanceTextColorFull;

	[SerializeField]
	private Color distanceTextColorHalf;

	[SerializeField]
	private Color distanceTextColorOver;

	private float adsValue;

	private float killMarkerTime = 0.6f;

	private float killMarkerTimer;

	private Camera _cam;

	private Camera MainCam
	{
		get
		{
			if (!_cam)
			{
				if (LevelManager.Instance == null)
				{
					return null;
				}
				if (LevelManager.Instance.GameCamera == null)
				{
					return null;
				}
				_cam = LevelManager.Instance.GameCamera.renderCamera;
			}
			return _cam;
		}
	}

	private void Awake()
	{
		if (!currentAdsAimMarker)
		{
			SwitchAdsAimMarker(defaultAdsAimMarker);
		}
	}

	private void Start()
	{
		rootCanvasGroup.alpha = 1f;
		ItemAgent_Gun.OnMainCharacterShootEvent += OnMainCharacterShoot;
		Health.OnDead += OnKill;
	}

	private void OnDestroy()
	{
		ItemAgent_Gun.OnMainCharacterShootEvent -= OnMainCharacterShoot;
		Health.OnDead -= OnKill;
	}

	private void Update()
	{
		aimMarkerAnimator.SetBool(inProgressHash, reloadProgressBar.InProgress);
		if (killMarkerTimer > 0f)
		{
			killMarkerTimer -= Time.deltaTime;
			aimMarkerAnimator.SetBool(killMarkerHash, killMarkerTimer > 0f);
		}
		CharacterMainControl main = CharacterMainControl.Main;
		if (main == null)
		{
			return;
		}
		if (main.Health.IsDead)
		{
			rootCanvasGroup.alpha = 0f;
			return;
		}
		InputManager inputManager = LevelManager.Instance.InputManager;
		if (!(inputManager == null))
		{
			Vector3 inputAimPoint = inputManager.InputAimPoint;
			Vector3 vector = MainCam.WorldToScreenPoint(inputAimPoint);
			vector = inputManager.AimScreenPoint;
			SetAimMarkerPosScreenSpace(vector);
		}
	}

	private void LateUpdate()
	{
		CharacterMainControl main = CharacterMainControl.Main;
		if (main == null)
		{
			return;
		}
		InputManager inputManager = LevelManager.Instance.InputManager;
		if (inputManager == null)
		{
			return;
		}
		float num = 0f;
		Vector3 inputAimPoint = inputManager.InputAimPoint;
		ItemAgent_Gun gun = main.GetGun();
		Color color = distanceTextColorFull;
		if (gun != null)
		{
			if (adsValue == 0f && gun.AdsValue > 0f)
			{
				OnStartAdsWithGun(gun);
			}
			adsValue = gun.AdsValue;
			scatter = Mathf.MoveTowards(scatter, gun.CurrentScatter, 500f * Time.deltaTime);
			minScatter = Mathf.MoveTowards(minScatter, gun.MinScatter, 500f * Time.deltaTime);
			left.anchoredPosition = Vector3.left * (20f + scatter * 5f);
			right.anchoredPosition = Vector3.right * (20f + scatter * 5f);
			up.anchoredPosition = Vector3.up * (20f + scatter * 5f);
			down.anchoredPosition = Vector3.down * (20f + scatter * 5f);
			num = Vector3.Distance(inputAimPoint, gun.muzzle.position);
			float bulletDistance = gun.BulletDistance;
			color = ((num < bulletDistance * 0.495f) ? distanceTextColorFull : ((!(num < bulletDistance)) ? distanceTextColorOver : distanceTextColorHalf));
		}
		else
		{
			adsValue = 0f;
			scatter = 0f;
			minScatter = 0f;
			num = Vector3.Distance(inputAimPoint, main.transform.position + Vector3.up * 0.5f);
			color = distanceTextColorFull;
		}
		float alpha = Mathf.Clamp01((0.5f - adsValue) * 2f);
		if ((bool)currentAdsAimMarker)
		{
			currentAdsAimMarker.SetScatter(scatter, minScatter);
			currentAdsAimMarker.SetAdsValue(adsValue);
			if (!currentAdsAimMarker.hideNormalCrosshair)
			{
				alpha = 1f;
			}
		}
		else
		{
			alpha = 1f;
		}
		normalAimCanvasGroup.alpha = alpha;
		if ((bool)distanceText)
		{
			distanceText.text = num.ToString("00") + " M";
			distanceText.color = color;
			distanceGlow.Color = color;
		}
	}

	public void SetAimMarkerPosScreenSpace(Vector3 pos)
	{
		aimMarkerUI.position = pos;
		if ((bool)currentAdsAimMarker)
		{
			currentAdsAimMarker.SetAimMarkerPos(pos);
		}
	}

	private void OnStartAdsWithGun(ItemAgent_Gun gun)
	{
		ADSAimMarker aimMarkerPfb = gun.GetAimMarkerPfb();
		if ((bool)aimMarkerPfb)
		{
			SwitchAdsAimMarker(aimMarkerPfb);
		}
	}

	private void SwitchAdsAimMarker(ADSAimMarker newAimMarkerPfb)
	{
		if (newAimMarkerPfb == null)
		{
			UnityEngine.Object.Destroy(currentAdsAimMarker.gameObject);
			currentAdsAimMarker = null;
		}
		else if (!currentAdsAimMarker || !(newAimMarkerPfb == currentAdsAimMarker.selfPrefab))
		{
			if ((bool)currentAdsAimMarker)
			{
				UnityEngine.Object.Destroy(currentAdsAimMarker.gameObject);
			}
			currentAdsAimMarker = UnityEngine.Object.Instantiate(newAimMarkerPfb);
			currentAdsAimMarker.selfPrefab = newAimMarkerPfb;
			currentAdsAimMarker.transform.SetParent(base.transform);
			currentAdsAimMarker.parentAimMarker = this;
			RectTransform obj = currentAdsAimMarker.transform as RectTransform;
			obj.anchorMin = Vector2.zero;
			obj.anchorMax = Vector2.one;
			obj.sizeDelta = Vector2.zero;
			obj.offsetMax = Vector2.zero;
			obj.offsetMin = Vector2.zero;
		}
	}

	private void SetAimMarkerColor(Color col)
	{
		int count = aimMarkerImages.Count;
		for (int i = 0; i < count; i++)
		{
			aimMarkerImages[i].color = col;
		}
	}

	private void OnKill(Health _health, DamageInfo dmgInfo)
	{
		if (!(_health == null) && _health.team != Teams.player)
		{
			killMarkerTimer = killMarkerTime;
		}
	}

	private void OnMainCharacterShoot(ItemAgent_Gun gunAgnet)
	{
		onShoot?.Invoke();
		if ((bool)currentAdsAimMarker)
		{
			currentAdsAimMarker.OnShoot();
		}
	}
}
public class AimTargetFinder : MonoBehaviour
{
	private Vector3 searchPoint;

	public float searchRadius;

	private LayerMask damageReceiverLayers;

	private Collider[] overlapcColliders;

	private void Start()
	{
	}

	public Transform Find(bool search, Vector3 findPoint, ref CharacterMainControl foundCharacter)
	{
		Transform result = null;
		if (search)
		{
			result = Search(findPoint, ref foundCharacter);
		}
		return result;
	}

	private Transform Search(Vector3 findPoint, ref CharacterMainControl character)
	{
		character = null;
		if (overlapcColliders == null)
		{
			overlapcColliders = new Collider[6];
			damageReceiverLayers = GameplayDataSettings.Layers.damageReceiverLayerMask;
		}
		int num = Physics.OverlapSphereNonAlloc(findPoint, searchRadius, overlapcColliders, damageReceiverLayers);
		Collider collider = null;
		if (num > 0)
		{
			for (int i = 0; i < num; i++)
			{
				DamageReceiver component = overlapcColliders[i].GetComponent<DamageReceiver>();
				if (!(component == null) && component.Team != Teams.player)
				{
					collider = overlapcColliders[i];
					if (component.health != null)
					{
						character = component.health.GetComponent<CharacterMainControl>();
					}
					break;
				}
			}
		}
		if ((bool)collider)
		{
			return collider.transform;
		}
		return null;
	}
}
public class CharacterInputControl : MonoBehaviour
{
	private class InputActionReferences
	{
		public InputAction MoveAxis;

		public InputAction Run;

		public InputAction Aim;

		public InputAction MousePos;

		public InputAction ItemShortcut1;

		public InputAction ItemShortcut2;

		public InputAction Skill_1_StartAim;

		public InputAction Reload;

		public InputAction UI_Inventory;

		public InputAction UI_Map;

		public InputAction Interact;

		public InputAction ScrollWheel;

		public InputAction SwitchWeapon;

		public InputAction SwitchInteractAndBulletType;

		public InputAction Trigger;

		public InputAction ToggleView;

		public InputAction ToggleNightVision;

		public InputAction CancelSkill;

		public InputAction Dash;

		public InputAction ItemShortcut3;

		public InputAction ItemShortcut4;

		public InputAction ItemShortcut5;

		public InputAction ItemShortcut6;

		public InputAction ItemShortcut7;

		public InputAction ItemShortcut8;

		public InputAction ADS;

		public InputAction UI_Quest;

		public InputAction StopAction;

		public InputAction PutAway;

		public InputAction ItemShortcut_Melee;

		public InputAction MouseDelta;

		public InputAction SwitchBulletType;

		public InputActionReferences(PlayerInput playerInput)
		{
			InputActionAsset actions = playerInput.actions;
			Type typeFromHandle = typeof(InputActionReferences);
			Type typeFromHandle2 = typeof(InputAction);
			FieldInfo[] fields = typeFromHandle.GetFields();
			FieldInfo[] array = fields;
			foreach (FieldInfo fieldInfo in array)
			{
				if (fieldInfo.FieldType != typeFromHandle2)
				{
					UnityEngine.Debug.LogError(fieldInfo.FieldType.Name);
					continue;
				}
				InputAction inputAction = actions[fieldInfo.Name];
				if (inputAction == null)
				{
					UnityEngine.Debug.LogError("找不到名为 " + fieldInfo.Name + " 的input action");
				}
				else
				{
					fieldInfo.SetValue(this, inputAction);
				}
			}
			array = fields;
			foreach (FieldInfo fieldInfo2 in array)
			{
				if (!(fieldInfo2.FieldType != typeFromHandle2))
				{
					fieldInfo2.GetValue(this);
				}
			}
		}
	}

	public InputManager inputManager;

	private bool runInput;

	private bool adsInput;

	private bool aimDown;

	private Vector2 mousePos;

	private Vector2 mouseDelta;

	private bool mouseKeyboardTriggerInput;

	private bool mouseKeyboardTriggerReleaseThisFrame;

	private bool mouseKeyboardTriggerInputThisFrame;

	private CharacterMainControl character;

	private InputActionReferences inputActions;

	private Queue<Action> unbindCommands = new Queue<Action>();

	private float scollY;

	private int scollYZeroFrames;

	public static CharacterInputControl Instance { get; private set; }

	private PlayerInput PlayerInput => GameManager.MainPlayerInput;

	private bool usingMouseAndKeyboard => InputManager.InputDevice == InputManager.InputDevices.mouseKeyboard;

	private void Awake()
	{
		Instance = this;
		inputActions = new InputActionReferences(PlayerInput);
		RegisterEvents();
	}

	private void OnDestroy()
	{
		UnregisterEvent();
	}

	private void RegisterEvents()
	{
		Bind(inputActions.MoveAxis, OnPlayerMoveInput);
		Bind(inputActions.Run, OnPlayerRunInput);
		Bind(inputActions.MousePos, OnPlayerMouseMove);
		Bind(inputActions.Skill_1_StartAim, OnStartCharacterSkillAim);
		Bind(inputActions.Reload, OnReloadInput);
		Bind(inputActions.Interact, OnInteractInput);
		Bind(inputActions.ScrollWheel, OnMouseScollerInput);
		Bind(inputActions.SwitchWeapon, OnSwitchWeaponInput);
		Bind(inputActions.SwitchInteractAndBulletType, OnSwitchInteractAndBulletTypeInput);
		Bind(inputActions.Trigger, OnPlayerTriggerInputUsingMouseKeyboard);
		Bind(inputActions.ToggleView, OnToggleViewInput);
		Bind(inputActions.ToggleNightVision, OnToggleNightVisionInput);
		Bind(inputActions.CancelSkill, OnCancelSkillInput);
		Bind(inputActions.Dash, OnDashInput);
		Bind(inputActions.ItemShortcut1, OnPlayerSwitchItemAgent1);
		Bind(inputActions.ItemShortcut2, OnPlayerSwitchItemAgent2);
		Bind(inputActions.ItemShortcut3, OnShortCutInput3);
		Bind(inputActions.ItemShortcut4, OnShortCutInput4);
		Bind(inputActions.ItemShortcut5, OnShortCutInput5);
		Bind(inputActions.ItemShortcut6, OnShortCutInput6);
		Bind(inputActions.ItemShortcut7, OnShortCutInput7);
		Bind(inputActions.ItemShortcut8, OnShortCutInput8);
		Bind(inputActions.ADS, OnPlayerAdsInput);
		Bind(inputActions.UI_Inventory, OnUIInventoryInput);
		Bind(inputActions.UI_Map, OnUIMapInput);
		Bind(inputActions.UI_Quest, OnUIQuestViewInput);
		Bind(inputActions.StopAction, OnPlayerStopAction);
		Bind(inputActions.PutAway, OnPutAwayInput);
		Bind(inputActions.ItemShortcut_Melee, OnPlayerSwitchItemAgentMelee);
		Bind(inputActions.MouseDelta, OnPlayerMouseDelta);
	}

	private void UnregisterEvent()
	{
		while (unbindCommands.Count > 0)
		{
			unbindCommands.Dequeue()();
		}
	}

	private void Bind(InputAction action, Action<InputAction.CallbackContext> method)
	{
		action.performed += method;
		action.started += method;
		action.canceled += method;
		unbindCommands.Enqueue(delegate
		{
			Unbind(action, method);
		});
	}

	private void Unbind(InputAction action, Action<InputAction.CallbackContext> method)
	{
		action.performed -= method;
		action.started -= method;
		action.canceled -= method;
	}

	private void Update()
	{
		if (!character)
		{
			character = CharacterMainControl.Main;
			if (!character)
			{
				return;
			}
		}
		if (usingMouseAndKeyboard)
		{
			inputManager.SetMousePosition(mousePos);
			inputManager.SetAimInputUsingMouse(mouseDelta);
			inputManager.SetTrigger(mouseKeyboardTriggerInput, mouseKeyboardTriggerInputThisFrame, mouseKeyboardTriggerReleaseThisFrame);
			if (character.skillAction.holdItemSkillKeeper.CheckSkillAndBinding())
			{
				inputManager.SetAimType(AimTypes.handheldSkill);
				if (mouseKeyboardTriggerInputThisFrame)
				{
					inputManager.StartItemSkillAim();
				}
				else if (mouseKeyboardTriggerReleaseThisFrame)
				{
					UnityEngine.Debug.Log("Release");
					inputManager.ReleaseItemSkill();
				}
			}
			else
			{
				inputManager.SetAimType(AimTypes.normalAim);
			}
			UpdateScollerInput();
		}
		mouseKeyboardTriggerInputThisFrame = false;
		mouseKeyboardTriggerReleaseThisFrame = false;
	}

	public void OnPlayerMoveInput(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			Vector2 moveInput = context.ReadValue<Vector2>();
			inputManager.SetMoveInput(moveInput);
		}
		if (context.canceled)
		{
			inputManager.SetMoveInput(Vector2.zero);
		}
	}

	public void OnPlayerRunInput(InputAction.CallbackContext context)
	{
		runInput = false;
		if (context.started)
		{
			inputManager.SetRunInput(run: true);
			runInput = true;
		}
		if (context.canceled)
		{
			inputManager.SetRunInput(run: false);
			runInput = false;
		}
	}

	public void OnPlayerAdsInput(InputAction.CallbackContext context)
	{
		adsInput = false;
		if (context.started)
		{
			inputManager.SetAdsInput(ads: true);
			adsInput = true;
		}
		if (context.canceled)
		{
			inputManager.SetAdsInput(ads: false);
			adsInput = false;
		}
	}

	public void OnToggleViewInput(InputAction.CallbackContext context)
	{
		if (!GameManager.Paused && context.started)
		{
			inputManager.ToggleView();
		}
	}

	public void OnToggleNightVisionInput(InputAction.CallbackContext context)
	{
		if (!GameManager.Paused && context.started)
		{
			inputManager.ToggleNightVision();
		}
	}

	public void OnPlayerTriggerInputUsingMouseKeyboard(InputAction.CallbackContext context)
	{
		if (InputManager.InputDevice == InputManager.InputDevices.mouseKeyboard)
		{
			if (context.started)
			{
				mouseKeyboardTriggerInputThisFrame = true;
				mouseKeyboardTriggerInput = true;
				mouseKeyboardTriggerReleaseThisFrame = false;
			}
			else if (context.canceled)
			{
				mouseKeyboardTriggerInputThisFrame = false;
				mouseKeyboardTriggerInput = false;
				mouseKeyboardTriggerReleaseThisFrame = true;
			}
		}
	}

	public void OnPlayerMouseMove(InputAction.CallbackContext context)
	{
		mousePos = context.ReadValue<Vector2>();
	}

	public void OnPlayerMouseDelta(InputAction.CallbackContext context)
	{
		mouseDelta = context.ReadValue<Vector2>();
	}

	public void OnPlayerStopAction(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			inputManager.StopAction();
		}
	}

	public void OnPlayerSwitchItemAgent1(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			inputManager.SwitchItemAgent(1);
		}
	}

	public void OnPlayerSwitchItemAgent2(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			inputManager.SwitchItemAgent(2);
		}
	}

	public void OnPlayerSwitchItemAgentMelee(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			inputManager.SwitchItemAgent(3);
		}
	}

	public void OnStartCharacterSkillAim(InputAction.CallbackContext context)
	{
		inputManager.StartCharacterSkillAim();
	}

	public void OnCharacterSkillRelease()
	{
		inputManager.ReleaseCharacterSkill();
	}

	public void OnReloadInput(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			CharacterMainControl.Main?.TryToReload();
		}
	}

	public void OnUIInventoryInput(InputAction.CallbackContext context)
	{
		if (!context.performed || GameManager.Paused || DialogueUI.Active || SceneLoader.IsSceneLoading)
		{
			return;
		}
		if (View.ActiveView == null)
		{
			if (LevelManager.Instance.IsBaseLevel)
			{
				PlayerStorage.Instance.InteractableLootBox.InteractWithMainCharacter();
			}
			else
			{
				InventoryView.Show();
			}
		}
		else
		{
			View.ActiveView.TryQuit();
		}
	}

	public void OnUIQuestViewInput(InputAction.CallbackContext context)
	{
		if (context.performed && !GameManager.Paused && !DialogueUI.Active)
		{
			if (View.ActiveView == null)
			{
				QuestView.Show();
			}
			else if (View.ActiveView is QuestView)
			{
				View.ActiveView.TryQuit();
			}
		}
	}

	public void OnDashInput(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			inputManager.Dash();
		}
	}

	public void OnUIMapInput(InputAction.CallbackContext context)
	{
		if (context.performed && !GameManager.Paused && !SceneLoader.IsSceneLoading)
		{
			if (View.ActiveView == null)
			{
				MiniMapView.Show();
			}
			else if (View.ActiveView is MiniMapView miniMapView)
			{
				miniMapView.Close();
			}
		}
	}

	public void OnCancelSkillInput(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			inputManager.CancleSkill();
		}
	}

	public void OnInteractInput(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			inputManager.Interact();
		}
	}

	public void OnPutAwayInput(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			inputManager.PutAway();
		}
	}

	public void OnMouseScollerInput(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			scollY = context.ReadValue<Vector2>().y;
		}
	}

	private void UpdateScollerInput()
	{
		if (Mathf.Abs(scollY) > 0.5f && (float)scollYZeroFrames > 3f)
		{
			if (ScrollWheelBehaviour.CurrentBehaviour == ScrollWheelBehaviour.Behaviour.AmmoAndInteract)
			{
				inputManager.SetSwitchInteractInput((scollY > 0f) ? 1 : (-1));
				inputManager.SetSwitchBulletTypeInput((scollY > 0f) ? 1 : (-1));
			}
			else
			{
				inputManager.SetSwitchWeaponInput((scollY > 0f) ? 1 : (-1));
			}
		}
		if (Mathf.Abs(scollY) < 0.5f)
		{
			scollYZeroFrames++;
		}
		else
		{
			scollYZeroFrames = 0;
		}
	}

	public void OnSwitchWeaponInput(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			float num = context.ReadValue<float>();
			inputManager.SetSwitchWeaponInput((!(num > 0f)) ? 1 : (-1));
		}
	}

	public void OnSwitchInteractAndBulletTypeInput(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			float num = context.ReadValue<float>();
			inputManager.SetSwitchInteractInput((!(num > 0f)) ? 1 : (-1));
			inputManager.SetSwitchBulletTypeInput((!(num > 0f)) ? 1 : (-1));
		}
	}

	private void ShortCutInput(int index)
	{
		if (View.ActiveView != null)
		{
			UIInputManager.NotifyShortcutInput(index - 3);
			return;
		}
		Item item = ItemShortcut.Get(index - 3);
		if (!(item == null) && (bool)character)
		{
			if ((bool)item && (bool)item.UsageUtilities && item.UsageUtilities.IsUsable(item, character))
			{
				character.UseItem(item);
			}
			else if ((bool)item && item.GetBool("IsSkill"))
			{
				character.ChangeHoldItem(item);
			}
			else if ((bool)item && item.HasHandHeldAgent)
			{
				UnityEngine.Debug.Log("has hand held");
				character.ChangeHoldItem(item);
			}
		}
	}

	public void OnShortCutInput3(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			ShortCutInput(3);
		}
	}

	public void OnShortCutInput4(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			ShortCutInput(4);
		}
	}

	public void OnShortCutInput5(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			ShortCutInput(5);
		}
	}

	public void OnShortCutInput6(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			ShortCutInput(6);
		}
	}

	public void OnShortCutInput7(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			ShortCutInput(7);
		}
	}

	public void OnShortCutInput8(InputAction.CallbackContext context)
	{
		if (context.performed)
		{
			ShortCutInput(8);
		}
	}

	internal static InputAction GetInputAction(string name)
	{
		if (Instance == null)
		{
			return null;
		}
		try
		{
			return Instance.PlayerInput.actions[name];
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			UnityEngine.Debug.LogError("查找 Input Action " + name + " 时发生错误, 返回null");
			return null;
		}
	}

	public static bool GetChangeBulletTypeWasPressed()
	{
		return Instance.inputActions.SwitchBulletType.WasPressedThisFrame();
	}
}
public class CharacterTouchInputControl : MonoBehaviour
{
	public InputManager characterInputManager;

	public void SetMoveInput(Vector2 axisInput, bool holding)
	{
		characterInputManager.SetMoveInput(axisInput);
	}

	public void SetRunInput(bool holding)
	{
		characterInputManager.SetRunInput(holding);
	}

	public void SetAdsInput(bool holding)
	{
		characterInputManager.SetAdsInput(holding);
	}

	public void SetGunAimInput(Vector2 axisInput, bool holding)
	{
		characterInputManager.SetAimInputUsingJoystick(axisInput);
		characterInputManager.SetAimType(AimTypes.normalAim);
	}

	public void SetCharacterSkillAimInput(Vector2 axisInput, bool holding)
	{
		characterInputManager.SetAimInputUsingJoystick(axisInput);
		characterInputManager.SetAimType(AimTypes.characterSkill);
	}

	public void StartCharacterSkillAim()
	{
		characterInputManager.StartCharacterSkillAim();
	}

	public void CharacterSkillRelease(bool trigger)
	{
		if (!trigger)
		{
			characterInputManager.CancleSkill();
		}
		else
		{
			characterInputManager.ReleaseCharacterSkill();
		}
	}

	public void SetItemSkillAimInput(Vector2 axisInput, bool holding)
	{
		characterInputManager.SetAimInputUsingJoystick(axisInput);
		characterInputManager.SetAimType(AimTypes.handheldSkill);
	}

	public void StartItemSkillAim()
	{
		characterInputManager.StartItemSkillAim();
	}

	public void ItemSkillRelease(bool trigger)
	{
		if (!trigger)
		{
			characterInputManager.CancleSkill();
		}
		else
		{
			characterInputManager.ReleaseItemSkill();
		}
	}
}
public class HitMarker : MonoBehaviour
{
	public UnityEvent hitEvent;

	public UnityEvent killEvent;

	public Animator animator;

	private readonly int hitHash1 = Animator.StringToHash("HitMarkerHit1");

	private readonly int hitHash2 = Animator.StringToHash("HitMarkerHit2");

	private readonly int critHash1 = Animator.StringToHash("HitMarkerCrit1");

	private readonly int critHash2 = Animator.StringToHash("HitMarkerCrit2");

	private bool hitMarkerIndex;

	private readonly int killHash = Animator.StringToHash("HitMarkerKill");

	private readonly int killCritHash = Animator.StringToHash("HitMarkerKillCrit");

	public List<RectTransform> hitMarkerImages;

	private float scatterOnHit;

	private Camera _cam;

	private Camera MainCam
	{
		get
		{
			if (!_cam)
			{
				if (LevelManager.Instance == null)
				{
					return null;
				}
				if (LevelManager.Instance.GameCamera == null)
				{
					return null;
				}
				_cam = LevelManager.Instance.GameCamera.renderCamera;
			}
			return _cam;
		}
	}

	public static event Action OnHitMarker;

	public static event Action OnKillMarker;

	private void Awake()
	{
		Health.OnHurt += OnHealthHitEvent;
		Health.OnDead += OnHealthKillEvent;
		HealthSimpleBase.OnSimpleHealthHit += OnSimpleHealthHit;
		HealthSimpleBase.OnSimpleHealthDead += OnSimpleHealthKill;
	}

	private void OnDestroy()
	{
		Health.OnHurt -= OnHealthHitEvent;
		Health.OnDead -= OnHealthKillEvent;
		HealthSimpleBase.OnSimpleHealthHit -= OnSimpleHealthHit;
		HealthSimpleBase.OnSimpleHealthDead -= OnSimpleHealthKill;
	}

	private void OnHealthHitEvent(Health _health, DamageInfo dmgInfo)
	{
		if (!dmgInfo.isFromBuffOrEffect && !(dmgInfo.damageValue <= 1.01f))
		{
			OnHit(dmgInfo);
		}
	}

	private void OnHit(DamageInfo dmgInfo)
	{
		if ((bool)dmgInfo.fromCharacter && dmgInfo.fromCharacter.IsMainCharacter && (!dmgInfo.toDamageReceiver || !dmgInfo.toDamageReceiver.IsMainCharacter))
		{
			bool flag = (float)dmgInfo.crit > 0f;
			Vector3 vector = MainCam.WorldToScreenPoint(dmgInfo.damagePoint);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(base.transform.parent as RectTransform, vector, null, out var localPoint);
			base.transform.localPosition = Vector3.ClampMagnitude(localPoint, 10f);
			ItemAgent_Gun gun = CharacterMainControl.Main.GetGun();
			if (gun != null)
			{
				scatterOnHit = gun.CurrentScatter;
			}
			int stateHashName = ((!flag) ? (hitMarkerIndex ? hitHash1 : hitHash2) : (hitMarkerIndex ? critHash1 : critHash2));
			int shortNameHash = animator.GetCurrentAnimatorStateInfo(0).shortNameHash;
			if (shortNameHash != killHash && shortNameHash != killCritHash)
			{
				hitMarkerIndex = !hitMarkerIndex;
				animator.CrossFade(stateHashName, 0.02f);
			}
			HitMarker.OnHitMarker?.Invoke();
			if (!dmgInfo.toDamageReceiver || !dmgInfo.toDamageReceiver.useSimpleHealth)
			{
				AudioManager.PostHitMarker(flag);
			}
			hitEvent?.Invoke();
		}
	}

	private void OnHealthKillEvent(Health _health, DamageInfo dmgInfo)
	{
		OnKill(dmgInfo);
	}

	private void OnKill(DamageInfo dmgInfo)
	{
		if ((bool)dmgInfo.fromCharacter && dmgInfo.fromCharacter.IsMainCharacter && (!dmgInfo.toDamageReceiver || !dmgInfo.toDamageReceiver.IsMainCharacter))
		{
			bool flag = (float)dmgInfo.crit > 0f;
			int stateHashName = (flag ? killCritHash : killHash);
			animator.CrossFade(stateHashName, 0.02f);
			if (!dmgInfo.toDamageReceiver || !dmgInfo.toDamageReceiver.useSimpleHealth)
			{
				AudioManager.PostKillMarker(flag);
			}
			HitMarker.OnKillMarker?.Invoke();
			killEvent?.Invoke();
		}
	}

	private void OnSimpleHealthHit(HealthSimpleBase health, DamageInfo dmgInfo)
	{
		if (!(dmgInfo.damageValue <= 1.01f))
		{
			OnHit(dmgInfo);
		}
	}

	private void OnSimpleHealthKill(HealthSimpleBase health, DamageInfo dmgInfo)
	{
		OnKill(dmgInfo);
	}

	private void LateUpdate()
	{
		foreach (RectTransform hitMarkerImage in hitMarkerImages)
		{
			hitMarkerImage.anchoredPosition += hitMarkerImage.anchoredPosition.normalized * scatterOnHit * 3f;
		}
	}
}
public class SingleCrosshair : MonoBehaviour
{
	public float rotation;

	public Vector3 axis;

	public float minDistance;

	public float scatterMoveScale = 5f;

	private float currentScatter;

	public bool controlRectWidthHeight;

	public float minScale = 100f;

	public float scatterScaleFactor = 5f;

	public void UpdateScatter(float _scatter)
	{
		currentScatter = _scatter;
		RectTransform rectTransform = base.transform as RectTransform;
		rectTransform.localRotation = Quaternion.Euler(0f, 0f, rotation);
		Vector3 vector = Vector3.zero;
		if (axis != Vector3.zero)
		{
			vector = rectTransform.parent.InverseTransformDirection(rectTransform.TransformDirection(axis));
		}
		rectTransform.anchoredPosition = vector * (minDistance + currentScatter * scatterMoveScale);
		if (controlRectWidthHeight)
		{
			float num = minScale + currentScatter * scatterScaleFactor;
			rectTransform.sizeDelta = Vector2.one * num;
		}
	}

	private void OnValidate()
	{
		UpdateScatter(0f);
	}
}
public class SkillHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	public CharacterTouchInputControl touchInputController;

	public UnityEngine.UI.Image skillIcon;

	private bool skillHudActive;

	public Soda_Joysticks skillJoystick;

	public GameObject skillButton;

	public GameObject activeParent;

	[SerializeField]
	private SkillTypes skillType;

	private CharacterSkillKeeper skillKeeper;

	private float rangeCache = -1f;

	private void Awake()
	{
		SyncHud();
	}

	private void SyncHud()
	{
		if (rangeCache < 0f)
		{
			rangeCache = skillJoystick.joystickRangePercent;
		}
		activeParent.SetActive(skillHudActive);
		if (skillHudActive)
		{
			skillIcon.sprite = skillKeeper.Skill.icon;
			if (skillKeeper.Skill.SkillContext.castRange > 0f)
			{
				skillJoystick.canCancle = true;
				skillJoystick.joystickRangePercent = rangeCache;
			}
			else
			{
				skillJoystick.canCancle = false;
				skillJoystick.joystickRangePercent = 0f;
			}
		}
	}

	private void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if (!characterMainControl)
			{
				return;
			}
			OnInit();
		}
		if (skillHudActive && (skillKeeper == null || !skillKeeper.CheckSkillAndBinding()))
		{
			skillHudActive = false;
			SyncHud();
		}
	}

	private void OnInit()
	{
		switch (skillType)
		{
		case SkillTypes.itemSkill:
			skillKeeper = characterMainControl.skillAction.holdItemSkillKeeper;
			skillJoystick.UpdateValueEvent.AddListener(touchInputController.SetItemSkillAimInput);
			skillJoystick.OnTouchEvent.AddListener(touchInputController.StartItemSkillAim);
			skillJoystick.OnUpEvent.AddListener(touchInputController.ItemSkillRelease);
			break;
		case SkillTypes.characterSkill:
			skillKeeper = characterMainControl.skillAction.characterSkillKeeper;
			skillJoystick.UpdateValueEvent.AddListener(touchInputController.SetCharacterSkillAimInput);
			skillJoystick.OnTouchEvent.AddListener(touchInputController.StartCharacterSkillAim);
			skillJoystick.OnUpEvent.AddListener(touchInputController.CharacterSkillRelease);
			break;
		}
		CharacterSkillKeeper characterSkillKeeper = skillKeeper;
		characterSkillKeeper.OnSkillChanged = (Action)Delegate.Combine(characterSkillKeeper.OnSkillChanged, new Action(OnSkillChanged));
		if (skillKeeper.CheckSkillAndBinding())
		{
			OnSkillChanged();
		}
	}

	private void OnSkillChanged()
	{
		skillHudActive = skillKeeper.CheckSkillAndBinding();
		if (skillJoystick.Holding)
		{
			skillJoystick.CancleTouch();
		}
		SyncHud();
	}

	private void OnDestroy()
	{
		if (skillKeeper != null)
		{
			CharacterSkillKeeper characterSkillKeeper = skillKeeper;
			characterSkillKeeper.OnSkillChanged = (Action)Delegate.Remove(characterSkillKeeper.OnSkillChanged, new Action(OnSkillChanged));
		}
	}
}
public class SetEndingMissleParameter : MonoBehaviour
{
	[SerializeField]
	private Condition launcherClosedCondition;

	private void Start()
	{
		bool flag = launcherClosedCondition.Evaluate();
		AudioManager.SetRTPC("Ending_Missile", flag ? 1 : 0);
	}
}
public class DynamicItemDebugger : MonoBehaviour
{
	[SerializeField]
	private List<Item> prefabs;

	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		Add();
	}

	private void Add()
	{
		foreach (Item prefab in prefabs)
		{
			ItemAssetsCollection.AddDynamicEntry(prefab);
		}
	}

	private void CreateCorresponding()
	{
		CreateTask().Forget();
	}

	private async UniTask CreateTask()
	{
		foreach (Item prefab in prefabs)
		{
			Item item = await ItemAssetsCollection.InstantiateAsync(prefab.TypeID);
			item.transform.SetParent(base.transform);
			if ((bool)CharacterMainControl.Main)
			{
				ItemUtilities.SendToPlayer(item);
			}
		}
	}
}
public class RectStructRefTest : MonoBehaviour
{
	private void Test()
	{
		Rect rect = new Rect(Vector2.up, Vector2.one);
		UnityEngine.Debug.Log("original: " + rect.size.ToString());
		Rect rect2 = rect;
		rect2.xMax = 20f;
		UnityEngine.Debug.Log("Changed");
		UnityEngine.Debug.Log("rect: " + rect.size.ToString());
		UnityEngine.Debug.Log("rect2: " + rect2.size.ToString());
	}
}
public class SodaImguiTest : MonoBehaviour
{
}
public class AddBuffAction : EffectAction
{
	public Buff buffPfb;

	private CharacterMainControl MainControl => base.Master?.Item?.GetCharacterMainControl();

	protected override void OnTriggered(bool positive)
	{
		if ((bool)MainControl)
		{
			MainControl.AddBuff(buffPfb, MainControl);
		}
	}
}
public class CostStaminaAction : EffectAction
{
	public float staminaCost;

	private CharacterMainControl MainControl => base.Master?.Item?.GetCharacterMainControl();

	protected override void OnTriggered(bool positive)
	{
		if ((bool)MainControl)
		{
			MainControl.UseStamina(staminaCost);
		}
	}
}
public class FxAction : EffectAction
{
	public enum Sockets
	{
		root,
		helmat,
		armor
	}

	public Sockets socket = Sockets.helmat;

	public GameObject fxPfb;

	private CharacterMainControl _mainControl;

	private CharacterMainControl MainControl
	{
		get
		{
			if (_mainControl == null)
			{
				_mainControl = base.Master?.Item?.GetCharacterMainControl();
			}
			return _mainControl;
		}
	}

	protected override void OnTriggered(bool positive)
	{
		if ((bool)MainControl && (bool)MainControl.characterModel)
		{
			Transform transform = MainControl.transform;
			switch (socket)
			{
			case Sockets.helmat:
				transform = MainControl.characterModel.HelmatSocket;
				break;
			case Sockets.armor:
				transform = MainControl.characterModel.ArmorSocket;
				break;
			default:
				throw new ArgumentOutOfRangeException();
			case Sockets.root:
				break;
			}
			if ((bool)transform && (bool)fxPfb)
			{
				UnityEngine.Object.Instantiate(fxPfb, transform.position, quaternion.identity);
			}
		}
	}
}
public class HealAction : EffectAction
{
	private CharacterMainControl _mainControl;

	public int healValue = 10;

	private CharacterMainControl MainControl
	{
		get
		{
			if (_mainControl == null)
			{
				_mainControl = base.Master?.Item?.GetCharacterMainControl();
			}
			return _mainControl;
		}
	}

	protected override void OnTriggered(bool positive)
	{
		if ((bool)MainControl)
		{
			MainControl.Health.AddHealth(healValue);
		}
	}
}
public class ModifierAction : EffectAction
{
	[SerializeField]
	private Buff buff;

	public string targetStatKey;

	private int targetStatHash;

	public ModifierType ModifierType;

	public float modifierValue;

	public bool overrideOrder;

	public int overrideOrderValue;

	private Modifier modifier;

	private Stat targetStat;

	protected override void Awake()
	{
		base.Awake();
		modifier = new Modifier(ModifierType, modifierValue, overrideOrder, overrideOrderValue, base.Master);
		targetStatHash = targetStatKey.GetHashCode();
		if ((bool)buff)
		{
			buff.OnLayerChangedEvent += OnBuffLayerChanged;
		}
		OnBuffLayerChanged();
	}

	private void OnBuffLayerChanged()
	{
		if ((bool)buff && modifier != null)
		{
			modifier.Value = modifierValue * (float)buff.CurrentLayers;
		}
	}

	protected override void OnTriggered(bool positive)
	{
		if (base.Master.Item == null)
		{
			return;
		}
		Item characterItem = base.Master.Item.GetCharacterItem();
		if (characterItem == null)
		{
			return;
		}
		if (positive)
		{
			if (targetStat != null)
			{
				targetStat.RemoveModifier(modifier);
				targetStat = null;
			}
			targetStat = characterItem.GetStat(targetStatHash);
			targetStat.AddModifier(modifier);
		}
		else if (targetStat != null)
		{
			targetStat.RemoveModifier(modifier);
			targetStat = null;
		}
	}

	private void OnDestroy()
	{
		if (targetStat != null)
		{
			targetStat.RemoveModifier(modifier);
			targetStat = null;
		}
		if ((bool)buff)
		{
			buff.OnLayerChangedEvent -= OnBuffLayerChanged;
		}
	}
}
public class RemoveBuffAction : EffectAction
{
	public int buffID;

	public bool removeOneLayer;

	private CharacterMainControl MainControl => base.Master?.Item?.GetCharacterMainControl();

	protected override void OnTriggered(bool positive)
	{
		if ((bool)MainControl)
		{
			MainControl.RemoveBuff(buffID, removeOneLayer);
		}
	}
}
public class SpawnPaperBoxAction : EffectAction
{
	public enum Sockets
	{
		root,
		helmat,
		armor
	}

	public Sockets socket = Sockets.helmat;

	public PaperBox paperBoxPrefab;

	private PaperBox instance;

	private CharacterMainControl _mainControl;

	private CharacterMainControl MainControl
	{
		get
		{
			if (_mainControl == null)
			{
				_mainControl = base.Master?.Item?.GetCharacterMainControl();
			}
			return _mainControl;
		}
	}

	protected override void OnTriggered(bool positive)
	{
		if ((bool)MainControl && (bool)MainControl.characterModel)
		{
			Transform transform = MainControl.transform;
			switch (socket)
			{
			case Sockets.helmat:
				transform = MainControl.characterModel.HelmatSocket;
				break;
			case Sockets.armor:
				transform = MainControl.characterModel.ArmorSocket;
				break;
			default:
				throw new ArgumentOutOfRangeException();
			case Sockets.root:
				break;
			}
			if ((bool)transform && (bool)paperBoxPrefab)
			{
				instance = UnityEngine.Object.Instantiate(paperBoxPrefab, transform);
				instance.character = MainControl;
			}
		}
	}

	private void OnDestroy()
	{
		if ((bool)instance)
		{
			UnityEngine.Object.Destroy(instance.gameObject);
		}
	}
}
[MenuPath("角色/角色正在奔跑")]
public class CharacterIsRunning : EffectFilter
{
	private CharacterMainControl _mainControl;

	public override string DisplayName => "角色正在奔跑";

	private CharacterMainControl MainControl
	{
		get
		{
			if (_mainControl == null)
			{
				_mainControl = base.Master?.Item?.GetCharacterMainControl();
			}
			return _mainControl;
		}
	}

	protected override bool OnEvaluate(EffectTriggerEventContext context)
	{
		return MainControl.Running;
	}

	private void OnDestroy()
	{
	}
}
[MenuPath("弱属性")]
public class ElementFactorFilter : EffectFilter
{
	public enum ElementFactorFilterTypes
	{
		GreaterThan,
		LessThan
	}

	public ElementFactorFilterTypes type;

	public float compareTo = 1f;

	public ElementTypes element;

	private CharacterMainControl _mainControl;

	public override string DisplayName => string.Format("如果{0}系数{1}{2}", element, (type == ElementFactorFilterTypes.GreaterThan) ? "大于" : "小于", compareTo);

	private CharacterMainControl MainControl
	{
		get
		{
			if (_mainControl == null)
			{
				_mainControl = base.Master?.Item?.GetCharacterMainControl();
			}
			return _mainControl;
		}
	}

	protected override bool OnEvaluate(EffectTriggerEventContext context)
	{
		if (!MainControl)
		{
			return false;
		}
		if (!MainControl.Health)
		{
			return false;
		}
		float num = MainControl.Health.ElementFactor(element);
		if (type != ElementFactorFilterTypes.GreaterThan)
		{
			return num < compareTo;
		}
		return num > compareTo;
	}

	private void OnDestroy()
	{
	}
}
[MenuPath("Health/一段时间没受伤")]
public class NotHurtForSeconds : EffectFilter
{
	public float time;

	private float lastHurtTime = -9999f;

	private bool binded;

	private CharacterMainControl _mainControl;

	public override string DisplayName => time + "秒内没受伤";

	private CharacterMainControl MainControl
	{
		get
		{
			if (_mainControl == null)
			{
				_mainControl = base.Master?.Item?.GetCharacterMainControl();
			}
			return _mainControl;
		}
	}

	protected override bool OnEvaluate(EffectTriggerEventContext context)
	{
		if (!binded && (bool)MainControl)
		{
			MainControl.Health.OnHurtEvent.AddListener(OnHurt);
			binded = true;
		}
		return Time.time - lastHurtTime > time;
	}

	private void OnDestroy()
	{
		if ((bool)MainControl)
		{
			MainControl.Health.OnHurtEvent.RemoveListener(OnHurt);
		}
	}

	private void OnHurt(DamageInfo dmgInfo)
	{
		lastHurtTime = Time.time;
	}
}
public class AISpecialAttachmentBase : MonoBehaviour
{
	public AICharacterController aiCharacterController;

	public CharacterMainControl character;

	public void Init(AICharacterController _ai, CharacterMainControl _character)
	{
		aiCharacterController = _ai;
		character = _character;
		OnInited();
	}

	protected virtual void OnInited()
	{
	}
}
public class AISpecialAttachment_Shop : AISpecialAttachmentBase
{
	public GameObject shop;

	protected override void OnInited()
	{
		base.OnInited();
		aiCharacterController.hideIfFoundEnemy = shop;
	}
}
public class AISpecialAttachment_SpawnItemOnCritKill : AISpecialAttachmentBase
{
	[ItemTypeID]
	public int itemToSpawn;

	private Item itemInstance;

	private bool hasDead;

	public bool inverse;

	protected override void OnInited()
	{
		character.BeforeCharacterSpawnLootOnDead += BeforeCharacterSpawnLootOnDead;
		SpawnItem().Forget();
	}

	private async UniTaskVoid SpawnItem()
	{
		itemInstance = await ItemAssetsCollection.InstantiateAsync(itemToSpawn);
		itemInstance.transform.SetParent(base.transform, worldPositionStays: false);
		if (hasDead)
		{
			UnityEngine.Object.Destroy(itemInstance.gameObject);
		}
	}

	private void OnDestroy()
	{
		if ((bool)character)
		{
			character.BeforeCharacterSpawnLootOnDead -= BeforeCharacterSpawnLootOnDead;
		}
	}

	private void BeforeCharacterSpawnLootOnDead(DamageInfo dmgInfo)
	{
		hasDead = true;
		UnityEngine.Debug.Log($"Die crit:{dmgInfo.crit}");
		bool flag = dmgInfo.crit > 0;
		if (inverse == flag || character == null)
		{
			if (itemInstance != null)
			{
				UnityEngine.Object.Destroy(itemInstance.gameObject);
			}
			return;
		}
		UnityEngine.Debug.Log("pick up on crit");
		if (itemInstance != null)
		{
			character.CharacterItem.Inventory.AddAndMerge(itemInstance);
		}
	}
}
public enum CharacterIconTypes
{
	none,
	elete,
	pmc,
	boss,
	merchant,
	pet
}
[CreateAssetMenu(fileName = "New Character Random Preset", menuName = "Character Random Preset", order = 51)]
public class CharacterRandomPreset : ScriptableObject
{
	[Serializable]
	private struct SetCharacterStatInfo
	{
		public string statName;

		public Vector2 statBaseValue;
	}

	[LocalizationKey("Characters")]
	public string nameKey;

	public AudioManager.VoiceType voiceType;

	public AudioManager.FootStepMaterialType footstepMaterialType;

	public InteractableLootbox lootBoxPrefab;

	public List<AISpecialAttachmentBase> specialAttachmentBases;

	public Teams team = Teams.scav;

	public bool showName;

	[FormerlySerializedAs("iconType")]
	[SerializeField]
	private CharacterIconTypes characterIconType;

	public float health;

	public bool hasSoul = true;

	public bool showHealthBar = true;

	public int exp = 100;

	[SerializeField]
	private CharacterModel characterModel;

	[SerializeField]
	private bool usePlayerPreset;

	[SerializeField]
	private CustomFacePreset facePreset;

	[SerializeField]
	private AICharacterController aiController;

	public bool setActiveByPlayerDistance = true;

	public float forceTracePlayerDistance;

	public bool shootCanMove;

	public float sightDistance = 17f;

	public float sightAngle = 100f;

	public float reactionTime = 0.2f;

	public float nightReactionTimeFactor = 1.5f;

	public float shootDelay = 0.2f;

	public Vector2 shootTimeRange = new Vector2(0.4f, 1.5f);

	public Vector2 shootTimeSpaceRange = new Vector2(2f, 3f);

	public Vector2 combatMoveTimeRange = new Vector2(1f, 3f);

	public float hearingAbility = 1f;

	public float patrolRange = 8f;

	[FormerlySerializedAs("combatRange")]
	public float combatMoveRange = 8f;

	public bool canDash;

	public Vector2 dashCoolTimeRange = new Vector2(2f, 4f);

	[Range(0f, 1f)]
	public float minTraceTargetChance = 1f;

	[Range(0f, 1f)]
	public float maxTraceTargetChance = 1f;

	public float forgetTime = 8f;

	public bool defaultWeaponOut = true;

	public bool canTalk = true;

	public float patrolTurnSpeed = 180f;

	public float combatTurnSpeed = 1200f;

	[ItemTypeID]
	public int wantItem = -1;

	public float moveSpeedFactor = 1f;

	public float bulletSpeedMultiplier = 1f;

	[Range(1f, 2f)]
	public float gunDistanceMultiplier = 1f;

	public float nightVisionAbility = 0.5f;

	public float gunScatterMultiplier = 1f;

	public float scatterMultiIfTargetRunning = 3f;

	public float scatterMultiIfOffScreen = 4f;

	[FormerlySerializedAs("gunDamageMultiplier")]
	public float damageMultiplier = 1f;

	public float gunCritRateGain;

	[Tooltip("用来决定双方造成伤害缩放")]
	public float aiCombatFactor = 1f;

	public bool hasSkill;

	public SkillBase skillPfb;

	[Range(0.01f, 1f)]
	public float hasSkillChance = 1f;

	public Vector2 skillCoolTimeRange = Vector2.one;

	[Range(0.01f, 1f)]
	public float skillSuccessChance = 1f;

	private float tryReleaseSkillTimeMarker = -1f;

	[Range(0f, 1f)]
	public float itemSkillChance = 0.3f;

	public float itemSkillCoolTime = 6f;

	public List<Buff> buffs;

	public List<Buff.BuffExclusiveTags> buffResist;

	public float elementFactor_Physics = 1f;

	public float elementFactor_Fire = 1f;

	public float elementFactor_Poison = 1f;

	public float elementFactor_Electricity = 1f;

	public float elementFactor_Space = 1f;

	[SerializeField]
	private List<SetCharacterStatInfo> setStats;

	[Range(0f, 1f)]
	public float hasCashChance;

	public Vector2Int cashRange;

	[SerializeField]
	private List<RandomItemGenerateDescription> itemsToGenerate;

	[Space(12f)]
	[SerializeField]
	private RandomContainer<int> bulletQualityDistribution;

	[SerializeField]
	private Tag[] bulletExclusiveTags;

	[HideInInspector]
	[SerializeField]
	private ItemFilter bulletFilter;

	[SerializeField]
	private Vector2 bulletCountRange = Vector2.one;

	public string Name => nameKey.ToPlainText();

	public string DisplayName => nameKey.ToPlainText();

	private int characterItemTypeID => GameplayDataSettings.ItemAssets.DefaultCharacterItemTypeID;

	public Sprite GetCharacterIcon()
	{
		return characterIconType switch
		{
			CharacterIconTypes.none => null, 
			CharacterIconTypes.elete => GameplayDataSettings.UIStyle.EleteCharacterIcon, 
			CharacterIconTypes.pmc => GameplayDataSettings.UIStyle.PmcCharacterIcon, 
			CharacterIconTypes.boss => GameplayDataSettings.UIStyle.BossCharacterIcon, 
			CharacterIconTypes.merchant => GameplayDataSettings.UIStyle.MerchantCharacterIcon, 
			CharacterIconTypes.pet => GameplayDataSettings.UIStyle.PetCharacterIcon, 
			_ => throw new ArgumentOutOfRangeException(), 
		};
	}

	public async UniTask<CharacterMainControl> CreateCharacterAsync(Vector3 pos, Vector3 dir, int relatedScene, CharacterSpawnerGroup group, bool isLeader)
	{
		Item characterItemInstance = await LevelManager.Instance.CharacterCreator.LoadOrCreateCharacterItemInstance(characterItemTypeID);
		MultiSceneCore.MoveToMainScene(characterItemInstance.gameObject);
		characterItemInstance.GetStat("MaxHealth".GetHashCode()).BaseValue = health * LevelManager.Rule.EnemyHealthFactor;
		characterItemInstance.SetInt("Exp", exp);
		for (int i = 0; i < setStats.Count; i++)
		{
			SetCharacterStatInfo setCharacterStatInfo = setStats[i];
			SetCharacterStat(setCharacterStatInfo.statName, UnityEngine.Random.Range(setCharacterStatInfo.statBaseValue.x, setCharacterStatInfo.statBaseValue.y));
		}
		SetCharacterStat("ElementFactor_Physics", elementFactor_Physics);
		SetCharacterStat("ElementFactor_Fire", elementFactor_Fire);
		SetCharacterStat("ElementFactor_Poison", elementFactor_Poison);
		SetCharacterStat("ElementFactor_Electricity", elementFactor_Electricity);
		SetCharacterStat("ElementFactor_Space", elementFactor_Space);
		SetCharacterStat("GunDistanceMultiplier", gunDistanceMultiplier);
		MultiplyCharacterStat("WalkSpeed", moveSpeedFactor);
		MultiplyCharacterStat("RunSpeed", moveSpeedFactor);
		SetCharacterStat("NightVisionAbility", nightVisionAbility);
		SetCharacterStat("GunScatterMultiplier", gunScatterMultiplier);
		SetCharacterStat("GunDamageMultiplier", damageMultiplier);
		SetCharacterStat("MeleeDamageMultiplier", damageMultiplier);
		SetCharacterStat("GunCritRateGain", gunCritRateGain);
		characterItemInstance.GetStat("BulletSpeedMultiplier".GetHashCode()).BaseValue = bulletSpeedMultiplier;
		List<Item> initialItems = await GenerateItems();
		dir = ((!(dir.magnitude > 0f)) ? Vector3.back : dir.normalized);
		CharacterMainControl character = await LevelManager.Instance.CharacterCreator.CreateCharacter(characterItemInstance, characterModel, pos, Quaternion.LookRotation(dir, Vector3.up));
		if (character == null)
		{
			return null;
		}
		character.characterPreset = this;
		character.SetAimPoint(pos + dir * 10f);
		character.deadLootBoxPrefab = lootBoxPrefab;
		if ((bool)character.characterModel)
		{
			if (usePlayerPreset)
			{
				CustomFaceSettingData faceFromData = LevelManager.Instance.CustomFaceManager.LoadMainCharacterSetting();
				character.characterModel.SetFaceFromData(faceFromData);
			}
			else
			{
				character.characterModel.SetFaceFromPreset(facePreset);
			}
		}
		if (MultiSceneCore.MainScene.HasValue)
		{
			character.SetRelatedScene(relatedScene, setActiveByPlayerDistance);
		}
		character.SetPosition(pos + Vector3.up * 0.5f);
		character.SetTeam(team);
		character.Health.hasSoul = hasSoul;
		character.Health.showHealthBar = showHealthBar;
		AICharacterController ai = null;
		if ((bool)aiController)
		{
			ai = UnityEngine.Object.Instantiate(aiController);
			if (hasSkill && UnityEngine.Random.Range(0f, 1f) < hasSkillChance)
			{
				ai.hasSkill = true;
				ai.skillPfb = skillPfb;
				ai.skillCoolTimeRange = skillCoolTimeRange;
				ai.skillSuccessChance = skillSuccessChance;
			}
			else
			{
				ai.hasSkill = false;
			}
			ai.Init(character, pos, voiceType, footstepMaterialType);
			ai.sightDistance = sightDistance;
			ai.forceTracePlayerDistance = forceTracePlayerDistance;
			ai.sightAngle = sightAngle;
			ai.shootCanMove = shootCanMove;
			ai.shootTimeRange = shootTimeRange * LevelManager.Rule.EnemyAttackTimeFactor;
			ai.shootTimeSpaceRange = shootTimeSpaceRange * LevelManager.Rule.EnemyAttackTimeSpaceFactor;
			ai.baseReactionTime = reactionTime * LevelManager.Rule.EnemyReactionTimeFactor;
			ai.reactionTime = ai.baseReactionTime;
			ai.nightReactionTimeFactor = nightReactionTimeFactor;
			ai.hearingAbility = hearingAbility;
			ai.patrolRange = patrolRange;
			ai.combatMoveRange = combatMoveRange;
			ai.combatMoveTimeRange = combatMoveTimeRange;
			ai.forgetTime = forgetTime;
			ai.traceTargetChance = UnityEngine.Random.Range(minTraceTargetChance, maxTraceTargetChance);
			ai.canDash = canDash;
			ai.canTalk = canTalk;
			ai.patrolTurnSpeed = patrolTurnSpeed;
			ai.combatTurnSpeed = combatTurnSpeed;
			ai.wantItem = wantItem;
			ai.dashCoolTimeRange = dashCoolTimeRange;
			ai.scatterMultiIfTargetRunning = scatterMultiIfTargetRunning;
			ai.scatterMultiIfOffScreen = scatterMultiIfOffScreen;
			ai.shootDelay = shootDelay;
			ai.itemSkillCoolTime = itemSkillCoolTime;
			ai.itemSkillChance = itemSkillChance;
			if ((bool)group)
			{
				group.AddCharacterSpawned(ai, isLeader);
			}
			ai.defaultWeaponOut = defaultWeaponOut;
		}
		foreach (Buff buff in buffs)
		{
			character.AddBuff(buff);
		}
		for (int j = 0; j < buffResist.Count; j++)
		{
			Buff.BuffExclusiveTags buffExclusiveTags = buffResist[j];
			if (buffExclusiveTags != Buff.BuffExclusiveTags.NotExclusive)
			{
				character.buffResist.Add(buffExclusiveTags);
			}
		}
		foreach (AISpecialAttachmentBase specialAttachmentBasis in specialAttachmentBases)
		{
			if (!(specialAttachmentBasis == null))
			{
				AISpecialAttachmentBase aISpecialAttachmentBase = UnityEngine.Object.Instantiate(specialAttachmentBasis, character.transform);
				aISpecialAttachmentBase.transform.localPosition = Vector3.zero;
				aISpecialAttachmentBase.transform.localRotation = Quaternion.identity;
				aISpecialAttachmentBase.Init(ai, character);
			}
		}
		await UniTask.NextFrame();
		character.CharacterItem.Inventory.SetCapacity(15);
		if (initialItems != null)
		{
			foreach (Item item in initialItems)
			{
				if (item == null || characterItemInstance.TryPlug(item))
				{
					continue;
				}
				bool flag = false;
				Item content = character.PrimWeaponSlot().Content;
				if (content != null)
				{
					flag = content.TryPlug(item);
				}
				if (flag)
				{
					continue;
				}
				Item content2 = character.MeleeWeaponSlot().Content;
				if (content2 != null)
				{
					flag = content2.TryPlug(item);
				}
				if (flag)
				{
					continue;
				}
				if (characterItemInstance.Inventory.AddAndMerge(item))
				{
					if ((bool)item)
					{
						ItemSetting_Skill component = item.GetComponent<ItemSetting_Skill>();
						if ((bool)component)
						{
							ai.AddItemSkill(component);
						}
						else
						{
							ai.CheckAndAddDrugItem(item);
						}
					}
				}
				else
				{
					item.DestroyTree();
				}
			}
		}
		await AddBullet(character);
		return character;
		void MultiplyCharacterStat(string statName, float multiplier)
		{
			Stat stat = characterItemInstance.GetStat(statName.GetHashCode());
			if (stat != null)
			{
				stat.BaseValue *= multiplier;
			}
		}
		void SetCharacterStat(string statName, float value)
		{
			Stat stat = characterItemInstance.GetStat(statName.GetHashCode());
			if (stat != null)
			{
				stat.BaseValue = value;
			}
		}
	}

	private async UniTask<List<Item>> GenerateItems()
	{
		List<Item> items = new List<Item>();
		foreach (RandomItemGenerateDescription item2 in itemsToGenerate)
		{
			items.AddRange(await item2.Generate());
		}
		if (UnityEngine.Random.Range(0f, 1f) < hasCashChance)
		{
			Item item = await ItemAssetsCollection.InstantiateAsync(GameplayDataSettings.ItemAssets.CashItemTypeID);
			item.StackCount = UnityEngine.Random.Range(cashRange.x, cashRange.y);
			items.Add(item);
		}
		return items;
	}

	private async UniTask AddBullet(CharacterMainControl character)
	{
		Item item = character.PrimWeaponSlot()?.Content;
		if (!(item != null))
		{
			return;
		}
		string text = item.Constants.GetString("Caliber");
		if (!string.IsNullOrEmpty(text))
		{
			int random = bulletQualityDistribution.GetRandom();
			bulletFilter.caliber = text;
			bulletFilter.minQuality = random;
			bulletFilter.maxQuality = random;
			bulletFilter.excludeTags = bulletExclusiveTags;
			int[] array = ItemAssetsCollection.Search(bulletFilter);
			if (array.Length >= 1)
			{
				Item item2 = await ItemAssetsCollection.InstantiateAsync(array.GetRandom());
				item2.StackCount = Mathf.RoundToInt((float)item2.StackCount * UnityEngine.Random.Range(bulletCountRange.x, bulletCountRange.y));
				character?.CharacterItem?.Inventory?.AddItem(item2);
			}
		}
	}
}
public class CharacterSpawnerBase : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public abstract class CharacterSpawnerComponentBase : MonoBehaviour
{
	public abstract void Init(CharacterSpawnerRoot root);

	public abstract void StartSpawn();
}
public class CharacterSpawnerGroup : CharacterSpawnerComponentBase
{
	public CharacterSpawnerRoot spawnerRoot;

	public bool hasLeader;

	[Range(0f, 1f)]
	public float hasLeaderChance = 1f;

	public List<RandomCharacterSpawner> spawners;

	private List<AICharacterController> characters;

	private AICharacterController leaderAI;

	public AICharacterController LeaderAI => leaderAI;

	public void Collect()
	{
		spawners = GetComponentsInChildren<RandomCharacterSpawner>().ToList();
	}

	public override void Init(CharacterSpawnerRoot root)
	{
		foreach (RandomCharacterSpawner spawner in spawners)
		{
			if (spawner == null)
			{
				UnityEngine.Debug.LogError("生成器引用为空：" + base.gameObject.name);
			}
			else
			{
				spawner.Init(root);
			}
		}
		spawnerRoot = root;
	}

	public void Awake()
	{
		characters = new List<AICharacterController>();
		if (hasLeader && UnityEngine.Random.Range(0f, 1f) > hasLeaderChance)
		{
			hasLeader = false;
		}
	}

	private void Update()
	{
		if (!hasLeader || !(leaderAI == null) || characters.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < characters.Count; i++)
		{
			if (characters[i] == null)
			{
				characters.RemoveAt(i);
				i--;
			}
			else
			{
				leaderAI = characters[i];
			}
		}
	}

	public void AddCharacterSpawned(AICharacterController _character, bool isLeader)
	{
		_character.group = this;
		if (isLeader)
		{
			leaderAI = _character;
		}
		else if (hasLeader && !leaderAI)
		{
			leaderAI = _character;
		}
		characters.Add(_character);
	}

	public override void StartSpawn()
	{
		bool flag = true;
		foreach (RandomCharacterSpawner spawner in spawners)
		{
			if (!(spawner == null))
			{
				spawner.masterGroup = this;
				if (flag && hasLeader)
				{
					spawner.firstIsLeader = true;
				}
				flag = false;
				spawner.StartSpawn();
			}
		}
	}
}
public class CharacterSpawnerGroupSelector : CharacterSpawnerComponentBase
{
	public CharacterSpawnerRoot spawnerRoot;

	public List<CharacterSpawnerGroup> groups;

	public Vector2Int spawnGroupCountRange = new Vector2Int(1, 1);

	private int finalCount;

	public void Collect()
	{
		groups = GetComponentsInChildren<CharacterSpawnerGroup>().ToList();
		foreach (CharacterSpawnerGroup group in groups)
		{
			group.Collect();
		}
	}

	public override void Init(CharacterSpawnerRoot root)
	{
		foreach (CharacterSpawnerGroup group in groups)
		{
			if (group == null)
			{
				UnityEngine.Debug.LogError("生成器引用为空");
			}
			else
			{
				group.Init(root);
			}
		}
		spawnerRoot = root;
	}

	public override void StartSpawn()
	{
		if (spawnGroupCountRange.y > groups.Count)
		{
			spawnGroupCountRange.y = groups.Count;
		}
		if (spawnGroupCountRange.x > groups.Count)
		{
			spawnGroupCountRange.x = groups.Count;
		}
		RandomSpawn(finalCount = UnityEngine.Random.Range(spawnGroupCountRange.x, spawnGroupCountRange.y));
	}

	private void OnValidate()
	{
		if (groups.Count >= 0 && spawnGroupCountRange.x > spawnGroupCountRange.y)
		{
			spawnGroupCountRange.y = spawnGroupCountRange.x;
		}
	}

	public void RandomSpawn(int count)
	{
		List<int> list = new List<int>();
		for (int i = 0; i < groups.Count; i++)
		{
			list.Add(i);
		}
		for (int j = 0; j < count; j++)
		{
			int index = UnityEngine.Random.Range(0, list.Count);
			int index2 = list[index];
			list.RemoveAt(index);
			CharacterSpawnerGroup characterSpawnerGroup = groups[index2];
			if ((bool)characterSpawnerGroup)
			{
				characterSpawnerGroup.StartSpawn();
			}
		}
	}
}
public class CharacterSpawnerRoot : MonoBehaviour
{
	public bool needTrigger;

	public OnTriggerEnterEvent trigger;

	private bool playerInTrigger;

	private bool created;

	private bool inited;

	[Range(0f, 1f)]
	public float spawnChance = 1f;

	public float minDistanceToPlayer = 25f;

	public bool useTimeOfDay;

	public float whenToSpawn;

	[Range(0f, 24f)]
	public float spawnTimeRangeFrom;

	[Range(0f, 24f)]
	public float spawnTimeRangeTo;

	[FormerlySerializedAs("despawnIfOutOfTime")]
	public bool despawnIfTimingWrong;

	public bool checkWeather;

	public List<Weather> targetWeathers;

	private int relatedScene = -1;

	[SerializeField]
	private CharacterSpawnerComponentBase spawnerComponent;

	public bool autoRefreshGuid = true;

	public int SpawnerGuid;

	private List<CharacterMainControl> createdCharacters = new List<CharacterMainControl>();

	private List<CharacterMainControl> despawningCharacters = new List<CharacterMainControl>();

	private float despawnTickTimer = 1f;

	public UnityEvent OnStartEvent;

	public UnityEvent OnAllDeadEvent;

	private bool allDeadEventInvoked;

	private bool stillhasAliveCharacters;

	private bool allDead;

	public int RelatedScene => relatedScene;

	private void Awake()
	{
		if (createdCharacters == null)
		{
			createdCharacters = new List<CharacterMainControl>();
		}
		if (despawningCharacters == null)
		{
			despawningCharacters = new List<CharacterMainControl>();
		}
		if (!useTimeOfDay && !checkWeather)
		{
			despawnIfTimingWrong = false;
		}
		if (needTrigger && (bool)trigger)
		{
			trigger.triggerOnce = false;
			trigger.onlyMainCharacter = true;
			trigger.DoOnTriggerEnter.AddListener(DoOnTriggerEnter);
			trigger.DoOnTriggerExit.AddListener(DoOnTriggerLeave);
		}
	}

	private void OnDestroy()
	{
		if (needTrigger && (bool)trigger)
		{
			trigger.DoOnTriggerEnter.RemoveListener(DoOnTriggerEnter);
			trigger.DoOnTriggerExit.RemoveListener(DoOnTriggerLeave);
		}
	}

	private void Start()
	{
		if ((bool)LevelManager.Instance && LevelManager.Instance.IsBaseLevel)
		{
			minDistanceToPlayer = 0f;
		}
	}

	private void Update()
	{
		if (!inited && LevelManager.LevelInited)
		{
			Init();
		}
		bool flag = CheckTiming();
		if (inited && !created && flag)
		{
			StartSpawn();
		}
		if (created && !flag && despawnIfTimingWrong)
		{
			despawningCharacters.AddRange(createdCharacters);
			createdCharacters.Clear();
			created = false;
		}
		despawnTickTimer -= Time.deltaTime;
		if (despawnTickTimer < 0f && despawnIfTimingWrong && despawningCharacters.Count > 0)
		{
			CheckDespawn();
		}
		if (!(despawnTickTimer < 0f) || allDead || !stillhasAliveCharacters || allDeadEventInvoked)
		{
			return;
		}
		if (createdCharacters.Count <= 0)
		{
			allDead = true;
		}
		else
		{
			allDead = true;
			foreach (CharacterMainControl createdCharacter in createdCharacters)
			{
				if (createdCharacter != null && (bool)createdCharacter.Health && !createdCharacter.Health.IsDead)
				{
					allDead = false;
					break;
				}
			}
		}
		if (allDead)
		{
			stillhasAliveCharacters = false;
			OnAllDeadEvent?.Invoke();
			allDeadEventInvoked = true;
		}
	}

	private void CheckDespawn()
	{
		for (int i = 0; i < despawningCharacters.Count; i++)
		{
			CharacterMainControl characterMainControl = despawningCharacters[i];
			if (!characterMainControl)
			{
				despawningCharacters.RemoveAt(i);
				i--;
			}
			else if (!characterMainControl.gameObject.activeInHierarchy)
			{
				UnityEngine.Object.Destroy(characterMainControl.gameObject);
				despawningCharacters.RemoveAt(i);
				i--;
			}
		}
	}

	private bool CheckTiming()
	{
		if (LevelManager.Instance == null)
		{
			return false;
		}
		if (needTrigger && !playerInTrigger)
		{
			return false;
		}
		bool flag = false;
		if (useTimeOfDay)
		{
			float num = (float)GameClock.TimeOfDay.TotalHours % 24f;
			flag = (num >= spawnTimeRangeFrom && num <= spawnTimeRangeTo) || (spawnTimeRangeTo < spawnTimeRangeFrom && (num >= spawnTimeRangeFrom || num <= spawnTimeRangeTo));
		}
		else
		{
			flag = LevelManager.Instance.LevelTime >= whenToSpawn;
		}
		bool flag2 = true;
		if (checkWeather && !targetWeathers.Contains(TimeOfDayController.Instance.CurrentWeather))
		{
			flag2 = false;
		}
		return flag && flag2;
	}

	private void Init()
	{
		inited = true;
		spawnerComponent.Init(this);
		_ = SceneManager.GetActiveScene().buildIndex;
		bool flag = true;
		if (MultiSceneCore.Instance != null)
		{
			flag = MultiSceneCore.Instance.usedCreatorIds.Contains(SpawnerGuid);
		}
		if (flag)
		{
			UnityEngine.Debug.Log("Contain this spawner");
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		relatedScene = SceneManager.GetActiveScene().buildIndex;
		flag = true;
		base.transform.SetParent(null);
		MultiSceneCore.MoveToMainScene(base.gameObject);
		MultiSceneCore.Instance.usedCreatorIds.Add(SpawnerGuid);
	}

	private void StartSpawn()
	{
		if (created)
		{
			return;
		}
		created = true;
		if (!(UnityEngine.Random.Range(0f, 1f) > spawnChance))
		{
			OnStartEvent?.Invoke();
			if ((bool)spawnerComponent)
			{
				spawnerComponent.StartSpawn();
			}
		}
	}

	private void DoOnTriggerEnter()
	{
		playerInTrigger = true;
	}

	private void DoOnTriggerLeave()
	{
		playerInTrigger = false;
	}

	public void AddCreatedCharacter(CharacterMainControl c)
	{
		createdCharacters.Add(c);
		stillhasAliveCharacters = true;
	}
}
[RequireComponent(typeof(Points))]
public class RandomCharacterSpawner : CharacterSpawnerComponentBase
{
	public Points spawnPoints;

	public CharacterSpawnerRoot spawnerRoot;

	public CharacterSpawnerGroup masterGroup;

	public List<CharacterRandomPresetInfo> randomPresetInfos;

	private float delayTime = 1f;

	public Vector2Int spawnCountRange;

	private float totalWeight = -1f;

	public bool isStaticTarget;

	public static string currentGizmosTag;

	public bool firstIsLeader;

	private bool firstCreateStarted;

	public UnityEvent OnStartCreateEvent;

	private int targetSpawnCount;

	private int currentSpawnedCount;

	private bool destroied;

	public string gizmosTag;

	private float minDistanceToMainCharacter => spawnerRoot.minDistanceToPlayer;

	private int scene => spawnerRoot.RelatedScene;

	private void ShowGizmo()
	{
		currentGizmosTag = gizmosTag;
	}

	public override void Init(CharacterSpawnerRoot root)
	{
		spawnerRoot = root;
		if (spawnPoints == null)
		{
			spawnPoints = GetComponent<Points>();
		}
	}

	private void OnDestroy()
	{
		destroied = true;
	}

	private CharacterRandomPresetInfo GetAPresetByWeight()
	{
		if (totalWeight < 0f)
		{
			totalWeight = 0f;
			for (int i = 0; i < randomPresetInfos.Count; i++)
			{
				if (randomPresetInfos[i].randomPreset == null)
				{
					randomPresetInfos.RemoveAt(i);
					i--;
					UnityEngine.Debug.Log("Null preset");
				}
				else
				{
					totalWeight += randomPresetInfos[i].weight;
				}
			}
		}
		float num = UnityEngine.Random.Range(0f, totalWeight);
		float num2 = 0f;
		for (int j = 0; j < randomPresetInfos.Count; j++)
		{
			num2 += randomPresetInfos[j].weight;
			if (num < num2)
			{
				return randomPresetInfos[j];
			}
		}
		UnityEngine.Debug.LogError("权重计算错误", base.gameObject);
		return randomPresetInfos[randomPresetInfos.Count - 1];
	}

	public override void StartSpawn()
	{
		CreateAsync().Forget();
	}

	private async UniTaskVoid CreateAsync()
	{
		if ((bool)LevelManager.Instance && LevelManager.Instance.IsBaseLevel)
		{
			delayTime = 0.5f;
		}
		if (LevelManager.Instance == null || spawnPoints == null)
		{
			return;
		}
		OnStartCreateEvent?.Invoke();
		int count = (targetSpawnCount = UnityEngine.Random.Range(spawnCountRange.x, spawnCountRange.y + 1));
		List<Vector3> randomPoints = spawnPoints.GetRandomPoints(count);
		foreach (Vector3 item in randomPoints)
		{
			bool flag = false;
			if (!firstCreateStarted)
			{
				flag = true;
				firstCreateStarted = true;
			}
			CreateAt(item, scene, masterGroup, flag && firstIsLeader).Forget();
			currentSpawnedCount++;
			await UniTask.WaitForSeconds(0.1f, ignoreTimeScale: true);
		}
	}

	private async UniTask<CharacterMainControl> CreateAt(Vector3 point, int scene, CharacterSpawnerGroup group, bool isLeader)
	{
		if (randomPresetInfos.Count <= 0)
		{
			return null;
		}
		Vector3 direction = UnityEngine.Random.insideUnitCircle.normalized;
		direction.z = direction.y;
		direction.y = 0f;
		while ((bool)CharacterMainControl.Main && Vector3.Distance(point, CharacterMainControl.Main.transform.position) < minDistanceToMainCharacter)
		{
			await UniTask.Yield();
		}
		if (destroied || base.gameObject == null || !LevelManager.Instance || CharacterMainControl.Main == null)
		{
			return null;
		}
		if (isStaticTarget)
		{
			direction = base.transform.forward;
		}
		CharacterMainControl characterMainControl = await GetAPresetByWeight().randomPreset.CreateCharacterAsync(point, direction, scene, group, isLeader);
		if (isStaticTarget)
		{
			Rigidbody component = characterMainControl.GetComponent<Rigidbody>();
			component.collisionDetectionMode = CollisionDetectionMode.Discrete;
			component.isKinematic = true;
		}
		spawnerRoot.AddCreatedCharacter(characterMainControl);
		return characterMainControl;
	}

	private void OnDrawGizmos()
	{
		if (!(currentGizmosTag != gizmosTag))
		{
			Gizmos.color = Color.yellow;
			if ((bool)spawnPoints && spawnPoints.points.Count > 0)
			{
				Vector3 point = spawnPoints.GetPoint(0);
				Vector3 vector = point + Vector3.up * 20f;
				Gizmos.DrawWireSphere(point, 10f);
				Gizmos.DrawLine(point, vector);
				Gizmos.DrawSphere(vector, 3f);
			}
		}
	}
}
[Serializable]
public struct CharacterRandomPresetInfo
{
	public CharacterRandomPreset randomPreset;

	[Range(0f, 1f)]
	public float weight;
}
public class StrJson
{
	public struct Entry
	{
		public string key;

		public string value;

		public Entry(string key, string value)
		{
			this.key = key;
			this.value = value;
		}
	}

	public List<Entry> entries;

	private StrJson(params string[] contentPairs)
	{
		entries = new List<Entry>();
		for (int i = 0; i < contentPairs.Length - 1; i += 2)
		{
			entries.Add(new Entry(contentPairs[i], contentPairs[i + 1]));
		}
	}

	public StrJson Add(string key, string value)
	{
		entries.Add(new Entry(key, value));
		return this;
	}

	public static StrJson Create(params string[] contentPairs)
	{
		return new StrJson(contentPairs);
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("{");
		for (int i = 0; i < entries.Count; i++)
		{
			Entry entry = entries[i];
			if (i > 0)
			{
				stringBuilder.Append(",");
			}
			stringBuilder.Append("\"" + entry.key + "\":\"" + entry.value + "\"");
		}
		stringBuilder.Append("}");
		return stringBuilder.ToString();
	}
}
public static class CharacterMainControlExtensions
{
	public static bool IsMainCharacter(this CharacterMainControl character)
	{
		if (character == null)
		{
			return false;
		}
		return LevelManager.Instance?.MainCharacter == character;
	}
}
public static class ColorExtensions
{
	public static string ToHexString(this Color color)
	{
		return ((byte)(color.r * 255f)).ToString("X2") + ((byte)(color.g * 255f)).ToString("X2") + ((byte)(color.b * 255f)).ToString("X2") + ((byte)(color.a * 255f)).ToString("X2");
	}
}
public static class RectTransformExtensions
{
	public static Camera GetUICamera()
	{
		return null;
	}

	public static void MatchWorldPosition(this RectTransform rectTransform, Vector3 worldPosition, Vector3 worldSpaceOffset = default(Vector3))
	{
		RectTransform rectTransform2 = rectTransform.parent as RectTransform;
		if (!(rectTransform2 == null))
		{
			worldPosition += worldSpaceOffset;
			Vector2 screenPoint = RectTransformUtility.WorldToScreenPoint(Camera.main, worldPosition);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform2, screenPoint, GetUICamera(), out var localPoint);
			rectTransform.localPosition = localPoint;
		}
	}
}
public class TagUtilities
{
	public static Tag TagFromString(string name)
	{
		name = name.Trim();
		Tag tag = GameplayDataSettings.Tags.AllTags.FirstOrDefault((Tag e) => e != null && e.name == name);
		if (tag == null)
		{
			UnityEngine.Debug.LogError("未找到Tag: " + name);
		}
		return tag;
	}
}
public class GameManager : MonoBehaviour
{
	private static GameManager _instance;

	[SerializeField]
	private AudioManager audioManager;

	[SerializeField]
	private UIInputManager uiInputManager;

	[SerializeField]
	private GameRulesManager difficultyManager;

	[SerializeField]
	private PauseMenu pauseMenu;

	[SerializeField]
	private SceneLoader sceneLoader;

	[SerializeField]
	private BlackScreen blackScreen;

	[SerializeField]
	private EventSystem eventSystem;

	[SerializeField]
	private PlayerInput mainPlayerInput;

	[SerializeField]
	private NightVisionVisual nightVision;

	[SerializeField]
	private ModManager modManager;

	[SerializeField]
	private NoteIndex noteIndex;

	[SerializeField]
	private AchievementManager achievementManager;

	public static bool newBoot;

	public static GameManager Instance
	{
		get
		{
			if (!Application.isPlaying)
			{
				return null;
			}
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<GameManager>();
				if ((bool)_instance)
				{
					UnityEngine.Object.DontDestroyOnLoad(_instance.gameObject);
				}
			}
			if (_instance == null)
			{
				GameObject obj = Resources.Load<GameObject>("GameManager");
				if (obj == null)
				{
					UnityEngine.Debug.LogError("Resources中找不到GameManager的Prefab");
				}
				GameManager component = UnityEngine.Object.Instantiate(obj).GetComponent<GameManager>();
				if (component == null)
				{
					UnityEngine.Debug.LogError("GameManager的prefab上没有GameManager组件");
					return null;
				}
				_instance = component;
				if ((bool)_instance)
				{
					UnityEngine.Object.DontDestroyOnLoad(_instance.gameObject);
				}
			}
			return _instance;
		}
	}

	public static bool Paused
	{
		get
		{
			if (Instance == null)
			{
				return false;
			}
			if (Instance.pauseMenu.Shown)
			{
				return true;
			}
			return false;
		}
	}

	public static AudioManager AudioManager => Instance.audioManager;

	public static UIInputManager UiInputManager => Instance.uiInputManager;

	public static PauseMenu PauseMenu => Instance.pauseMenu;

	public static GameRulesManager DifficultyManager => Instance.difficultyManager;

	public static SceneLoader SceneLoader => Instance.sceneLoader;

	public static BlackScreen BlackScreen => Instance.blackScreen;

	public static EventSystem EventSystem => Instance.eventSystem;

	public static NightVisionVisual NightVision => Instance.nightVision;

	public static bool BloodFxOn => GameMetaData.BloodFxOn;

	public static PlayerInput MainPlayerInput => Instance.mainPlayerInput;

	public static ModManager ModManager => Instance.modManager;

	public static NoteIndex NoteIndex => Instance.noteIndex;

	public static AchievementManager AchievementManager => Instance.achievementManager;

	private void Awake()
	{
		if (_instance == null)
		{
			_instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}
		else if (_instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		DOTween.defaultTimeScaleIndependent = true;
		DebugManager.instance.enableRuntimeUI = false;
		DebugManager.instance.displayRuntimeUI = false;
	}

	private void Update()
	{
		_ = Application.isEditor;
	}

	public static void TimeTravelDetected()
	{
		UnityEngine.Debug.Log("检测到穿越者");
	}
}
public class TimeScaleManager : MonoBehaviour
{
	private void Awake()
	{
	}

	private void Update()
	{
		float timeScale = 1f;
		if (GameManager.Paused)
		{
			timeScale = 0f;
		}
		if (CameraMode.Active)
		{
			timeScale = 0f;
		}
		Time.timeScale = timeScale;
		Time.fixedDeltaTime = Mathf.Max(0.0005f, Time.timeScale * 0.02f);
	}
}
public class Carriable : MonoBehaviour
{
	private CA_Carry carrier;

	[SerializeField]
	private Rigidbody rb;

	[SerializeField]
	private float selfWeight;

	public InteractableLootbox lootbox;

	private bool droping;

	private float startDropTime = -1f;

	private bool carring;

	private Inventory inventory
	{
		get
		{
			if (lootbox == null)
			{
				return null;
			}
			return lootbox.Inventory;
		}
	}

	public float GetWeight()
	{
		if ((bool)inventory)
		{
			return inventory.CachedWeight + selfWeight;
		}
		return selfWeight;
	}

	public void Take(CA_Carry _carrier)
	{
		if ((bool)_carrier)
		{
			if ((bool)carrier)
			{
				carrier.StopAction();
			}
			droping = false;
			carrier = _carrier;
			if ((bool)inventory)
			{
				inventory.RecalculateWeight();
			}
			rb.transform.SetParent(carrier.characterController.modelRoot);
			rb.velocity = Vector3.zero;
			rb.transform.position = carrier.characterController.modelRoot.TransformPoint(carrier.carryPoint);
			rb.transform.localRotation = Quaternion.identity;
			SetRigidbodyActive(active: false);
		}
	}

	private void SetRigidbodyActive(bool active)
	{
		if (active)
		{
			rb.isKinematic = false;
			rb.interpolation = RigidbodyInterpolation.Interpolate;
			if ((bool)lootbox && (bool)lootbox.interactCollider)
			{
				lootbox.interactCollider.isTrigger = false;
			}
		}
		else
		{
			rb.isKinematic = true;
			rb.interpolation = RigidbodyInterpolation.None;
			if ((bool)lootbox && (bool)lootbox.interactCollider)
			{
				lootbox.interactCollider.isTrigger = true;
			}
		}
	}

	public void Drop()
	{
		if (carrier.Running)
		{
			carrier.StopAction();
		}
		carrier = null;
		MultiSceneCore.MoveToActiveWithScene(rb.gameObject, SceneManager.GetActiveScene().buildIndex);
		DropTask().Forget();
	}

	public void OnCarriableUpdate(float deltaTime)
	{
		if ((bool)carrier)
		{
			Vector3 position = carrier.characterController.modelRoot.TransformPoint(carrier.carryPoint);
			if ((bool)carrier.characterController.RightHandSocket)
			{
				position.y = carrier.characterController.RightHandSocket.transform.position.y + carrier.carryPoint.y;
			}
			rb.transform.position = position;
		}
	}

	private async UniTaskVoid DropTask()
	{
		startDropTime = Time.time;
		droping = true;
		SetRigidbodyActive(active: true);
		rb.velocity = base.transform.forward * 1.5f + base.transform.up * 0.5f;
		while (Time.time - startDropTime < 3f)
		{
			await UniTask.WaitForEndOfFrame(this);
		}
		droping = false;
		SetRigidbodyActive(active: false);
	}
}
public class Egg : MonoBehaviour
{
	public GameObject spawnFx;

	public CharacterMainControl fromCharacter;

	public Rigidbody rb;

	private float life;

	private CharacterRandomPreset characterPreset;

	private bool inited;

	private float timer;

	private bool spawned;

	private void Start()
	{
	}

	public void Init(Vector3 spawnPosition, Vector3 spawnVelocity, CharacterMainControl _fromCharacter, CharacterRandomPreset preset, float _life)
	{
		characterPreset = preset;
		base.transform.position = spawnPosition;
		if ((bool)rb)
		{
			rb.position = spawnPosition;
			rb.velocity = spawnVelocity;
		}
		fromCharacter = _fromCharacter;
		life = _life;
		inited = true;
	}

	private async UniTaskVoid Spawn()
	{
		if ((bool)spawnFx)
		{
			UnityEngine.Object.Instantiate(spawnFx, base.transform.position, Quaternion.identity);
		}
		if (!fromCharacter)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		_ = fromCharacter.IsMainCharacter;
		CharacterMainControl obj = await characterPreset.CreateCharacterAsync(base.transform.position + Vector3.down * 0.25f, Vector3.forward, MultiSceneCore.MainScene.Value.buildIndex, null, isLeader: false);
		AICharacterController componentInChildren = obj.GetComponentInChildren<AICharacterController>();
		obj.SetPosition(base.transform.position + Vector3.down * 0.25f);
		if ((bool)componentInChildren)
		{
			PetAI component = componentInChildren.GetComponent<PetAI>();
			if ((bool)component)
			{
				component.SetMaster(fromCharacter);
			}
			componentInChildren.leader = fromCharacter;
			if ((bool)fromCharacter)
			{
				componentInChildren.CharacterMainControl.SetTeam(fromCharacter.Team);
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void Update()
	{
		if (inited)
		{
			timer += Time.deltaTime;
			if (timer > life && !spawned)
			{
				spawned = true;
				Spawn().Forget();
			}
		}
	}
}
public class EndingControl : MonoBehaviour
{
	public int endingIndex;

	public string MissleLuncherClosedKey = "MissleLuncherClosed";

	public void SetEndingIndex()
	{
		Ending.endingIndex = endingIndex;
		AchievementManager instance = AchievementManager.Instance;
		bool flag = SavesSystem.Load<bool>(MissleLuncherClosedKey);
		DifficultySelection.UnlockRage();
		if (!instance)
		{
			return;
		}
		if (endingIndex == 0)
		{
			if (!flag)
			{
				instance.Unlock("Ending_0");
			}
			else
			{
				instance.Unlock("Ending_3");
			}
		}
		else if (!flag)
		{
			instance.Unlock("Ending_1");
		}
		else
		{
			instance.Unlock("Ending_2");
		}
	}
}
public class FillWaterAndFood : MonoBehaviour
{
	public float water;

	public float food;

	public void Fill()
	{
		CharacterMainControl main = CharacterMainControl.Main;
		if ((bool)main)
		{
			main.AddWater(water);
			main.AddEnergy(food);
		}
	}
}
public class Action_Fishing : CharacterActionBase
{
	public enum FishingStates
	{
		notStarted,
		intro,
		selectingBait,
		fishing,
		catching,
		over
	}

	[SerializeField]
	private CinemachineVirtualCamera fishingCamera;

	private FishingRod fishingRod;

	[SerializeField]
	private FishingPoint fishingPoint;

	[SerializeField]
	private float introTime = 0.2f;

	private float fishingWaitTime = 2f;

	private float catchTime = 0.5f;

	private Item bait;

	private Transform socket;

	[SerializeField]
	[ItemTypeID]
	private int testCatchItem;

	private Item catchedItem;

	private bool quit;

	private UniTask currentTask;

	private bool catchInput;

	private bool resultConfirmed;

	private bool continueFishing;

	private FishingStates fishingState;

	private int fishingTaskToken;

	public FishingStates FishingState => fishingState;

	public static event Action<Action_Fishing, ICollection<Item>, Func<Item, bool>> OnPlayerStartSelectBait;

	public static event Action<Action_Fishing> OnPlayerStartFishing;

	public static event Action<Action_Fishing, float, Func<float>> OnPlayerStartCatching;

	public static event Action<Action_Fishing, Item, Action<bool>> OnPlayerStopCatching;

	public static event Action<Action_Fishing> OnPlayerStopFishing;

	private void Awake()
	{
		fishingCamera.gameObject.SetActive(value: false);
	}

	public override bool CanEditInventory()
	{
		return false;
	}

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.Fishing;
	}

	protected override bool OnStart()
	{
		if (!characterController)
		{
			return false;
		}
		fishingCamera.gameObject.SetActive(value: true);
		fishingRod = characterController.CurrentHoldItemAgent.GetComponent<FishingRod>();
		bool result = fishingRod != null;
		currentTask = Fishing();
		InputManager.OnInteractButtonDown = (Action)Delegate.Remove(InputManager.OnInteractButtonDown, new Action(OnCatchButton));
		InputManager.OnInteractButtonDown = (Action)Delegate.Combine(InputManager.OnInteractButtonDown, new Action(OnCatchButton));
		UIInputManager.OnCancel -= UIOnCancle;
		UIInputManager.OnCancel += UIOnCancle;
		return result;
	}

	private void OnCatchButton()
	{
		if (fishingState == FishingStates.catching)
		{
			catchInput = true;
		}
	}

	private void UIOnCancle(UIInputEventData data)
	{
		data.Use();
		Quit();
	}

	protected override void OnStop()
	{
		base.OnStop();
		fishingState = FishingStates.notStarted;
		Action_Fishing.OnPlayerStopFishing?.Invoke(this);
		InputManager.OnInteractButtonDown = (Action)Delegate.Remove(InputManager.OnInteractButtonDown, new Action(OnCatchButton));
		UIInputManager.OnCancel -= UIOnCancle;
		fishingCamera.gameObject.SetActive(value: false);
	}

	public override bool CanControlAim()
	{
		return false;
	}

	public override bool CanMove()
	{
		return false;
	}

	public override bool CanRun()
	{
		return false;
	}

	public override bool CanUseHand()
	{
		return false;
	}

	public override bool IsReady()
	{
		return true;
	}

	private int NewToken()
	{
		fishingTaskToken++;
		fishingTaskToken %= 1000;
		return fishingTaskToken;
	}

	private async UniTask Fishing()
	{
		int token = NewToken();
		quit = false;
		fishingState = FishingStates.intro;
		await UniTask.WaitForSeconds(introTime);
		while (IsTaskValid())
		{
			await UniTask.WaitForEndOfFrame(this);
			await SingleFishingLoop(IsTaskValid);
		}
		bool IsTaskValid()
		{
			bool flag = true;
			if (!characterController)
			{
				flag = false;
			}
			if (!base.Running)
			{
				flag = false;
			}
			if (quit)
			{
				flag = false;
			}
			if (token != fishingTaskToken)
			{
				flag = false;
			}
			if (!flag)
			{
				UnityEngine.Debug.Log($"钓鱼终止：当前状态：{fishingState}");
			}
			return flag;
		}
	}

	private async UniTask SingleFishingLoop(Func<bool> IsTaskValid)
	{
		if (IsTaskValid())
		{
			fishingState = FishingStates.selectingBait;
			bool flag = await WaitForSelectBait();
			if (IsTaskValid() && flag)
			{
				fishingState = FishingStates.fishing;
				Action_Fishing.OnPlayerStartFishing?.Invoke(this);
				await UniTask.WaitForSeconds(fishingWaitTime);
				if (IsTaskValid())
				{
					bool flag2 = await Catching(IsTaskValid);
					if (IsTaskValid())
					{
						fishingState = FishingStates.over;
						resultConfirmed = false;
						continueFishing = false;
						if (flag2)
						{
							Item arg = await ItemAssetsCollection.InstantiateAsync(testCatchItem);
							Action_Fishing.OnPlayerStopCatching?.Invoke(this, arg, ResultConfirm);
							PopText.Pop("成功", base.transform.position, Color.white, 1f);
						}
						else
						{
							Action_Fishing.OnPlayerStopCatching?.Invoke(this, null, ResultConfirm);
							PopText.Pop("失败", base.transform.position, Color.white, 1f);
						}
						await UniTask.WaitUntil(() => quit || resultConfirmed);
						if (IsTaskValid() && continueFishing)
						{
							fishingState = FishingStates.notStarted;
							return;
						}
					}
				}
			}
		}
		fishingState = FishingStates.notStarted;
		quit = true;
		if (base.Running)
		{
			StopAction();
		}
	}

	private void ResultConfirm(bool _continueFishing)
	{
		resultConfirmed = true;
		continueFishing = _continueFishing;
	}

	private async UniTask<bool> Catching(Func<bool> IsTaskValid)
	{
		catchInput = false;
		fishingState = FishingStates.catching;
		PopText.Pop($"FFFF,控制:{InputManager.InputActived}", base.transform.position, Color.white, 1f);
		float currentTime = 0f;
		Action_Fishing.OnPlayerStartCatching?.Invoke(this, catchTime, () => currentTime);
		await UniTask.WaitForEndOfFrame(this);
		float startCatchTime = Time.time;
		bool catchOver = false;
		while (!catchOver)
		{
			currentTime = Time.time - startCatchTime;
			if (!IsTaskValid())
			{
				return false;
			}
			if (catchInput && currentTime < catchTime)
			{
				UnityEngine.Debug.Log("catch");
				return true;
			}
			if (currentTime >= catchTime)
			{
				return false;
			}
			await UniTask.WaitForEndOfFrame(this);
		}
		return false;
	}

	private async UniTask<bool> WaitForSelectBait()
	{
		bait = null;
		Action_Fishing.OnPlayerStartSelectBait?.Invoke(this, GetAllBaits(), SelectBaitAndStartFishing);
		await UniTask.WaitUntil(() => quit || bait != null);
		if (quit)
		{
			return false;
		}
		return true;
	}

	public List<Item> GetAllBaits()
	{
		List<Item> list = new List<Item>();
		if (!characterController)
		{
			return list;
		}
		foreach (Item item in characterController.CharacterItem.Inventory)
		{
			if (item.Tags.Contains(GameplayDataSettings.Tags.Bait))
			{
				list.Add(item);
			}
		}
		return list;
	}

	public void CatchButton()
	{
	}

	public void Quit()
	{
		UnityEngine.Debug.Log("Quit");
		quit = true;
	}

	private bool SelectBaitAndStartFishing(Item _bait)
	{
		if (_bait == null)
		{
			UnityEngine.Debug.Log("鱼饵选了个null, 退出");
			Quit();
			return false;
		}
		if (!_bait.Tags.Contains(GameplayDataSettings.Tags.Bait))
		{
			Quit();
			return false;
		}
		bait = _bait;
		return true;
	}

	private void OnDestroy()
	{
		if (base.Running)
		{
			Action_Fishing.OnPlayerStopFishing?.Invoke(this);
		}
		InputManager.OnInteractButtonDown = (Action)Delegate.Remove(InputManager.OnInteractButtonDown, new Action(OnCatchButton));
		UIInputManager.OnCancel -= UIOnCancle;
	}
}
public class Action_FishingV2 : CharacterActionBase
{
	public enum FishingStates
	{
		non,
		throwing,
		waiting,
		ring,
		cancleBack,
		successBack,
		failBack
	}

	public InteractableBase interactable;

	public Transform baitVisual;

	public TrailRenderer baitTrail;

	public Canvas fishingHudCanvas;

	public Transform targetPoint;

	public Transform bucketPoint;

	[LocalizationKey("Default")]
	public string noRodText = "Pop_NoRod";

	[LocalizationKey("Default")]
	public string noBaitText = "Pop_NoBait";

	[LocalizationKey("Default")]
	public string gotFishText = "Notify_GotFish";

	[LocalizationKey("Default")]
	public string failText = "Notify_FishRunAway";

	private FishingRod rod;

	private ItemAgent rodAgent;

	private Item baitItem;

	public Animator ringAnimator;

	public Vector2 waitTimeRange = new Vector2(3f, 9f);

	private float waitTime;

	public Vector2 scaleRange = new Vector2(0.5f, 3f);

	public Vector2 successRange = new Vector2(0.75f, 1.1f);

	private float ringScaling = 2.5f;

	private float stateTimer;

	private bool catchInput;

	public Transform scaleRing;

	public LineRenderer lineRenderer;

	public float throwStartTime = 0.1f;

	public float outTime;

	public AnimationCurve outYCurve;

	public ParticleSystem waveParticle;

	public GameObject dropParticle;

	public GameObject bucketParticle;

	public InteractableLootbox lootbox;

	private bool hookFxSpawned;

	public GameObject hookFx;

	public float backTime;

	public AnimationCurve backYCurve;

	private Vector3 hookStartPoint;

	public GameObject gotFx;

	public FishSpawner lootSpawner;

	private Item currentFish;

	private float luck = 1f;

	private float scaleTime;

	private float scaleTimeFactor = 1.25f;

	private int fishingTimeHash = "FishingTime".GetHashCode();

	private int fishingDifficultyHash = "FishingDifficulty".GetHashCode();

	private int fishingQualityFactorHash = "FishingQualityFactor".GetHashCode();

	private Slot characterMeleeWeaponSlot;

	private string currentStateInfo;

	private string throwSoundKey = "SFX/Actions/Fishing_Throw";

	private string startFishingSoundKey = "SFX/Actions/Fishing_Start";

	private string pulloutSoundKey = "SFX/Actions/Fishing_PullOut";

	private string baitSoundKey = "SFX/Actions/Fishing_Bait";

	private string successSoundKey = "SFX/Actions/Fishing_Success";

	private string failSoundKey = "SFX/Actions/Fishing_Failed";

	public FishingStates fishingState = FishingStates.waiting;

	private bool needStopAction;

	public override ActionPriorities ActionPriority()
	{
		return ActionPriorities.Fishing;
	}

	public override bool CanControlAim()
	{
		return false;
	}

	public override bool CanMove()
	{
		return false;
	}

	public override bool CanRun()
	{
		return false;
	}

	public override bool CanUseHand()
	{
		return false;
	}

	private void Awake()
	{
		interactable.OnInteractTimeoutEvent.AddListener(OnInteractTimeOut);
		interactable.finishWhenTimeOut = false;
		fishingHudCanvas.gameObject.SetActive(value: false);
		baitVisual.gameObject.SetActive(value: false);
		baitTrail.gameObject.SetActive(value: false);
		dropParticle.SetActive(value: false);
		bucketParticle.SetActive(value: false);
		gotFx.SetActive(value: false);
		SyncInteractable(CharacterMainControl.Main);
		CharacterMainControl.OnMainCharacterChangeHoldItemAgentEvent = (Action<CharacterMainControl, DuckovItemAgent>)Delegate.Combine(CharacterMainControl.OnMainCharacterChangeHoldItemAgentEvent, new Action<CharacterMainControl, DuckovItemAgent>(OnMainCharacterChangeItemAgent));
		TransToNon();
	}

	private void OnMainCharacterChangeItemAgent(CharacterMainControl character, DuckovItemAgent agent)
	{
		SyncInteractable(character);
	}

	private void SyncInteractable(CharacterMainControl character)
	{
		if (!character)
		{
			interactable.gameObject.SetActive(value: false);
			return;
		}
		DuckovItemAgent currentHoldItemAgent = character.CurrentHoldItemAgent;
		if (!currentHoldItemAgent)
		{
			interactable.gameObject.SetActive(value: false);
			return;
		}
		FishingRod component = currentHoldItemAgent.GetComponent<FishingRod>();
		interactable.gameObject.SetActive(component != null);
	}

	private void SetWaveEmissionRate(float rate)
	{
		ParticleSystem.EmissionModule emission = waveParticle.emission;
		emission.rateOverTime = rate;
	}

	private void OnDestroy()
	{
		if ((bool)interactable)
		{
			interactable.OnInteractTimeoutEvent.RemoveListener(OnInteractTimeOut);
		}
		CharacterMainControl.OnMainCharacterChangeHoldItemAgentEvent = (Action<CharacterMainControl, DuckovItemAgent>)Delegate.Remove(CharacterMainControl.OnMainCharacterChangeHoldItemAgentEvent, new Action<CharacterMainControl, DuckovItemAgent>(OnMainCharacterChangeItemAgent));
	}

	public void TryCatch()
	{
		UnityEngine.Debug.Log("TryCatch");
		if (fishingState == FishingStates.waiting || fishingState == FishingStates.ring)
		{
			catchInput = true;
		}
	}

	private void OnInteractTimeOut(CharacterMainControl target, InteractableBase interactable)
	{
		interactable.StopInteract();
		target.StartAction(this);
	}

	public override bool IsReady()
	{
		return !base.Running;
	}

	protected override bool OnStart()
	{
		if (characterController == null)
		{
			StopAction();
		}
		waitTime = UnityEngine.Random.Range(waitTimeRange.x, waitTimeRange.y);
		ringAnimator.SetInteger("State", 0);
		rodAgent = characterController.CurrentHoldItemAgent;
		if (!rodAgent)
		{
			characterController.PopText(noRodText.ToPlainText());
			return false;
		}
		rod = rodAgent.GetComponent<FishingRod>();
		if (!rod)
		{
			characterController.PopText(noRodText.ToPlainText());
			return false;
		}
		baitItem = rod.Bait;
		if (!baitItem)
		{
			characterController.PopText(noBaitText.ToPlainText());
			return false;
		}
		characterController.characterModel.ForcePlayAttackAnimation();
		Vector3 direction = targetPoint.position - characterController.transform.position;
		direction.y = 0f;
		direction.Normalize();
		characterController.movementControl.ForceTurnTo(direction);
		fishingHudCanvas.worldCamera = Camera.main;
		fishingHudCanvas.gameObject.SetActive(value: true);
		hookStartPoint = rod.lineStart.position;
		TransToThrowing();
		return true;
	}

	protected override void OnStop()
	{
		TransToNon();
		fishingHudCanvas.gameObject.SetActive(value: false);
		ringAnimator.gameObject.SetActive(value: false);
		lineRenderer.gameObject.SetActive(value: false);
		baitVisual.gameObject.SetActive(value: false);
		gotFx.SetActive(value: false);
		SetWaveEmissionRate(0f);
		ringAnimator.SetInteger("State", 0);
		if ((bool)currentFish)
		{
			currentFish.DestroyTree();
			currentFish = null;
		}
	}

	private void SpawnDropParticle()
	{
		UnityEngine.Object.Instantiate(dropParticle, targetPoint).SetActive(value: true);
	}

	private void SpawnBucketParticle()
	{
		UnityEngine.Object.Instantiate(bucketParticle, bucketPoint).SetActive(value: true);
	}

	private void OnDisable()
	{
		if (base.Running)
		{
			StopAction();
		}
		fishingHudCanvas.gameObject.SetActive(value: false);
	}

	public override bool IsStopable()
	{
		return needStopAction;
	}

	private Vector3 GetHookOutPos(float lerpValue)
	{
		lerpValue = Mathf.Clamp01(lerpValue);
		Vector3 a = hookStartPoint;
		Vector3 position = targetPoint.position;
		Vector3 result = Vector3.Lerp(a, position, lerpValue);
		float y = Mathf.LerpUnclamped(position.y, a.y, outYCurve.Evaluate(lerpValue));
		result.y = y;
		return result;
	}

	private Vector3 GetHookBackPos(float lerpValue)
	{
		lerpValue = Mathf.Clamp01(lerpValue);
		Vector3 position = rod.lineStart.position;
		Vector3 position2 = targetPoint.position;
		Vector3 result = Vector3.Lerp(position2, position, lerpValue);
		float y = Mathf.LerpUnclamped(position2.y, position.y, backYCurve.Evaluate(lerpValue));
		result.y = y;
		return result;
	}

	protected override void OnUpdateAction(float deltaTime)
	{
		if (!characterController || !rod)
		{
			needStopAction = true;
			StopAction();
			return;
		}
		lineRenderer.SetPosition(0, rod.lineStart.position);
		Vector3 position = rod.lineStart.position;
		needStopAction = false;
		if (rod == null)
		{
			needStopAction = true;
			StopAction();
			return;
		}
		switch (fishingState)
		{
		case FishingStates.throwing:
			if (!baitItem || catchInput)
			{
				TransToCancleBack();
			}
			else if (stateTimer < throwStartTime)
			{
				hookStartPoint = rod.lineStart.position;
				position = hookStartPoint;
				baitTrail.Clear();
			}
			else if (stateTimer < outTime)
			{
				position = GetHookOutPos((stateTimer - throwStartTime) / (outTime - throwStartTime));
				if (!baitVisual.gameObject.activeInHierarchy)
				{
					baitVisual.gameObject.SetActive(value: true);
					baitTrail.gameObject.SetActive(value: true);
				}
				baitVisual.transform.position = position;
				baitTrail.transform.position = position;
			}
			else
			{
				TransToWaiting();
			}
			break;
		case FishingStates.waiting:
			if (catchInput)
			{
				TransToCancleBack();
				break;
			}
			position = targetPoint.position;
			baitVisual.transform.position = position;
			baitTrail.transform.position = position;
			if (stateTimer >= waitTime)
			{
				if (currentFish != null)
				{
					TransToRing();
				}
				else
				{
					characterController.PopText("Error:Spawn fish failed");
					TransToCancleBack();
				}
			}
			if (waitTime - stateTimer < 0.25f && !hookFxSpawned)
			{
				hookFxSpawned = true;
				SpawnHookFx();
			}
			break;
		case FishingStates.ring:
		{
			position = targetPoint.position;
			float num2 = Mathf.Lerp(scaleRange.y, scaleRange.x, 1f - stateTimer / scaleTime);
			scaleRing.localScale = Vector3.one * num2;
			if (catchInput)
			{
				if (num2 < successRange.x || num2 > successRange.y)
				{
					TransToFailBack();
					break;
				}
				TransToSuccessback();
			}
			if (stateTimer > scaleTime)
			{
				TransToFailBack();
			}
			break;
		}
		case FishingStates.cancleBack:
			position = GetHookBackPos(stateTimer / backTime);
			baitVisual.transform.position = position;
			baitTrail.transform.position = position;
			if (stateTimer > backTime)
			{
				needStopAction = true;
			}
			break;
		case FishingStates.successBack:
		{
			float num = 0.2f;
			if (!(stateTimer < num))
			{
				position = GetHookBackPos((stateTimer - num) / backTime);
				baitVisual.transform.position = position;
				baitTrail.transform.position = position;
				if (stateTimer - num > backTime)
				{
					needStopAction = true;
				}
			}
			break;
		}
		case FishingStates.failBack:
			position = GetHookBackPos(stateTimer / backTime);
			baitVisual.transform.position = position;
			baitTrail.transform.position = position;
			if (stateTimer > backTime)
			{
				NotificationText.Push(failText.ToPlainText());
				needStopAction = true;
			}
			break;
		}
		lineRenderer.SetPosition(1, position);
		catchInput = false;
		stateTimer += deltaTime;
		if (needStopAction)
		{
			baitVisual.gameObject.SetActive(value: false);
			baitTrail.gameObject.SetActive(value: false);
			baitTrail.Clear();
			StopAction();
		}
	}

	private void TransToNon()
	{
		fishingState = FishingStates.non;
		SetWaveEmissionRate(0f);
	}

	private void TransToThrowing()
	{
		AudioManager.Post(throwSoundKey, base.gameObject);
		stateTimer = 0f;
		lineRenderer.gameObject.SetActive(value: true);
		lineRenderer.positionCount = 2;
		lineRenderer.SetPosition(0, rod.lineStart.position);
		lineRenderer.SetPosition(1, rod.lineStart.position);
		ringAnimator.gameObject.SetActive(value: true);
		ringAnimator.SetInteger("State", 0);
		fishingState = FishingStates.throwing;
	}

	private void TransToWaiting()
	{
		if (baitItem == null)
		{
			needStopAction = true;
			StopAction();
		}
		AudioManager.Post(startFishingSoundKey, targetPoint.gameObject);
		hookFxSpawned = false;
		SpawnDropParticle();
		SetWaveEmissionRate(1.5f);
		stateTimer = 0f;
		ringAnimator.SetInteger("State", 0);
		luck = characterController.CharacterItem.GetStatValue(fishingQualityFactorHash);
		SpawnFish(luck).Forget();
		fishingState = FishingStates.waiting;
	}

	private void SpawnHookFx()
	{
		if (!(hookFx == null))
		{
			UnityEngine.Object.Instantiate(hookFx, targetPoint.position + Vector3.up * 3f, Quaternion.identity);
			AudioManager.Post(baitSoundKey, targetPoint.gameObject);
		}
	}

	private void TransToRing()
	{
		scaleTime = characterController.CharacterItem.GetStatValue(fishingTimeHash) * scaleTimeFactor;
		scaleTime = Mathf.Max(0.01f, scaleTime);
		float num = currentFish.GetStatValue(fishingDifficultyHash);
		if (num < 0.02f)
		{
			num = 1f;
		}
		scaleTime /= num;
		if (scaleTime > 7f)
		{
			scaleTime = 7f;
		}
		stateTimer = 0f;
		catchInput = false;
		fishingState = FishingStates.ring;
		ringAnimator.SetInteger("State", 1);
	}

	private void TransToCancleBack()
	{
		stateTimer = 0f;
		ringAnimator.SetInteger("State", 0);
		fishingState = FishingStates.cancleBack;
		SetWaveEmissionRate(0f);
		SpawnDropParticle();
		fishingHudCanvas.gameObject.SetActive(value: false);
		AudioManager.Post(pulloutSoundKey, targetPoint.gameObject);
	}

	private void TransToSuccessback()
	{
		stateTimer = 0f;
		ringAnimator.SetInteger("State", 2);
		AudioManager.Post(successSoundKey, targetPoint.gameObject);
		fishingState = FishingStates.successBack;
		SetWaveEmissionRate(0f);
		SpawnDropParticle();
		gotFx.SetActive(value: true);
		fishingHudCanvas.gameObject.SetActive(value: false);
		CatchFish().Forget();
		RequireHasFished.SetHasFished();
	}

	private void TransToFailBack()
	{
		stateTimer = 0f;
		ringAnimator.SetInteger("State", 3);
		AudioManager.Post(failSoundKey, targetPoint.gameObject);
		fishingState = FishingStates.failBack;
		SetWaveEmissionRate(0f);
		SpawnDropParticle();
		fishingHudCanvas.gameObject.SetActive(value: false);
	}

	private async UniTaskVoid SpawnFish(float luck)
	{
		if (!baitItem)
		{
			return;
		}
		int typeID = baitItem.TypeID;
		if (lootbox.Inventory.GetFirstEmptyPosition() == -1)
		{
			lootbox.Inventory.SetCapacity(lootbox.Inventory.Capacity + 5);
		}
		Item item = await lootSpawner.Spawn(typeID, luck);
		if (item == null)
		{
			return;
		}
		item.Inspected = true;
		currentFish = item;
		if ((bool)baitItem)
		{
			if (baitItem.Stackable)
			{
				baitItem.StackCount--;
			}
			else
			{
				baitItem.DestroyTree();
			}
		}
	}

	private async UniTaskVoid CatchFish()
	{
		if (!(currentFish == null))
		{
			string notify = gotFishText.ToPlainText() + " " + currentFish.DisplayName + "!";
			characterController.PickupItem(currentFish);
			currentFish = null;
			await UniTask.WaitForSeconds(0.65f);
			NotificationText.Push(notify);
		}
	}

	public override bool CanEditInventory()
	{
		return false;
	}
}
public class FishingPoint : MonoBehaviour
{
	public InteractableBase Interactable;

	public Action_Fishing action;

	public Transform playerPoint;

	private void Awake()
	{
		OnPlayerTakeFishingRod(null);
		Interactable.OnInteractFinishedEvent.AddListener(OnInteractFinished);
	}

	private void OnDestroy()
	{
		if ((bool)Interactable)
		{
			Interactable.OnInteractFinishedEvent.RemoveListener(OnInteractFinished);
		}
	}

	private void OnPlayerTakeFishingRod(FishingRod rod)
	{
	}

	private void OnInteractFinished(CharacterMainControl character, InteractableBase interact)
	{
		if ((bool)character)
		{
			character.SetPosition(playerPoint.position);
			character.SetAimPoint(playerPoint.position + playerPoint.forward * 10f);
			character.movementControl.SetAimDirection(playerPoint.forward);
			character.StartAction(action);
		}
	}
}
public class FowSmoke : MonoBehaviour
{
	[SerializeField]
	private int res = 8;

	[SerializeField]
	private float radius;

	[SerializeField]
	private float height;

	[SerializeField]
	private float thickness;

	public Transform colParent;

	public ParticleSystem[] particles;

	public float startTime;

	public float lifeTime;

	public float particleFadeTime = 3f;

	public UnityEvent beforeFadeOutEvent;

	private void Start()
	{
		UpdateSmoke().Forget();
	}

	private async UniTaskVoid UpdateSmoke()
	{
		if (colParent == null)
		{
			return;
		}
		colParent.localScale = Vector3.one * 0.01f;
		float startTimer = 0f;
		while (startTimer < startTime)
		{
			await UniTask.WaitForEndOfFrame(this);
			if (colParent == null)
			{
				return;
			}
			startTimer += Time.deltaTime;
			colParent.localScale = Vector3.one * Mathf.Clamp01(startTimer / startTime);
		}
		await UniTask.WaitForSeconds(startTime);
		if (colParent != null)
		{
			colParent.gameObject.SetActive(value: true);
		}
		await UniTask.WaitForSeconds(lifeTime);
		beforeFadeOutEvent?.Invoke();
		for (int i = 0; i < particles.Length; i++)
		{
			if (!(particles[i] == null))
			{
				ParticleSystem.EmissionModule emission = particles[i].emission;
				emission.rateOverTime = 0f;
			}
		}
		float dieTimer = 0f;
		while (dieTimer < particleFadeTime)
		{
			await UniTask.WaitForEndOfFrame(this);
			dieTimer += Time.deltaTime;
			float num = Mathf.Clamp01(dieTimer / particleFadeTime);
			if (colParent == null)
			{
				return;
			}
			colParent.localScale = Vector3.one * (1f - num);
		}
		if (base.gameObject != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.DrawWireSphere(base.transform.position, radius);
	}
}
public class SetInLevelDataBoolProxy : MonoBehaviour
{
	public bool targetValue = true;

	public string keyString = "";

	private int keyHash;

	private bool keyInited;

	public void SetToTarget()
	{
		SetTo(targetValue);
	}

	public void SetTo(bool target)
	{
		if (!(keyString == ""))
		{
			if (!keyInited)
			{
				InitKey();
			}
			if ((bool)MultiSceneCore.Instance)
			{
				MultiSceneCore.Instance.inLevelData[keyHash] = target;
			}
		}
	}

	private void InitKey()
	{
		keyHash = keyString.GetHashCode();
		keyInited = true;
	}
}
[Obsolete]
public class InvisibleTeleporter : MonoBehaviour, IDrawGizmos
{
	[SerializeField]
	private Transform target;

	[SerializeField]
	private Vector3 position;

	[SerializeField]
	private Space space;

	private bool UsePosition => target == null;

	private Vector3 TargetWorldPosition
	{
		get
		{
			if (target != null)
			{
				return target.transform.position;
			}
			return space switch
			{
				Space.World => position, 
				Space.Self => base.transform.TransformPoint(position), 
				_ => default(Vector3), 
			};
		}
	}

	public void Teleport()
	{
		CharacterMainControl main = CharacterMainControl.Main;
		if (!(main == null))
		{
			GameCamera instance = GameCamera.Instance;
			Vector3 vector = instance.transform.position - main.transform.position;
			main.SetPosition(TargetWorldPosition);
			Vector3 vector2 = main.transform.position + vector;
			instance.transform.position = vector2;
		}
	}

	private void LateUpdate()
	{
		if (Keyboard.current != null && Keyboard.current.tKey.wasPressedThisFrame)
		{
			Teleport();
		}
	}

	public void DrawGizmos()
	{
		if (GizmoContext.InActiveSelection(this))
		{
			CharacterMainControl main = CharacterMainControl.Main;
			if (main == null)
			{
				Drawing.Draw.Arrow(base.transform.position, TargetWorldPosition);
			}
			else
			{
				Drawing.Draw.Arrow(main.transform.position, TargetWorldPosition);
			}
		}
	}
}
public class KunEvents : MonoBehaviour
{
	[SerializeField]
	private int hairID = 6;

	[ItemTypeID]
	[SerializeField]
	private int armorID;

	public DialogueBubbleProxy dialogueBubbleProxy;

	[LocalizationKey("Dialogues")]
	public string notRight;

	[LocalizationKey("Dialogues")]
	public string onlyRightFace;

	[LocalizationKey("Dialogues")]
	public string onlyRightCloth;

	[LocalizationKey("Dialogues")]
	public string allRight;

	[FormerlySerializedAs("SetActiveObject")]
	public GameObject setActiveObject;

	private void Awake()
	{
		setActiveObject.SetActive(value: false);
		if (!dialogueBubbleProxy)
		{
			dialogueBubbleProxy.GetComponent<DialogueBubbleProxy>();
		}
	}

	public void Check()
	{
		bool flag = false;
		bool flag2 = false;
		if (CharacterMainControl.Main == null)
		{
			return;
		}
		CharacterMainControl main = CharacterMainControl.Main;
		CharacterModel characterModel = main.characterModel;
		if (!characterModel)
		{
			return;
		}
		CustomFaceInstance customFace = characterModel.CustomFace;
		if ((bool)customFace)
		{
			flag = customFace.ConvertToSaveData().hairID == hairID;
			Item armorItem = main.GetArmorItem();
			if (armorItem != null && armorItem.TypeID == armorID)
			{
				flag2 = true;
			}
			if (!flag && !flag2)
			{
				dialogueBubbleProxy.textKey = notRight;
			}
			else if (flag && !flag2)
			{
				dialogueBubbleProxy.textKey = onlyRightFace;
			}
			else if (!flag && flag2)
			{
				dialogueBubbleProxy.textKey = onlyRightCloth;
			}
			else
			{
				dialogueBubbleProxy.textKey = allRight;
				setActiveObject.SetActive(value: true);
			}
			dialogueBubbleProxy.Pop();
		}
	}
}
public class PaperBox : MonoBehaviour
{
	[HideInInspector]
	public CharacterMainControl character;

	public Transform setActiveWhileStandStill;

	private void Update()
	{
		if ((bool)character && (bool)setActiveWhileStandStill)
		{
			bool flag = character.Velocity.magnitude < 0.2f;
			if (setActiveWhileStandStill.gameObject.activeSelf != flag)
			{
				setActiveWhileStandStill.gameObject.SetActive(flag);
			}
		}
	}
}
public class RandomActiveSelector : MonoBehaviour
{
	[Range(0f, 1f)]
	public float activeChance = 1f;

	private int activeIndex;

	private int guid;

	private bool setted;

	public List<GameObject> selections;

	private void Awake()
	{
		foreach (GameObject selection in selections)
		{
			if (!(selection == null))
			{
				selection.SetActive(value: false);
			}
		}
	}

	private void Update()
	{
		if (!setted && LevelManager.LevelInited)
		{
			Set();
		}
	}

	private void Set()
	{
		if (MultiSceneCore.Instance == null)
		{
			return;
		}
		if (MultiSceneCore.Instance.inLevelData.TryGetValue(guid, out var value))
		{
			activeIndex = (int)value;
		}
		else
		{
			if (UnityEngine.Random.Range(0f, 1f) > activeChance)
			{
				activeIndex = -1;
			}
			else
			{
				activeIndex = UnityEngine.Random.Range(0, selections.Count);
			}
			MultiSceneCore.Instance.inLevelData.Add(guid, activeIndex);
		}
		if (activeIndex >= 0)
		{
			GameObject gameObject = selections[activeIndex];
			if ((bool)gameObject)
			{
				gameObject.SetActive(value: true);
			}
		}
		setted = true;
		base.enabled = false;
	}
}
public class SaveDataBoolProxy : MonoBehaviour
{
	public string key;

	public bool value;

	public void Save()
	{
		SavesSystem.Save(key, value);
		UnityEngine.Debug.Log($"SetSaveData:{key} to {value}");
	}
}
public class SetActiveByChance : MonoBehaviour
{
	public bool saveInLevel;

	private int keyCached;

	[Range(0f, 1f)]
	public float activeChange = 0.5f;

	private void Awake()
	{
		bool flag = UnityEngine.Random.Range(0f, 1f) < activeChange;
		if (saveInLevel && (bool)MultiSceneCore.Instance)
		{
			if (MultiSceneCore.Instance.inLevelData.TryGetValue(keyCached, out var value) && value is bool flag2)
			{
				UnityEngine.Debug.Log($"存在门存档信息：{flag2}");
				flag = flag2;
			}
			MultiSceneCore.Instance.inLevelData[keyCached] = flag;
		}
		base.gameObject.SetActive(flag);
	}

	private int GetKey()
	{
		Vector3 vector = base.transform.position * 10f;
		int x = Mathf.RoundToInt(vector.x);
		int y = Mathf.RoundToInt(vector.y);
		int z = Mathf.RoundToInt(vector.z);
		Vector3Int vector3Int = new Vector3Int(x, y, z);
		return $"Door_{vector3Int}".GetHashCode();
	}
}
public class SetActiveByCondition : MonoBehaviour
{
	public GameObject targetObject;

	public bool inverse;

	public bool requireLevelInited = true;

	public List<Condition> conditions;

	public bool update;

	private float checkTimeSpace = 1f;

	private void Update()
	{
		if (LevelManager.LevelInited || !requireLevelInited)
		{
			Set();
			if (update)
			{
				CheckAndLoop().Forget();
			}
			base.enabled = false;
		}
	}

	public void Set()
	{
		if ((bool)targetObject)
		{
			bool flag = conditions.Satisfied();
			if (inverse)
			{
				flag = !flag;
			}
			targetObject.SetActive(flag);
		}
	}

	private async UniTaskVoid CheckAndLoop()
	{
		await UniTask.WaitForSeconds(checkTimeSpace);
		if (!(this == null))
		{
			Set();
			CheckAndLoop().Forget();
		}
	}
}
public class SetTimeOnEnterBaseFirstTime : MonoBehaviour
{
	public int setTimeTo;

	private void Start()
	{
		if (!SavesSystem.Load<bool>("FirstTimeToBaseTimeSetted"))
		{
			SavesSystem.Save("FirstTimeToBaseTimeSetted", value: true);
			TimeSpan time = new TimeSpan(setTimeTo, 0, 0);
			GameClock.Instance.StepTimeTil(time);
		}
	}
}
public class SimpleTeleporter : InteractableBase
{
	public enum TransitionTypes
	{
		volumeFx,
		blackScreen
	}

	public Transform target;

	[SerializeField]
	private Transform selfTeleportPoint;

	[SerializeField]
	private TransitionTypes transitionType;

	[FormerlySerializedAs("fxTime")]
	public float transitionTime = 0.28f;

	private float delay = 0.3f;

	public Volume teleportVolume;

	private int fxShaderID = Shader.PropertyToID("TeleportFXStrength");

	private bool blackScreen;

	public Transform TeleportPoint
	{
		get
		{
			if (!selfTeleportPoint)
			{
				return base.transform;
			}
			return selfTeleportPoint;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		teleportVolume.gameObject.SetActive(value: false);
	}

	protected override void OnInteractFinished()
	{
		if ((bool)interactCharacter)
		{
			Teleport(interactCharacter).Forget();
		}
	}

	private async UniTask Teleport(CharacterMainControl targetCharacter)
	{
		switch (transitionType)
		{
		case TransitionTypes.volumeFx:
			VolumeFx(show: true, transitionTime).Forget();
			break;
		case TransitionTypes.blackScreen:
			blackScreen = true;
			BlackScreen.ShowAndReturnTask(null, 0f, transitionTime);
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
		await UniTask.WaitForSeconds(transitionTime + delay, ignoreTimeScale: true);
		if (targetCharacter != null)
		{
			targetCharacter.SetPosition(target.position);
			if ((bool)LevelManager.Instance)
			{
				LevelManager.Instance.GameCamera.ForceSyncPos();
			}
		}
		switch (transitionType)
		{
		case TransitionTypes.volumeFx:
			VolumeFx(show: false, transitionTime).Forget();
			break;
		case TransitionTypes.blackScreen:
			BlackScreen.HideAndReturnTask(null, 0f, transitionTime);
			blackScreen = false;
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	private async UniTask VolumeFx(bool show, float time)
	{
		float startTime = Time.time;
		bool end = false;
		teleportVolume.priority = 9999f;
		teleportVolume.gameObject.SetActive(value: true);
		while (!end)
		{
			float num = Time.time - startTime;
			float num2 = Mathf.Clamp01(num / time);
			if (!show)
			{
				num2 = 1f - num2;
			}
			teleportVolume.weight = num2;
			Shader.SetGlobalFloat(fxShaderID, num2);
			if (num > time)
			{
				if (!show)
				{
					teleportVolume.gameObject.SetActive(value: false);
				}
				end = true;
			}
			await UniTask.Yield();
		}
	}
}
[RequireComponent(typeof(Points))]
public class SimpleTeleporterSpawner : MonoBehaviour
{
	private int scene = -1;

	[SerializeField]
	private int pairCount = 3;

	[SerializeField]
	private SimpleTeleporter simpleTeleporterPfb;

	[SerializeField]
	private Points points;

	private void Start()
	{
		if (points == null)
		{
			points = GetComponent<Points>();
			if (points == null)
			{
				return;
			}
		}
		scene = SceneManager.GetActiveScene().buildIndex;
		if (LevelManager.LevelInited)
		{
			StartCreate();
		}
		else
		{
			LevelManager.OnLevelInitialized += StartCreate;
		}
	}

	private void OnValidate()
	{
		if (points == null)
		{
			points = GetComponent<Points>();
		}
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= StartCreate;
	}

	public void StartCreate()
	{
		scene = SceneManager.GetActiveScene().buildIndex;
		int key = GetKey();
		if (!MultiSceneCore.Instance.inLevelData.TryGetValue(key, out var _))
		{
			MultiSceneCore.Instance.inLevelData.Add(key, true);
			Create();
		}
	}

	private void Create()
	{
		List<Vector3> randomPoints = points.GetRandomPoints(pairCount * 2);
		for (int i = 0; i < pairCount; i++)
		{
			CreateAPair(randomPoints[i * 2], randomPoints[i * 2 + 1]);
		}
	}

	private void CreateAPair(Vector3 point1, Vector3 point2)
	{
		SimpleTeleporter simpleTeleporter = CreateATeleporter(point1);
		SimpleTeleporter simpleTeleporter2 = CreateATeleporter(point2);
		simpleTeleporter.target = simpleTeleporter2.TeleportPoint;
		simpleTeleporter2.target = simpleTeleporter.TeleportPoint;
	}

	private SimpleTeleporter CreateATeleporter(Vector3 point)
	{
		SimpleTeleporter simpleTeleporter = UnityEngine.Object.Instantiate(simpleTeleporterPfb);
		MultiSceneCore.MoveToActiveWithScene(simpleTeleporter.gameObject, scene);
		simpleTeleporter.transform.position = point;
		return simpleTeleporter;
	}

	private int GetKey()
	{
		Vector3 vector = base.transform.position * 10f;
		int x = Mathf.RoundToInt(vector.x);
		int y = Mathf.RoundToInt(vector.y);
		int z = Mathf.RoundToInt(vector.z);
		Vector3Int vector3Int = new Vector3Int(x, y, z);
		return $"SimpTeles_{vector3Int}".GetHashCode();
	}
}
public class SoulCollector : MonoBehaviour
{
	public DuckovItemAgent selfAgent;

	private CharacterMainControl selfCharacter;

	[ItemTypeID]
	public int soulCubeID = 1165;

	private Slot cubeSlot;

	public GameObject addFx;

	public SoulCube cubePfb;

	private void Awake()
	{
		Health.OnDead += OnCharacterDie;
	}

	private void OnDestroy()
	{
		Health.OnDead -= OnCharacterDie;
	}

	private void Update()
	{
	}

	private void OnCharacterDie(Health health, DamageInfo dmgInfo)
	{
		if (!health || !health.hasSoul)
		{
			return;
		}
		if (!selfCharacter && (bool)selfAgent.Item)
		{
			selfCharacter = selfAgent.Item.GetCharacterMainControl();
		}
		if ((bool)selfCharacter && !(Vector3.Distance(health.transform.position, selfCharacter.transform.position) > 40f))
		{
			int num = Mathf.RoundToInt(health.MaxHealth / 15f);
			if (num < 1)
			{
				num = 1;
			}
			if (LevelManager.Rule.AdvancedDebuffMode)
			{
				num *= 3;
			}
			SpawnCubes(health.transform.position + Vector3.up * 0.75f, num).Forget();
		}
	}

	private async UniTaskVoid SpawnCubes(Vector3 startPoint, int times)
	{
		if (this == null)
		{
			return;
		}
		for (int i = 0; i < times; i++)
		{
			if (this == null)
			{
				break;
			}
			UnityEngine.Object.Instantiate(cubePfb, startPoint, Quaternion.identity).Init(this);
			await UniTask.WaitForSeconds(0.05f);
		}
	}

	public void AddCube()
	{
		AddCubeAsync().Forget();
	}

	private async UniTaskVoid AddCubeAsync()
	{
		if (cubeSlot == null)
		{
			cubeSlot = selfAgent.Item.Slots["SoulCube"];
		}
		if (cubeSlot == null)
		{
			return;
		}
		if (cubeSlot.Content != null)
		{
			if (cubeSlot.Content.StackCount >= cubeSlot.Content.MaxStackCount)
			{
				return;
			}
			cubeSlot.Content.StackCount++;
		}
		else
		{
			Item otherItem = await ItemAssetsCollection.InstantiateAsync(soulCubeID);
			cubeSlot.Plug(otherItem, out var _);
		}
		UnityEngine.Object.Instantiate(addFx, base.transform, worldPositionStays: false);
	}
}
public class SoulCube : MonoBehaviour
{
	private enum States
	{
		spawn,
		goToTarget
	}

	private States currentState;

	private SoulCollector target;

	private Vector3 direction;

	private float stateTimer;

	public Vector2 speedRange;

	private float spawnSpeed;

	public float spawnTime;

	public float toTargetSpeed;

	public AnimationCurve spawnSpeedCurve;

	private Vector3 velocity;

	public Transform roatePart;

	public Vector2 rotateSpeedRange = new Vector2(300f, 1000f);

	private float rotateSpeed;

	private Vector3 rotateAxis;

	public void Init(SoulCollector collectorTarget)
	{
		target = collectorTarget;
		direction = UnityEngine.Random.insideUnitSphere + Vector3.up;
		direction.Normalize();
		spawnSpeed = UnityEngine.Random.Range(speedRange.x, speedRange.y);
		roatePart.transform.localRotation = Quaternion.Euler(UnityEngine.Random.insideUnitSphere * 360f);
		rotateAxis = UnityEngine.Random.insideUnitSphere;
		rotateSpeed = UnityEngine.Random.Range(rotateSpeedRange.x, rotateSpeedRange.y);
	}

	private void Update()
	{
		roatePart.Rotate(rotateSpeed * rotateAxis * Time.deltaTime);
		if (target == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		stateTimer += Time.deltaTime;
		switch (currentState)
		{
		case States.spawn:
			velocity = spawnSpeed * direction * spawnSpeedCurve.Evaluate(Mathf.Clamp01(stateTimer / spawnTime));
			base.transform.position += velocity * Time.deltaTime;
			if (stateTimer > spawnTime)
			{
				currentState = States.goToTarget;
			}
			break;
		case States.goToTarget:
			base.transform.position = Vector3.MoveTowards(base.transform.position, target.transform.position, toTargetSpeed * Time.deltaTime);
			if (Vector3.Distance(base.transform.position, target.transform.position) < 0.3f)
			{
				AddCube();
			}
			break;
		}
	}

	private void AddCube()
	{
		if ((bool)target)
		{
			target.AddCube();
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class SpaceShipInstaller : MonoBehaviour
{
	[SerializeField]
	private string saveDataKey;

	[SerializeField]
	private int questID;

	[SerializeField]
	private InteractableBase interactable;

	[SerializeField]
	[LocalizationKey("Default")]
	private string notificationKey;

	[SerializeField]
	[LocalizationKey("Default")]
	private string interactKey;

	private bool inited;

	public GameObject builtGraphic;

	public GameObject unbuiltGraphic;

	public GameObject buildFx;

	private bool Installed
	{
		get
		{
			return SavesSystem.Load<bool>(saveDataKey);
		}
		set
		{
			SavesSystem.Save(saveDataKey, value);
		}
	}

	private void Awake()
	{
		if ((bool)buildFx)
		{
			buildFx.SetActive(value: false);
		}
		interactable.overrideInteractName = true;
		interactable._overrideInteractNameKey = interactKey;
	}

	public void Install()
	{
		if ((bool)buildFx)
		{
			buildFx.SetActive(value: true);
		}
		AudioManager.Post("Archived/Building/Default/Constructed", base.gameObject);
		Installed = true;
		SyncGraphic(_installed: true);
		interactable.gameObject.SetActive(value: false);
		NotificationText.Push(notificationKey.ToPlainText());
	}

	private void SyncGraphic(bool _installed)
	{
		if ((bool)builtGraphic)
		{
			builtGraphic.SetActive(_installed);
		}
		if ((bool)unbuiltGraphic)
		{
			unbuiltGraphic.SetActive(!_installed);
		}
	}

	private void Update()
	{
		if (!LevelManager.LevelInited)
		{
			return;
		}
		bool flag = false;
		if (!inited)
		{
			flag = Installed;
			if (flag)
			{
				TaskEvent.EmitTaskEvent(saveDataKey);
			}
			else if (QuestManager.IsQuestFinished(questID))
			{
				flag = true;
				Installed = true;
			}
			interactable.gameObject.SetActive(!flag && QuestManager.IsQuestActive(questID));
			SyncGraphic(flag);
			inited = true;
		}
		if (!Installed && !interactable.gameObject.activeSelf && QuestManager.IsQuestActive(questID))
		{
			interactable.gameObject.SetActive(value: true);
		}
	}
}
public class TeleportBeacon : MonoBehaviour
{
	[SceneID]
	public string beaconScene;

	public int beaconIndex;

	public GameObject activeByUnlocked;

	public InteractableBase interactable;

	private void Start()
	{
		bool beaconUnlocked = BeaconManager.GetBeaconUnlocked(beaconScene, beaconIndex);
		activeByUnlocked.SetActive(beaconUnlocked);
		interactable.gameObject.SetActive(!beaconUnlocked);
	}

	public void ActivateBeacon()
	{
		BeaconManager.UnlockBeacon(beaconScene, beaconIndex);
		activeByUnlocked.SetActive(value: true);
		interactable.gameObject.SetActive(value: false);
	}
}
public class WishListProxy : MonoBehaviour
{
	private void Start()
	{
	}

	public void ShowStorePage()
	{
		AddToWishListButton.ShowPage();
	}
}
[RequireComponent(typeof(Rigidbody))]
public class Zone : MonoBehaviour
{
	public bool onlyPlayerTeam;

	private HashSet<Health> healths;

	public bool setActiveByDistance = true;

	private Rigidbody rb;

	private int sceneBuildIndex = -1;

	public HashSet<Health> Healths => healths;

	private void Awake()
	{
		rb = GetComponent<Rigidbody>();
		healths = new HashSet<Health>();
		rb.isKinematic = true;
		rb.useGravity = false;
		sceneBuildIndex = SceneManager.GetActiveScene().buildIndex;
		if (setActiveByDistance)
		{
			SetActiveByPlayerDistance.Register(base.gameObject, sceneBuildIndex);
		}
	}

	private void OnDestroy()
	{
		if (setActiveByDistance)
		{
			SetActiveByPlayerDistance.Unregister(base.gameObject, sceneBuildIndex);
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (LevelManager.LevelInited && other.gameObject.layer == LayerMask.NameToLayer("Character"))
		{
			Health component = other.GetComponent<Health>();
			if (!(component == null) && (!onlyPlayerTeam || component.team == Teams.player) && !healths.Contains(component))
			{
				healths.Add(component);
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (other.gameObject.layer == LayerMask.NameToLayer("Character"))
		{
			Health component = other.GetComponent<Health>();
			if (!(component == null) && (!onlyPlayerTeam || component.team == Teams.player) && healths.Contains(component))
			{
				healths.Remove(component);
			}
		}
	}

	private void OnDisable()
	{
		healths.Clear();
	}
}
[RequireComponent(typeof(Zone))]
public class ZoneDamage : MonoBehaviour
{
	public Zone zone;

	public float timeSpace = 0.5f;

	private float timer;

	public DamageInfo damageInfo;

	public bool checkGasMask;

	public bool checkElecProtection;

	public bool checkFireProtection;

	private int hasMaskHash = "GasMask".GetHashCode();

	private int elecProtectionHash = "ElecProtection".GetHashCode();

	private int fireProtectionHash = "FireProtection".GetHashCode();

	private void Start()
	{
		if (zone == null)
		{
			zone = GetComponent<Zone>();
		}
	}

	private void Update()
	{
		if (LevelManager.LevelInited)
		{
			timer += Time.deltaTime;
			if (timer > timeSpace)
			{
				timer %= timeSpace;
				Damage();
			}
		}
	}

	private void Damage()
	{
		foreach (Health health in zone.Healths)
		{
			CharacterMainControl characterMainControl = health.TryGetCharacter();
			if (characterMainControl == null)
			{
				continue;
			}
			if (checkGasMask && characterMainControl.HasGasMask)
			{
				Item faceMaskItem = characterMainControl.GetFaceMaskItem();
				if ((bool)faceMaskItem && faceMaskItem.GetStat(hasMaskHash) != null)
				{
					faceMaskItem.Durability -= 0.1f * timeSpace;
				}
			}
			else if ((!checkElecProtection || !(characterMainControl.CharacterItem.GetStat(elecProtectionHash).Value > 0.99f)) && (!checkFireProtection || !(characterMainControl.CharacterItem.GetStat(fireProtectionHash).Value > 0.99f)))
			{
				damageInfo.fromCharacter = null;
				damageInfo.damagePoint = health.transform.position + Vector3.up * 0.5f;
				damageInfo.damageNormal = Vector3.up;
				health.Hurt(damageInfo);
			}
		}
	}
}
public class BulletCountHUD : MonoBehaviour
{
	private ItemAgent_Gun gunAgent;

	private CharacterMainControl characterMainControl;

	private ItemAgent_Gun gunAgnet;

	public UnityEngine.CanvasGroup canvasGroup;

	public TextMeshProUGUI bulletCountText;

	public TextMeshProUGUI capacityText;

	public ProceduralImage background;

	public Color normalBackgroundColor;

	public Color emptyBackgroundColor;

	private int bulletCount = -1;

	private int totalCount = -1;

	public UnityEvent OnValueChangeEvent;

	private void Awake()
	{
	}

	public void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if ((bool)characterMainControl)
			{
				characterMainControl.OnHoldAgentChanged += OnHoldAgentChanged;
				characterMainControl.CharacterItem.Inventory.onContentChanged += OnInventoryChanged;
				if (characterMainControl.CurrentHoldItemAgent != null)
				{
					OnHoldAgentChanged(characterMainControl.CurrentHoldItemAgent);
				}
				ChangeTotalCount();
				capacityText.text = totalCount.ToString("D2");
			}
		}
		if (gunAgnet == null)
		{
			canvasGroup.alpha = 0f;
			return;
		}
		bool flag = false;
		canvasGroup.alpha = 1f;
		int num = gunAgnet.BulletCount;
		if (bulletCount != num)
		{
			bulletCount = num;
			bulletCountText.text = num.ToString("D2");
			flag = true;
		}
		if (flag)
		{
			OnValueChangeEvent?.Invoke();
			if (bulletCount <= 0 && (totalCount <= 0 || !capacityText.gameObject.activeInHierarchy))
			{
				background.color = emptyBackgroundColor;
			}
			else
			{
				background.color = normalBackgroundColor;
			}
		}
	}

	private void OnInventoryChanged(Inventory inventory, int index)
	{
		ChangeTotalCount();
	}

	private void ChangeTotalCount()
	{
		int num = 0;
		if ((bool)gunAgnet)
		{
			num = gunAgnet.GetBulletCountInInventory();
		}
		if (totalCount != num)
		{
			totalCount = num;
			capacityText.text = totalCount.ToString("D2");
		}
	}

	private void OnDestroy()
	{
		if ((bool)characterMainControl)
		{
			characterMainControl.OnHoldAgentChanged -= OnHoldAgentChanged;
			characterMainControl.CharacterItem.Inventory.onContentChanged -= OnInventoryChanged;
		}
	}

	private void OnHoldAgentChanged(DuckovItemAgent newAgent)
	{
		if (newAgent == null)
		{
			gunAgnet = null;
		}
		gunAgnet = newAgent as ItemAgent_Gun;
		ChangeTotalCount();
	}
}
public class BulletTypeHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	private ItemAgent_Gun gunAgent;

	[SerializeField]
	private UnityEngine.CanvasGroup canvasGroup;

	[SerializeField]
	private TextMeshProUGUI bulletTypeText;

	[SerializeField]
	private ProceduralImage background;

	[SerializeField]
	private Color normalColor;

	[SerializeField]
	private Color emptyColor;

	private int bulletTpyeID = -2;

	[SerializeField]
	private GameObject typeList;

	public UnityEvent OnTypeChangeEvent;

	public GameObject indicator;

	private int selectIndex;

	private int totalSelctionCount;

	[SerializeField]
	private BulletTypeSelectButton originSelectButton;

	private List<BulletTypeSelectButton> selectionsHUD;

	private PrefabPool<BulletTypeSelectButton> _selectionsCache;

	private bool listOpen;

	private PrefabPool<BulletTypeSelectButton> Selections
	{
		get
		{
			if (_selectionsCache == null)
			{
				_selectionsCache = new PrefabPool<BulletTypeSelectButton>(originSelectButton);
			}
			return _selectionsCache;
		}
	}

	private bool CanOpenList
	{
		get
		{
			if (!characterMainControl)
			{
				return false;
			}
			if ((bool)characterMainControl.CurrentAction && characterMainControl.CurrentAction.Running)
			{
				return false;
			}
			if (!InputManager.InputActived)
			{
				return false;
			}
			return true;
		}
	}

	private void Awake()
	{
		selectionsHUD = new List<BulletTypeSelectButton>();
		originSelectButton.gameObject.SetActive(value: false);
		WeaponButton.OnWeaponButtonSelected += OnWeaponButtonSelected;
		typeList.SetActive(value: false);
		InputManager.OnSwitchBulletTypeInput += OnSwitchInput;
	}

	private void OnDestroy()
	{
		WeaponButton.OnWeaponButtonSelected -= OnWeaponButtonSelected;
		if ((bool)characterMainControl)
		{
			characterMainControl.OnHoldAgentChanged -= OnHoldAgentChanged;
		}
		InputManager.OnSwitchBulletTypeInput -= OnSwitchInput;
	}

	private void OnWeaponButtonSelected(WeaponButton button)
	{
		RectTransform obj = canvasGroup.transform as RectTransform;
		RectTransform rectTransform = button.transform as RectTransform;
		obj.position = (Vector2)rectTransform.position + (rectTransform.rect.center + (Vector2)((rectTransform.rect.height / 2f + 8f) * rectTransform.up)) * rectTransform.lossyScale;
	}

	public void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if ((bool)characterMainControl)
			{
				characterMainControl.OnHoldAgentChanged += OnHoldAgentChanged;
				if (characterMainControl.CurrentHoldItemAgent != null)
				{
					OnHoldAgentChanged(characterMainControl.CurrentHoldItemAgent);
				}
			}
		}
		if (gunAgent == null)
		{
			canvasGroup.alpha = 0f;
			canvasGroup.interactable = false;
			return;
		}
		canvasGroup.alpha = 1f;
		canvasGroup.interactable = true;
		if (bulletTypeText != null && gunAgent.GunItemSetting != null)
		{
			int targetBulletID = gunAgent.GunItemSetting.TargetBulletID;
			if (bulletTpyeID != targetBulletID)
			{
				bulletTpyeID = targetBulletID;
				if (bulletTpyeID >= 0)
				{
					bulletTypeText.text = gunAgent.GunItemSetting.CurrentBulletName;
					bulletTypeText.color = Color.black;
					background.color = normalColor;
				}
				else
				{
					bulletTypeText.text = "UI_Bullet_NotAssigned".ToPlainText();
					bulletTypeText.color = Color.white;
					background.color = emptyColor;
				}
				OnTypeChangeEvent?.Invoke();
			}
		}
		if (listOpen && !CanOpenList)
		{
			CloseList();
		}
		if (!CharacterInputControl.GetChangeBulletTypeWasPressed())
		{
			return;
		}
		if (!listOpen)
		{
			OpenList();
			return;
		}
		if (selectIndex < selectionsHUD.Count && selectionsHUD[selectIndex] != null)
		{
			SetBulletType(selectionsHUD[selectIndex].BulletTypeID);
		}
		CloseList();
	}

	private void OnHoldAgentChanged(DuckovItemAgent newAgent)
	{
		if (newAgent == null)
		{
			gunAgent = null;
		}
		gunAgent = newAgent as ItemAgent_Gun;
		CloseList();
	}

	private void OnSwitchInput(int dir)
	{
		if (listOpen)
		{
			selectIndex -= dir;
			if (totalSelctionCount == 0)
			{
				selectIndex = 0;
			}
			else if (selectIndex >= totalSelctionCount)
			{
				selectIndex = 0;
			}
			else if (selectIndex < 0)
			{
				selectIndex = totalSelctionCount - 1;
			}
			for (int i = 0; i < selectionsHUD.Count; i++)
			{
				selectionsHUD[i].SetSelection(i == selectIndex);
			}
		}
	}

	private void OpenList()
	{
		UnityEngine.Debug.Log("OpenList");
		if (CanOpenList && !listOpen)
		{
			typeList.SetActive(value: true);
			listOpen = true;
			indicator.SetActive(value: false);
			RefreshContent();
		}
	}

	public void CloseList()
	{
		if (listOpen)
		{
			typeList.SetActive(value: false);
			listOpen = false;
			indicator.SetActive(value: true);
		}
	}

	private void RefreshContent()
	{
		selectionsHUD.Clear();
		Selections.ReleaseAll();
		Dictionary<int, BulletTypeInfo> dictionary = new Dictionary<int, BulletTypeInfo>();
		ItemSetting_Gun gunItemSetting = gunAgent.GunItemSetting;
		if (gunItemSetting != null)
		{
			dictionary = gunItemSetting.GetBulletTypesInInventory(characterMainControl.CharacterItem.Inventory);
		}
		if (bulletTpyeID > 0 && !dictionary.ContainsKey(bulletTpyeID))
		{
			BulletTypeInfo bulletTypeInfo = new BulletTypeInfo();
			bulletTypeInfo.bulletTypeID = bulletTpyeID;
			bulletTypeInfo.count = 0;
			dictionary.Add(bulletTpyeID, bulletTypeInfo);
		}
		if (dictionary.Count <= 0)
		{
			BulletTypeInfo bulletTypeInfo2 = new BulletTypeInfo();
			bulletTypeInfo2.bulletTypeID = -1;
			bulletTypeInfo2.count = 0;
			dictionary.Add(-1, bulletTypeInfo2);
		}
		totalSelctionCount = dictionary.Count;
		int num = 0;
		selectIndex = 0;
		foreach (KeyValuePair<int, BulletTypeInfo> item in dictionary)
		{
			BulletTypeSelectButton bulletTypeSelectButton = Selections.Get(typeList.transform);
			bulletTypeSelectButton.gameObject.SetActive(value: true);
			bulletTypeSelectButton.transform.SetAsLastSibling();
			bulletTypeSelectButton.Init(item.Value.bulletTypeID, item.Value.count);
			if (bulletTpyeID == item.Value.bulletTypeID)
			{
				bulletTypeSelectButton.SetSelection(selected: true);
				selectIndex = num;
			}
			selectionsHUD.Add(bulletTypeSelectButton);
			UnityEngine.Debug.Log($"BUlletType {selectIndex}:{item.Value.bulletTypeID}");
			num++;
		}
	}

	public void SetBulletType(int typeID)
	{
		CloseList();
		if ((bool)gunAgent && (bool)gunAgent.GunItemSetting)
		{
			bool num = gunAgent.GunItemSetting.TargetBulletID != typeID;
			gunAgent.GunItemSetting.SetTargetBulletType(typeID);
			if (num)
			{
				characterMainControl.TryToReload();
			}
		}
	}
}
public class BulletTypeSelectButton : MonoBehaviour
{
	private int bulletTypeID;

	private int bulletCount;

	public BulletTypeHUD bulletTypeHUD;

	public TextMeshProUGUI nameText;

	public TextMeshProUGUI countText;

	public TrueShadow selectShadow;

	public GameObject indicator;

	public int BulletTypeID => bulletTypeID;

	public void SetSelection(bool selected)
	{
		selectShadow.enabled = selected;
		indicator.SetActive(selected);
	}

	public void Init(int id, int count)
	{
		bulletTypeID = id;
		bulletCount = count;
		SetSelection(selected: false);
		RefreshContent();
	}

	public void RefreshContent()
	{
		nameText.text = GetBulletName(bulletTypeID);
		countText.text = bulletCount.ToString();
	}

	public string GetBulletName(int id)
	{
		if (id > 0)
		{
			return ItemAssetsCollection.GetMetaData(id).DisplayName;
		}
		return "UI_Bullet_NotAssigned".ToPlainText();
	}
}
public class EnergyHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	private float percent = -1f;

	public ProceduralImage fillImage;

	public ProceduralImage backgroundImage;

	public Color backgroundColor;

	public Color emptyBackgroundColor;

	private Item item => characterMainControl.CharacterItem;

	private void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if (!characterMainControl)
			{
				return;
			}
		}
		float a = characterMainControl.CurrentEnergy / characterMainControl.MaxEnergy;
		if (!Mathf.Approximately(a, percent))
		{
			percent = a;
			fillImage.fillAmount = percent;
			if (percent <= 0f)
			{
				backgroundImage.color = emptyBackgroundColor;
			}
			else
			{
				backgroundImage.color = backgroundColor;
			}
		}
	}
}
public class HealthHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	private float percent = -1f;

	private float maxHealth;

	private float currenthealth;

	public ProceduralImage fillImage;

	public ProceduralImage backgroundImage;

	public Color backgroundColor;

	public Color emptyBackgroundColor;

	public TextMeshProUGUI text;

	private Item item => characterMainControl.CharacterItem;

	private void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if (!characterMainControl)
			{
				return;
			}
		}
		float num = characterMainControl.Health.MaxHealth;
		float currentHealth = characterMainControl.Health.CurrentHealth;
		float a = currentHealth / num;
		if (!Mathf.Approximately(a, percent))
		{
			percent = a;
			fillImage.fillAmount = percent;
			if (percent <= 0f)
			{
				backgroundImage.color = emptyBackgroundColor;
			}
			else
			{
				backgroundImage.color = backgroundColor;
			}
		}
		if (num != maxHealth || currentHealth != currenthealth)
		{
			maxHealth = num;
			currenthealth = currentHealth;
			text.text = currenthealth.ToString("0.#") + " / " + maxHealth.ToString("0.#");
		}
	}
}
public class IndicatorHUD : MonoBehaviour
{
	public GameObject mapIndicator;

	public GameObject toggleParent;

	public bool startActive;

	private void Start()
	{
		if ((LevelManager.Instance == null || LevelManager.Instance.IsBaseLevel) && (bool)mapIndicator)
		{
			mapIndicator.SetActive(value: false);
		}
		toggleParent.SetActive(startActive);
	}

	private void Awake()
	{
		UIInputManager.OnToggleIndicatorHUD += Toggle;
	}

	private void OnDestroy()
	{
		UIInputManager.OnToggleIndicatorHUD -= Toggle;
	}

	private void Toggle(UIInputEventData data)
	{
		if (base.gameObject.activeInHierarchy)
		{
			toggleParent.SetActive(!toggleParent.activeInHierarchy);
		}
	}
}
public class StaminaHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	private float percent;

	public UnityEngine.CanvasGroup canvasGroup;

	private float targetAlpha;

	public ProceduralImage fillImage;

	public Gradient glowColor;

	private Item item => characterMainControl.CharacterItem;

	private void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if (!characterMainControl)
			{
				return;
			}
		}
		float a = characterMainControl.CurrentStamina / characterMainControl.MaxStamina;
		if (!Mathf.Approximately(a, percent))
		{
			percent = a;
			fillImage.fillAmount = percent;
			SetColor();
			if (Mathf.Approximately(a, 1f))
			{
				targetAlpha = 0f;
			}
			else
			{
				targetAlpha = 1f;
			}
		}
		UpdateAlpha(Time.unscaledDeltaTime);
	}

	private void SetColor()
	{
		Color.RGBToHSV(glowColor.Evaluate(percent), out var H, out var S, out var V);
		S = 0.4f;
		V = 1f;
		Color color = Color.HSVToRGB(H, S, V);
		fillImage.color = color;
	}

	private void UpdateAlpha(float deltaTime)
	{
		if (targetAlpha != canvasGroup.alpha)
		{
			canvasGroup.alpha = Mathf.MoveTowards(canvasGroup.alpha, targetAlpha, 5f * deltaTime);
		}
	}
}
public class WaterHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	private float percent = -1f;

	public ProceduralImage fillImage;

	public ProceduralImage backgroundImage;

	public Color backgroundColor;

	public Color emptyBackgroundColor;

	private Item item => characterMainControl.CharacterItem;

	private void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if (!characterMainControl)
			{
				return;
			}
		}
		float a = characterMainControl.CurrentWater / characterMainControl.MaxWater;
		if (!Mathf.Approximately(a, percent))
		{
			percent = a;
			fillImage.fillAmount = percent;
			if (percent <= 0f)
			{
				backgroundImage.color = emptyBackgroundColor;
			}
			else
			{
				backgroundImage.color = backgroundColor;
			}
		}
	}
}
public enum ResModes
{
	Source,
	HalfRes,
	R720p,
	R480p
}
public enum TextureModes
{
	High,
	Middle,
	Low,
	VeryLow
}
public class InteractHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	public RectTransform master;

	private InteractableBase interactableMaster;

	private InteractableBase interactableMasterTemp;

	private List<InteractableBase> interactableGroup;

	private List<InteractSelectionHUD> selectionsHUD;

	private int interactableIndexTemp;

	private bool interactable;

	private Camera camera;

	public bool syncPosToTarget;

	public InteractSelectionHUD selectionPrefab;

	private int interactableHash = Shader.PropertyToID("Interactable");

	private PrefabPool<InteractSelectionHUD> _selectionsCache;

	private PrefabPool<InteractSelectionHUD> Selections
	{
		get
		{
			if (_selectionsCache == null)
			{
				_selectionsCache = new PrefabPool<InteractSelectionHUD>(selectionPrefab);
			}
			return _selectionsCache;
		}
	}

	private void Awake()
	{
		interactableGroup = new List<InteractableBase>();
		selectionsHUD = new List<InteractSelectionHUD>();
		selectionPrefab.gameObject.SetActive(value: false);
		master.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (characterMainControl == null)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if (characterMainControl == null)
			{
				return;
			}
		}
		if (camera == null)
		{
			camera = Camera.main;
			if (camera == null)
			{
				return;
			}
		}
		bool flag = false;
		bool flag2 = false;
		interactableMaster = characterMainControl.interactAction.MasterInteractableAround;
		bool flag3 = InputManager.InputActived && (!characterMainControl.CurrentAction || !characterMainControl.CurrentAction.Running);
		Shader.SetGlobalFloat(interactableHash, flag3 ? 1f : 0f);
		interactable = interactableMaster != null && flag3;
		if (interactable)
		{
			if (interactableMaster != interactableMasterTemp)
			{
				interactableMasterTemp = interactableMaster;
				flag = true;
				flag2 = true;
			}
			if (interactableIndexTemp != characterMainControl.interactAction.InteractIndexInGroup)
			{
				interactableIndexTemp = characterMainControl.interactAction.InteractIndexInGroup;
				flag2 = true;
			}
		}
		else
		{
			interactableMasterTemp = null;
		}
		if (interactable != master.gameObject.activeInHierarchy)
		{
			master.gameObject.SetActive(interactable);
		}
		if (flag)
		{
			RefreshContent();
			SyncPos();
		}
		if (flag2)
		{
			RefreshSelection();
		}
	}

	private void LateUpdate()
	{
		if (!(characterMainControl == null) && !(camera == null))
		{
			SyncPos();
			UpdateInteractLine();
		}
	}

	private void SyncPos()
	{
		if (syncPosToTarget && (bool)interactableMaster)
		{
			Vector3 position = interactableMaster.transform.TransformPoint(interactableMaster.interactMarkerOffset);
			Vector3 vector = LevelManager.Instance.GameCamera.renderCamera.WorldToScreenPoint(position);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(base.transform.parent as RectTransform, vector, null, out var localPoint);
			base.transform.localPosition = localPoint;
		}
	}

	private void RefreshContent()
	{
		if (interactableMaster == null)
		{
			return;
		}
		selectionsHUD.Clear();
		interactableGroup.Clear();
		foreach (InteractableBase interactable in interactableMaster.GetInteractableList())
		{
			if (interactable != null)
			{
				interactableGroup.Add(interactable);
			}
		}
		Selections.ReleaseAll();
		foreach (InteractableBase item in interactableGroup)
		{
			InteractSelectionHUD interactSelectionHUD = Selections.Get();
			interactSelectionHUD.transform.SetAsLastSibling();
			interactSelectionHUD.SetInteractable(item, interactableGroup.Count > 1);
			selectionsHUD.Add(interactSelectionHUD);
		}
		master.ForceUpdateRectTransforms();
	}

	private void RefreshSelection()
	{
		InteractableBase interactTarget = characterMainControl.interactAction.InteractTarget;
		foreach (InteractSelectionHUD item in selectionsHUD)
		{
			if (item.InteractTarget == interactTarget)
			{
				item.SetSelection(_select: true);
			}
			else
			{
				item.SetSelection(_select: false);
			}
		}
		master.ForceUpdateRectTransforms();
	}

	private void UpdateInteractLine()
	{
	}
}
public class InteractSelectionHUD : MonoBehaviour
{
	private InteractableBase interactable;

	public GameObject selectIndicator;

	public TextMeshProUGUI text;

	public ProceduralImage background;

	public Color selectedColor;

	public Color unselectedColor;

	public UnityEngine.CanvasGroup requireCanvasGroup;

	public ProceduralImage requireItemBackgroundImage;

	public TextMeshProUGUI requireText;

	[LocalizationKey("UI")]
	public string requirItemTextKey = "UI_RequireItem";

	[LocalizationKey("UI")]
	public string requirUseItemTextKey = "UI_RequireUseItem";

	public UnityEngine.UI.Image requirementIcon;

	public Color hasRequireItemColor;

	public Color noRequireItemColor;

	private bool selecting;

	public UnityEvent OnSelectedEvent;

	public GameObject selectionPoint;

	public GameObject upDownIndicator;

	private bool hasUpDown;

	public InteractableBase InteractTarget => interactable;

	public void SetInteractable(InteractableBase _interactable, bool _hasUpDown)
	{
		interactable = _interactable;
		text.text = interactable.GetInteractName();
		UpdateRequireItem(interactable);
		selectionPoint.SetActive(_hasUpDown);
		hasUpDown = _hasUpDown;
	}

	private void UpdateRequireItem(InteractableBase interactable)
	{
		if ((bool)interactable && interactable.requireItem)
		{
			requireCanvasGroup.alpha = 1f;
			CharacterMainControl mainCharacter = LevelManager.Instance.MainCharacter;
			bool num = interactable.whenToUseRequireItem != InteractableBase.WhenToUseRequireItemTypes.None;
			string text = (num ? requirUseItemTextKey.ToPlainText() : requirItemTextKey.ToPlainText());
			requireText.text = text + " " + interactable.GetRequiredItemName();
			if (num)
			{
				requireText.text += " x1";
			}
			requirementIcon.sprite = interactable.GetRequireditemIcon();
			if (interactable.TryGetRequiredItem(mainCharacter).hasItem)
			{
				requireItemBackgroundImage.color = hasRequireItemColor;
			}
			else
			{
				requireItemBackgroundImage.color = noRequireItemColor;
			}
		}
		else
		{
			requireCanvasGroup.alpha = 0f;
		}
	}

	public void SetSelection(bool _select)
	{
		selecting = _select;
		selectIndicator.SetActive(selecting);
		upDownIndicator.SetActive(selecting && hasUpDown);
		selectionPoint.SetActive(!selecting && hasUpDown);
		if (_select)
		{
			OnSelectedEvent?.Invoke();
			background.color = selectedColor;
		}
		else
		{
			background.color = unselectedColor;
		}
	}
}
public class EvacuationCountdownUI : MonoBehaviour
{
	private static EvacuationCountdownUI _instance;

	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private UnityEngine.UI.Image progressFill;

	[SerializeField]
	private TextMeshProUGUI countdownDigit;

	[SerializeField]
	private string digitFormat = "{0:00}:{1:00}<sub>.{2:000}</sub>";

	private CountDownArea target;

	public static EvacuationCountdownUI Instance => _instance;

	private void Awake()
	{
		if (_instance == null)
		{
			_instance = this;
		}
		if (_instance != this)
		{
			UnityEngine.Debug.LogWarning("Multiple Evacuation Countdown UI detected");
		}
	}

	private string ToDigitString(float number)
	{
		int num = (int)number;
		int num2 = Mathf.Min(999, Mathf.RoundToInt((number - (float)num) * 1000f));
		int num3 = num / 60;
		num -= num3 * 60;
		return string.Format(digitFormat, num3, num, num2);
	}

	private void Update()
	{
		if (target == null && fadeGroup.IsShown)
		{
			Hide().Forget();
		}
		Refresh();
	}

	private void Refresh()
	{
		if (!(target == null))
		{
			progressFill.fillAmount = target.Progress;
			countdownDigit.text = ToDigitString(target.RemainingTime);
		}
	}

	private async UniTask Hide()
	{
		target = null;
		await fadeGroup.HideAndReturnTask();
	}

	private async UniTask Show(CountDownArea target)
	{
		this.target = target;
		if (!(this.target == null))
		{
			await fadeGroup.ShowAndReturnTask();
		}
	}

	public static void Request(CountDownArea target)
	{
		if (!(Instance == null))
		{
			Instance.Show(target).Forget();
		}
	}

	public static void Release(CountDownArea target)
	{
		if (!(Instance == null) && Instance.target == target)
		{
			Instance.Hide().Forget();
		}
	}
}
public class NotificationProxy : MonoBehaviour
{
	[LocalizationKey("Default")]
	public string notification;

	public void Notify()
	{
		NotificationText.Push(notification.ToPlainText());
	}
}
public class ActionProgressHUD : MonoBehaviour
{
	public CharacterActionBase.ActionPriorities specificActionType;

	public ProceduralImage fillImage;

	public UnityEngine.CanvasGroup parentCanvasGroup;

	private CharacterMainControl characterMainControl;

	private IProgress currentProgressInterface;

	private float targetAlpha;

	private bool inProgress;

	public UnityEvent OnFinishEvent;

	[FormerlySerializedAs("cancleIndicator")]
	public GameObject stopIndicator;

	public bool InProgress => inProgress;

	public void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if ((bool)characterMainControl)
			{
				characterMainControl.OnActionStartEvent += OnActionStart;
				characterMainControl.OnActionProgressFinishEvent += OnActionFinish;
			}
		}
		inProgress = false;
		float num = 0f;
		if (currentProgressInterface as UnityEngine.Object != null)
		{
			Duckov.Progress progress = currentProgressInterface.GetProgress();
			inProgress = progress.inProgress;
			num = progress.progress;
			if (!inProgress)
			{
				currentProgressInterface = null;
			}
		}
		if (inProgress)
		{
			targetAlpha = 1f;
			fillImage.fillAmount = num;
			if (num >= 1f)
			{
				targetAlpha = 0f;
			}
		}
		else
		{
			targetAlpha = 0f;
		}
		parentCanvasGroup.alpha = Mathf.MoveTowards(parentCanvasGroup.alpha, targetAlpha, 8f * Time.deltaTime);
		if ((bool)stopIndicator && (bool)characterMainControl)
		{
			bool flag = false;
			CharacterActionBase currentAction = characterMainControl.CurrentAction;
			if ((bool)currentAction && currentAction.Running && currentAction.IsStopable())
			{
				flag = true;
			}
			if (flag != stopIndicator.activeSelf && targetAlpha != 0f)
			{
				stopIndicator.SetActive(flag);
			}
		}
	}

	private void OnDestroy()
	{
		if ((bool)characterMainControl)
		{
			characterMainControl.OnActionStartEvent -= OnActionStart;
			characterMainControl.OnActionProgressFinishEvent -= OnActionFinish;
		}
	}

	private void OnActionStart(CharacterActionBase action)
	{
		currentProgressInterface = action as IProgress;
		if (specificActionType != CharacterActionBase.ActionPriorities.Whatever && action.ActionPriority() != specificActionType)
		{
			currentProgressInterface = null;
		}
		if ((bool)action && !action.progressHUD)
		{
			currentProgressInterface = null;
		}
	}

	private void OnActionFinish(CharacterActionBase action)
	{
		OnFinishEvent?.Invoke();
		if ((bool)fillImage)
		{
			fillImage.fillAmount = 1f;
		}
	}
}
public class FollowCharacterHUD : MonoBehaviour
{
	public float maxDistance = 2f;

	public float smoothTime;

	private Vector3 worldPos;

	private Vector3 velocityTemp;

	public Vector3 offset;

	private void Awake()
	{
		GameCamera.OnCameraPosUpdate = (Action<GameCamera, CharacterMainControl>)Delegate.Combine(GameCamera.OnCameraPosUpdate, new Action<GameCamera, CharacterMainControl>(UpdatePos));
	}

	private void OnDestroy()
	{
		GameCamera.OnCameraPosUpdate = (Action<GameCamera, CharacterMainControl>)Delegate.Remove(GameCamera.OnCameraPosUpdate, new Action<GameCamera, CharacterMainControl>(UpdatePos));
	}

	private void UpdatePos(GameCamera gameCamera, CharacterMainControl target)
	{
		Camera renderCamera = gameCamera.renderCamera;
		Vector3 vector = target.transform.position + offset;
		worldPos = Vector3.SmoothDamp(worldPos, vector, ref velocityTemp, smoothTime);
		if (Vector3.Distance(worldPos, vector) > maxDistance)
		{
			worldPos = (worldPos - vector).normalized * maxDistance + vector;
		}
		Vector3 position = renderCamera.WorldToScreenPoint(worldPos);
		base.transform.position = position;
		if (target.gameObject.activeInHierarchy != base.gameObject.activeInHierarchy)
		{
			base.gameObject.SetActive(target.gameObject.activeInHierarchy);
		}
	}
}
public class LittleMoveHUD : MonoBehaviour
{
	private Camera camera;

	private CharacterMainControl character;

	public float maxDistance = 2f;

	public float smoothTime;

	private Vector3 worldPos;

	private Vector3 velocityTemp;

	public Vector3 offset;

	private void LateUpdate()
	{
		if (!character)
		{
			if ((bool)LevelManager.Instance)
			{
				character = LevelManager.Instance.MainCharacter;
			}
			if (!character)
			{
				return;
			}
		}
		if (!camera)
		{
			camera = Camera.main;
			if (!camera)
			{
				return;
			}
		}
		Vector3 vector = character.transform.position + offset;
		worldPos = Vector3.SmoothDamp(worldPos, vector, ref velocityTemp, smoothTime);
		if (Vector3.Distance(worldPos, vector) > maxDistance)
		{
			worldPos = (worldPos - vector).normalized * maxDistance + vector;
		}
		Vector3 position = camera.WorldToScreenPoint(worldPos);
		base.transform.position = position;
	}
}
public class ReloadHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	public UnityEngine.UI.Button button;

	private bool reloadable;

	public UnityEvent OnShowEvent;

	public UnityEvent OnHideEvent;

	private int frame;

	private void Update()
	{
		if (characterMainControl == null)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if (characterMainControl == null)
			{
				return;
			}
			button.onClick.AddListener(Reload);
		}
		reloadable = characterMainControl.GetGunReloadable();
		if (reloadable != button.interactable)
		{
			button.interactable = reloadable;
			if (reloadable)
			{
				OnShowEvent?.Invoke();
			}
			else
			{
				OnHideEvent?.Invoke();
			}
		}
		frame++;
	}

	private void OnDestroy()
	{
		button.onClick.RemoveAllListeners();
	}

	private void Reload()
	{
		if ((bool)characterMainControl)
		{
			characterMainControl.TryToReload();
		}
	}
}
[ExecuteAlways]
public class ShapesSkillLine : MonoBehaviour
{
	public Vector3[] points;

	public Color[] colors;

	public Vector3 hitPoint;

	public bool hitObsticle;

	public ShapesBlendMode blendMode;

	public bool worldSpace;

	public float dotRadius = 0.02f;

	public float lineThickness = 0.02f;

	private Camera cam;

	private void Awake()
	{
	}

	public void DrawLine()
	{
		if (!cam)
		{
			if ((bool)LevelManager.Instance)
			{
				cam = LevelManager.Instance.GameCamera.renderCamera;
			}
			if (!cam)
			{
				return;
			}
		}
		if (points.Length == 0)
		{
			return;
		}
		using (Shapes.Draw.Command(cam))
		{
			Shapes.Draw.LineGeometry = LineGeometry.Billboard;
			Shapes.Draw.BlendMode = blendMode;
			Shapes.Draw.ThicknessSpace = ThicknessSpace.Meters;
			Shapes.Draw.Thickness = lineThickness;
			Shapes.Draw.ZTest = CompareFunction.Always;
			if (!worldSpace)
			{
				Shapes.Draw.Matrix = base.transform.localToWorldMatrix;
			}
			for (int i = 0; i < points.Length - 1; i++)
			{
				Shapes.Draw.Sphere(points[i], dotRadius, colors[i]);
				Shapes.Draw.Line(points[i], points[i + 1], colors[i]);
			}
			Shapes.Draw.Sphere(points[points.Length - 1], dotRadius, colors[colors.Length - 1]);
			if (hitObsticle)
			{
				Shapes.Draw.Sphere(hitPoint, dotRadius, colors[0]);
			}
		}
	}
}
public class SkillHud3D : MonoBehaviour
{
	private CharacterMainControl character;

	private bool aiming;

	public SkillRangeHUD skillRangeHUD;

	public SkillProjectileLineHUD projectileLine;

	private SkillBase currentSkill;

	private void Awake()
	{
		HideAll();
	}

	private void HideAll()
	{
		skillRangeHUD.gameObject.SetActive(value: false);
		projectileLine.gameObject.SetActive(value: false);
	}

	private void LateUpdate()
	{
		if (!character)
		{
			character = LevelManager.Instance.MainCharacter;
			return;
		}
		currentSkill = null;
		currentSkill = character.skillAction.CurrentRunningSkill;
		if (aiming != (currentSkill != null))
		{
			aiming = !aiming;
			if (currentSkill != null)
			{
				currentSkill = character.skillAction.CurrentRunningSkill;
				skillRangeHUD.gameObject.SetActive(value: true);
				float range = 1f;
				if (currentSkill.SkillContext.effectRange > 1f)
				{
					range = currentSkill.SkillContext.effectRange;
				}
				skillRangeHUD.SetRange(range);
				if (currentSkill.SkillContext.isGrenade)
				{
					projectileLine.gameObject.SetActive(value: true);
				}
			}
			else
			{
				HideAll();
			}
		}
		Vector3 currentSkillAimPoint = character.GetCurrentSkillAimPoint();
		bool flag = false;
		Vector3 hitPoint = Vector3.one;
		if (projectileLine.gameObject.activeSelf)
		{
			flag = projectileLine.UpdateLine(character.CurrentUsingAimSocket.position, currentSkillAimPoint, currentSkill.SkillContext.grenageVerticleSpeed, ref hitPoint);
		}
		skillRangeHUD.transform.position = currentSkillAimPoint;
		skillRangeHUD.SetProgress(character.skillAction.GetProgress().progress);
	}
}
public class SkillProjectileLineHUD : MonoBehaviour
{
	public ShapesSkillLine line;

	public int fragmentCount = 20;

	[ColorUsage(true, true)]
	public Color lineColor;

	[ColorUsage(true, true)]
	public Color obsticleColor;

	private LayerMask obsticleLayers;

	private RaycastHit[] hits;

	private void Awake()
	{
		obsticleLayers = (int)GameplayDataSettings.Layers.wallLayerMask | (int)GameplayDataSettings.Layers.groundLayerMask | (int)GameplayDataSettings.Layers.fowBlockLayers;
	}

	public bool UpdateLine(Vector3 start, Vector3 target, float verticleSpeed, ref Vector3 hitPoint)
	{
		float magnitude = Physics.gravity.magnitude;
		if (line.points.Length != fragmentCount + 1)
		{
			line.points = new Vector3[fragmentCount + 1];
			line.colors = new Color[fragmentCount + 1];
		}
		float num = verticleSpeed / magnitude;
		float num2 = Mathf.Sqrt(2f * (num * verticleSpeed * 0.5f + start.y - target.y) / magnitude);
		float num3 = num + num2;
		Vector3 vector = start;
		vector.y = 0f;
		Vector3 vector2 = target;
		vector2.y = 0f;
		float num4 = Vector3.Distance(vector, vector2);
		float num5 = 0f;
		Vector3 vector3 = vector2 - vector;
		if (vector3.magnitude > 0f)
		{
			vector3 = vector3.normalized;
			num5 = num4 / num3;
		}
		else
		{
			vector3 = Vector3.zero;
		}
		float num6 = num3 / (float)fragmentCount;
		bool flag = false;
		for (int i = 0; i < fragmentCount + 1; i++)
		{
			float num7 = num6 * (float)i;
			line.points[i] = start + Vector3.up * (verticleSpeed - magnitude * num7 * 0.5f) * num7 + vector3 * num5 * num7;
			Vector3 vector4 = line.points[i];
			if (i > 0 && i < line.points.Length - 1 && !flag)
			{
				Vector3 vector5 = line.points[i - 1];
				flag = CheckObsticle(vector5, vector4, ref hitPoint);
				hitPoint = vector5 + (vector4 - vector5).normalized * (hitPoint - vector5).magnitude;
			}
			if (flag)
			{
				line.colors[i] = obsticleColor;
			}
			else
			{
				line.colors[i] = lineColor;
			}
		}
		line.hitObsticle = flag;
		if (flag)
		{
			line.hitPoint = hitPoint;
		}
		line.DrawLine();
		return flag;
	}

	private bool CheckObsticle(Vector3 from, Vector3 to, ref Vector3 hitPoint)
	{
		if (hits == null)
		{
			hits = new RaycastHit[3];
		}
		if (Physics.SphereCastNonAlloc(from, 0.2f, (to - from).normalized, hits, (to - from).magnitude, obsticleLayers) > 0)
		{
			hitPoint = hits[0].point;
			return true;
		}
		return false;
	}
}
public class SkillRangeHUD : MonoBehaviour
{
	public Transform rangeTarget;

	public Renderer rangeRenderer;

	private Material rangeMat;

	public void SetRange(float range)
	{
		rangeTarget.localScale = Vector3.one * range;
	}

	public void SetProgress(float progress)
	{
		if (rangeMat == null)
		{
			rangeMat = rangeRenderer.material;
		}
		if (!(rangeMat == null))
		{
			rangeMat.SetFloat("_Progress", progress);
		}
	}
}
public class SyncDebugEdgeLight : MonoBehaviour
{
	private void Awake()
	{
		DebugView.OnDebugViewConfigChanged += OnDebugConfigChanged;
	}

	private void OnDestroy()
	{
		DebugView.OnDebugViewConfigChanged -= OnDebugConfigChanged;
	}

	private void OnDebugConfigChanged(DebugView debugView)
	{
		if (!(debugView == null))
		{
			base.gameObject.SetActive(debugView.EdgeLightActive);
		}
	}
}
public class TimeOfDayAlert : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.CanvasGroup canvasGroup;

	[SerializeField]
	public TextMeshProUGUI text;

	[SerializeField]
	private ColorPunch blinkPunch;

	[LocalizationKey("Default")]
	public string nearNightKey = "TODAlert_NearNight";

	[LocalizationKey("Default")]
	public string inNightKey = "TODAlert_InNight";

	private float stayTime = 5f;

	private float timer;

	public static event Action OnAlertTriggeredEvent;

	private void Awake()
	{
		canvasGroup.alpha = 0f;
		OnAlertTriggeredEvent += OnAlertTriggered;
	}

	private void OnDestroy()
	{
		OnAlertTriggeredEvent -= OnAlertTriggered;
	}

	private void Update()
	{
		if (!LevelManager.LevelInited)
		{
			return;
		}
		if (!LevelManager.Instance.IsBaseLevel)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		if (timer > 0f)
		{
			timer -= Time.deltaTime;
		}
		if (timer <= 0f && canvasGroup.alpha > 0f)
		{
			canvasGroup.alpha = Mathf.MoveTowards(canvasGroup.alpha, 0f, 0.4f * Time.unscaledDeltaTime);
		}
	}

	private void OnAlertTriggered()
	{
		bool flag = false;
		float time = TimeOfDayController.Instance.Time;
		if (TimeOfDayController.Instance.AtNight)
		{
			flag = true;
			UnityEngine.Debug.Log($"At Night,time:{time}");
			text.text = inNightKey.ToPlainText();
		}
		else if (TimeOfDayController.Instance.nightStart - time < 4f)
		{
			flag = true;
			UnityEngine.Debug.Log($"Near Night,time:{time},night start:{TimeOfDayController.Instance.nightStart}");
			text.text = nearNightKey.ToPlainText();
		}
		if (flag)
		{
			canvasGroup.alpha = 1f;
			timer = stayTime;
			blinkPunch.Punch();
		}
	}

	public static void EnterAlertTrigger()
	{
		TimeOfDayAlert.OnAlertTriggeredEvent?.Invoke();
	}

	public static void LeaveAlertTrigger()
	{
	}
}
public class TimeOfDayAlertTriggerProxy : MonoBehaviour
{
	public void OnEnter()
	{
		TimeOfDayAlert.EnterAlertTrigger();
	}

	public void OnLeave()
	{
		TimeOfDayAlert.LeaveAlertTrigger();
	}
}
public class TimeOfDayDisplay : MonoBehaviour
{
	private TimePhaseTags currentPhaseTag;

	private Weather currentWeather;

	public TextMeshProUGUI phaseText;

	public TextMeshProUGUI weatherText;

	public TextMeshProUGUI stormTitleText;

	public TextMeshProUGUI stormText;

	[LocalizationKey("Default")]
	public string StormComingETAKey = "StormETA";

	[LocalizationKey("Default")]
	public string StormComingOneDayKey = "StormOneDayETA";

	[LocalizationKey("Default")]
	public string StormPhaseIIETAKey = "StormPhaseIIETA";

	[LocalizationKey("Default")]
	public string StormOverETAKey = "StormOverETA";

	public GameObject stormDescObject;

	private float refreshTimeSpace = 0.5f;

	private float refreshTimer;

	public Animator stormIndicatorAnimator;

	public ProceduralImage stormFillImage;

	private void Start()
	{
		RefreshPhase(TimeOfDayController.Instance.CurrentPhase.timePhaseTag);
		RefreshWeather(TimeOfDayController.Instance.CurrentWeather);
	}

	private void Update()
	{
		refreshTimer -= Time.unscaledDeltaTime;
		if (!(refreshTimer > 0f))
		{
			refreshTimer = refreshTimeSpace;
			TimePhaseTags timePhaseTag = TimeOfDayController.Instance.CurrentPhase.timePhaseTag;
			if (currentPhaseTag != timePhaseTag)
			{
				RefreshPhase(timePhaseTag);
			}
			Weather weather = TimeOfDayController.Instance.CurrentWeather;
			if (currentWeather != weather)
			{
				RefreshWeather(weather);
			}
			RefreshStormText(weather);
		}
	}

	private void RefreshStormText(Weather _weather)
	{
		TimeSpan timeSpan = default(TimeSpan);
		float num = 0f;
		switch (_weather)
		{
		case Weather.Stormy_I:
			stormIndicatorAnimator.SetBool("Grow", value: false);
			stormTitleText.text = StormPhaseIIETAKey.ToPlainText();
			timeSpan = WeatherManager.Instance.Storm.GetStormIOverETA(GameClock.Now);
			num = WeatherManager.Instance.Storm.GetStormRemainPercent(GameClock.Now);
			stormDescObject.SetActive(LevelManager.Instance.IsBaseLevel);
			break;
		case Weather.Stormy_II:
			stormIndicatorAnimator.SetBool("Grow", value: false);
			stormTitleText.text = StormOverETAKey.ToPlainText();
			timeSpan = WeatherManager.Instance.Storm.GetStormIIOverETA(GameClock.Now);
			num = WeatherManager.Instance.Storm.GetStormRemainPercent(GameClock.Now);
			stormDescObject.SetActive(LevelManager.Instance.IsBaseLevel);
			break;
		default:
			stormIndicatorAnimator.SetBool("Grow", value: true);
			num = WeatherManager.Instance.Storm.GetSleepPercent(GameClock.Now);
			timeSpan = WeatherManager.Instance.Storm.GetStormETA(GameClock.Now);
			if (timeSpan.TotalHours < 24.0)
			{
				stormTitleText.text = StormComingOneDayKey.ToPlainText();
				stormDescObject.SetActive(LevelManager.Instance.IsBaseLevel);
			}
			else
			{
				stormTitleText.text = StormComingETAKey.ToPlainText();
				stormDescObject.SetActive(value: false);
			}
			break;
		}
		stormFillImage.fillAmount = num;
		stormText.text = $"{Mathf.FloorToInt((float)timeSpan.TotalHours):000}:{timeSpan.Minutes:00}";
	}

	private void RefreshPhase(TimePhaseTags _phase)
	{
		currentPhaseTag = _phase;
		phaseText.text = TimeOfDayController.GetTimePhaseNameByPhaseTag(_phase);
	}

	private void RefreshWeather(Weather _weather)
	{
		currentWeather = _weather;
		weatherText.text = TimeOfDayController.GetWeatherNameByWeather(_weather);
	}
}
public class WeightBarHUD : MonoBehaviour
{
	private CharacterMainControl characterMainControl;

	private float percent;

	private float weight;

	private float maxWeight;

	public ProceduralImage fillImage;

	public TrueShadow glow;

	public Color lightColor;

	public Color normalColor;

	public Color heavyColor;

	public Color overWeightColor;

	public TextMeshProUGUI weightText;

	public string weightTextFormat = "{0:0.#}/{1:0.#}kg";

	private Item item => characterMainControl.CharacterItem;

	private void Update()
	{
		if (!characterMainControl)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
			if (!characterMainControl)
			{
				return;
			}
		}
		float totalWeight = characterMainControl.CharacterItem.TotalWeight;
		float a = characterMainControl.MaxWeight;
		if (!Mathf.Approximately(totalWeight, weight) || !Mathf.Approximately(a, maxWeight))
		{
			weight = totalWeight;
			maxWeight = a;
			percent = weight / maxWeight;
			weightText.text = string.Format(weightTextFormat, weight, maxWeight);
			fillImage.fillAmount = percent;
			SetColor();
		}
	}

	private void SetColor()
	{
		Color color = ((percent < 0.25f) ? lightColor : ((percent < 0.75f) ? normalColor : ((!(percent < 1f)) ? overWeightColor : heavyColor)));
		Color.RGBToHSV(color, out var H, out var S, out var V);
		Color color2 = color;
		if (S > 0.4f)
		{
			S = 0.4f;
			V = 1f;
			color2 = Color.HSVToRGB(H, S, V);
		}
		glow.Color = color;
		fillImage.color = color2;
		weightText.color = color;
	}
}
public class ConstructionSite : MonoBehaviour
{
	[SerializeField]
	private string _key;

	[SerializeField]
	private bool dontSave;

	private bool saveInMultiSceneCore;

	[SerializeField]
	private Cost cost;

	[SerializeField]
	private CostTaker costTaker;

	[SerializeField]
	private GameObject[] notBuiltGameObjects;

	[SerializeField]
	private GameObject[] builtGameObjects;

	[SerializeField]
	private GameObject[] setActiveOnBuilt;

	[SerializeField]
	private UnityEvent<ConstructionSite> onBuilt;

	[SerializeField]
	private UnityEvent<ConstructionSite> onActivate;

	[SerializeField]
	private UnityEvent<ConstructionSite> onDeactivate;

	private bool wasBuilt;

	private Color KeyFieldColor
	{
		get
		{
			if (string.IsNullOrWhiteSpace(_key))
			{
				return Color.red;
			}
			return Color.white;
		}
	}

	private string SaveKey => "ConstructionSite_" + _key;

	private void Awake()
	{
		costTaker.onPayed += OnBuilt;
		Load();
		SavesSystem.OnCollectSaveData += Save;
		costTaker.SetCost(cost);
		RefreshGameObjects();
	}

	private void OnDestroy()
	{
		SavesSystem.OnCollectSaveData -= Save;
	}

	private void Save()
	{
		if (dontSave)
		{
			int inLevelDataKey = GetInLevelDataKey();
			if (MultiSceneCore.Instance.inLevelData.ContainsKey(inLevelDataKey))
			{
				MultiSceneCore.Instance.inLevelData[inLevelDataKey] = wasBuilt;
			}
			else
			{
				MultiSceneCore.Instance.inLevelData.Add(inLevelDataKey, wasBuilt);
			}
		}
		else if (string.IsNullOrWhiteSpace(_key))
		{
			UnityEngine.Debug.LogError($"Construction Site {base.gameObject} 没有配置保存用的key");
		}
		else
		{
			SavesSystem.Save(SaveKey, wasBuilt);
		}
	}

	private int GetInLevelDataKey()
	{
		Vector3 vector = base.transform.position * 10f;
		int x = Mathf.RoundToInt(vector.x);
		int y = Mathf.RoundToInt(vector.y);
		int z = Mathf.RoundToInt(vector.z);
		return ("ConstSite" + new Vector3Int(x, y, z).ToString()).GetHashCode();
	}

	private void Load()
	{
		if (!dontSave)
		{
			if (string.IsNullOrWhiteSpace(_key))
			{
				UnityEngine.Debug.LogError($"Construction Site {base.gameObject} 没有配置保存用的key");
			}
			wasBuilt = SavesSystem.Load<bool>(SaveKey);
		}
		else
		{
			int inLevelDataKey = GetInLevelDataKey();
			MultiSceneCore.Instance.inLevelData.TryGetValue(inLevelDataKey, out var value);
			if (value != null)
			{
				wasBuilt = (bool)value;
			}
		}
		if (wasBuilt)
		{
			OnActivate();
		}
		else
		{
			OnDeactivate();
		}
	}

	private void Start()
	{
	}

	private void OnBuilt(CostTaker taker)
	{
		wasBuilt = true;
		onBuilt?.Invoke(this);
		RefreshGameObjects();
		GameObject[] array = setActiveOnBuilt;
		foreach (GameObject gameObject in array)
		{
			if ((bool)gameObject)
			{
				gameObject.SetActive(value: true);
			}
		}
		Save();
	}

	private void OnActivate()
	{
		onActivate?.Invoke(this);
		RefreshGameObjects();
	}

	private void OnDeactivate()
	{
		onDeactivate?.Invoke(this);
		RefreshGameObjects();
	}

	public void RefreshGameObjects()
	{
		costTaker.gameObject.SetActive(!wasBuilt);
		GameObject[] array = notBuiltGameObjects;
		foreach (GameObject gameObject in array)
		{
			if ((bool)gameObject)
			{
				gameObject.SetActive(!wasBuilt);
			}
		}
		array = builtGameObjects;
		foreach (GameObject gameObject2 in array)
		{
			if ((bool)gameObject2)
			{
				gameObject2.SetActive(wasBuilt);
			}
		}
	}
}
public class CostTaker : InteractableBase
{
	[SerializeField]
	private Cost cost;

	public UnityEvent<CostTaker> onPayedUnityEvent;

	private static List<CostTaker> activeCostTakers = new List<CostTaker>();

	private static ReadOnlyCollection<CostTaker> _activeCostTakers_ReadOnly;

	public Cost Cost => cost;

	public static ReadOnlyCollection<CostTaker> ActiveCostTakers
	{
		get
		{
			if (_activeCostTakers_ReadOnly == null)
			{
				_activeCostTakers_ReadOnly = new ReadOnlyCollection<CostTaker>(activeCostTakers);
			}
			return _activeCostTakers_ReadOnly;
		}
	}

	public event Action<CostTaker> onPayed;

	public static event Action<CostTaker> OnCostTakerRegistered;

	public static event Action<CostTaker> OnCostTakerUnregistered;

	protected override bool IsInteractable()
	{
		return cost.Enough;
	}

	protected override void OnInteractFinished()
	{
		if (cost.Enough && cost.Pay())
		{
			this.onPayed?.Invoke(this);
			onPayedUnityEvent?.Invoke(this);
		}
	}

	private void OnEnable()
	{
		Register(this);
	}

	private void OnDisable()
	{
		Unregister(this);
	}

	public static void Register(CostTaker costTaker)
	{
		activeCostTakers.Add(costTaker);
		CostTaker.OnCostTakerRegistered?.Invoke(costTaker);
	}

	public static void Unregister(CostTaker costTaker)
	{
		if (activeCostTakers.Remove(costTaker))
		{
			CostTaker.OnCostTakerUnregistered?.Invoke(costTaker);
		}
	}

	public void SetCost(Cost cost)
	{
		Unregister(this);
		this.cost = cost;
		if (base.isActiveAndEnabled)
		{
			Register(this);
		}
	}
}
public class CostTakerHUD : MonoBehaviour
{
	[SerializeField]
	private CostTakerHUD_Entry entryTemplate;

	private PrefabPool<CostTakerHUD_Entry> _entryPool;

	private PrefabPool<CostTakerHUD_Entry> EntryPool
	{
		get
		{
			if (_entryPool == null)
			{
				_entryPool = new PrefabPool<CostTakerHUD_Entry>(entryTemplate);
			}
			return _entryPool;
		}
	}

	private void Awake()
	{
		entryTemplate.gameObject.SetActive(value: false);
		ShowAll();
		CostTaker.OnCostTakerRegistered += OnCostTakerRegistered;
		CostTaker.OnCostTakerUnregistered += OnCostTakerUnregistered;
	}

	private void OnDestroy()
	{
		CostTaker.OnCostTakerRegistered -= OnCostTakerRegistered;
		CostTaker.OnCostTakerUnregistered -= OnCostTakerUnregistered;
	}

	private void OnCostTakerRegistered(CostTaker taker)
	{
		ShowHUD(taker);
	}

	private void OnCostTakerUnregistered(CostTaker taker)
	{
		HideHUD(taker);
	}

	private void Start()
	{
	}

	private void ShowAll()
	{
		EntryPool.ReleaseAll();
		foreach (CostTaker activeCostTaker in CostTaker.ActiveCostTakers)
		{
			ShowHUD(activeCostTaker);
		}
	}

	private void ShowHUD(CostTaker costTaker)
	{
		EntryPool.Get().Setup(costTaker);
	}

	private void HideHUD(CostTaker costTaker)
	{
		CostTakerHUD_Entry costTakerHUD_Entry = EntryPool.Find((CostTakerHUD_Entry e) => e.gameObject.activeSelf && e.Target == costTaker);
		if (!(costTakerHUD_Entry == null))
		{
			EntryPool.Release(costTakerHUD_Entry);
		}
	}
}
public class CostTakerHUD_Entry : MonoBehaviour
{
	private RectTransform rectTransform;

	[SerializeField]
	private TextMeshProUGUI nameText;

	[SerializeField]
	private CostDisplay costDisplay;

	[SerializeField]
	private FadeGroup fadeGroup;

	private const float HideDistance = 10f;

	private const float HideDistanceYLimit = 2.5f;

	public CostTaker Target { get; private set; }

	private void Awake()
	{
		rectTransform = base.transform as RectTransform;
	}

	private void LateUpdate()
	{
		UpdatePosition();
		UpdateFadeGroup();
	}

	internal void Setup(CostTaker cur)
	{
		Target = cur;
		nameText.text = cur.InteractName;
		costDisplay.Setup(cur.Cost);
		UpdatePosition();
	}

	private void UpdatePosition()
	{
		rectTransform.MatchWorldPosition(Target.transform.TransformPoint(Target.interactMarkerOffset), Vector3.up * 0.5f);
	}

	private void UpdateFadeGroup()
	{
		CharacterMainControl main = CharacterMainControl.Main;
		bool flag = false;
		if (!(Target == null) && !(main == null))
		{
			Vector3 vector = main.transform.position - Target.transform.position;
			if (!(Mathf.Abs(vector.y) > 2.5f) && !(vector.magnitude > 10f))
			{
				flag = true;
			}
		}
		if (flag && !fadeGroup.IsShown)
		{
			fadeGroup.Show();
		}
		else if (!flag && fadeGroup.IsShown)
		{
			fadeGroup.Hide();
		}
	}
}
public class Door : MonoBehaviour
{
	[Serializable]
	public struct DoorTransformInfo
	{
		public Transform target;

		public Vector3 localPosition;

		public quaternion localRotation;

		public bool activation;
	}

	private bool closed = true;

	private float closedLerpValue;

	private float targetLerpValue;

	[SerializeField]
	private float lerpTime = 0.5f;

	[SerializeField]
	private List<Transform> doorParts;

	[SerializeField]
	private List<DoorTransformInfo> closeTransforms;

	[SerializeField]
	private List<DoorTransformInfo> openTransforms;

	[SerializeField]
	private DoorTrigger doorTrigger;

	[SerializeField]
	private Collider doorCollider;

	[SerializeField]
	private List<NavmeshCut> navmeshCuts = new List<NavmeshCut>();

	[SerializeField]
	private bool activeNavmeshCutWhenDoorIsOpen = true;

	[SerializeField]
	private bool ignoreInLevelData;

	private int _doorClosedDataKeyCached = -1;

	[SerializeField]
	private InteractableBase interact;

	public bool hasSound;

	public string openSound = "SFX/Actions/door_normal_open";

	public string closeSound = "SFX/Actions/door_normal_close";

	public UnityEvent OnOpenEvent;

	public UnityEvent OnCloseEvent;

	public bool IsOpen => !closed;

	public bool NoRequireItem
	{
		get
		{
			if (!interact)
			{
				return true;
			}
			return !interact.requireItem;
		}
	}

	public InteractableBase Interact => interact;

	private void Start()
	{
		if (_doorClosedDataKeyCached == -1)
		{
			_doorClosedDataKeyCached = GetKey();
		}
		if (!ignoreInLevelData && (bool)MultiSceneCore.Instance && MultiSceneCore.Instance.inLevelData.TryGetValue(_doorClosedDataKeyCached, out var value) && value is bool flag)
		{
			UnityEngine.Debug.Log($"存在门存档信息：{flag}");
			closed = flag;
		}
		targetLerpValue = (closedLerpValue = (closed ? 1f : 0f));
		SyncNavmeshCut();
		SetPartsByLerpValue(setActivation: true);
	}

	private void OnEnable()
	{
		if ((bool)doorCollider)
		{
			doorCollider.isTrigger = true;
		}
	}

	private void OnDisable()
	{
		if ((bool)doorCollider)
		{
			doorCollider.isTrigger = false;
		}
	}

	private void SyncNavmeshCut()
	{
		bool flag = false;
		if (closed)
		{
			if (NoRequireItem)
			{
				flag = false;
			}
			else
			{
				flag = true;
			}
			return;
		}
		flag = activeNavmeshCutWhenDoorIsOpen;
		foreach (NavmeshCut navmeshCut in navmeshCuts)
		{
			if ((bool)(UnityEngine.Object)(object)navmeshCut)
			{
				((Behaviour)(object)navmeshCut).enabled = flag;
			}
		}
	}

	private void Update()
	{
		targetLerpValue = (closed ? 1f : 0f);
		if (targetLerpValue == closedLerpValue)
		{
			base.enabled = false;
		}
		closedLerpValue = Mathf.MoveTowards(closedLerpValue, targetLerpValue, Time.deltaTime / lerpTime);
		SetPartsByLerpValue(targetLerpValue == closedLerpValue);
	}

	public void Switch()
	{
		SetClosed(!closed);
	}

	public void Open()
	{
		SetClosed(_closed: false);
	}

	public void Close()
	{
		SetClosed(_closed: true);
	}

	public void ForceSetClosed(bool _closed, bool triggerEvent)
	{
		SetClosed(_closed, triggerEvent);
	}

	private void SetClosed(bool _closed, bool triggerEvent = true)
	{
		if (!LevelManager.LevelInited)
		{
			UnityEngine.Debug.LogError("在关卡没有初始化时，不能对门进行设置");
			return;
		}
		if (triggerEvent)
		{
			if (_closed)
			{
				OnCloseEvent?.Invoke();
			}
			else
			{
				OnOpenEvent?.Invoke();
			}
		}
		UnityEngine.Debug.Log($"Set Door Closed:{_closed}");
		if (_doorClosedDataKeyCached == -1)
		{
			_doorClosedDataKeyCached = GetKey();
		}
		closed = _closed;
		targetLerpValue = (closed ? 1f : 0f);
		if (closedLerpValue != targetLerpValue)
		{
			base.enabled = true;
		}
		if (hasSound)
		{
			AudioManager.Post(_closed ? closeSound : openSound, base.gameObject);
		}
		if ((bool)MultiSceneCore.Instance)
		{
			MultiSceneCore.Instance.inLevelData[_doorClosedDataKeyCached] = closed;
		}
		else
		{
			UnityEngine.Debug.Log("没有MultiScene Core，无法存储data");
		}
		SyncNavmeshCut();
	}

	private List<DoorTransformInfo> GetCurrentTransformInfos()
	{
		List<DoorTransformInfo> list = new List<DoorTransformInfo>();
		foreach (Transform doorPart in doorParts)
		{
			DoorTransformInfo item = default(DoorTransformInfo);
			if (doorPart != null)
			{
				item.target = doorPart;
				item.localPosition = doorPart.localPosition;
				item.localRotation = doorPart.localRotation;
				item.activation = doorPart.gameObject.activeSelf;
			}
			list.Add(item);
		}
		return list;
	}

	public void SetParts(List<DoorTransformInfo> transforms)
	{
		for (int i = 0; i < transforms.Count; i++)
		{
			DoorTransformInfo doorTransformInfo = transforms[i];
			if (!(doorTransformInfo.target == null))
			{
				doorTransformInfo.target.localPosition = doorTransformInfo.localPosition;
				doorTransformInfo.target.localRotation = doorTransformInfo.localRotation;
				doorTransformInfo.target.gameObject.SetActive(doorTransformInfo.activation);
			}
		}
	}

	private void SetPartsByLerpValue(bool setActivation)
	{
		if (doorParts.Count != closeTransforms.Count || doorParts.Count != openTransforms.Count)
		{
			return;
		}
		for (int i = 0; i < openTransforms.Count; i++)
		{
			DoorTransformInfo doorTransformInfo = openTransforms[i];
			DoorTransformInfo doorTransformInfo2 = closeTransforms[i];
			if (doorTransformInfo.target == null || doorTransformInfo.target != doorTransformInfo2.target)
			{
				continue;
			}
			doorTransformInfo.target.localPosition = Vector3.Lerp(doorTransformInfo.localPosition, doorTransformInfo2.localPosition, closedLerpValue);
			doorTransformInfo.target.localRotation = Quaternion.Lerp(doorTransformInfo.localRotation, doorTransformInfo2.localRotation, closedLerpValue);
			if (setActivation)
			{
				if (closedLerpValue >= 1f)
				{
					doorTransformInfo.target.gameObject.SetActive(doorTransformInfo2.activation);
				}
				else
				{
					doorTransformInfo.target.gameObject.SetActive(doorTransformInfo.activation);
				}
			}
		}
	}

	private int GetKey()
	{
		Vector3 vector = base.transform.position * 10f;
		int x = Mathf.RoundToInt(vector.x);
		int y = Mathf.RoundToInt(vector.y);
		int z = Mathf.RoundToInt(vector.z);
		Vector3Int vector3Int = new Vector3Int(x, y, z);
		return $"Door_{vector3Int}".GetHashCode();
	}
}
public class DoorTrigger : MonoBehaviour
{
	public Door parent;

	private void OnTriggerEnter(Collider collision)
	{
		if (!parent.IsOpen && parent.NoRequireItem && (!parent.Interact || parent.Interact.gameObject.activeInHierarchy) && collision.gameObject.layer == LayerMask.NameToLayer("Character"))
		{
			CharacterMainControl component = collision.gameObject.GetComponent<CharacterMainControl>();
			if ((bool)component && component.Team != Teams.player)
			{
				parent.Open();
			}
		}
	}
}
public class InteractableBase : MonoBehaviour, IProgress
{
	public enum WhenToUseRequireItemTypes
	{
		None,
		OnFinshed,
		OnTimeOut,
		OnStartInteract
	}

	public bool interactableGroup;

	[SerializeField]
	private List<InteractableBase> otherInterablesInGroup;

	public bool zoomIn = true;

	private List<InteractableBase> _interactbleList = new List<InteractableBase>();

	[SerializeField]
	private float interactTime;

	public bool finishWhenTimeOut = true;

	private float interactTimer;

	public Vector3 interactMarkerOffset;

	public bool overrideInteractName;

	[LocalizationKey("Default")]
	private string defaultInteractNameKey = "UI_Interact";

	[LocalizationKey("Interact")]
	public string _overrideInteractNameKey;

	public Collider interactCollider;

	public bool requireItem;

	public bool requireOnce = true;

	[ItemTypeID]
	public int requireItemId;

	public float unlockTime;

	public bool overrideItemUsedKey;

	public string overrideItemUsedSaveKey;

	public WhenToUseRequireItemTypes whenToUseRequireItem;

	public UnityEvent OnRequiredItemUsedEvent;

	private int requireItemDataKeyCached;

	private bool requireItemUsed;

	private ItemMetaData? _cachedMeta;

	public UnityEvent<CharacterMainControl, InteractableBase> OnInteractStartEvent;

	public UnityEvent<CharacterMainControl, InteractableBase> OnInteractTimeoutEvent;

	public UnityEvent<CharacterMainControl, InteractableBase> OnInteractFinishedEvent;

	public bool disableOnFinish;

	public float coolTime;

	private float lastStopTime = -1f;

	protected CharacterMainControl interactCharacter;

	private bool timeOut;

	[SerializeField]
	private bool interactMarkerVisible = true;

	private InteractMarker markerObject;

	public float InteractTime
	{
		get
		{
			if (requireItem && !requireItemUsed)
			{
				return interactTime + unlockTime;
			}
			return interactTime;
		}
	}

	public string InteractName
	{
		get
		{
			if (overrideInteractName)
			{
				return _overrideInteractNameKey.ToPlainText();
			}
			return defaultInteractNameKey.ToPlainText();
		}
		set
		{
			overrideInteractName = true;
			_overrideInteractNameKey = value;
		}
	}

	private bool ShowBaseInteractName
	{
		get
		{
			if (overrideInteractName)
			{
				return ShowBaseInteractNameInspector;
			}
			return false;
		}
	}

	protected virtual bool ShowBaseInteractNameInspector => true;

	private ItemMetaData CachedMeta
	{
		get
		{
			if (!_cachedMeta.HasValue)
			{
				_cachedMeta = ItemAssetsCollection.GetMetaData(requireItemId);
			}
			return _cachedMeta.Value;
		}
	}

	protected virtual bool ShowUnityEvents => true;

	public bool Interacting => interactCharacter != null;

	public bool MarkerActive
	{
		get
		{
			return interactMarkerVisible;
		}
		set
		{
			if (base.enabled)
			{
				interactMarkerVisible = value;
				if (value)
				{
					ActiveMarker();
				}
				else if ((bool)markerObject)
				{
					markerObject.gameObject.SetActive(value: false);
				}
			}
		}
	}

	public static event Action<InteractableBase> OnInteractStartStaticEvent;

	public List<InteractableBase> GetInteractableList()
	{
		_interactbleList.Clear();
		_interactbleList.Add(this);
		if (!interactableGroup || otherInterablesInGroup.Count <= 0)
		{
			return _interactbleList;
		}
		foreach (InteractableBase item in otherInterablesInGroup)
		{
			if (!(item == null) && item.gameObject.activeInHierarchy)
			{
				_interactbleList.Add(item);
			}
		}
		return _interactbleList;
	}

	protected virtual void Awake()
	{
		requireItemDataKeyCached = GetKey();
		if (interactCollider == null)
		{
			interactCollider = GetComponent<Collider>();
			if (interactCollider == null)
			{
				interactCollider = base.gameObject.AddComponent<BoxCollider>();
				interactCollider.enabled = false;
			}
		}
		if (interactCollider != null)
		{
			interactCollider.gameObject.layer = LayerMask.NameToLayer("Interactable");
		}
		foreach (InteractableBase item in otherInterablesInGroup)
		{
			if ((bool)item)
			{
				item.MarkerActive = false;
				item.transform.position = base.transform.position;
				item.transform.rotation = base.transform.rotation;
				item.interactMarkerOffset = interactMarkerOffset;
			}
		}
		_interactbleList = new List<InteractableBase>();
	}

	protected virtual void Start()
	{
		if (requireItem && (bool)MultiSceneCore.Instance && MultiSceneCore.Instance.inLevelData.TryGetValue(requireItemDataKeyCached, out var value) && value is bool && (bool)value)
		{
			requireItem = false;
			requireItemUsed = true;
			OnRequiredItemUsedEvent?.Invoke();
		}
		MarkerActive = interactMarkerVisible;
	}

	private void ActiveMarker()
	{
		if ((bool)markerObject)
		{
			if (!markerObject.gameObject.activeInHierarchy)
			{
				markerObject.gameObject.SetActive(value: true);
			}
		}
		else
		{
			markerObject = UnityEngine.Object.Instantiate(GameplayDataSettings.Prefabs.InteractMarker, base.transform);
			markerObject.transform.localPosition = interactMarkerOffset;
			CheckInteractable();
		}
	}

	public void SetMarkerUsed()
	{
		if ((bool)markerObject)
		{
			markerObject.MarkAsUsed();
		}
	}

	public bool StartInteract(CharacterMainControl _interactCharacter)
	{
		if (!_interactCharacter)
		{
			return false;
		}
		if (requireItem && !TryGetRequiredItem(_interactCharacter).hasItem)
		{
			return false;
		}
		if (interactCharacter == _interactCharacter)
		{
			return false;
		}
		if (!CheckInteractable())
		{
			return false;
		}
		if (requireItem && whenToUseRequireItem == WhenToUseRequireItemTypes.OnStartInteract && !UseRequiredItem(_interactCharacter))
		{
			StopInteract();
			return false;
		}
		interactCharacter = _interactCharacter;
		interactTimer = 0f;
		timeOut = false;
		OnInteractStartEvent?.Invoke(_interactCharacter, this);
		InteractableBase.OnInteractStartStaticEvent?.Invoke(this);
		try
		{
			OnInteractStart(_interactCharacter);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			if ((bool)CharacterMainControl.Main)
			{
				CharacterMainControl.Main.PopText("OnInteractStart开始失败，Log Error");
			}
			return false;
		}
		return true;
	}

	public InteractableBase GetInteractableInGroup(int index)
	{
		if (index == 0)
		{
			return this;
		}
		List<InteractableBase> interactableList = GetInteractableList();
		if (index >= interactableList.Count)
		{
			return null;
		}
		return interactableList[index];
	}

	public void InternalStopInteract()
	{
		interactCharacter = null;
		lastStopTime = Time.time;
		OnInteractStop();
	}

	public void StopInteract()
	{
		CharacterMainControl characterMainControl = interactCharacter;
		if ((bool)characterMainControl && characterMainControl.interactAction.Running && characterMainControl.interactAction.InteractingTarget == this)
		{
			interactCharacter.interactAction.StopAction();
		}
		else
		{
			InternalStopInteract();
		}
	}

	public void UpdateInteract(CharacterMainControl _interactCharacter, float deltaTime)
	{
		interactTimer += deltaTime;
		OnUpdate(_interactCharacter, deltaTime);
		if (timeOut || !(interactTimer >= InteractTime))
		{
			return;
		}
		if (requireItem && whenToUseRequireItem == WhenToUseRequireItemTypes.OnTimeOut && !UseRequiredItem(_interactCharacter))
		{
			StopInteract();
			return;
		}
		if (requireItem && whenToUseRequireItem == WhenToUseRequireItemTypes.None && !requireItemUsed)
		{
			requireItemUsed = true;
			OnRequiredItemUsedEvent?.Invoke();
			if ((bool)MultiSceneCore.Instance)
			{
				MultiSceneCore.Instance.inLevelData[requireItemDataKeyCached] = true;
				UnityEngine.Debug.Log("设置使用过物品为true");
			}
		}
		timeOut = true;
		OnTimeOut();
		OnInteractTimeoutEvent?.Invoke(_interactCharacter, this);
		if (finishWhenTimeOut)
		{
			FinishInteract(_interactCharacter);
		}
	}

	public void FinishInteract(CharacterMainControl _interactCharacter)
	{
		if (requireItem && whenToUseRequireItem == WhenToUseRequireItemTypes.OnFinshed && !UseRequiredItem(_interactCharacter))
		{
			StopInteract();
			return;
		}
		try
		{
			OnInteractFinished();
			OnInteractFinishedEvent?.Invoke(_interactCharacter, this);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
		StopInteract();
		if (disableOnFinish)
		{
			base.enabled = false;
			if ((bool)markerObject)
			{
				markerObject.gameObject.SetActive(value: false);
			}
			if ((bool)interactCollider)
			{
				interactCollider.enabled = false;
			}
		}
	}

	protected virtual void OnUpdate(CharacterMainControl _interactCharacter, float deltaTime)
	{
	}

	protected virtual void OnTimeOut()
	{
	}

	private bool UseRequiredItem(CharacterMainControl interactCharacter)
	{
		UnityEngine.Debug.Log("尝试使用");
		(bool, Item) tuple = TryGetRequiredItem(interactCharacter);
		Item item = tuple.Item2;
		if (!tuple.Item1 || tuple.Item2 == null)
		{
			return false;
		}
		if (item.UseDurability)
		{
			UnityEngine.Debug.Log("尝试消耗耐久");
			item.Durability -= 1f;
			if (item.Durability <= 0f)
			{
				item.Detach();
				item.DestroyTree();
			}
		}
		else if (!item.Stackable)
		{
			UnityEngine.Debug.Log("尝试直接消耗掉");
			item.Detach();
			item.DestroyTree();
		}
		else
		{
			UnityEngine.Debug.Log("尝试消耗堆叠");
			item.StackCount--;
		}
		if (requireOnce)
		{
			requireItem = false;
			requireItemUsed = true;
			OnRequiredItemUsedEvent?.Invoke();
			if ((bool)MultiSceneCore.Instance)
			{
				MultiSceneCore.Instance.inLevelData[requireItemDataKeyCached] = true;
				UnityEngine.Debug.Log("设置使用过物品为true");
			}
		}
		return true;
	}

	public bool CheckInteractable()
	{
		if (interactCharacter != null)
		{
			if (!(interactCharacter.interactAction.InteractingTarget != this))
			{
				return false;
			}
			StopInteract();
		}
		if (Time.time - lastStopTime < coolTime && coolTime > 0f && lastStopTime > 0f)
		{
			return false;
		}
		return IsInteractable();
	}

	protected virtual bool IsInteractable()
	{
		return true;
	}

	protected virtual void OnInteractStart(CharacterMainControl interactCharacter)
	{
	}

	protected virtual void OnInteractStop()
	{
	}

	protected virtual void OnInteractFinished()
	{
	}

	public string GetInteractName()
	{
		if (overrideInteractName)
		{
			return InteractName;
		}
		return "UI_Interact".ToPlainText();
	}

	public string GetRequiredItemName()
	{
		if (!requireItem)
		{
			return null;
		}
		return CachedMeta.DisplayName;
	}

	public Sprite GetRequireditemIcon()
	{
		if (!requireItem)
		{
			return null;
		}
		return CachedMeta.icon;
	}

	protected virtual void OnDestroy()
	{
		if (Interacting)
		{
			StopInteract();
		}
	}

	public virtual Duckov.Progress GetProgress()
	{
		Duckov.Progress result = default(Duckov.Progress);
		if (Interacting && InteractTime > 0f)
		{
			result.inProgress = true;
			result.total = InteractTime;
			result.current = interactTimer;
		}
		else
		{
			result.inProgress = false;
		}
		return result;
	}

	public (bool hasItem, Item ItemInstance) TryGetRequiredItem(CharacterMainControl fromCharacter)
	{
		if (!requireItem)
		{
			return (hasItem: false, ItemInstance: null);
		}
		if (!fromCharacter)
		{
			return (hasItem: false, ItemInstance: null);
		}
		if (MasterKeysManager.IsActive(requireItemId))
		{
			return (hasItem: true, ItemInstance: null);
		}
		foreach (Slot slot in fromCharacter.CharacterItem.Slots)
		{
			if ((bool)slot.Content && slot.Content.TypeID == requireItemId)
			{
				return (hasItem: true, ItemInstance: slot.Content);
			}
		}
		foreach (Item item in fromCharacter.CharacterItem.Inventory)
		{
			if (item.TypeID == requireItemId)
			{
				return (hasItem: true, ItemInstance: item);
			}
			if (!(item.Slots != null) || item.Slots.Count <= 0)
			{
				continue;
			}
			foreach (Slot slot2 in item.Slots)
			{
				if (slot2.Content != null && slot2.Content.TypeID == requireItemId)
				{
					return (hasItem: true, ItemInstance: slot2.Content);
				}
			}
		}
		foreach (Item item2 in LevelManager.Instance.PetProxy.Inventory)
		{
			if (item2.TypeID == requireItemId)
			{
				return (hasItem: true, ItemInstance: item2);
			}
			if (!item2.Slots || item2.Slots.Count <= 0)
			{
				continue;
			}
			foreach (Slot slot3 in item2.Slots)
			{
				if (slot3.Content != null && slot3.Content.TypeID == requireItemId)
				{
					return (hasItem: true, ItemInstance: slot3.Content);
				}
			}
		}
		return (hasItem: false, ItemInstance: null);
	}

	private int GetKey()
	{
		if (overrideItemUsedKey)
		{
			return overrideItemUsedSaveKey.GetHashCode();
		}
		Vector3 vector = base.transform.position * 10f;
		int x = Mathf.RoundToInt(vector.x);
		int y = Mathf.RoundToInt(vector.y);
		int z = Mathf.RoundToInt(vector.z);
		Vector3Int vector3Int = new Vector3Int(x, y, z);
		return $"Intact_{vector3Int}".GetHashCode();
	}

	public void InteractWithMainCharacter()
	{
		CharacterMainControl.Main?.Interact(this);
	}

	private void OnDrawGizmos()
	{
		if (interactMarkerVisible)
		{
			Gizmos.color = Color.yellow;
			Gizmos.DrawSphere(base.transform.TransformPoint(interactMarkerOffset), 0.1f);
		}
	}
}
public class InteractableCarriable : InteractableBase
{
	public Carriable carryTarget;

	protected override void Start()
	{
		base.Start();
		finishWhenTimeOut = true;
	}

	protected override bool IsInteractable()
	{
		return true;
	}

	protected override void OnInteractStart(CharacterMainControl character)
	{
	}

	protected override void OnInteractFinished()
	{
		if ((bool)interactCharacter)
		{
			CharacterMainControl characterMainControl = interactCharacter;
			StopInteract();
			characterMainControl.Carry(carryTarget);
		}
	}
}
public class InteractableLootbox : InteractableBase
{
	public enum LootBoxStates
	{
		closed,
		openning,
		looting
	}

	public bool useDefaultInteractName;

	[SerializeField]
	private bool showSortButton;

	[SerializeField]
	private bool usePages;

	public bool needInspect = true;

	public bool showPickAllButton = true;

	public Transform hideIfEmpty;

	[LocalizationKey("Default")]
	[SerializeField]
	private string displayNameKey;

	[SerializeField]
	private Inventory inventoryReference;

	private Item inspectingItem;

	private float inspectTime = 1f;

	private float inspectTimer;

	private LootBoxStates lootState;

	public bool ShowSortButton => showSortButton;

	public bool UsePages => usePages;

	public static Transform LootBoxInventoriesParent => LevelManager.LootBoxInventoriesParent;

	public static Dictionary<int, Inventory> Inventories => LevelManager.LootBoxInventories;

	public Inventory Inventory
	{
		get
		{
			Inventory inventory = null;
			if ((bool)inventoryReference)
			{
				inventory = inventoryReference;
			}
			else
			{
				inventory = GetOrCreateInventory(this);
				if (inventory == null)
				{
					if (LevelManager.Instance == null)
					{
						UnityEngine.Debug.Log("LevelManager.Instance 不存在，取消创建i nventory");
						return null;
					}
					LevelManager.Instance.MainCharacter.PopText("空的Inventory");
					UnityEngine.Debug.LogError("未能成功创建Inventory," + base.gameObject.name, this);
				}
				inventoryReference = inventory;
			}
			if ((bool)inventoryReference && inventoryReference.hasBeenInspectedInLootBox)
			{
				SetMarkerUsed();
			}
			inventory.DisplayNameKey = displayNameKey;
			return inventory;
		}
	}

	public bool Looted => LootView.HasInventoryEverBeenLooted(Inventory);

	public static InteractableLootbox Prefab => GameplayDataSettings.Prefabs?.LootBoxPrefab;

	public static event Action<InteractableLootbox> OnStartLoot;

	public static event Action<InteractableLootbox> OnStopLoot;

	public static Inventory GetOrCreateInventory(InteractableLootbox lootBox)
	{
		if (lootBox == null)
		{
			if (CharacterMainControl.Main != null)
			{
				CharacterMainControl.Main.PopText("ERROR:尝试创建Inventory, 但lootbox是null");
			}
			UnityEngine.Debug.LogError("尝试创建Inventory, 但lootbox是null");
			return null;
		}
		int key = lootBox.GetKey();
		if (Inventories.TryGetValue(key, out var value))
		{
			if (!(value == null))
			{
				return value;
			}
			CharacterMainControl.Main.PopText($"Inventory缓存字典里有Key: {key}, 但其对应值为null.重新创建Inventory。");
			UnityEngine.Debug.LogError($"Inventory缓存字典里有Key: {key}, 但其对应值为null.重新创建Inventory。");
		}
		GameObject obj = new GameObject($"Inventory_{key}");
		obj.transform.SetParent(LootBoxInventoriesParent);
		obj.transform.position = lootBox.transform.position;
		value = obj.AddComponent<Inventory>();
		value.NeedInspection = lootBox.needInspect;
		Inventories.Add(key, value);
		LootBoxLoader component = lootBox.GetComponent<LootBoxLoader>();
		if ((bool)component && component.autoSetup)
		{
			component.Setup().Forget();
		}
		return value;
	}

	private int GetKey()
	{
		Vector3 vector = base.transform.position * 10f;
		int x = Mathf.RoundToInt(vector.x);
		int y = Mathf.RoundToInt(vector.y);
		int z = Mathf.RoundToInt(vector.z);
		return new Vector3Int(x, y, z).GetHashCode();
	}

	protected override void Start()
	{
		base.Start();
		if (inventoryReference == null)
		{
			GetOrCreateInventory(this);
		}
		if ((bool)Inventory && Inventory.hasBeenInspectedInLootBox)
		{
			SetMarkerUsed();
		}
		overrideInteractName = true;
		base.InteractName = displayNameKey;
	}

	protected override bool IsInteractable()
	{
		if (Inventory == null)
		{
			if ((bool)CharacterMainControl.Main)
			{
				CharacterMainControl.Main.PopText("ERROR :( 存在不包含Inventory的Lootbox。");
			}
			return false;
		}
		if (lootState != LootBoxStates.closed)
		{
			return false;
		}
		return true;
	}

	protected override void OnUpdate(CharacterMainControl interactCharacter, float deltaTime)
	{
		if (Inventory == null)
		{
			StopInteract();
			if ((bool)LootView.Instance && LootView.Instance.open)
			{
				LootView.Instance.Close();
			}
			return;
		}
		switch (lootState)
		{
		case LootBoxStates.closed:
			StopInteract();
			break;
		case LootBoxStates.openning:
			if (interactCharacter.CurrentAction.ActionTimer >= base.InteractTime && !Inventory.Loading)
			{
				if (StartLoot())
				{
					lootState = LootBoxStates.looting;
					break;
				}
				CharacterMainControl.Main.PopText("ERROR :Start loot失败，终止交互。");
				StopInteract();
				lootState = LootBoxStates.closed;
			}
			break;
		case LootBoxStates.looting:
			if (!LootView.Instance || !LootView.Instance.open)
			{
				CharacterMainControl.Main.PopText("ERROR :打开Loot界面失败，终止交互。");
				StopInteract();
			}
			else if (inspectingItem != null)
			{
				inspectTimer += deltaTime;
				if (inspectTimer >= inspectTime)
				{
					inspectingItem.Inspected = true;
					inspectingItem.Inspecting = false;
				}
				if (!inspectingItem.Inspecting)
				{
					inspectingItem = null;
				}
			}
			else
			{
				Item item = FindFistUninspectedItem();
				if (!item)
				{
					StopInteract();
				}
				else
				{
					StartInspectItem(item);
				}
			}
			break;
		}
	}

	private void StartInspectItem(Item item)
	{
		if (!(item == null))
		{
			if (inspectingItem != null)
			{
				inspectingItem.Inspecting = false;
			}
			inspectingItem = item;
			inspectingItem.Inspecting = true;
			inspectTimer = 0f;
			inspectTime = GameplayDataSettings.LootingData.GetInspectingTime(item);
		}
	}

	private void UpdateInspect()
	{
	}

	private Item FindFistUninspectedItem()
	{
		if (!Inventory)
		{
			return null;
		}
		if (!Inventory.NeedInspection)
		{
			return null;
		}
		return Inventory.FirstOrDefault((Item e) => !e.Inspected);
	}

	protected override void OnInteractStart(CharacterMainControl interactCharacter)
	{
		lootState = LootBoxStates.openning;
	}

	protected override void OnInteractStop()
	{
		lootState = LootBoxStates.closed;
		InteractableLootbox.OnStopLoot?.Invoke(this);
		if (inspectingItem != null)
		{
			inspectingItem.Inspecting = false;
		}
		if ((bool)Inventory)
		{
			Inventory.hasBeenInspectedInLootBox = true;
		}
		SetMarkerUsed();
		CheckHideIfEmpty();
	}

	protected override void OnInteractFinished()
	{
		base.OnInteractFinished();
		if (inspectingItem != null)
		{
			inspectingItem.Inspecting = false;
		}
		CheckHideIfEmpty();
	}

	public void CheckHideIfEmpty()
	{
		if ((bool)hideIfEmpty && Inventory.IsEmpty())
		{
			hideIfEmpty.gameObject.SetActive(value: false);
		}
	}

	private bool StartLoot()
	{
		if (Inventory == null)
		{
			StopInteract();
			UnityEngine.Debug.LogError("开始loot失败，缺少inventory。");
			return false;
		}
		InteractableLootbox.OnStartLoot?.Invoke(this);
		return true;
	}

	private void CreateLocalInventory()
	{
		Inventory inventory = base.gameObject.AddComponent<Inventory>();
		inventoryReference = inventory;
	}

	public static InteractableLootbox CreateFromItem(Item item, Vector3 position, Quaternion rotation, bool moveToMainScene = true, InteractableLootbox prefab = null, bool filterDontDropOnDead = false)
	{
		if (item == null)
		{
			UnityEngine.Debug.LogError("正在尝试给一个不存在的Item创建LootBox，已取消。");
			return null;
		}
		if (prefab == null)
		{
			prefab = Prefab;
		}
		if (prefab == null)
		{
			UnityEngine.Debug.LogError("未配置LootBox的Prefab");
			return null;
		}
		InteractableLootbox interactableLootbox = UnityEngine.Object.Instantiate(prefab, position, rotation);
		interactableLootbox.CreateLocalInventory();
		if (moveToMainScene)
		{
			MultiSceneCore.MoveToActiveWithScene(interactableLootbox.gameObject, SceneManager.GetActiveScene().buildIndex);
		}
		Inventory inventory = interactableLootbox.Inventory;
		if (inventory == null)
		{
			UnityEngine.Debug.LogError("LootBox未配置Inventory");
			return interactableLootbox;
		}
		inventory.SetCapacity(512);
		List<Item> list = new List<Item>();
		if (item.Slots != null)
		{
			foreach (Slot slot in item.Slots)
			{
				Item content = slot.Content;
				if (!(content == null))
				{
					content.Inspected = true;
					if (content.Tags.Contains(GameplayDataSettings.Tags.DestroyOnLootBox))
					{
						content.DestroyTree();
					}
					if (!filterDontDropOnDead || (!content.Tags.Contains(GameplayDataSettings.Tags.DontDropOnDeadInSlot) && !content.Sticky))
					{
						list.Add(content);
					}
				}
			}
		}
		if (item.Inventory != null)
		{
			foreach (Item item2 in item.Inventory)
			{
				if (!(item2 == null) && !item2.Tags.Contains(GameplayDataSettings.Tags.DestroyOnLootBox))
				{
					list.Add(item2);
				}
			}
		}
		foreach (Item item3 in list)
		{
			item3.Detach();
			inventory.AddAndMerge(item3);
		}
		int capacity = Mathf.Max(8, inventory.GetLastItemPosition() + 1);
		inventory.SetCapacity(capacity);
		inventory.NeedInspection = prefab.needInspect;
		return interactableLootbox;
	}
}
public class InteractablePickup : InteractableBase
{
	[SerializeField]
	private DuckovItemAgent itemAgent;

	public SpriteRenderer sprite;

	private Rigidbody rb;

	private Vector3 throwStartPoint;

	private bool destroied;

	public DuckovItemAgent ItemAgent => itemAgent;

	protected override bool IsInteractable()
	{
		return true;
	}

	public void OnInit()
	{
		if ((bool)itemAgent && (bool)itemAgent.Item && (bool)sprite)
		{
			sprite.sprite = itemAgent.Item.Icon;
		}
		overrideInteractName = true;
		base.InteractName = itemAgent.Item.DisplayNameRaw;
	}

	protected override void OnInteractStart(CharacterMainControl character)
	{
		character.PickupItem(itemAgent.Item);
		StopInteract();
	}

	public void Throw(Vector3 direction, float randomAngle)
	{
		throwStartPoint = base.transform.position;
		if (!rb)
		{
			rb = base.gameObject.AddComponent<Rigidbody>();
		}
		rb.collisionDetectionMode = CollisionDetectionMode.Continuous;
		rb.constraints = RigidbodyConstraints.FreezeRotation;
		if (direction.magnitude < 0.1f)
		{
			direction = Vector3.zero;
		}
		else
		{
			direction.y = 0f;
			direction.Normalize();
			direction = Quaternion.Euler(0f, UnityEngine.Random.Range(0f - randomAngle, randomAngle) * 0.5f, 0f) * direction;
			direction *= UnityEngine.Random.Range(0.5f, 1f) * 3f;
			direction.y = 2.5f;
		}
		rb.velocity = direction;
		DestroyRigidbody().Forget();
	}

	protected override void OnDestroy()
	{
		destroied = true;
		base.OnDestroy();
	}

	private async UniTaskVoid DestroyRigidbody()
	{
		await UniTask.WaitForSeconds(3);
		if (destroied || !rb)
		{
			return;
		}
		if (rb.velocity.y < -0.2f)
		{
			rb.transform.position = throwStartPoint;
			rb.position = throwStartPoint;
			await UniTask.WaitForSeconds(3);
		}
		if (!destroied && (bool)rb)
		{
			if (rb.velocity.y < -0.2f)
			{
				rb.transform.position = throwStartPoint;
				rb.position = throwStartPoint;
			}
			if ((bool)rb)
			{
				UnityEngine.Object.Destroy(rb);
			}
		}
	}
}
public class InteractMarker : MonoBehaviour
{
	private bool markedAsUsed;

	public GameObject showIfUsedObject;

	public GameObject hideIfUsedObject;

	public void MarkAsUsed()
	{
		if (!markedAsUsed)
		{
			markedAsUsed = true;
			if ((bool)hideIfUsedObject)
			{
				hideIfUsedObject.SetActive(value: false);
			}
			if ((bool)showIfUsedObject)
			{
				showIfUsedObject.SetActive(value: true);
			}
		}
	}
}
public class ItemStarterkit : InteractableBase
{
	[ItemTypeID]
	[SerializeField]
	private List<int> items;

	[SerializeField]
	private GameObject notPickedItem;

	[SerializeField]
	private GameObject pickedItem;

	[SerializeField]
	private GameObject pickFX;

	private List<Item> itemsCache;

	[SerializeField]
	private string notificationTextKey;

	private bool caching;

	private bool cached;

	private bool picked;

	private string saveKey = "StarterKit_Picked";

	protected override bool IsInteractable()
	{
		if (picked)
		{
			return false;
		}
		if (!cached)
		{
			return false;
		}
		return true;
	}

	private async UniTask CacheItems()
	{
		if (caching || cached)
		{
			return;
		}
		caching = true;
		cached = false;
		itemsCache = new List<Item>();
		foreach (int item2 in items)
		{
			Item item = await ItemAssetsCollection.InstantiateAsync(item2);
			if (!(item == null))
			{
				item.transform.SetParent(base.transform);
				itemsCache.Add(item);
			}
		}
		caching = false;
		cached = true;
	}

	protected override void Awake()
	{
		base.Awake();
		SavesSystem.OnCollectSaveData += Save;
		SceneLoader.onStartedLoadingScene += OnStartedLoadingScene;
	}

	protected override void OnDestroy()
	{
		SavesSystem.OnCollectSaveData -= Save;
		SceneLoader.onStartedLoadingScene -= OnStartedLoadingScene;
		base.OnDestroy();
	}

	private void OnStartedLoadingScene(SceneLoadingContext context)
	{
		picked = false;
		Save();
	}

	private void Save()
	{
		SavesSystem.Save(saveKey, picked);
	}

	private void Load()
	{
		picked = SavesSystem.Load<bool>(saveKey);
		base.MarkerActive = !picked;
		if ((bool)notPickedItem)
		{
			notPickedItem?.SetActive(!picked);
		}
		if ((bool)pickedItem)
		{
			pickedItem.SetActive(picked);
		}
	}

	protected override void Start()
	{
		base.Start();
		Load();
		if (!picked)
		{
			CacheItems().Forget();
		}
	}

	protected override void OnInteractFinished()
	{
		foreach (Item item in itemsCache)
		{
			ItemUtilities.SendToPlayerCharacter(item);
		}
		picked = true;
		base.MarkerActive = !picked;
		itemsCache.Clear();
		OnPicked();
	}

	private void OnPicked()
	{
		if ((bool)notPickedItem)
		{
			notPickedItem.SetActive(value: false);
		}
		if ((bool)pickedItem)
		{
			pickedItem.SetActive(value: true);
		}
		if ((bool)pickFX)
		{
			pickFX.SetActive(value: true);
		}
		NotificationText.Push(notificationTextKey.ToPlainText());
	}
}
public class OnTriggerEnterEvent : MonoBehaviour
{
	public bool onlyMainCharacter;

	public bool filterByTeam;

	public Teams selfTeam;

	public LayerMask layerMask;

	public bool triggerOnce;

	public UnityEvent DoOnTriggerEnter = new UnityEvent();

	public UnityEvent DoOnTriggerExit = new UnityEvent();

	private bool triggered;

	private bool mainCharacterIn;

	private bool hideLayerMask
	{
		get
		{
			if (!onlyMainCharacter)
			{
				return filterByTeam;
			}
			return true;
		}
	}

	private void Awake()
	{
		Init();
	}

	public void Init()
	{
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			component.isTrigger = true;
		}
		if (filterByTeam)
		{
			layerMask = 1 << LayerMask.NameToLayer("Character");
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		OnEvent(collision.gameObject, enter: true);
	}

	private void OnCollisionExit(Collision collision)
	{
		OnEvent(collision.gameObject, enter: false);
	}

	private void OnTriggerEnter(Collider other)
	{
		OnEvent(other.gameObject, enter: true);
	}

	private void OnTriggerExit(Collider other)
	{
		OnEvent(other.gameObject, enter: false);
	}

	private void OnEvent(GameObject other, bool enter)
	{
		if (triggerOnce && triggered)
		{
			return;
		}
		if (onlyMainCharacter)
		{
			if (CharacterMainControl.Main == null || other != CharacterMainControl.Main.gameObject)
			{
				return;
			}
		}
		else
		{
			if (((1 << other.layer) | (int)layerMask) != (int)layerMask)
			{
				return;
			}
			if (filterByTeam)
			{
				CharacterMainControl component = other.GetComponent<CharacterMainControl>();
				if (!component)
				{
					return;
				}
				Teams team = component.Team;
				if (!Team.IsEnemy(selfTeam, team))
				{
					return;
				}
			}
		}
		triggered = true;
		if (enter)
		{
			DoOnTriggerEnter?.Invoke();
		}
		else
		{
			DoOnTriggerExit?.Invoke();
		}
	}
}
public class SetDoorOpenIfSaveData : MonoBehaviour
{
	public Door door;

	public string key;

	public bool openIfDataTure = true;

	private void Start()
	{
		if (LevelManager.LevelInited)
		{
			OnSet();
		}
		else
		{
			LevelManager.OnLevelInitialized += OnSet;
		}
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= OnSet;
	}

	private void OnSet()
	{
		bool flag = SavesSystem.Load<bool>(key);
		UnityEngine.Debug.Log($"Load door data:{key}  {flag}");
		door.ForceSetClosed(flag != openIfDataTure, triggerEvent: false);
	}
}
public enum HandheldSocketTypes
{
	normalHandheld = 1,
	meleeWeapon,
	leftHandSocket
}
public enum HandheldAnimationType
{
	normal = 1,
	gun,
	meleeWeapon,
	bow
}
public class DuckovItemAgent : ItemAgent
{
	public HandheldSocketTypes handheldSocket = HandheldSocketTypes.normalHandheld;

	public HandheldAnimationType handAnimationType = HandheldAnimationType.normal;

	private CharacterMainControl holder;

	public UnityEvent OnInitializdEvent;

	[SerializeField]
	private List<Transform> socketsList = new List<Transform>();

	public GameObject setActiveIfMainCharacter;

	private Dictionary<string, Transform> _socketsDic;

	private IAgentUsable usableInterface;

	public CharacterMainControl Holder => holder;

	private Dictionary<string, Transform> SocketsDic
	{
		get
		{
			if (_socketsDic == null)
			{
				_socketsDic = new Dictionary<string, Transform>();
				foreach (Transform sockets in socketsList)
				{
					_socketsDic.Add(sockets.name, sockets);
				}
			}
			return _socketsDic;
		}
	}

	public IAgentUsable UsableInterface => usableInterface;

	public Transform GetSocket(string socketName, bool createNew)
	{
		Transform value;
		bool num = SocketsDic.TryGetValue(socketName, out value);
		if (num && value == null)
		{
			SocketsDic.Remove(socketName);
		}
		if (!num && createNew)
		{
			value = new GameObject(socketName).transform;
			value.SetParent(base.transform);
			value.localPosition = Vector3.zero;
			value.localRotation = Quaternion.identity;
			SocketsDic.Add(socketName, value);
		}
		return value;
	}

	public void SetHolder(CharacterMainControl _holder)
	{
		holder = _holder;
		if ((bool)setActiveIfMainCharacter)
		{
			setActiveIfMainCharacter.SetActive(_holder.IsMainCharacter);
		}
	}

	public CharacterMainControl GetHolder()
	{
		return holder;
	}

	protected override void OnInitialize()
	{
		base.OnInitialize();
		InitInterfaces();
		OnInitializdEvent?.Invoke();
	}

	private void InitInterfaces()
	{
		usableInterface = this as IAgentUsable;
	}
}
public interface IAgentUsable
{
	bool BeginUse();
}
public class FishingRod : MonoBehaviour
{
	[SerializeField]
	private ItemAgent _selfAgent;

	private Slot baitSlot;

	public Transform lineStart;

	private ItemAgent selfAgent
	{
		get
		{
			if (_selfAgent == null)
			{
				_selfAgent = GetComponent<ItemAgent>();
			}
			return _selfAgent;
		}
	}

	public Item Bait
	{
		get
		{
			if (baitSlot == null)
			{
				baitSlot = selfAgent.Item.Slots.GetSlot("Bait");
			}
			if (baitSlot != null)
			{
				return baitSlot.Content;
			}
			return null;
		}
	}

	public bool UseBait()
	{
		Item bait = Bait;
		if (bait == null)
		{
			return false;
		}
		if (bait.Stackable)
		{
			bait.StackCount--;
		}
		else
		{
			bait.DestroyTree();
		}
		return true;
	}
}
public class ItemAgent_Gun : DuckovItemAgent
{
	public enum GunStates
	{
		shootCooling,
		ready,
		fire,
		burstEachShotCooling,
		empty,
		reloading
	}

	private Item _bulletItem;

	private static int ShootSpeedHash = "ShootSpeed".GetHashCode();

	private static int ReloadTimeHash = "ReloadTime".GetHashCode();

	private static int CapacityHash = "Capacity".GetHashCode();

	private static int DurabilityHash = "Durability".GetHashCode();

	private float maxDurability;

	private static int DamageHash = "Damage".GetHashCode();

	private static int BurstCountHash = "BurstCount".GetHashCode();

	private static int BulletSpeedHash = "BulletSpeed".GetHashCode();

	private static int BulletDistanceHash = "BulletDistance".GetHashCode();

	private static int PenetrateHash = "Penetrate".GetHashCode();

	private static int explosionDamageMultiplierHash = "ExplosionDamageMultiplier".GetHashCode();

	private static int CritRateHash = "CritRate".GetHashCode();

	private static int CritDamageFactorHash = "CritDamageFactor".GetHashCode();

	private static int SoundRangeHash = "SoundRange".GetHashCode();

	private static int ArmorPiercingHash = "ArmorPiercing".GetHashCode();

	private static int ArmorBreakHash = "ArmorBreak".GetHashCode();

	private static int ShotCountHash = "ShotCount".GetHashCode();

	private static int ShotAngleHash = "ShotAngle".GetHashCode();

	private static int ADSAimDistanceFactorHash = "ADSAimDistanceFactor".GetHashCode();

	private static int AdsTimeHash = "ADSTime".GetHashCode();

	private float scatterFactorHips = 1f;

	private float scatterFactorAds = 1f;

	private static int ScatterFactorHash = "ScatterFactor".GetHashCode();

	private static int ScatterFactorHashADS = "ScatterFactorADS".GetHashCode();

	private static int DefaultScatterHash = "DefaultScatter".GetHashCode();

	private static int DefaultScatterHashADS = "DefaultScatterADS".GetHashCode();

	private static int MaxScatterHash = "MaxScatter".GetHashCode();

	private static int MaxScatterHashADS = "MaxScatterADS".GetHashCode();

	private static int ScatterGrowHash = "ScatterGrow".GetHashCode();

	private static int ScatterGrowHashADS = "ScatterGrowADS".GetHashCode();

	private static int ScatterRecoverHash = "ScatterRecover".GetHashCode();

	private static int ScatterRecoverHashADS = "ScatterRecoverADS".GetHashCode();

	private static int RecoilVMinHash = "RecoilVMin".GetHashCode();

	private static int RecoilVMaxHash = "RecoilVMax".GetHashCode();

	private static int RecoilHMinHash = "RecoilHMin".GetHashCode();

	private static int RecoilHMaxHash = "RecoilHMax".GetHashCode();

	private static int RecoilScaleVHash = "RecoilScaleV".GetHashCode();

	private static int RecoilScaleHHash = "RecoilScaleH".GetHashCode();

	private static int RecoilRecoverHash = "RecoilRecover".GetHashCode();

	private static int RecoilTimeHash = "RecoilTime".GetHashCode();

	private static int RecoilRecoverTimeHash = "RecoilRecoverTime".GetHashCode();

	private static int MoveSpeedMultiplierHash = "MoveSpeedMultiplier".GetHashCode();

	private static int AdsWalkSpeedMultiplierHash = "AdsWalkSpeedMultiplier".GetHashCode();

	private static int BuffChanceHash = "BuffChance".GetHashCode();

	private static int bulletCritRateGainHash = "CritRateGain".GetHashCode();

	private static int bulletCritDamageFactorGainHash = "CritDamageFactorGain".GetHashCode();

	private static int bulletArmorPiercingGainHash = "ArmorPiercingGain".GetHashCode();

	private static int BulletDamageMultiplierHash = "damageMultiplier".GetHashCode();

	private static int bulletExplosionRangeHash = "ExplosionRange".GetHashCode();

	private static int BulletBuffChanceMultiplierHash = "buffChanceMultiplier".GetHashCode();

	private static int BulletBleedChanceHash = "bleedChance".GetHashCode();

	private static int bulletExplosionDamageHash = "ExplosionDamage".GetHashCode();

	private static int armorBreakGainHash = "ArmorBreakGain".GetHashCode();

	private static int bulletDurabilityCostHash = "DurabilityCost".GetHashCode();

	private int muzzleIndex;

	public GameObject loadedVisualObject;

	private float adsValue;

	private Transform _mz1;

	private Transform _mz2;

	private bool hasMz2 = true;

	[SerializeField]
	private ParticleSystem shellParticle;

	private ItemSetting_Gun _gunItemSetting;

	private bool triggerInput;

	private bool triggerThisFrame;

	private bool releaseThisFrame;

	private bool triggerBuffer;

	private float scatterBeforeControl;

	private FMOD.Studio.EventInstance? _shootSoundEvent;

	private FMOD.Studio.EventInstance? _reloadSoundLoopEvent;

	private float stateTimer;

	private int burstCounter;

	private Projectile projInst;

	private GunStates gunState = GunStates.ready;

	private bool needAutoReload;

	private bool loadBulletsStarted;

	private float _recoilMoveValue;

	private float _recoilDistance = 0.2f;

	private float _recoilBackSpeed = 20f;

	private float _recoilRecoverSpeed = 8f;

	private bool _recoilBack;

	public Item BulletItem
	{
		get
		{
			if (_bulletItem == null || _bulletItem.ParentItem != base.Item)
			{
				foreach (Item item in base.Item.Inventory)
				{
					if (item != null)
					{
						_bulletItem = item;
						break;
					}
				}
			}
			return _bulletItem;
		}
	}

	public float ShootSpeed => base.Item.GetStatValue(ShootSpeedHash);

	public float ReloadTime => base.Item.GetStatValue(ReloadTimeHash) / (1f + CharacterReloadSpeedGain);

	public int Capacity => Mathf.RoundToInt(base.Item.GetStatValue(CapacityHash));

	public float durabilityPercent => Durability / MaxDurability;

	public float Durability => base.Item.Variables.GetFloat(DurabilityHash);

	public float MaxDurability
	{
		get
		{
			if (maxDurability <= 0f)
			{
				maxDurability = base.Item.Constants.GetFloat("MaxDurability", 50f);
			}
			return maxDurability;
		}
	}

	public float Damage => base.Item.GetStatValue(DamageHash);

	public int BurstCount => Mathf.Max(1, Mathf.RoundToInt(base.Item.GetStatValue(BurstCountHash)));

	public float BulletSpeed => base.Item.GetStatValue(BulletSpeedHash);

	public float BulletDistance => base.Item.GetStatValue(BulletDistanceHash) * (base.Holder ? base.Holder.GunDistanceMultiplier : 1f);

	public int Penetrate => Mathf.RoundToInt(base.Item.GetStatValue(PenetrateHash));

	public float ExplosionDamageMultiplier => base.Item.GetStatValue(explosionDamageMultiplierHash);

	public float CritRate => base.Item.GetStatValue(CritRateHash);

	public float CritDamageFactor => base.Item.GetStatValue(CritDamageFactorHash);

	public float SoundRange => base.Item.GetStatValue(SoundRangeHash);

	public bool Silenced
	{
		get
		{
			Stat stat = base.Item.GetStat(SoundRangeHash);
			return stat.Value < stat.BaseValue * 0.95f;
		}
	}

	public float ArmorPiercing => base.Item.GetStatValue(ArmorPiercingHash);

	public float ArmorBreak => base.Item.GetStatValue(ArmorBreakHash);

	public int ShotCount => Mathf.RoundToInt(base.Item.GetStatValue(ShotCountHash));

	public float ShotAngle => base.Item.GetStatValue(ShotAngleHash) * (IsInAds ? 0.5f : 1f);

	public float ADSAimDistanceFactor => base.Item.GetStatValue(ADSAimDistanceFactorHash);

	public float AdsSpeed => 1f / base.Item.GetStatValue(AdsTimeHash);

	public float DefaultScatter
	{
		get
		{
			float a = base.Item.GetStatValue(DefaultScatterHash) * scatterFactorHips;
			float b = base.Item.GetStatValue(DefaultScatterHashADS) * scatterFactorAds;
			return Mathf.Lerp(a, b, adsValue);
		}
	}

	public float MaxScatter
	{
		get
		{
			float a = base.Item.GetStatValue(MaxScatterHash) * scatterFactorHips;
			float b = base.Item.GetStatValue(MaxScatterHashADS) * scatterFactorAds;
			return Mathf.Lerp(a, b, adsValue);
		}
	}

	public float ScatterGrow
	{
		get
		{
			float a = base.Item.GetStatValue(ScatterGrowHash) * scatterFactorHips;
			float b = base.Item.GetStatValue(ScatterGrowHashADS) * scatterFactorAds;
			return Mathf.Lerp(a, b, adsValue);
		}
	}

	public float ScatterRecover
	{
		get
		{
			float statValue = base.Item.GetStatValue(ScatterRecoverHash);
			float statValue2 = base.Item.GetStatValue(ScatterRecoverHashADS);
			return Mathf.Lerp(statValue, statValue2, adsValue) * ScatterGrow * ShootSpeed;
		}
	}

	public float RecoilVMin => base.Item.GetStatValue(RecoilVMinHash);

	public float RecoilVMax => base.Item.GetStatValue(RecoilVMaxHash);

	public float RecoilHMin => base.Item.GetStatValue(RecoilHMinHash);

	public float RecoilHMax => base.Item.GetStatValue(RecoilHMaxHash);

	public float RecoilScaleV => base.Item.GetStatValue(RecoilScaleVHash);

	public float RecoilScaleH => base.Item.GetStatValue(RecoilScaleHHash);

	public float RecoilRecover => base.Item.GetStatValue(RecoilRecoverHash);

	public float RecoilTime => base.Item.GetStatValue(RecoilTimeHash);

	public float RecoilRecoverTime => base.Item.GetStatValue(RecoilRecoverTimeHash);

	public float MoveSpeedMultiplier => base.Item.GetStatValue(MoveSpeedMultiplierHash);

	public float AdsWalkSpeedMultiplier => Mathf.Min(1f, base.Item.GetStatValue(AdsWalkSpeedMultiplierHash));

	public float burstCoolTime => 1f / ShootSpeed * ((float)(3 * BurstCount) / ((float)BurstCount + 2f));

	public float burstShotTimeSpace => 1f / ShootSpeed * ((float)BurstCount / ((float)BurstCount + 2f));

	public float BuffChance => base.Item.GetStatValue(BuffChanceHash);

	public float bulletCritRateGain
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(bulletCritRateGainHash);
			}
			return 0f;
		}
	}

	public float BulletCritDamageFactorGain
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(bulletCritDamageFactorGainHash);
			}
			return 0f;
		}
	}

	public float BulletArmorPiercingGain
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(bulletArmorPiercingGainHash);
			}
			return 0f;
		}
	}

	public float BulletDamageMultiplier
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(BulletDamageMultiplierHash);
			}
			return 0f;
		}
	}

	public float BulletExplosionRange
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(bulletExplosionRangeHash);
			}
			return 0f;
		}
	}

	public float BulletBuffChanceMultiplier
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(BulletBuffChanceMultiplierHash);
			}
			return 0f;
		}
	}

	public float BulletBleedChance
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(BulletBleedChanceHash);
			}
			return 0f;
		}
	}

	public float BulletExplosionDamage
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(bulletExplosionDamageHash);
			}
			return 0f;
		}
	}

	public float BulletArmorBreakGain
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(armorBreakGainHash);
			}
			return 0f;
		}
	}

	public float bulletDurabilityCost
	{
		get
		{
			if ((bool)BulletItem)
			{
				return BulletItem.Constants.GetFloat(bulletDurabilityCostHash);
			}
			return 0f;
		}
	}

	public float CharacterDamageMultiplier
	{
		get
		{
			if (!base.Holder)
			{
				return 0f;
			}
			return base.Holder.GunDamageMultiplier;
		}
	}

	public float CharacterReloadSpeedGain
	{
		get
		{
			if (!base.Holder)
			{
				return 0f;
			}
			return base.Holder.ReloadSpeedGain;
		}
	}

	public float CharacterGunCritRateGain
	{
		get
		{
			if (!base.Holder)
			{
				return 0f;
			}
			return base.Holder.GunCritRateGain;
		}
	}

	public float CharacterGunCritDamageGain
	{
		get
		{
			if (!base.Holder)
			{
				return 0f;
			}
			return base.Holder.GunCritDamageGain;
		}
	}

	public float CharacterRecoilControl
	{
		get
		{
			if (!base.Holder)
			{
				return 1f;
			}
			return base.Holder.RecoilControl;
		}
	}

	public float CharacterScatterMultiplier
	{
		get
		{
			if (!base.Holder)
			{
				return 1f;
			}
			return Mathf.Max(0.1f, base.Holder.GunScatterMultiplier);
		}
	}

	public int BulletCount
	{
		get
		{
			if (!GunItemSetting)
			{
				return 0;
			}
			return GunItemSetting.BulletCount;
		}
	}

	public float AdsValue => adsValue;

	public Transform muzzle
	{
		get
		{
			if (muzzleIndex != 0 && muzzle2 != null)
			{
				return muzzle2;
			}
			return muzzle1;
		}
	}

	private Transform muzzle1
	{
		get
		{
			if (_mz1 == null)
			{
				_mz1 = GetSocket("Muzzle", createNew: true);
			}
			return _mz1;
		}
	}

	private Transform muzzle2
	{
		get
		{
			if (_mz2 == null && hasMz2)
			{
				_mz2 = GetSocket("Muzzle2", createNew: false);
				if (_mz2 == null)
				{
					hasMz2 = false;
				}
			}
			return _mz2;
		}
	}

	private GameObject muzzleFxPfb => GunItemSetting.muzzleFxPfb;

	public ItemSetting_Gun GunItemSetting
	{
		get
		{
			if (!_gunItemSetting && (bool)base.Item)
			{
				_gunItemSetting = base.Item.GetComponent<ItemSetting_Gun>();
			}
			return _gunItemSetting;
		}
	}

	public bool IsInAds
	{
		get
		{
			if (!base.Holder)
			{
				return false;
			}
			return base.Holder.IsInAdsInput;
		}
	}

	public float CurrentScatter => scatterBeforeControl * CharacterScatterMultiplier;

	public float MinScatter => DefaultScatter;

	public float StateTimer => stateTimer;

	public GunStates GunState => gunState;

	public static event Action<ItemAgent_Gun> OnMainCharacterShootEvent;

	public event Action OnShootEvent;

	public event Action OnLoadedEvent;

	private void Update()
	{
		UpdateGun();
		UpdateScatterFactor();
		triggerInput = false;
		triggerThisFrame = false;
		releaseThisFrame = false;
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		StopReloadSound();
	}

	private void UpdateScatterFactor()
	{
		scatterFactorHips = base.Item.GetStatValue(ScatterFactorHash);
		scatterFactorAds = base.Item.GetStatValue(ScatterFactorHashADS);
	}

	private void UpdateGun()
	{
		float maxScatter = MaxScatter;
		if (scatterBeforeControl > maxScatter)
		{
			scatterBeforeControl = maxScatter;
		}
		scatterBeforeControl = Mathf.MoveTowards(scatterBeforeControl, DefaultScatter, ScatterRecover * Time.deltaTime * ((scatterBeforeControl < DefaultScatter) ? 6f : 1f));
		UpdateStates();
		UpdateAds();
		UpdateVisualRecoil();
	}

	protected override void OnInitialize()
	{
		base.OnInitialize();
		if ((bool)GunItemSetting)
		{
			if ((bool)base.Holder && (bool)base.Holder.CharacterItem && (bool)base.Holder.CharacterItem.Inventory)
			{
				GunItemSetting.AutoSetTypeInInventory(base.Holder.CharacterItem.Inventory);
			}
			else
			{
				GunItemSetting.AutoSetTypeInInventory(null);
			}
			scatterBeforeControl = DefaultScatter;
			if (loadedVisualObject != null)
			{
				loadedVisualObject.SetActive(GunItemSetting.BulletCount > 0);
			}
		}
	}

	public void UpdateStates()
	{
		if (GunItemSetting.LoadingBullets)
		{
			return;
		}
		if (triggerThisFrame && ShootSpeed >= 5f)
		{
			triggerBuffer = true;
			triggerThisFrame = false;
		}
		switch (gunState)
		{
		case GunStates.shootCooling:
			stateTimer += Time.deltaTime;
			if (stateTimer >= burstCoolTime)
			{
				TransToReady();
			}
			break;
		case GunStates.ready:
		{
			bool flag = false;
			if (BulletCount <= 0)
			{
				TransToEmpty();
			}
			else if (GunItemSetting.triggerMode == ItemSetting_Gun.TriggerModes.auto)
			{
				if (triggerInput)
				{
					flag = true;
				}
			}
			else if ((GunItemSetting.triggerMode == ItemSetting_Gun.TriggerModes.semi || GunItemSetting.triggerMode == ItemSetting_Gun.TriggerModes.bolt) && (triggerBuffer || triggerThisFrame))
			{
				triggerThisFrame = false;
				triggerBuffer = false;
				flag = true;
			}
			if (flag)
			{
				TransToFire(triggerThisFrame);
			}
			else if (needAutoReload)
			{
				needAutoReload = false;
				CharacterReload();
			}
			break;
		}
		case GunStates.fire:
			triggerBuffer = false;
			if (BulletCount <= 0)
			{
				muzzleIndex = ((muzzleIndex == 0) ? 1 : 0);
				TransToEmpty();
			}
			else if (burstCounter >= BurstCount)
			{
				muzzleIndex = ((muzzleIndex == 0) ? 1 : 0);
				TransToBurstCooling();
			}
			else
			{
				TransToBurstEachShotCooling();
			}
			break;
		case GunStates.burstEachShotCooling:
			stateTimer += Time.deltaTime;
			if (stateTimer >= burstShotTimeSpace)
			{
				TransToFire(isFirstShot: false);
			}
			break;
		case GunStates.empty:
			if (needAutoReload)
			{
				needAutoReload = false;
				CharacterReload();
			}
			else if ((triggerThisFrame || triggerBuffer) && base.Holder != null)
			{
				triggerThisFrame = false;
				triggerBuffer = false;
				base.Holder.TryToReload();
			}
			break;
		case GunStates.reloading:
			triggerBuffer = false;
			stateTimer += Time.deltaTime;
			if (stateTimer < ReloadTime)
			{
				loadBulletsStarted = false;
			}
			else if (!loadBulletsStarted)
			{
				loadBulletsStarted = true;
				StartLoadBullets();
			}
			else if (!GunItemSetting.LoadingBullets)
			{
				if (GunItemSetting.LoadBulletsSuccess)
				{
					PostReloadSuccessSound();
				}
				needAutoReload = GunItemSetting.reloadMode == ItemSetting_Gun.ReloadModes.singleBullet && !GunItemSetting.IsFull();
				loadBulletsStarted = false;
				if (GunItemSetting.BulletCount > 0 && loadedVisualObject != null)
				{
					loadedVisualObject.SetActive(value: true);
				}
				this.OnLoadedEvent?.Invoke();
				TransToReady();
			}
			break;
		}
	}

	private void UpdateAds()
	{
		float num = 0f;
		if ((bool)base.Holder && base.Holder.IsInAdsInput)
		{
			num = 1f;
		}
		float num2 = AdsSpeed;
		if (num == 0f)
		{
			num2 = Mathf.Max(num2, 4f);
		}
		adsValue = Mathf.MoveTowards(adsValue, num, Time.deltaTime * num2);
	}

	private void TransToBurstCooling()
	{
		gunState = GunStates.shootCooling;
		burstCounter = 0;
		stateTimer = 0f;
	}

	private void TransToReady()
	{
		gunState = GunStates.ready;
		burstCounter = 0;
	}

	private void TransToFire(bool isFirstShot)
	{
		if (BulletCount <= 0 || base.Item.Durability <= 0f)
		{
			return;
		}
		gunState = GunStates.fire;
		Vector3 vector = muzzle.forward;
		if ((bool)base.Holder && base.Holder.CharacterMoveability > 0.5f)
		{
			Vector3 currentAimPoint = base.Holder.GetCurrentAimPoint();
			currentAimPoint.y = 0f;
			Vector3 position = base.Holder.transform.position;
			position.y = 0f;
			Vector3 position2 = muzzle.position;
			position2.y = 0f;
			if (Vector3.Distance(position, currentAimPoint) > Vector3.Distance(position, position2) + 0.1f)
			{
				vector = base.Holder.GetCurrentAimPoint() - muzzle.position;
				vector.Normalize();
			}
		}
		for (int i = 0; i < ShotCount; i++)
		{
			Vector3 vector2 = vector;
			float num = ShotAngle;
			bool flag = num > 359f;
			if (flag)
			{
				num -= num / (float)ShotCount;
			}
			float num2 = (0f - num) * 0.5f;
			float num3 = num / ((float)ShotCount - 1f);
			if ((float)ShotCount % 2f < 0.01f && flag)
			{
				num2 -= num3 * 0.5f;
			}
			if (ShotCount > 1)
			{
				vector2 = Quaternion.Euler(0f, num2 + (float)i * num3, 0f) * vector;
			}
			Vector3 localPosition = muzzle.localPosition;
			localPosition.y = 0f;
			float magnitude = localPosition.magnitude;
			ShootOneBullet(muzzle.position, vector2, muzzle.position - magnitude * vector2);
			if (base.Holder != null)
			{
				AIMainBrain.MakeSound(new AISound
				{
					fromCharacter = base.Holder,
					fromObject = base.gameObject,
					pos = muzzle.position,
					soundType = SoundTypes.combatSound,
					fromTeam = base.Holder.Team,
					radius = SoundRange
				});
			}
		}
		PostShootSound();
		scatterBeforeControl = Mathf.Clamp(scatterBeforeControl + ScatterGrow, DefaultScatter, MaxScatter);
		AimRecoil(vector);
		if (base.Holder == LevelManager.Instance.MainCharacter)
		{
			LevelManager.Instance.InputManager.AddRecoil(this);
		}
		StartVisualRecoil();
		GunItemSetting.UseABullet();
		base.Holder.TriggerShootEvent(this);
		this.OnShootEvent?.Invoke();
		if (BulletCount <= 0 && GunItemSetting.autoReload)
		{
			needAutoReload = true;
		}
		if (GunItemSetting.BulletCount <= 0 && loadedVisualObject != null)
		{
			loadedVisualObject.SetActive(value: false);
		}
		if ((bool)base.Holder && base.Holder.IsMainCharacter && LevelManager.Instance.IsRaidMap)
		{
			base.Item.Durability = Mathf.Max(0f, base.Item.Durability - bulletDurabilityCost);
		}
		if ((bool)muzzleFxPfb)
		{
			UnityEngine.Object.Instantiate(muzzleFxPfb, muzzle.position, muzzle.rotation).transform.SetParent(muzzle);
		}
		if ((bool)shellParticle)
		{
			shellParticle.Emit(1);
		}
		burstCounter++;
		if ((bool)base.Holder && base.Holder.IsMainCharacter)
		{
			CameraShaker.Shake(-muzzle.forward * 0.07f, CameraShaker.CameraShakeTypes.recoil);
			ItemAgent_Gun.OnMainCharacterShootEvent?.Invoke(this);
		}
	}

	private void TransToBurstEachShotCooling()
	{
		gunState = GunStates.burstEachShotCooling;
		stateTimer = 0f;
	}

	private void TransToEmpty()
	{
		gunState = GunStates.empty;
	}

	private void ShootOneBullet(Vector3 _muzzlePoint, Vector3 _shootDirection, Vector3 firstFrameCheckStartPoint)
	{
		bool flag = false;
		if (GunItemSetting.LoadingBullets || !BulletItem)
		{
			return;
		}
		if ((bool)base.Holder && base.Holder.IsMainCharacter)
		{
			flag = true;
		}
		ItemSetting_Bullet component = BulletItem.GetComponent<ItemSetting_Bullet>();
		float num = 0f;
		if (flag)
		{
			num = Mathf.Max(1f, CurrentScatter) * Mathf.Lerp(1.5f, 0f, Mathf.InverseLerp(0f, 0.5f, durabilityPercent));
		}
		float y = UnityEngine.Random.Range(-0.5f, 0.5f) * (CurrentScatter + num);
		_shootDirection = Quaternion.Euler(0f, y, 0f) * _shootDirection;
		_shootDirection.Normalize();
		Projectile projectile = _gunItemSetting.bulletPfb;
		if (projectile == null)
		{
			projectile = GameplayDataSettings.Prefabs.DefaultBullet;
		}
		projInst = LevelManager.Instance.BulletPool.GetABullet(projectile);
		projInst.transform.position = _muzzlePoint;
		projInst.transform.rotation = Quaternion.LookRotation(_shootDirection, Vector3.up);
		ProjectileContext context = new ProjectileContext
		{
			firstFrameCheck = true,
			firstFrameCheckStartPoint = firstFrameCheckStartPoint,
			direction = _shootDirection.normalized,
			speed = BulletSpeed
		};
		if ((bool)base.Holder)
		{
			context.team = base.Holder.Team;
			context.speed *= base.Holder.GunBulletSpeedMultiplier;
		}
		context.distance = BulletDistance + 0.4f;
		context.halfDamageDistance = context.distance * 0.5f;
		if (!flag)
		{
			context.distance *= 1.05f;
		}
		context.penetrate = Penetrate;
		float characterDamageMultiplier = CharacterDamageMultiplier;
		float num2 = 1f;
		context.damage = Damage * BulletDamageMultiplier * num2 * characterDamageMultiplier / (float)ShotCount;
		if (Damage > 1f && context.damage < 1f)
		{
			context.damage = 1f;
		}
		context.critDamageFactor = (CritDamageFactor + BulletCritDamageFactorGain) * (1f + CharacterGunCritDamageGain);
		context.critRate = CritRate * (1f + CharacterGunCritRateGain + bulletCritRateGain);
		if (flag)
		{
			context.critRate = (LevelManager.Instance.InputManager.AimingEnemyHead ? 1f : 0f);
		}
		context.armorPiercing = ArmorPiercing + BulletArmorPiercingGain;
		context.armorBreak = ArmorBreak + BulletArmorBreakGain;
		context.fromCharacter = base.Holder;
		context.explosionRange = BulletExplosionRange;
		context.explosionDamage = BulletExplosionDamage * ExplosionDamageMultiplier;
		switch (_gunItemSetting.element)
		{
		case ElementTypes.physics:
			context.element_Physics = 1f;
			break;
		case ElementTypes.fire:
			context.element_Fire = 1f;
			break;
		case ElementTypes.poison:
			context.element_Poison = 1f;
			break;
		case ElementTypes.electricity:
			context.element_Electricity = 1f;
			break;
		case ElementTypes.space:
			context.element_Space = 1f;
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
		context.fromWeaponItemID = base.Item.TypeID;
		context.buff = _gunItemSetting.buff;
		if ((bool)component)
		{
			context.buffChance = BulletBuffChanceMultiplier * BuffChance;
		}
		context.bleedChance = BulletBleedChance;
		if ((bool)base.Holder)
		{
			if (flag)
			{
				if (base.Holder.HasNearByHalfObsticle())
				{
					context.ignoreHalfObsticle = true;
				}
			}
			else
			{
				projInst.damagedObjects.AddRange(base.Holder.GetNearByHalfObsticles());
			}
		}
		if (context.critRate > 0.99f)
		{
			context.ignoreHalfObsticle = true;
		}
		projInst.Init(context);
	}

	private void AimRecoil(Vector3 shootDir)
	{
		if ((bool)base.Holder && base.Holder == CharacterMainControl.Main)
		{
			Vector3 currentAimDirection = base.Holder.CurrentAimDirection;
			currentAimDirection.y = 0f;
			currentAimDirection = currentAimDirection.normalized * 0.2f;
		}
	}

	public bool CharacterReload(Item prefererdBullet = null)
	{
		if (!base.Holder)
		{
			return false;
		}
		return base.Holder.TryToReload(prefererdBullet);
	}

	public bool BeginReload()
	{
		if (gunState != GunStates.ready && gunState != GunStates.empty && gunState != GunStates.shootCooling)
		{
			return false;
		}
		burstCounter = 0;
		if (GunItemSetting.PreferdBulletsToLoad != null)
		{
			GunItemSetting.SetTargetBulletType(GunItemSetting.PreferdBulletsToLoad);
		}
		if (GunItemSetting.TargetBulletID == -1)
		{
			GunItemSetting.AutoSetTypeInInventory(base.Holder.CharacterItem.Inventory);
		}
		if (GunItemSetting.TargetBulletID == -1)
		{
			return false;
		}
		int num = -1;
		Item currentLoadedBullet = GunItemSetting.GetCurrentLoadedBullet();
		if (currentLoadedBullet != null)
		{
			num = currentLoadedBullet.TypeID;
		}
		if (BulletCount >= Capacity && num == GunItemSetting.TargetBulletID)
		{
			return false;
		}
		if (GunItemSetting.PreferdBulletsToLoad == null && GunItemSetting.GetBulletCountofTypeInInventory(GunItemSetting.TargetBulletID, base.Holder.CharacterItem.Inventory) <= 0)
		{
			if ((bool)base.Holder && GunItemSetting.BulletCount <= 0)
			{
				base.Holder.PopText("Poptext_OutOfAmmo".ToPlainText());
			}
			return false;
		}
		gunState = GunStates.reloading;
		stateTimer = 0f;
		PostStartReloadSound();
		return true;
	}

	private void PostStartReloadSound()
	{
		if (_reloadSoundLoopEvent.HasValue)
		{
			_reloadSoundLoopEvent.Value.stop(FMOD.Studio.STOP_MODE.IMMEDIATE);
		}
		if (base.gameObject.activeInHierarchy)
		{
			string soundkey = GunItemSetting.reloadKey.ToLower() + "_start";
			string eventName = "SFX/Combat/Gun/Reload/{soundkey}".Format(new { soundkey });
			_reloadSoundLoopEvent = AudioManager.Post(eventName, base.gameObject);
		}
	}

	private void PostReloadSuccessSound()
	{
		if (_reloadSoundLoopEvent.HasValue)
		{
			_reloadSoundLoopEvent.Value.stop(FMOD.Studio.STOP_MODE.IMMEDIATE);
		}
		if (base.gameObject.activeInHierarchy)
		{
			string soundkey = GunItemSetting.reloadKey.ToLower() + "_end";
			AudioManager.Post("SFX/Combat/Gun/Reload/{soundkey}".Format(new { soundkey }), base.gameObject);
		}
	}

	private void PostShootSound()
	{
		string text = GunItemSetting.shootKey.ToLower();
		if (Silenced)
		{
			text += "_mute";
		}
		string eventName = "SFX/Combat/Gun/Shoot/{soundkey}".Format(new
		{
			soundkey = text
		});
		_shootSoundEvent = AudioManager.Post(eventName, base.gameObject);
	}

	private void StopAllSound()
	{
		AudioManager.StopAll(base.gameObject);
	}

	private void StopReloadSound()
	{
		if (_reloadSoundLoopEvent.HasValue)
		{
			_reloadSoundLoopEvent.Value.stop(FMOD.Studio.STOP_MODE.IMMEDIATE);
		}
	}

	public void CancleReload()
	{
		StopReloadSound();
		if (gunState == GunStates.reloading)
		{
			TransToBurstCooling();
		}
	}

	public bool IsFull()
	{
		return BulletCount >= Capacity;
	}

	public int GetBulletCountInInventory()
	{
		if (!GunItemSetting || !base.Holder || !base.Holder.CharacterItem)
		{
			return 0;
		}
		return GunItemSetting.GetBulletCountofTypeInInventory(GunItemSetting.TargetBulletID, base.Holder.CharacterItem.Inventory);
	}

	private void StartLoadBullets()
	{
		GunItemSetting.LoadBulletsFromInventory(base.Holder.CharacterItem.Inventory).Forget();
	}

	private void StartVisualRecoil()
	{
		_recoilBack = true;
	}

	private void UpdateVisualRecoil()
	{
		bool flag = false;
		if (_recoilBack)
		{
			flag = true;
			_recoilMoveValue = Mathf.MoveTowards(_recoilMoveValue, 1f, _recoilBackSpeed * Time.deltaTime);
			if (Mathf.Approximately(_recoilMoveValue, 1f))
			{
				_recoilBack = false;
			}
		}
		else if (_recoilMoveValue > 0f)
		{
			flag = true;
			_recoilMoveValue = Mathf.MoveTowards(_recoilMoveValue, 0f, _recoilRecoverSpeed * Time.deltaTime);
		}
		if (flag)
		{
			base.transform.localPosition = Vector3.back * _recoilMoveValue * _recoilDistance;
		}
	}

	public void SetTrigger(bool trigger, bool _triggerThisFrame, bool _releaseThisFrame)
	{
		triggerInput = trigger;
		triggerThisFrame = _triggerThisFrame;
		releaseThisFrame = _releaseThisFrame;
	}

	public bool IsReloading()
	{
		return gunState == GunStates.reloading;
	}

	public Duckov.Progress GetReloadProgress()
	{
		Duckov.Progress result = default(Duckov.Progress);
		if (IsReloading())
		{
			result.inProgress = true;
			result.total = ReloadTime;
			result.current = stateTimer;
		}
		else
		{
			result.inProgress = false;
		}
		return result;
	}

	public ADSAimMarker GetAimMarkerPfb()
	{
		Slot slot = base.Item.Slots.GetSlot("Scope");
		if (slot != null && slot.Content != null)
		{
			ItemSetting_Accessory component = slot.Content.GetComponent<ItemSetting_Accessory>();
			if ((bool)component.overrideAdsAimMarker)
			{
				return component.overrideAdsAimMarker;
			}
		}
		return _gunItemSetting.adsAimMarker;
	}
}
public class ItemAgent_MeleeWeapon : DuckovItemAgent
{
	public GameObject hitFx;

	public GameObject slashFx;

	public float slashFxDelayTime = 0.05f;

	[SerializeField]
	private string soundKey = "Default";

	private Collider[] colliders;

	private ItemSetting_MeleeWeapon setting;

	private static int DamageHash = "Damage".GetHashCode();

	private static int CritRateHash = "CritRate".GetHashCode();

	private static int CritDamageFactorHash = "CritDamageFactor".GetHashCode();

	private static int ArmorPiercingHash = "ArmorPiercing".GetHashCode();

	private static int AttackSpeedHash = "AttackSpeed".GetHashCode();

	private static int AttackRangeHash = "AttackRange".GetHashCode();

	private static int DealDamageTimeHash = "DealDamageTime".GetHashCode();

	private static int StaminaCostHash = "StaminaCost".GetHashCode();

	private static int BleedChanceHash = "BleedChance".GetHashCode();

	private static int MoveSpeedMultiplierHash = "MoveSpeedMultiplier".GetHashCode();

	public float Damage => base.Item.GetStatValue(DamageHash);

	public float CritRate => base.Item.GetStatValue(CritRateHash);

	public float CritDamageFactor => base.Item.GetStatValue(CritDamageFactorHash);

	public float ArmorPiercing => base.Item.GetStatValue(ArmorPiercingHash);

	public float AttackSpeed => Mathf.Max(0.1f, base.Item.GetStatValue(AttackSpeedHash));

	public float AttackRange => base.Item.GetStatValue(AttackRangeHash);

	public float DealDamageTime => base.Item.GetStatValue(DealDamageTimeHash);

	public float StaminaCost => base.Item.GetStatValue(StaminaCostHash);

	public float BleedChance => base.Item.GetStatValue(BleedChanceHash);

	public float MoveSpeedMultiplier => base.Item.GetStatValue(MoveSpeedMultiplierHash);

	public float CharacterDamageMultiplier
	{
		get
		{
			if (!base.Holder)
			{
				return 1f;
			}
			return base.Holder.MeleeDamageMultiplier;
		}
	}

	public float CharacterCritRateGain
	{
		get
		{
			if (!base.Holder)
			{
				return 0f;
			}
			return base.Holder.MeleeCritRateGain;
		}
	}

	public float CharacterCritDamageGain
	{
		get
		{
			if (!base.Holder)
			{
				return 0f;
			}
			return base.Holder.MeleeCritDamageGain;
		}
	}

	public string SoundKey
	{
		get
		{
			if (string.IsNullOrWhiteSpace(soundKey))
			{
				return "Default";
			}
			return soundKey;
		}
	}

	private int UpdateColliders()
	{
		if (colliders == null)
		{
			colliders = new Collider[6];
		}
		return Physics.OverlapSphereNonAlloc(base.Holder.transform.position, AttackRange, colliders, GameplayDataSettings.Layers.damageReceiverLayerMask);
	}

	public void CheckAndDealDamage()
	{
		CheckCollidersInRange(dealDamage: true);
	}

	public bool AttackableTargetInRange()
	{
		return CheckCollidersInRange(dealDamage: false) > 0;
	}

	private int CheckCollidersInRange(bool dealDamage)
	{
		if (colliders == null)
		{
			colliders = new Collider[6];
		}
		int num = UpdateColliders();
		int num2 = 0;
		for (int i = 0; i < num; i++)
		{
			Collider collider = colliders[i];
			DamageReceiver component = collider.GetComponent<DamageReceiver>();
			if (component == null || !Team.IsEnemy(component.Team, base.Holder.Team))
			{
				continue;
			}
			Health health = component.health;
			if ((bool)health)
			{
				CharacterMainControl characterMainControl = health.TryGetCharacter();
				if (characterMainControl == base.Holder || ((bool)characterMainControl && characterMainControl.Dashing))
				{
					continue;
				}
			}
			Vector3 vector = collider.transform.position - base.Holder.transform.position;
			vector.y = 0f;
			vector.Normalize();
			if (!(Vector3.Angle(vector, base.Holder.CurrentAimDirection) < 90f))
			{
				continue;
			}
			num2++;
			if (dealDamage)
			{
				DamageInfo damageInfo = new DamageInfo(base.Holder);
				damageInfo.damageValue = Damage * CharacterDamageMultiplier;
				damageInfo.armorPiercing = ArmorPiercing;
				damageInfo.critDamageFactor = CritDamageFactor * (1f + CharacterCritDamageGain);
				damageInfo.critRate = CritRate * (1f + CharacterCritRateGain);
				damageInfo.crit = -1;
				damageInfo.damageNormal = -base.Holder.modelRoot.right;
				damageInfo.damagePoint = collider.transform.position - vector * 0.2f;
				damageInfo.damagePoint.y = base.transform.position.y;
				damageInfo.fromWeaponItemID = base.Item.TypeID;
				damageInfo.bleedChance = BleedChance;
				if ((bool)setting)
				{
					damageInfo.isExplosion = setting.dealExplosionDamage;
				}
				component.Hurt(damageInfo);
				component.AddBuff(GameplayDataSettings.Buffs.Pain, base.Holder);
				if ((bool)hitFx)
				{
					UnityEngine.Object.Instantiate(hitFx, damageInfo.damagePoint, Quaternion.LookRotation(damageInfo.damageNormal, Vector3.up));
				}
				if ((bool)base.Holder && base.Holder == CharacterMainControl.Main)
				{
					Vector3 right = base.Holder.modelRoot.right;
					right += UnityEngine.Random.insideUnitSphere * 0.3f;
					right.Normalize();
					CameraShaker.Shake(right * 0.05f, CameraShaker.CameraShakeTypes.meleeAttackHit);
				}
			}
		}
		return num2;
	}

	private void Update()
	{
	}

	protected override void OnInitialize()
	{
		base.OnInitialize();
		setting = base.Item.GetComponent<ItemSetting_MeleeWeapon>();
	}
}
public class SavedInventory : MonoBehaviour
{
	[SerializeField]
	private Inventory inventory;

	[SerializeField]
	private string key = "DefaultSavedInventory";

	private static Dictionary<string, SavedInventory> activeInventories = new Dictionary<string, SavedInventory>();

	private bool registered;

	private void Awake()
	{
		if (inventory == null)
		{
			inventory = GetComponent<Inventory>();
		}
		Register();
	}

	private void Start()
	{
		if (registered)
		{
			Load();
		}
	}

	private void OnDestroy()
	{
		Unregsister();
	}

	private void Register()
	{
		if (activeInventories.TryGetValue(key, out var _))
		{
			UnityEngine.Debug.LogError("存在多个带有相同Key的Saved Inventory: " + key, base.gameObject);
			return;
		}
		SavesSystem.OnCollectSaveData += Save;
		registered = true;
	}

	private void Unregsister()
	{
		SavesSystem.OnCollectSaveData -= Save;
	}

	private void Save()
	{
		inventory.Save(key);
	}

	private void Load()
	{
		if (inventory.Loading)
		{
			UnityEngine.Debug.LogError("Inventory is already loading.", base.gameObject);
		}
		else
		{
			ItemSavesUtilities.LoadInventory(key, inventory).Forget();
		}
	}
}
public static class InventoryExtensions
{
	private static void Sort(this Inventory inventory, Comparison<Item> comparison)
	{
		inventory.Content.Sort(comparison);
	}
}
public static class ItemExtensions
{
	public static readonly int PickupHash = "Pickup".GetHashCode();

	public static readonly int HandheldHash = "Handheld".GetHashCode();

	private static ItemAgent CreatePickupAgent(this Item itemInstance, Vector3 pos)
	{
		if (itemInstance.ActiveAgent != null)
		{
			UnityEngine.Debug.LogError("创建pickup agent失败,已有agent:" + itemInstance.ActiveAgent.name);
			return null;
		}
		ItemAgent itemAgent = itemInstance.AgentUtilities.GetPrefab(PickupHash);
		if (itemAgent == null)
		{
			itemAgent = GameplayDataSettings.Prefabs.PickupAgentPrefab;
		}
		ItemAgent itemAgent2 = itemInstance.AgentUtilities.CreateAgent(itemAgent, ItemAgent.AgentTypes.pickUp);
		itemAgent2.transform.position = pos;
		return itemAgent2;
	}

	public static ItemAgent CreateHandheldAgent(this Item itemInstance)
	{
		if (itemInstance.ActiveAgent != null)
		{
			UnityEngine.Debug.LogError("创建pickup agent失败,已有agent");
			return null;
		}
		ItemAgent itemAgent = itemInstance.AgentUtilities.GetPrefab(HandheldHash);
		if (itemAgent == null)
		{
			itemAgent = GameplayDataSettings.Prefabs.HandheldAgentPrefab;
		}
		return itemInstance.AgentUtilities.CreateAgent(itemAgent, ItemAgent.AgentTypes.handheld);
	}

	public static DuckovItemAgent Drop(this Item item, Vector3 pos, bool createRigidbody, Vector3 dropDirection, float randomAngle)
	{
		if (item == null)
		{
			UnityEngine.Debug.Log("尝试丢弃不存在的物体");
			return null;
		}
		item.Detach();
		if (MultiSceneCore.MainScene.HasValue)
		{
			item.gameObject.transform.SetParent(null);
			SceneManager.MoveGameObjectToScene(item.gameObject, MultiSceneCore.MainScene.Value);
		}
		ItemAgent itemAgent = item.CreatePickupAgent(pos);
		if ((bool)MultiSceneCore.Instance)
		{
			if (itemAgent == null)
			{
				UnityEngine.Debug.Log("创建的agent是null");
			}
			MultiSceneCore.MoveToActiveWithScene(itemAgent.gameObject, SceneManager.GetActiveScene().buildIndex);
		}
		InteractablePickup component = itemAgent.GetComponent<InteractablePickup>();
		if (createRigidbody && component != null)
		{
			component.Throw(dropDirection, randomAngle);
		}
		else
		{
			component.transform.rotation = Quaternion.Euler(0f, UnityEngine.Random.Range(0f - randomAngle, randomAngle) * 0.5f, 0f);
		}
		return itemAgent as DuckovItemAgent;
	}

	public static void Drop(this Item item, CharacterMainControl character, bool createRigidbody)
	{
		if (!(item == null))
		{
			Vector3 vector = UnityEngine.Random.insideUnitSphere * 1f;
			vector.y = 0f;
			item.Drop(character.transform.position, createRigidbody, character.CurrentAimDirection, 45f);
			if (character.IsMainCharacter && LevelManager.LevelInited)
			{
				AudioManager.Post("SFX/Item/put_" + item.SoundKey, character.gameObject);
			}
		}
	}

	public static async UniTask<List<Item>> GetItemsOfAmount(this Inventory inventory, int itemTypeID, int amount)
	{
		List<Item> list = inventory.FindAll((Item e) => e != null && e.TypeID == itemTypeID);
		List<Item> result = new List<Item>();
		int count = 0;
		foreach (Item item in list)
		{
			int remainingCount = amount - count;
			if (item.StackCount > remainingCount)
			{
				result.Add(await item.Split(remainingCount));
				count += remainingCount;
			}
			else
			{
				item.Detach();
				result.Add(item);
				count += item.StackCount;
			}
			if (count >= amount)
			{
				break;
			}
		}
		return result;
	}

	public static bool TryFindItemsOfAmount(this IEnumerable<Inventory> inventories, int itemTypeID, int requiredAmount, out List<Item> result)
	{
		result = new List<Item>();
		int num = 0;
		foreach (Inventory inventory in inventories)
		{
			foreach (Item item in inventory)
			{
				if (item.TypeID == itemTypeID)
				{
					result.Add(item);
					num += item.StackCount;
					if (num >= requiredAmount)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	public static void ConsumeItemsOfAmount(this IEnumerable<Item> itemsToBeConsumed, int amount)
	{
		List<Item> list = new List<Item>();
		int num = 0;
		foreach (Item item2 in itemsToBeConsumed)
		{
			list.Add(item2);
			num += item2.StackCount;
			if (num >= amount)
			{
				break;
			}
		}
		num = 0;
		for (int i = 0; i < list.Count; i++)
		{
			Item item = list[i];
			int num2 = amount - num;
			if (num2 >= item.StackCount)
			{
				item.Detach();
				item.DestroyTree();
				continue;
			}
			item.StackCount -= num2;
			break;
		}
	}

	private static bool TryMerge(IEnumerable<Item> itemsOfSameTypeID, out List<Item> result)
	{
		result = null;
		List<Item> list = itemsOfSameTypeID.ToList();
		list.RemoveAll((Item e) => e == null);
		if (list.Count <= 0)
		{
			return false;
		}
		int typeID = list[0].TypeID;
		foreach (Item item3 in list)
		{
			if (typeID != item3.TypeID)
			{
				UnityEngine.Debug.LogError("尝试融合的Item具有不同的TypeID,已取消");
				return false;
			}
		}
		if (!list[0].Stackable)
		{
			UnityEngine.Debug.LogError("此类物品不可堆叠，已取消");
			return false;
		}
		result = new List<Item>();
		Stack<Item> stack = new Stack<Item>(list);
		Item item = null;
		while (stack.Count > 0)
		{
			if (item == null)
			{
				item = stack.Pop();
			}
			if (stack.Count <= 0)
			{
				result.Add(item);
				break;
			}
			Item item2 = null;
			while (item.StackCount < item.MaxStackCount && stack.Count > 0)
			{
				item2 = stack.Pop();
				item.Combine(item2);
			}
			result.Add(item);
			if (item2 != null && item2.StackCount > 0)
			{
				if (stack.Count <= 0)
				{
					result.Add(item2);
					break;
				}
				item = item2;
			}
			else
			{
				item = null;
			}
		}
		return true;
	}
}
public abstract class ItemSettingBase : MonoBehaviour
{
	protected Item _item;

	public Item Item
	{
		get
		{
			if (_item == null)
			{
				_item = GetComponent<Item>();
			}
			return _item;
		}
	}

	public void Awake()
	{
		if ((bool)Item)
		{
			SetMarkerParam(Item);
			OnInit();
		}
	}

	public virtual void OnInit()
	{
	}

	public virtual void Start()
	{
	}

	public abstract void SetMarkerParam(Item selfItem);
}
public class ItemSetting_Accessory : ItemSettingBase
{
	[SerializeField]
	private AccessoryBase accessoryPfb;

	public ADSAimMarker overrideAdsAimMarker;

	private AccessoryBase accessoryInstance;

	private bool created;

	private Item masterItem;

	public override void SetMarkerParam(Item selfItem)
	{
		selfItem.SetBool("IsBullet", value: true);
	}

	public override void OnInit()
	{
		base.Item.onPluggedIntoSlot += OnPluggedIntoSlot;
		base.Item.onUnpluggedFromSlot += OnUnpluggedIntoSlot;
	}

	private void OnPluggedIntoSlot(Item selfItem)
	{
		Slot pluggedIntoSlot = selfItem.PluggedIntoSlot;
		if (pluggedIntoSlot != null)
		{
			masterItem = pluggedIntoSlot.Master;
			if ((bool)masterItem)
			{
				masterItem.AgentUtilities.onCreateAgent += OnMasterCreateAgent;
				CreateAccessory(masterItem.AgentUtilities.ActiveAgent as DuckovItemAgent);
			}
		}
	}

	private void OnUnpluggedIntoSlot(Item selfItem)
	{
		if ((bool)masterItem)
		{
			masterItem.AgentUtilities.onCreateAgent -= OnMasterCreateAgent;
		}
		DestroyAccessory();
	}

	private void OnDestroy()
	{
		if ((bool)masterItem)
		{
			masterItem.AgentUtilities.onCreateAgent -= OnMasterCreateAgent;
		}
		DestroyAccessory();
	}

	private void OnMasterCreateAgent(Item _masterItem, ItemAgent newAgnet)
	{
		if (masterItem != _masterItem)
		{
			UnityEngine.Debug.LogError("缓存了错误的Item");
		}
		if (newAgnet.AgentType == ItemAgent.AgentTypes.handheld)
		{
			CreateAccessory(newAgnet as DuckovItemAgent);
		}
	}

	private void CreateAccessory(DuckovItemAgent parentAgent)
	{
		DestroyAccessory();
		if (!(accessoryPfb == null) && !(parentAgent == null) && parentAgent.AgentType == ItemAgent.AgentTypes.handheld)
		{
			accessoryInstance = UnityEngine.Object.Instantiate(accessoryPfb);
			accessoryInstance.Init(parentAgent, base.Item);
		}
	}

	private void DestroyAccessory()
	{
		if ((bool)accessoryInstance)
		{
			UnityEngine.Object.Destroy(accessoryInstance.gameObject);
		}
	}
}
public class ItemSetting_Bullet : ItemSettingBase
{
	public override void SetMarkerParam(Item selfItem)
	{
		selfItem.SetBool("IsBullet", value: true);
	}
}
public class ItemSetting_Formula : ItemSettingBase
{
	public string formulaID;

	public override void SetMarkerParam(Item selfItem)
	{
	}
}
public class ItemSetting_GPU : ItemSettingBase
{
	public MiningMachineCardDisplay.CardTypes cardType;

	public override void SetMarkerParam(Item selfItem)
	{
	}
}
public enum Calibers
{
	AR_S,
	AR_B,
	SMG,
	Sniper,
	ShotGun,
	Grenade
}
public class ItemSetting_Gun : ItemSettingBase
{
	public enum TriggerModes
	{
		auto,
		semi,
		bolt
	}

	public enum ReloadModes
	{
		fullMag,
		singleBullet
	}

	private int targetBulletID = -1;

	public ADSAimMarker adsAimMarker;

	public GameObject muzzleFxPfb;

	public Projectile bulletPfb;

	public string shootKey = "Default";

	public string reloadKey = "Default";

	private int bulletCountHash = "BulletCount".GetHashCode();

	private int _bulletCountCache = -1;

	private static int CapacityHash = "Capacity".GetHashCode();

	private bool loadingBullets;

	private bool loadBulletsSuccess;

	private int caliberHash = "Caliber".GetHashCode();

	public TriggerModes triggerMode;

	public ReloadModes reloadMode;

	public bool autoReload;

	public ElementTypes element;

	public Buff buff;

	private Item preferedBulletsToLoad;

	public int TargetBulletID => targetBulletID;

	public string CurrentBulletName
	{
		get
		{
			if (TargetBulletID < 0)
			{
				return "UI_Bullet_NotAssigned".ToPlainText();
			}
			return ItemAssetsCollection.GetMetaData(TargetBulletID).DisplayName;
		}
	}

	public int BulletCount
	{
		get
		{
			if (loadingBullets)
			{
				return -1;
			}
			if (bulletCount < 0)
			{
				bulletCount = GetBulletCount();
			}
			return bulletCount;
		}
	}

	private int bulletCount
	{
		get
		{
			return _bulletCountCache;
		}
		set
		{
			_bulletCountCache = value;
			base.Item.Variables.SetInt(bulletCountHash, _bulletCountCache);
		}
	}

	public int Capacity => Mathf.RoundToInt(base.Item.GetStatValue(CapacityHash));

	public bool LoadingBullets => loadingBullets;

	public bool LoadBulletsSuccess => loadBulletsSuccess;

	public Item PreferdBulletsToLoad
	{
		get
		{
			return preferedBulletsToLoad;
		}
		set
		{
			preferedBulletsToLoad = value;
		}
	}

	public void SetTargetBulletType(Item bulletItem)
	{
		if (bulletItem != null)
		{
			SetTargetBulletType(bulletItem.TypeID);
		}
		else
		{
			SetTargetBulletType(-1);
		}
	}

	public void SetTargetBulletType(int typeID)
	{
		bool flag = false;
		if (TargetBulletID != typeID && TargetBulletID != -1)
		{
			flag = true;
		}
		targetBulletID = typeID;
		if (flag)
		{
			TakeOutAllBullets();
		}
	}

	public override void Start()
	{
		base.Start();
		AutoSetTypeInInventory(null);
	}

	public void UseABullet()
	{
		if (LevelManager.Instance.IsBaseLevel)
		{
			return;
		}
		foreach (Item item in base.Item.Inventory)
		{
			if (!(item == null) && item.StackCount >= 1)
			{
				item.StackCount--;
				break;
			}
		}
		bulletCount--;
	}

	public bool IsFull()
	{
		return bulletCount >= Capacity;
	}

	public bool IsValidBullet(Item newBulletItem)
	{
		if (newBulletItem == null)
		{
			return false;
		}
		if (!newBulletItem.Tags.Contains(GameplayDataSettings.Tags.Bullet))
		{
			return false;
		}
		Item currentLoadedBullet = GetCurrentLoadedBullet();
		if (currentLoadedBullet != null && currentLoadedBullet.TypeID == newBulletItem.TypeID && bulletCount >= Capacity)
		{
			return false;
		}
		string text = newBulletItem.Constants.GetString(caliberHash);
		string text2 = base.Item.Constants.GetString(caliberHash);
		if (text != text2)
		{
			return false;
		}
		return true;
	}

	public bool LoadSpecificBullet(Item newBulletItem)
	{
		UnityEngine.Debug.Log("尝试安装指定弹药");
		if (!IsValidBullet(newBulletItem))
		{
			return false;
		}
		UnityEngine.Debug.Log("指定弹药判定通过");
		ItemAgent_Gun itemAgent_Gun = base.Item.ActiveAgent as ItemAgent_Gun;
		if (itemAgent_Gun != null)
		{
			if (itemAgent_Gun.Holder != null)
			{
				bool flag = itemAgent_Gun.CharacterReload(newBulletItem);
				UnityEngine.Debug.Log($"角色reload:{flag}");
				return true;
			}
			return false;
		}
		Inventory inventory = base.Item.InInventory;
		if (inventory != null && inventory != CharacterMainControl.Main.CharacterItem.Inventory)
		{
			inventory = null;
		}
		preferedBulletsToLoad = newBulletItem;
		LoadBulletsFromInventory(inventory).Forget();
		return true;
	}

	public async UniTaskVoid LoadBulletsFromInventory(Inventory inventory)
	{
		if (loadingBullets)
		{
			return;
		}
		loadingBullets = true;
		loadBulletsSuccess = false;
		Item item = preferedBulletsToLoad;
		preferedBulletsToLoad = null;
		if (item != null)
		{
			SetTargetBulletType(item);
		}
		bulletCount = GetBulletCount();
		if (bulletCount > 0)
		{
			Item currentLoadedBullet = GetCurrentLoadedBullet();
			if ((bool)currentLoadedBullet && currentLoadedBullet.TypeID != TargetBulletID)
			{
				TakeOutAllBullets();
			}
		}
		int capacity = Capacity;
		int needCount = capacity - bulletCount;
		if (needCount < 0)
		{
			loadBulletsSuccess = false;
			loadingBullets = false;
			return;
		}
		if (reloadMode == ReloadModes.singleBullet)
		{
			needCount = 1;
		}
		List<Item> bullets = new List<Item>();
		if (item != null)
		{
			if (item.StackCount > needCount)
			{
				bullets.Add(await item.Split(needCount));
				needCount = 0;
			}
			else
			{
				item.Detach();
				bullets.Add(item);
				needCount -= item.StackCount;
			}
		}
		if (needCount > 0 && inventory != null)
		{
			CharacterMainControl characterMainControl = base.Item.GetCharacterMainControl();
			if (characterMainControl == LevelManager.Instance.MainCharacter)
			{
				bullets.AddRange(await inventory.GetItemsOfAmount(targetBulletID, needCount));
			}
			else if (characterMainControl != null)
			{
				Item item2 = await ItemAssetsCollection.InstantiateAsync(targetBulletID);
				item2.StackCount = needCount;
				bullets.Add(item2);
			}
		}
		if (bullets.Count <= 0)
		{
			loadBulletsSuccess = false;
			loadingBullets = false;
			return;
		}
		foreach (Item item3 in bullets)
		{
			if (item3 == null)
			{
				loadBulletsSuccess = false;
				continue;
			}
			item3.Inspected = true;
			base.Item.Inventory.AddAndMerge(item3);
		}
		bulletCount = GetBulletCount();
		loadBulletsSuccess = true;
		loadingBullets = false;
	}

	public bool AutoSetTypeInInventory(Inventory inventory)
	{
		string text = base.Item.Constants.GetString(caliberHash);
		Item currentLoadedBullet = GetCurrentLoadedBullet();
		if (currentLoadedBullet != null)
		{
			SetTargetBulletType(currentLoadedBullet);
			return false;
		}
		if (inventory == null)
		{
			return false;
		}
		foreach (Item item in inventory)
		{
			if (item.GetBool("IsBullet") && !(item.Constants.GetString(caliberHash) != text))
			{
				SetTargetBulletType(item);
				break;
			}
		}
		if (targetBulletID == -1)
		{
			return false;
		}
		return true;
	}

	public int GetBulletCount()
	{
		int num = 0;
		if (base.Item == null)
		{
			return 0;
		}
		foreach (Item item in base.Item.Inventory)
		{
			if (!(item == null))
			{
				num += item.StackCount;
			}
		}
		return num;
	}

	public Item GetCurrentLoadedBullet()
	{
		foreach (Item item in base.Item.Inventory)
		{
			if (!(item == null))
			{
				return item;
			}
		}
		return null;
	}

	public int GetBulletCountofTypeInInventory(int bulletItemTypeID, Inventory inventory)
	{
		if (targetBulletID == -1)
		{
			return 0;
		}
		int num = 0;
		foreach (Item item in inventory)
		{
			if (!(item == null) && item.TypeID == bulletItemTypeID)
			{
				num += item.StackCount;
			}
		}
		return num;
	}

	public void TakeOutAllBullets()
	{
		if (base.Item == null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (Item item2 in base.Item.Inventory)
		{
			if (!(item2 == null))
			{
				list.Add(item2);
			}
		}
		CharacterMainControl characterMainControl = base.Item.GetCharacterMainControl();
		if ((bool)base.Item.InInventory && (bool)LevelManager.Instance && base.Item.InInventory == LevelManager.Instance.PetProxy.Inventory)
		{
			characterMainControl = LevelManager.Instance.MainCharacter;
		}
		for (int i = 0; i < list.Count; i++)
		{
			Item item = list[i];
			if (item == null)
			{
				continue;
			}
			if ((bool)characterMainControl)
			{
				item.Drop(characterMainControl, createRigidbody: true);
				characterMainControl.PickupItem(item);
				continue;
			}
			bool flag = false;
			Inventory inInventory = base.Item.InInventory;
			if ((bool)inInventory)
			{
				flag = inInventory.AddAndMerge(item);
			}
			if (!flag)
			{
				item.Detach();
				item.DestroyTree();
			}
		}
		bulletCount = 0;
	}

	public Dictionary<int, BulletTypeInfo> GetBulletTypesInInventory(Inventory inventory)
	{
		Dictionary<int, BulletTypeInfo> dictionary = new Dictionary<int, BulletTypeInfo>();
		string text = base.Item.Constants.GetString(caliberHash);
		foreach (Item item in inventory)
		{
			if (!(item == null) && item.GetBool("IsBullet") && !(item.Constants.GetString(caliberHash) != text))
			{
				if (!dictionary.ContainsKey(item.TypeID))
				{
					BulletTypeInfo bulletTypeInfo = new BulletTypeInfo();
					bulletTypeInfo.bulletTypeID = item.TypeID;
					bulletTypeInfo.count = item.StackCount;
					dictionary.Add(bulletTypeInfo.bulletTypeID, bulletTypeInfo);
				}
				else
				{
					dictionary[item.TypeID].count += item.StackCount;
				}
			}
		}
		return dictionary;
	}

	public override void SetMarkerParam(Item selfItem)
	{
		selfItem.SetBool("IsGun", value: true);
	}
}
public class BulletTypeInfo
{
	public int bulletTypeID;

	public int count;
}
public class ItemSetting_MeleeWeapon : ItemSettingBase
{
	public bool dealExplosionDamage;

	public override void Start()
	{
		base.Start();
	}

	public override void SetMarkerParam(Item selfItem)
	{
		selfItem.SetBool("IsMeleeWeapon", value: true);
	}
}
public class ItemSetting_NightVision : ItemSettingBase
{
	private bool nightVisionOn = true;

	public override void OnInit()
	{
		if ((bool)_item)
		{
			_item.onPluggedIntoSlot += OnplugedIntoSlot;
		}
	}

	private void OnplugedIntoSlot(Item item)
	{
		nightVisionOn = true;
		SyncModifiers();
	}

	private void OnDestroy()
	{
		if ((bool)_item)
		{
			_item.onPluggedIntoSlot -= OnplugedIntoSlot;
		}
	}

	public void ToggleNightVison()
	{
		nightVisionOn = !nightVisionOn;
		SyncModifiers();
	}

	private void SyncModifiers()
	{
		if ((bool)_item)
		{
			_item.Modifiers.ModifierEnable = nightVisionOn;
		}
	}

	public override void SetMarkerParam(Item selfItem)
	{
		selfItem.SetBool("IsNightVision", value: true);
	}
}
public class ItemSetting_Skill : ItemSettingBase
{
	public enum OnReleaseAction
	{
		none,
		reduceCount
	}

	public OnReleaseAction onRelease;

	public SkillBase Skill;

	public override void OnInit()
	{
		if ((bool)Skill)
		{
			SkillBase skill = Skill;
			skill.OnSkillReleasedEvent = (Action)Delegate.Combine(skill.OnSkillReleasedEvent, new Action(OnSkillReleased));
			Skill.fromItem = base.Item;
		}
	}

	private void OnSkillReleased()
	{
		OnReleaseAction onReleaseAction = onRelease;
		if (onReleaseAction != OnReleaseAction.none && onReleaseAction == OnReleaseAction.reduceCount && (!LevelManager.Instance || !LevelManager.Instance.IsBaseLevel))
		{
			if (base.Item.Stackable)
			{
				base.Item.StackCount--;
				return;
			}
			base.Item.Detach();
			base.Item.DestroyTree();
		}
	}

	private void OnDestroy()
	{
		if ((bool)Skill)
		{
			SkillBase skill = Skill;
			skill.OnSkillReleasedEvent = (Action)Delegate.Remove(skill.OnSkillReleasedEvent, new Action(OnSkillReleased));
		}
	}

	public override void SetMarkerParam(Item selfItem)
	{
		selfItem.SetBool("IsSkill", value: true);
	}
}
public static class ItemUtilities
{
	private static Item CharacterItem => LevelManager.Instance?.MainCharacter?.CharacterItem;

	private static Inventory CharacterInventory => CharacterItem?.Inventory;

	private static Inventory PlayerStorageInventory => PlayerStorage.Inventory;

	public static event Action OnPlayerItemOperation;

	public static event Action<Item> OnItemSentToPlayerInventory;

	public static event Action<Item> OnItemSentToPlayerStorage;

	public static async UniTask<bool> Decompose(Item item, int count)
	{
		return await DecomposeDatabase.Decompose(item, count);
	}

	public static async UniTask<Item> GenerateBullet(Item gunItem)
	{
		UnityEngine.Debug.Log("Trying to generate bullet for " + gunItem.DisplayName);
		if ((bool)gunItem.GetComponent<ItemSetting_Gun>())
		{
			string text = gunItem.Constants.GetString("Caliber");
			if (!string.IsNullOrEmpty(text))
			{
				ItemFilter filter = new ItemFilter
				{
					caliber = text,
					minQuality = 0,
					maxQuality = 1,
					requireTags = new Tag[1] { GameplayDataSettings.Tags.Get("Bullet") }
				};
				filter.caliber = text;
				int[] array = ItemAssetsCollection.Search(filter);
				if (array.Length != 0)
				{
					Item obj = await ItemAssetsCollection.InstantiateAsync(array.GetRandom());
					if (obj == null)
					{
						UnityEngine.Debug.Log("Bullet generation failed for " + gunItem.DisplayName);
					}
					return obj;
				}
			}
		}
		UnityEngine.Debug.Log("Bullet generation failed for " + gunItem.DisplayName);
		return null;
	}

	public static List<Item> FindAllBelongsToPlayer(Predicate<Item> predicate)
	{
		List<Item> list = new List<Item>();
		Inventory playerStorageInventory = PlayerStorageInventory;
		if (playerStorageInventory != null)
		{
			List<Item> collection = playerStorageInventory.FindAll(predicate);
			list.AddRange(collection);
		}
		Inventory characterInventory = CharacterInventory;
		if (characterInventory != null)
		{
			List<Item> collection2 = characterInventory.FindAll(predicate);
			list.AddRange(collection2);
		}
		Inventory inventory = LevelManager.Instance?.PetProxy?.Inventory;
		if (inventory != null)
		{
			List<Item> collection3 = inventory.FindAll(predicate);
			list.AddRange(collection3);
		}
		return list;
	}

	public static int GetItemCount(int typeID)
	{
		List<Item> list = FindAllBelongsToPlayer((Item e) => e != null && e.TypeID == typeID);
		int num = 0;
		foreach (Item item in list)
		{
			num += item.StackCount;
		}
		return num;
	}

	public static bool AddAndMerge(this Inventory inventory, Item item, int preferedFirstPosition = 0)
	{
		if (inventory == null)
		{
			return false;
		}
		if (item.Stackable)
		{
			while (item.StackCount > 0)
			{
				Item item2 = inventory.FirstOrDefault((Item e) => e.TypeID == item.TypeID && e.MaxStackCount > e.StackCount);
				if (item2 == null)
				{
					break;
				}
				item2.Combine(item);
			}
			if (item.StackCount <= 0)
			{
				return true;
			}
		}
		int firstEmptyPosition = inventory.GetFirstEmptyPosition(preferedFirstPosition);
		if (firstEmptyPosition < 0)
		{
			return false;
		}
		item.Detach();
		inventory.AddAt(item, firstEmptyPosition);
		return true;
	}

	public static bool SendToPlayerCharacter(Item item, bool dontMerge = false)
	{
		if (item == null)
		{
			return false;
		}
		Item item2 = LevelManager.Instance?.MainCharacter?.CharacterItem;
		if (item2 == null)
		{
			return false;
		}
		if (item2.TryPlug(item, emptyOnly: true))
		{
			ItemUtilities.OnPlayerItemOperation?.Invoke();
			return true;
		}
		return SendToPlayerCharacterInventory(item, dontMerge);
	}

	public static void SendToPlayer(Item item, bool dontMerge = false, bool sendToStorage = true)
	{
		if (!SendToPlayerCharacter(item, dontMerge))
		{
			if (sendToStorage)
			{
				SendToPlayerStorage(item);
			}
			else
			{
				item.Drop(CharacterMainControl.Main, createRigidbody: true);
			}
		}
	}

	public static bool SendToPlayerCharacterInventory(Item item, bool dontMerge = false)
	{
		if (item == null)
		{
			return false;
		}
		Inventory inventory = LevelManager.Instance?.MainCharacter?.CharacterItem?.Inventory;
		if (inventory == null)
		{
			return false;
		}
		int preferedFirstPosition = 0;
		bool flag = false;
		if (!((!dontMerge) ? inventory.AddAndMerge(item, preferedFirstPosition) : inventory.AddItem(item)))
		{
			return false;
		}
		ItemUtilities.OnPlayerItemOperation?.Invoke();
		ItemUtilities.OnItemSentToPlayerInventory?.Invoke(item);
		return true;
	}

	public static void SendToPlayerStorage(Item item, bool directToBuffer = false)
	{
		item.Detach();
		PlayerStorage.Push(item, directToBuffer);
		ItemUtilities.OnItemSentToPlayerStorage?.Invoke(item);
	}

	public static bool IsInPlayerCharacter(this Item item)
	{
		Item characterItem = LevelManager.Instance?.MainCharacter?.CharacterItem;
		if (characterItem == null)
		{
			return false;
		}
		return item.GetAllParents().Any((Item e) => e == characterItem);
	}

	public static bool IsInPlayerStorage(this Item item)
	{
		Inventory playerStorageInventory = PlayerStorage.Inventory;
		if (playerStorageInventory == null)
		{
			return false;
		}
		return item.GetAllParents().Any((Item e) => e.InInventory == playerStorageInventory);
	}

	public static bool IsRegistered(this Item item)
	{
		if (item == null)
		{
			return false;
		}
		if (MasterKeysManager.IsActive(item.TypeID))
		{
			return true;
		}
		if (CraftingManager.IsFormulaUnlocked(FormulasRegisterView.GetFormulaID(item)))
		{
			return true;
		}
		return false;
	}

	public static bool TryPlug(this Item main, Item part, bool emptyOnly = false, Inventory backupInventory = null, int preferredFirstIndex = 0)
	{
		if (main == null)
		{
			return false;
		}
		if (part == null)
		{
			return false;
		}
		if (main.Slots == null)
		{
			return false;
		}
		bool num = main.IsInPlayerCharacter();
		bool flag = part.IsInPlayerCharacter();
		bool flag2 = main.IsInPlayerStorage();
		bool flag3 = part.IsInPlayerStorage();
		bool flag4 = num || flag || flag2 || flag3;
		Slot slot = null;
		Slot pluggedIntoSlot = part.PluggedIntoSlot;
		if (backupInventory == null)
		{
			if ((bool)part.InInventory)
			{
				backupInventory = part.InInventory;
			}
			else if ((bool)main.InInventory)
			{
				backupInventory = main.InInventory;
			}
			else if (part.PluggedIntoSlot != null)
			{
				Item characterItem = part.GetCharacterItem();
				if (characterItem != null)
				{
					backupInventory = characterItem.Inventory;
				}
			}
			if (backupInventory == null)
			{
				Item characterItem2 = main.GetCharacterItem();
				if (characterItem2 != null)
				{
					backupInventory = characterItem2.Inventory;
				}
			}
		}
		IEnumerable<Slot> enumerable = main.Slots.Where((Slot e) => e?.CanPlug(part) ?? false);
		if (part.PluggedIntoSlot != null)
		{
			foreach (Slot item in enumerable)
			{
				if (part.PluggedIntoSlot == item)
				{
					UnityEngine.Debug.Log("什么也没做，因为已经在这个物体上了。");
					return false;
				}
			}
		}
		if (part.Stackable)
		{
			foreach (Slot item2 in enumerable)
			{
				Item content = item2.Content;
				if (!(content == null) && content.TypeID == part.TypeID)
				{
					content.Combine(part);
					if (part.StackCount <= 0)
					{
						return true;
					}
				}
			}
		}
		Slot slot2 = enumerable.FirstOrDefault((Slot e) => e.Content == null);
		if (slot2 != null)
		{
			slot = slot2;
		}
		else if (!emptyOnly)
		{
			slot = enumerable.FirstOrDefault();
		}
		if (slot == null)
		{
			return false;
		}
		slot.Plug(part, out var unpluggedItem);
		if (unpluggedItem != null)
		{
			bool flag5 = false;
			if (pluggedIntoSlot != null && pluggedIntoSlot.Content == null)
			{
				flag5 = pluggedIntoSlot.Plug(unpluggedItem, out var _);
			}
			if (!flag5 && backupInventory != null)
			{
				flag5 = backupInventory.AddAndMerge(unpluggedItem, preferredFirstIndex);
			}
			if (!flag5)
			{
				if (flag4)
				{
					unpluggedItem.Drop(CharacterMainControl.Main, createRigidbody: true);
				}
				else
				{
					unpluggedItem.Drop(Vector3.down * 1000f, createRigidbody: false, Vector3.up, 0f);
				}
			}
		}
		return true;
	}

	public static CharacterMainControl GetCharacterMainControl(this Item item)
	{
		return item.GetRoot()?.GetComponentInParent<CharacterMainControl>();
	}

	internal static IEnumerable<Inventory> GetPlayerInventories()
	{
		HashSet<Inventory> hashSet = new HashSet<Inventory>();
		Inventory inventory = LevelManager.Instance?.MainCharacter?.CharacterItem?.Inventory;
		if ((bool)inventory)
		{
			hashSet.Add(inventory);
		}
		if (PlayerStorage.Inventory != null)
		{
			hashSet.Add(PlayerStorage.Inventory);
		}
		return hashSet;
	}

	internal static bool ConsumeItems(Cost cost)
	{
		List<Action> list = new List<Action>();
		List<Item> detachedItems = new List<Item>();
		if (cost.items != null)
		{
			Cost.ItemEntry[] items = cost.items;
			for (int i = 0; i < items.Length; i++)
			{
				Cost.ItemEntry cur = items[i];
				List<Item> items2 = FindAllBelongsToPlayer((Item e) => e != null && e.TypeID == cur.id);
				int count = Count(items2);
				if (count < cur.amount)
				{
					return false;
				}
				list.Add(delegate
				{
					long num = cur.amount;
					for (int j = 0; j < count; j++)
					{
						Item item = items2[j];
						if (!(item == null))
						{
							if (item.Slots != null)
							{
								foreach (Slot slot in item.Slots)
								{
									if (slot != null)
									{
										Item content = slot.Content;
										if (!(content == null))
										{
											content.Detach();
											detachedItems.Add(content);
										}
									}
								}
							}
							if (item.StackCount <= num)
							{
								num -= item.StackCount;
								item.Detach();
								item.DestroyTree();
							}
							else
							{
								item.StackCount -= (int)num;
								num = 0L;
							}
							if (num <= 0)
							{
								break;
							}
						}
					}
				});
			}
		}
		foreach (Action item2 in list)
		{
			item2();
		}
		foreach (Item item3 in detachedItems)
		{
			if (!(item3 == null))
			{
				SendToPlayer(item3, dontMerge: false, PlayerStorage.Inventory != null);
			}
		}
		ItemUtilities.OnPlayerItemOperation?.Invoke();
		return true;
	}

	internal static bool ConsumeItems(int itemTypeID, long amount)
	{
		List<Item> list = FindAllBelongsToPlayer((Item e) => e != null && e.TypeID == itemTypeID);
		if (Count(list) < amount)
		{
			return false;
		}
		List<Item> list2 = new List<Item>();
		long num = amount;
		for (int num2 = 0; num2 < list.Count; num2++)
		{
			Item item = list[num2];
			if (item == null)
			{
				continue;
			}
			if (item.Slots != null)
			{
				foreach (Slot slot in item.Slots)
				{
					if (slot != null)
					{
						Item content = slot.Content;
						if (!(content == null))
						{
							content.Detach();
							list2.Add(content);
						}
					}
				}
			}
			if (item.StackCount <= num)
			{
				num -= item.StackCount;
				item.Detach();
				item.DestroyTree();
			}
			else
			{
				item.StackCount -= (int)num;
				num = 0L;
			}
			if (num <= 0)
			{
				break;
			}
		}
		foreach (Item item2 in list2)
		{
			if (!(item2 == null))
			{
				SendToPlayer(item2, dontMerge: false, PlayerStorage.Inventory != null);
			}
		}
		return true;
	}

	internal static int Count(IEnumerable<Item> items)
	{
		int num = 0;
		foreach (Item item in items)
		{
			num = ((!item.Stackable) ? (num + 1) : (num + item.StackCount));
		}
		return num;
	}

	public static float GetRepairLossRatio(this Item item)
	{
		if (item == null)
		{
			return 0f;
		}
		float defaultResult = 0.14f;
		float num = item.Constants.GetFloat("RepairLossRatio", defaultResult);
		if (item.Tags.Contains("Weapon"))
		{
			float num2 = CharacterMainControl.WeaponRepairLossFactor();
			return num * num2;
		}
		float num3 = CharacterMainControl.EquipmentRepairLossFactor();
		return num * num3;
	}

	internal static void NotifyPlayerItemOperation()
	{
		ItemUtilities.OnPlayerItemOperation?.Invoke();
	}
}
public class PlayerStorage : MonoBehaviour, IInitializedQueryHandler
{
	public class StorageCapacityCalculationHolder
	{
		public int capacity;
	}

	[SerializeField]
	private Inventory inventory;

	[SerializeField]
	private InteractableLootbox interactable;

	[SerializeField]
	private int defaultCapacity = 32;

	private static bool needRecalculateCapacity;

	private const string inventorySaveKey = "PlayerStorage";

	private bool initialized;

	public static PlayerStorage Instance { get; private set; }

	public static Inventory Inventory
	{
		get
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.inventory;
		}
	}

	public static List<ItemTreeData> IncomingItemBuffer => PlayerStorageBuffer.Buffer;

	public InteractableLootbox InteractableLootBox => interactable;

	public int DefaultCapacity => defaultCapacity;

	public static bool Loading { get; private set; }

	public static bool TakingItem { get; private set; }

	public static event Action<PlayerStorage, Inventory, int> OnPlayerStorageChange;

	public static event Action<StorageCapacityCalculationHolder> OnRecalculateStorageCapacity;

	public static event Action OnTakeBufferItem;

	public static event Action<Item> OnItemAddedToBuffer;

	public static event Action OnLoadingFinished;

	public static bool IsAccessableAndNotFull()
	{
		if (Instance == null)
		{
			return false;
		}
		if (Inventory == null)
		{
			return false;
		}
		return Inventory.GetFirstEmptyPosition() >= 0;
	}

	public static void NotifyCapacityDirty()
	{
		needRecalculateCapacity = true;
	}

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		if (Instance != this)
		{
			UnityEngine.Debug.LogError("发现了多个Player Storage!");
			return;
		}
		if (interactable == null)
		{
			interactable = GetComponent<InteractableLootbox>();
		}
		inventory.onContentChanged += OnInventoryContentChanged;
		SavesSystem.OnCollectSaveData += SavesSystem_OnCollectSaveData;
		LevelManager.RegisterWaitForInitialization(this);
	}

	private void Start()
	{
		Load().Forget();
	}

	private void OnDestroy()
	{
		inventory.onContentChanged -= OnInventoryContentChanged;
		SavesSystem.OnCollectSaveData -= SavesSystem_OnCollectSaveData;
		LevelManager.UnregisterWaitForInitialization(this);
	}

	private void SavesSystem_OnSetFile()
	{
		Load().Forget();
	}

	private void SavesSystem_OnCollectSaveData()
	{
		Save();
	}

	private void OnInventoryContentChanged(Inventory inventory, int index)
	{
		PlayerStorage.OnPlayerStorageChange?.Invoke(this, inventory, index);
	}

	public static void Push(Item item, bool toBufferDirectly = false)
	{
		if (item == null)
		{
			return;
		}
		if (!toBufferDirectly && Inventory != null)
		{
			if (item.Stackable)
			{
				while (item.StackCount > 0)
				{
					Item item2 = Inventory.FirstOrDefault((Item e) => e.TypeID == item.TypeID && e.MaxStackCount > e.StackCount);
					if (item2 == null)
					{
						break;
					}
					item2.Combine(item);
				}
			}
			if (item != null && item.StackCount > 0)
			{
				int firstEmptyPosition = Inventory.GetFirstEmptyPosition();
				if (firstEmptyPosition >= 0)
				{
					Inventory.AddAt(item, firstEmptyPosition);
					return;
				}
			}
		}
		NotificationText.Push("PlayerStorage_Notification_ItemAddedToBuffer".ToPlainText().Format(new
		{
			displayName = item.DisplayName
		}));
		IncomingItemBuffer.Add(ItemTreeData.FromItem(item));
		item.Detach();
		item.DestroyTree();
		PlayerStorage.OnItemAddedToBuffer?.Invoke(item);
	}

	private void Save()
	{
		if (!Loading)
		{
			inventory.Save("PlayerStorage");
		}
	}

	private async UniTask Load()
	{
		Loading = true;
		inventory.SetCapacity(16384);
		await ItemSavesUtilities.LoadInventory("PlayerStorage", inventory);
		RecalculateStorageCapacity();
		Loading = false;
		PlayerStorage.OnLoadingFinished?.Invoke();
		initialized = true;
	}

	private void Update()
	{
		if (needRecalculateCapacity)
		{
			RecalculateStorageCapacity();
		}
	}

	public static int RecalculateStorageCapacity()
	{
		if (Instance == null)
		{
			return 0;
		}
		StorageCapacityCalculationHolder storageCapacityCalculationHolder = new StorageCapacityCalculationHolder();
		storageCapacityCalculationHolder.capacity = Instance.DefaultCapacity;
		PlayerStorage.OnRecalculateStorageCapacity?.Invoke(storageCapacityCalculationHolder);
		int capacity = storageCapacityCalculationHolder.capacity;
		Instance.SetCapacity(capacity);
		needRecalculateCapacity = false;
		return capacity;
	}

	private void SetCapacity(int capacity)
	{
		inventory.SetCapacity(capacity);
	}

	public static async UniTask TakeBufferItem(int index)
	{
		if (!Loading && !TakingItem && index >= 0 && index <= IncomingItemBuffer.Count && IsAccessableAndNotFull())
		{
			ItemTreeData itemTreeData = IncomingItemBuffer[index];
			if (itemTreeData != null)
			{
				TakingItem = true;
				Item item = await ItemTreeData.InstantiateAsync(itemTreeData);
				Inventory.AddAndMerge(item);
				IncomingItemBuffer.RemoveAt(index);
				PlayerStorage.OnTakeBufferItem?.Invoke();
				TakingItem = false;
			}
		}
	}

	public bool HasInitialized()
	{
		return initialized;
	}
}
public class PlayerStorageBuffer : MonoBehaviour
{
	private const string bufferSaveKey = "PlayerStorage_Buffer";

	private static List<ItemTreeData> incomingItemBuffer = new List<ItemTreeData>();

	public static PlayerStorageBuffer Instance { get; private set; }

	public static List<ItemTreeData> Buffer => incomingItemBuffer;

	private void Awake()
	{
		Instance = this;
		LoadBuffer();
		SavesSystem.OnCollectSaveData += OnCollectSaveData;
	}

	private void OnCollectSaveData()
	{
		SaveBuffer();
	}

	public static void SaveBuffer()
	{
		List<ItemTreeData> list = new List<ItemTreeData>();
		foreach (ItemTreeData item in incomingItemBuffer)
		{
			if (item != null)
			{
				list.Add(item);
			}
		}
		SavesSystem.Save("PlayerStorage_Buffer", list);
	}

	public static void LoadBuffer()
	{
		incomingItemBuffer.Clear();
		List<ItemTreeData> list = SavesSystem.Load<List<ItemTreeData>>("PlayerStorage_Buffer");
		if (list != null)
		{
			if (list.Count <= 0)
			{
				UnityEngine.Debug.Log("tree data is empty");
			}
			{
				foreach (ItemTreeData item in list)
				{
					incomingItemBuffer.Add(item);
				}
				return;
			}
		}
		UnityEngine.Debug.Log("Tree Data is null");
	}
}
[Serializable]
public struct RandomItemGenerateDescription
{
	[Serializable]
	public struct Entry
	{
		[ItemTypeID]
		[SerializeField]
		public int itemTypeID;
	}

	[TextArea]
	[SerializeField]
	private string comment;

	[Range(0f, 1f)]
	public float chance;

	public Vector2Int randomCount;

	public bool controlDurability;

	public Vector2 durability;

	public Vector2 durabilityIntegrity;

	public bool randomFromPool;

	[SerializeField]
	public RandomContainer<Entry> itemPool;

	public RandomContainer<Tag> tags;

	public List<Tag> addtionalRequireTags;

	public List<Tag> excludeTags;

	public RandomContainer<int> qualities;

	public async UniTask<List<Item>> Generate(int count = -1)
	{
		List<Item> items = new List<Item>();
		if (count < 0)
		{
			count = UnityEngine.Random.Range(randomCount.x, randomCount.y + 1);
		}
		if (count < 1)
		{
			return items;
		}
		List<int> list = new List<int>();
		if (randomFromPool)
		{
			if (UnityEngine.Random.Range(0f, 1f) > chance)
			{
				return items;
			}
			for (int i = 0; i < count; i++)
			{
				Item item = await ItemAssetsCollection.InstantiateAsync(itemPool.GetRandom().itemTypeID);
				if (!(item == null))
				{
					items.Add(item);
					SetDurabilityIfNeeded(item);
				}
			}
			return items;
		}
		if (!excludeTags.Contains(GameplayDataSettings.Tags.Special))
		{
			excludeTags.Add(GameplayDataSettings.Tags.Special);
		}
		if (!LevelManager.Rule.AdvancedDebuffMode && !excludeTags.Contains(GameplayDataSettings.Tags.AdvancedDebuffMode))
		{
			excludeTags.Add(GameplayDataSettings.Tags.AdvancedDebuffMode);
		}
		for (int j = 0; j < count; j++)
		{
			if (!(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				Tag random = tags.GetRandom();
				int random2 = qualities.GetRandom();
				List<Tag> list2 = new List<Tag>();
				if (random != null)
				{
					list2.Add(random);
				}
				if (addtionalRequireTags.Count > 0)
				{
					list2.AddRange(addtionalRequireTags);
				}
				int[] array = ItemAssetsCollection.Search(new ItemFilter
				{
					requireTags = list2.ToArray(),
					excludeTags = excludeTags.ToArray(),
					minQuality = random2,
					maxQuality = random2
				});
				if (array.Length >= 1)
				{
					int random3 = array.GetRandom();
					list.Add(random3);
				}
			}
		}
		foreach (int item3 in list)
		{
			Item item2 = await ItemAssetsCollection.InstantiateAsync(item3);
			if (!(item2 == null))
			{
				items.Add(item2);
				SetDurabilityIfNeeded(item2);
			}
		}
		return items;
	}

	private void SetDurabilityIfNeeded(Item targetItem)
	{
		if (!(targetItem == null) && controlDurability && targetItem.UseDurability)
		{
			float num = UnityEngine.Random.Range(durabilityIntegrity.x, durabilityIntegrity.y);
			targetItem.DurabilityLoss = 1f - num;
			float num2 = UnityEngine.Random.Range(durability.x, durability.y);
			if (num2 > num)
			{
				num2 = num;
			}
			targetItem.Durability = targetItem.MaxDurability * num2;
		}
	}

	private void RefreshPercent()
	{
		itemPool.RefreshPercent();
	}
}
public class UseToCreateItem : UsageBehavior
{
	[Serializable]
	private struct Entry
	{
		[ItemTypeID]
		[SerializeField]
		public int itemTypeID;
	}

	[SerializeField]
	private RandomContainer<Entry> entries;

	[LocalizationKey("Items")]
	public string descKey;

	[LocalizationKey("Default")]
	public string notificationKey;

	private bool running;

	public override DisplaySettingsData DisplaySettings => new DisplaySettingsData
	{
		display = true,
		description = descKey.ToPlainText()
	};

	public override bool CanBeUsed(Item item, object user)
	{
		if (!(user as CharacterMainControl))
		{
			return false;
		}
		return true;
	}

	protected override void OnUse(Item item, object user)
	{
		CharacterMainControl characterMainControl = user as CharacterMainControl;
		if ((bool)characterMainControl && entries.entries.Count != 0)
		{
			Generate(entries.GetRandom().itemTypeID, characterMainControl).Forget();
		}
	}

	private async UniTask Generate(int typeID, CharacterMainControl character)
	{
		if (running)
		{
			return;
		}
		running = true;
		Item item = await ItemAssetsCollection.InstantiateAsync(typeID);
		string displayName = item.DisplayName;
		bool num = character.PickupItem(item);
		NotificationText.Push(notificationKey.ToPlainText() + " " + displayName);
		if (!num && item != null)
		{
			if (item.ActiveAgent != null)
			{
				item.AgentUtilities.ReleaseActiveAgent();
			}
			PlayerStorage.Push(item);
		}
		running = false;
	}

	private void OnValidate()
	{
		entries.RefreshPercent();
	}
}
public class AIMainBrain : MonoBehaviour
{
	public struct SearchTaskContext
	{
		public Vector3 searchCenter;

		public Vector3 searchDirection;

		public float searchAngle;

		public float searchDistance;

		public Teams selfTeam;

		public bool checkObsticle;

		public bool thermalOn;

		public bool ignoreFowBlockLayer;

		public int searchPickupID;

		public Action<DamageReceiver, InteractablePickup> onSearchFinishedCallback;

		public SearchTaskContext(Vector3 center, Vector3 dir, float searchAngle, float searchDistance, Teams selfTeam, bool checkObsticle, bool thermalOn, bool ignoreFowBlockLayer, int searchPickupID, Action<DamageReceiver, InteractablePickup> callback)
		{
			searchCenter = center;
			searchDirection = dir;
			this.searchAngle = searchAngle;
			this.searchDistance = searchDistance;
			this.selfTeam = selfTeam;
			this.thermalOn = thermalOn;
			this.checkObsticle = checkObsticle;
			this.searchPickupID = searchPickupID;
			onSearchFinishedCallback = callback;
			this.ignoreFowBlockLayer = ignoreFowBlockLayer;
		}
	}

	public struct CheckObsticleTaskContext
	{
		public Vector3 start;

		public Vector3 end;

		public bool thermalOn;

		public bool ignoreFowBlockLayer;

		public Action<bool> onCheckFinishCallback;

		public CheckObsticleTaskContext(Vector3 start, Vector3 end, bool thermalOn, bool ignoreFowBlockLayer, Action<bool> onCheckFinishCallback)
		{
			this.start = start;
			this.end = end;
			this.thermalOn = thermalOn;
			this.onCheckFinishCallback = onCheckFinishCallback;
			this.ignoreFowBlockLayer = ignoreFowBlockLayer;
		}
	}

	private Queue<SearchTaskContext> searchTasks;

	private Queue<CheckObsticleTaskContext> checkObsticleTasks;

	private LayerMask dmgReceiverLayers;

	private LayerMask interactLayers;

	private LayerMask obsticleLayers;

	private LayerMask obsticleLayersWithThermal;

	private Collider[] cols;

	private RaycastHit[] ObsHits;

	public int maxSeachCount;

	public int maxCheckObsticleCount;

	private static CharacterMainControl _mc;

	private int fowBlockLayer;

	private DamageReceiver dmgReceiverTemp;

	private static CharacterMainControl mainCharacter
	{
		get
		{
			if (_mc == null)
			{
				_mc = CharacterMainControl.Main;
			}
			return _mc;
		}
	}

	public static event Action<AISound> OnSoundSpawned;

	public static event Action<AISound> OnPlayerHearSound;

	public static void MakeSound(AISound sound)
	{
		AIMainBrain.OnSoundSpawned?.Invoke(sound);
		FilterPlayerHearSound(sound);
	}

	private static void FilterPlayerHearSound(AISound sound)
	{
		if (!mainCharacter || !Team.IsEnemy(Teams.player, sound.fromTeam) || ((bool)sound.fromCharacter && (bool)sound.fromCharacter.characterModel && !sound.fromCharacter.characterModel.Hidden && !GameCamera.Instance.IsOffScreen(sound.pos)))
		{
			return;
		}
		float num = Vector3.Distance(sound.pos, mainCharacter.transform.position);
		if (!(mainCharacter.SoundVisable < 0.2f))
		{
			float hearingAbility = mainCharacter.HearingAbility;
			if (!(num > sound.radius * hearingAbility))
			{
				AIMainBrain.OnPlayerHearSound?.Invoke(sound);
			}
		}
	}

	public void Awake()
	{
		searchTasks = new Queue<SearchTaskContext>();
		checkObsticleTasks = new Queue<CheckObsticleTaskContext>();
		fowBlockLayer = LayerMask.NameToLayer("FowBlock");
	}

	private void Start()
	{
		dmgReceiverLayers = GameplayDataSettings.Layers.damageReceiverLayerMask;
		interactLayers = 1 << LayerMask.NameToLayer("Interactable");
		obsticleLayers = GameplayDataSettings.Layers.fowBlockLayers;
		obsticleLayersWithThermal = GameplayDataSettings.Layers.fowBlockLayersWithThermal;
		cols = new Collider[15];
		ObsHits = new RaycastHit[15];
	}

	private void Update()
	{
		for (int i = 0; i < maxSeachCount; i++)
		{
			if (searchTasks.Count <= 0)
			{
				break;
			}
			DoSearch(searchTasks.Dequeue());
		}
		for (int j = 0; j < maxCheckObsticleCount; j++)
		{
			if (checkObsticleTasks.Count <= 0)
			{
				break;
			}
			DoCheckObsticle(checkObsticleTasks.Dequeue());
		}
	}

	private void DoSearch(SearchTaskContext context)
	{
		int num = Physics.OverlapSphereNonAlloc(context.searchCenter, context.searchDistance, cols, (context.searchPickupID > 0) ? ((int)dmgReceiverLayers | (int)interactLayers) : ((int)dmgReceiverLayers), QueryTriggerInteraction.Collide);
		if (num <= 0)
		{
			context.onSearchFinishedCallback(null, null);
			return;
		}
		float num2 = 9999f;
		DamageReceiver arg = null;
		float num3 = 9999f;
		InteractablePickup arg2 = null;
		float num4 = 1.5f;
		for (int i = 0; i < num; i++)
		{
			Collider collider = cols[i];
			if (Mathf.Abs(context.searchCenter.y - collider.transform.position.y) > 4f)
			{
				continue;
			}
			float num5 = Vector3.Distance(context.searchCenter, collider.transform.position);
			if (Vector3.Angle(context.searchDirection.normalized, (collider.transform.position - context.searchCenter).normalized) > context.searchAngle * 0.5f && num5 > num4)
			{
				continue;
			}
			dmgReceiverTemp = null;
			float num6 = 1f;
			if (collider.gameObject.IsInLayerMask(dmgReceiverLayers))
			{
				dmgReceiverTemp = collider.GetComponent<DamageReceiver>();
				if (dmgReceiverTemp != null && (bool)dmgReceiverTemp.health)
				{
					CharacterMainControl characterMainControl = dmgReceiverTemp.health.TryGetCharacter();
					if ((bool)characterMainControl)
					{
						num6 = characterMainControl.VisableDistanceFactor;
					}
				}
			}
			if (num5 > context.searchDistance * num6 || (num5 >= num2 && num5 >= num3) || (context.checkObsticle && num5 > num4 && CheckObsticle(context.searchCenter, collider.transform.position + Vector3.up * 1.5f, context.thermalOn, context.ignoreFowBlockLayer)))
			{
				continue;
			}
			if ((bool)dmgReceiverTemp)
			{
				if (!(dmgReceiverTemp.health == null) && Team.IsEnemy(context.selfTeam, dmgReceiverTemp.Team))
				{
					num2 = num5;
					arg = dmgReceiverTemp;
				}
			}
			else if (context.searchPickupID > 0)
			{
				InteractablePickup component = collider.GetComponent<InteractablePickup>();
				if ((bool)component && (bool)component.ItemAgent && (bool)component.ItemAgent.Item && component.ItemAgent.Item.TypeID == context.searchPickupID)
				{
					num3 = num5;
					arg2 = component;
				}
			}
		}
		context.onSearchFinishedCallback(arg, arg2);
	}

	public void AddSearchTask(Vector3 center, Vector3 dir, float searchAngle, float searchDistance, Teams selfTeam, bool checkObsticle, bool thermalOn, bool ignoreFowBlockLayer, int searchPickupID, Action<DamageReceiver, InteractablePickup> callback)
	{
		SearchTaskContext item = new SearchTaskContext(center, dir, searchAngle, searchDistance, selfTeam, checkObsticle, thermalOn, ignoreFowBlockLayer, searchPickupID, callback);
		searchTasks.Enqueue(item);
	}

	private void DoCheckObsticle(CheckObsticleTaskContext context)
	{
		bool obj = CheckObsticle(context.start, context.end, context.thermalOn, context.ignoreFowBlockLayer);
		context.onCheckFinishCallback(obj);
	}

	public void AddCheckObsticleTask(Vector3 start, Vector3 end, bool thermalOn, bool ignoreFowBlockLayer, Action<bool> callback)
	{
		CheckObsticleTaskContext item = new CheckObsticleTaskContext(start, end, thermalOn, ignoreFowBlockLayer, callback);
		checkObsticleTasks.Enqueue(item);
	}

	private bool CheckObsticle(Vector3 startPoint, Vector3 endPoint, bool thermalOn, bool ignoreFowBlockLayer)
	{
		Ray ray = new Ray(startPoint, (endPoint - startPoint).normalized);
		LayerMask layerMask = (thermalOn ? obsticleLayersWithThermal : obsticleLayers);
		if (ignoreFowBlockLayer)
		{
			layerMask = (int)layerMask & ~(1 << fowBlockLayer);
		}
		return Physics.RaycastNonAlloc(ray, ObsHits, (endPoint - startPoint).magnitude, layerMask) > 0;
	}
}
public struct AISound
{
	public Vector3 pos;

	public float radius;

	public Teams fromTeam;

	public SoundTypes soundType;

	public CharacterMainControl fromCharacter;

	public GameObject fromObject;
}
public enum SoundTypes
{
	unknowNoise,
	combatSound,
	grenadeDropSound,
	alert
}
public class CharacterCreator : MonoBehaviour
{
	public CharacterMainControl characterPfb => GameplayDataSettings.Prefabs.CharacterPrefab;

	public async UniTask<CharacterMainControl> CreateCharacter(Item itemInstance, CharacterModel modelPrefab, Vector3 pos, Quaternion rotation)
	{
		CharacterMainControl characterMainControl = UnityEngine.Object.Instantiate(characterPfb, pos, rotation);
		CharacterModel characterModel = UnityEngine.Object.Instantiate(modelPrefab);
		characterMainControl.SetCharacterModel(characterModel);
		if (itemInstance == null)
		{
			if ((bool)characterMainControl)
			{
				UnityEngine.Object.Destroy(characterMainControl.gameObject);
			}
			return null;
		}
		characterMainControl.SetItem(itemInstance);
		if (!LevelManager.Instance.IsRaidMap)
		{
			characterMainControl.AddBuff(GameplayDataSettings.Buffs.BaseBuff);
		}
		return characterMainControl;
	}

	public async UniTask<Item> LoadOrCreateCharacterItemInstance(int itemTypeID)
	{
		return await ItemAssetsCollection.InstantiateAsync(itemTypeID);
	}
}
public class CharacterPosInShader : MonoBehaviour
{
	private int characterPosHash = Shader.PropertyToID("CharacterPos");

	private void Update()
	{
		if ((bool)CharacterMainControl.Main)
		{
			Shader.SetGlobalVector(characterPosHash, CharacterMainControl.Main.transform.position);
		}
	}
}
public class CustomFaceManager : MonoBehaviour
{
	public void SaveSettingToMainCharacter(CustomFaceSettingData setting)
	{
		SaveSetting("CustomFace_MainCharacter", setting);
	}

	public CustomFaceSettingData LoadMainCharacterSetting()
	{
		return LoadSetting("CustomFace_MainCharacter");
	}

	private void SaveSetting(string key, CustomFaceSettingData setting)
	{
		setting.savedSetting = true;
		SavesSystem.Save(key, setting);
	}

	private CustomFaceSettingData LoadSetting(string key)
	{
		CustomFaceSettingData result = SavesSystem.Load<CustomFaceSettingData>(key);
		if (!result.savedSetting)
		{
			result = GameplayDataSettings.CustomFaceData.DefaultPreset.settings;
		}
		return result;
	}
}
public class ExitCreator : MonoBehaviour
{
	public GameObject exitPrefab;

	[LocalizationKey("Default")]
	public string exitNameKey;

	[SerializeField]
	private Sprite icon;

	[SerializeField]
	private Color iconColor = Color.white;

	[SerializeField]
	private Color shadowColor = Color.white;

	[SerializeField]
	private float shadowDistance;

	private int minExitCount => LevelConfig.MinExitCount;

	private int maxExitCount => LevelConfig.MaxExitCount;

	public void Spawn()
	{
		int num = UnityEngine.Random.Range(minExitCount, maxExitCount + 1);
		if (MultiSceneCore.Instance == null)
		{
			return;
		}
		List<(string, SubSceneEntry.Location)> list = new List<(string, SubSceneEntry.Location)>();
		foreach (SubSceneEntry subScene in MultiSceneCore.Instance.SubScenes)
		{
			foreach (SubSceneEntry.Location cachedLocation in subScene.cachedLocations)
			{
				if (IsPathCompitable(cachedLocation))
				{
					list.Add((subScene.sceneID, cachedLocation));
				}
			}
		}
		list.Sort(compareExit);
		if (num > list.Count)
		{
			num = list.Count;
		}
		MiniMapSettings.TryGetMinimapPosition(LevelManager.Instance.MainCharacter.transform.position, out var _);
		int num2 = Mathf.RoundToInt((float)list.Count * 0.8f);
		if (num > num2)
		{
			num2 = num;
		}
		for (int i = 0; i < num; i++)
		{
			int index = UnityEngine.Random.Range(0, num2);
			num2--;
			(string, SubSceneEntry.Location) tuple = list[index];
			list.RemoveAt(index);
			SceneInfoEntry sceneInfo = SceneInfoCollection.GetSceneInfo(tuple.Item1);
			CreateExit(tuple.Item2.position, sceneInfo.BuildIndex, i);
		}
	}

	private int compareExit((string sceneID, SubSceneEntry.Location locationData) a, (string sceneID, SubSceneEntry.Location locationData) b)
	{
		if (!MiniMapSettings.TryGetMinimapPosition(LevelManager.Instance.MainCharacter.transform.position, out var result))
		{
			return -1;
		}
		if (!MiniMapSettings.TryGetMinimapPosition(a.locationData.position, a.sceneID, out var result2))
		{
			return -1;
		}
		if (!MiniMapSettings.TryGetMinimapPosition(b.locationData.position, b.sceneID, out var result3))
		{
			return -1;
		}
		float num = Vector3.Distance(result, result2);
		float num2 = Vector3.Distance(result, result3);
		if (num > num2)
		{
			return -1;
		}
		return 1;
	}

	private bool IsPathCompitable(SubSceneEntry.Location location)
	{
		string path = location.path;
		int num = path.IndexOf('/');
		if (num != -1 && path.Substring(0, num) == "Exits")
		{
			return true;
		}
		return false;
	}

	private void CreateExit(Vector3 position, int sceneBuildIndex, int debugIndex)
	{
		GameObject go = UnityEngine.Object.Instantiate(exitPrefab, position, Quaternion.identity);
		if ((bool)MultiSceneCore.Instance)
		{
			MultiSceneCore.MoveToActiveWithScene(go, sceneBuildIndex);
		}
		SpawnMapElement(position, sceneBuildIndex, debugIndex);
	}

	private void SpawnMapElement(Vector3 position, int sceneBuildIndex, int debugIndex)
	{
		SimplePointOfInterest simplePointOfInterest = new GameObject("MapElement").AddComponent<SimplePointOfInterest>();
		simplePointOfInterest.transform.position = position;
		if (MultiSceneCore.Instance != null)
		{
			simplePointOfInterest.Color = iconColor;
			simplePointOfInterest.ShadowColor = shadowColor;
			simplePointOfInterest.ShadowDistance = shadowDistance;
			simplePointOfInterest.IsArea = false;
			simplePointOfInterest.ScaleFactor = 1f;
			string sceneID = SceneInfoCollection.GetSceneID(sceneBuildIndex);
			simplePointOfInterest.Setup(icon, exitNameKey, followActiveScene: false, sceneID);
			SceneManager.MoveGameObjectToScene(simplePointOfInterest.gameObject, MultiSceneCore.MainScene.Value);
		}
	}
}
public enum ExplosionFxTypes
{
	normal,
	flash,
	fire,
	ice,
	custom
}
public class ExplosionManager : MonoBehaviour
{
	private LayerMask damageReceiverLayers;

	private LayerMask obsticleLayers;

	private List<Health> damagedHealth;

	private Collider[] colliders;

	public GameObject normalFxPfb;

	public GameObject flashFxPfb;

	private RaycastHit[] ObsHits;

	private void Awake()
	{
		ObsHits = new RaycastHit[3];
	}

	public void CreateExplosion(Vector3 center, float radius, DamageInfo dmgInfo, ExplosionFxTypes fxType = ExplosionFxTypes.normal, float shakeStrength = 1f, bool canHurtSelf = true)
	{
		Vector3.Distance(center, CharacterMainControl.Main.transform.position);
		if (Vector3.Distance(center, CharacterMainControl.Main.transform.position) < 30f)
		{
			CameraShaker.Shake((center - LevelManager.Instance.MainCharacter.transform.position).normalized * 0.4f * shakeStrength, CameraShaker.CameraShakeTypes.explosion);
		}
		dmgInfo.isExplosion = true;
		if (damagedHealth == null)
		{
			damagedHealth = new List<Health>();
			colliders = new Collider[8];
			damageReceiverLayers = GameplayDataSettings.Layers.damageReceiverLayerMask;
		}
		damagedHealth.Clear();
		Teams selfTeam = Teams.all;
		if ((bool)dmgInfo.fromCharacter && !canHurtSelf)
		{
			selfTeam = dmgInfo.fromCharacter.Team;
		}
		int num = Physics.OverlapSphereNonAlloc(center, radius, colliders, damageReceiverLayers);
		for (int i = 0; i < num; i++)
		{
			DamageReceiver component = colliders[i].gameObject.GetComponent<DamageReceiver>();
			if (!(component != null) || !Team.IsEnemy(selfTeam, component.Team) || (component.health != null && CheckObsticle(center + Vector3.up * 0.2f, colliders[i].gameObject.transform.position + Vector3.up * 0.6f)))
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			if (component.health != null)
			{
				if (damagedHealth.Contains(component.health))
				{
					flag = true;
				}
				else
				{
					damagedHealth.Add(component.health);
				}
				CharacterMainControl characterMainControl = component.health.TryGetCharacter();
				if ((bool)characterMainControl && characterMainControl.Dashing)
				{
					flag2 = true;
				}
			}
			if (!flag && !flag2)
			{
				dmgInfo.toDamageReceiver = component;
				dmgInfo.damagePoint = component.transform.position + Vector3.up * 0.6f;
				dmgInfo.damageNormal = (dmgInfo.damagePoint - center).normalized;
				component.Hurt(dmgInfo);
			}
		}
		switch (fxType)
		{
		case ExplosionFxTypes.normal:
			UnityEngine.Object.Instantiate(normalFxPfb, center, Quaternion.identity);
			break;
		case ExplosionFxTypes.flash:
			UnityEngine.Object.Instantiate(flashFxPfb, center, Quaternion.identity);
			break;
		case ExplosionFxTypes.fire:
		case ExplosionFxTypes.ice:
			break;
		}
	}

	private bool CheckObsticle(Vector3 startPoint, Vector3 endPoint)
	{
		obsticleLayers = (int)GameplayDataSettings.Layers.wallLayerMask | (int)GameplayDataSettings.Layers.groundLayerMask;
		startPoint.y = 0.5f;
		endPoint.y = 0.5f;
		return Physics.RaycastNonAlloc(new Ray(startPoint, (endPoint - startPoint).normalized), ObsHits, (endPoint - startPoint).magnitude, obsticleLayers) > 0;
	}
}
public class InputManager : MonoBehaviour
{
	public enum InputDevices
	{
		mouseKeyboard,
		touch
	}

	private static InputDevices inputDevice = InputDevices.mouseKeyboard;

	public CharacterMainControl characterMainControl;

	public AimTargetFinder aimTargetFinder;

	public float runThreshold = 0.85f;

	private Vector3 worldMoveInput;

	public static Action OnInteractButtonDown;

	private Transform aimTargetCol;

	private LayerMask obsticleLayers;

	private RaycastHit[] obsticleHits;

	private RaycastHit hittedCharacterDmgReceiverInfo;

	private RaycastHit hittedObsticleInfo;

	private RaycastHit hittedHead;

	private LayerMask aimCheckLayers;

	private CharacterMainControl foundCharacter;

	public static readonly int PrimaryWeaponSlotHash = "PrimaryWeapon".GetHashCode();

	public static readonly int SecondaryWeaponSlotHash = "SecondaryWeapon".GetHashCode();

	public static readonly int MeleeWeaponSlotHash = "MeleeWeapon".GetHashCode();

	private Camera mainCam;

	private float checkGunDurabilityCoolTimer;

	private float checkGunDurabilityCoolTime = 2f;

	private Transform aimTarget;

	private Vector2 joystickAxisInput;

	private Vector2 moveAxisInput;

	private Vector2 aimScreenPoint;

	private Vector3 inputAimPoint;

	public static bool useRunInputBuffer = false;

	private HashSet<GameObject> blockInputSources = new HashSet<GameObject>();

	private int inputActiveCoolCounter;

	private bool adsInput;

	private bool runInputBuffer;

	private bool runInput;

	private bool runInptutThisFrame;

	private bool newRecoil;

	private ItemAgent_Gun recoilGun;

	private float recoilV;

	private float recoilH;

	private float recoilRecover;

	private bool triggerInput;

	private Vector2 recoilNeedToRecover;

	private Vector2 inputMousePosition;

	private Vector2 _aimMousePosCache;

	private bool aimMousePosFirstSynced;

	private bool cursorVisable = true;

	private bool aimingEnemyHead;

	private bool currentFocus = true;

	private float fovCache = -1f;

	private float _oppositeDelta;

	private float recoilTimer;

	private float recoilTime = 0.04f;

	private float recoilRecoverTime = 0.1f;

	private Vector2 recoilThisShot;

	public static InputDevices InputDevice => inputDevice;

	public Vector3 WorldMoveInput => worldMoveInput;

	public Transform AimTarget => aimTargetCol;

	public Vector2 MoveAxisInput => moveAxisInput;

	public Vector2 AimScreenPoint => aimScreenPoint;

	public Vector3 InputAimPoint => inputAimPoint;

	private static InputManager instance
	{
		get
		{
			if (LevelManager.Instance == null)
			{
				return null;
			}
			return LevelManager.Instance.InputManager;
		}
	}

	public static bool InputActived
	{
		get
		{
			if (!instance)
			{
				return false;
			}
			if (GameManager.Paused)
			{
				return false;
			}
			if (CameraMode.Active)
			{
				return false;
			}
			if (!LevelManager.LevelInited)
			{
				return false;
			}
			if (!CharacterMainControl.Main || CharacterMainControl.Main.Health.IsDead)
			{
				return false;
			}
			return instance.inputActiveCoolCounter <= 0;
		}
	}

	public Vector2 MousePos => inputMousePosition;

	public bool TriggerInput => triggerInput;

	private Vector2 AimMousePosition
	{
		get
		{
			if (!aimMousePosFirstSynced)
			{
				aimMousePosFirstSynced = true;
				if (Mouse.current != null)
				{
					_aimMousePosCache = Mouse.current.position.ReadValue();
				}
			}
			return _aimMousePosCache;
		}
		set
		{
			if (!aimMousePosFirstSynced)
			{
				aimMousePosFirstSynced = true;
				if (Mouse.current != null)
				{
					_aimMousePosCache = Mouse.current.position.ReadValue();
				}
			}
			_aimMousePosCache = value;
		}
	}

	public bool AimingEnemyHead => aimingEnemyHead;

	public static event Action OnInputDeviceChanged;

	public static event Action<int> OnSwitchBulletTypeInput;

	public static event Action<int> OnSwitchWeaponInput;

	private void OnDestroy()
	{
		UnityEngine.Cursor.visible = true;
		UnityEngine.Cursor.lockState = CursorLockMode.None;
	}

	private void Start()
	{
		obsticleHits = new RaycastHit[3];
		obsticleLayers = (int)GameplayDataSettings.Layers.wallLayerMask | (int)GameplayDataSettings.Layers.groundLayerMask;
	}

	private void OnApplicationFocus(bool hasFocus)
	{
		currentFocus = hasFocus;
		if (!currentFocus)
		{
			UnityEngine.Cursor.lockState = CursorLockMode.None;
		}
	}

	private void Awake()
	{
		if (blockInputSources == null)
		{
			blockInputSources = new HashSet<GameObject>();
		}
	}

	public static void DisableInput(GameObject source)
	{
		if (!(source == null) && !(instance == null))
		{
			instance.inputActiveCoolCounter = 2;
			instance.blockInputSources.Add(source);
		}
	}

	public static void ActiveInput(GameObject source)
	{
		if (!(source == null))
		{
			instance.blockInputSources.Remove(source);
		}
	}

	public static void SetInputDevice(InputDevices _inputDevice)
	{
		InputManager.OnInputDeviceChanged?.Invoke();
	}

	private void UpdateCursor()
	{
		if (LevelManager.Instance == null || characterMainControl == null || !characterMainControl.gameObject.activeInHierarchy)
		{
			UnityEngine.Cursor.visible = true;
			UnityEngine.Cursor.lockState = CursorLockMode.None;
			return;
		}
		bool flag = !characterMainControl || characterMainControl.Health.IsDead;
		bool flag2 = true;
		if (InputActived && !flag)
		{
			flag2 = false;
		}
		if (CameraMode.Active)
		{
			flag2 = false;
		}
		if (View.ActiveView != null)
		{
			flag2 = true;
		}
		if (!Application.isFocused)
		{
			flag2 = true;
		}
		if (cursorVisable != flag2)
		{
			cursorVisable = !cursorVisable;
		}
		if (cursorVisable)
		{
			recoilNeedToRecover = Vector2.zero;
			if (Mouse.current != null)
			{
				AimMousePosition = Mouse.current.position.ReadValue();
			}
		}
		if (Application.isFocused)
		{
			UnityEngine.Cursor.visible = cursorVisable;
		}
		else
		{
			UnityEngine.Cursor.visible = true;
		}
		bool flag3 = false;
		if (CameraMode.Active)
		{
			flag3 = true;
		}
		if (currentFocus)
		{
			UnityEngine.Cursor.lockState = (flag3 ? CursorLockMode.Locked : CursorLockMode.Confined);
		}
		else
		{
			UnityEngine.Cursor.lockState = CursorLockMode.None;
		}
	}

	private void Update()
	{
		if (!characterMainControl)
		{
			return;
		}
		if (!mainCam)
		{
			mainCam = LevelManager.Instance.GameCamera.renderCamera;
			return;
		}
		UpdateInputActived();
		UpdateCursor();
		if (runInput)
		{
			if (runInptutThisFrame)
			{
				runInputBuffer = !runInputBuffer;
			}
		}
		else if (moveAxisInput.magnitude < 0.1f)
		{
			runInputBuffer = false;
		}
		else if (adsInput)
		{
			runInputBuffer = false;
		}
		characterMainControl.SetRunInput(useRunInputBuffer ? runInputBuffer : runInput);
		SetMoveInput(moveAxisInput);
		if (InputDevice == InputDevices.touch)
		{
			UpdateJoystickAim();
			UpdateAimWhileUsingTouch();
		}
		if (checkGunDurabilityCoolTimer <= checkGunDurabilityCoolTime)
		{
			checkGunDurabilityCoolTimer += Time.deltaTime;
		}
		runInptutThisFrame = false;
	}

	private void UpdateInputActived()
	{
		blockInputSources.RemoveWhere((GameObject x) => x == null || !x.activeInHierarchy);
		if (blockInputSources.Count > 0)
		{
			instance.inputActiveCoolCounter = 2;
		}
		else if (instance.inputActiveCoolCounter > 0)
		{
			instance.inputActiveCoolCounter--;
		}
	}

	private void UpdateAimWhileUsingTouch()
	{
	}

	public void SetTrigger(bool trigger, bool triggerThisFrame, bool releaseThisFrame)
	{
		triggerInput = false;
		if (!characterMainControl)
		{
			return;
		}
		if (!InputActived)
		{
			characterMainControl.Trigger(trigger: false, triggerThisFrame: false, releaseThisFrame: false);
			return;
		}
		triggerInput = trigger;
		characterMainControl.Trigger(trigger, triggerThisFrame, releaseThisFrame);
		if (trigger)
		{
			CheckGunDurability();
		}
		if (triggerThisFrame)
		{
			runInputBuffer = false;
			characterMainControl.Attack();
		}
	}

	private void CheckAttack()
	{
		if (InputDevice == InputDevices.touch && (!characterMainControl.CurrentAction || !characterMainControl.CurrentAction.Running))
		{
			ItemAgent_MeleeWeapon meleeWeapon = characterMainControl.GetMeleeWeapon();
			if (!(meleeWeapon == null) && meleeWeapon.AttackableTargetInRange())
			{
				characterMainControl.Attack();
			}
		}
	}

	private void CheckGunDurability()
	{
		if (!(checkGunDurabilityCoolTimer <= checkGunDurabilityCoolTime))
		{
			ItemAgent_Gun gun = characterMainControl.GetGun();
			if (gun != null && gun.Item.Durability <= 0f)
			{
				DialogueBubblesManager.Show("Pop_GunBroken".ToPlainText(), characterMainControl.transform, 2.5f).Forget();
			}
		}
	}

	private Vector3 TrnasAxisInputToWorld(Vector2 axisInput)
	{
		Vector3 zero = Vector3.zero;
		if (!mainCam)
		{
			return zero;
		}
		if (!characterMainControl)
		{
			return zero;
		}
		if (MoveDirectionOptions.MoveViaCharacterDirection)
		{
			Vector3 vector = inputAimPoint - characterMainControl.transform.position;
			vector.y = 0f;
			if (vector.magnitude < 1f)
			{
				return characterMainControl.transform.forward;
			}
			vector.Normalize();
			Vector3 vector2 = Quaternion.Euler(0f, 90f, 0f) * vector;
			return axisInput.x * vector2 + axisInput.y * vector;
		}
		Vector3 right = mainCam.transform.right;
		right.y = 0f;
		right.Normalize();
		Vector3 forward = mainCam.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		return axisInput.x * right + axisInput.y * forward;
	}

	public void SetSwitchBulletTypeInput(int dir)
	{
		if ((bool)characterMainControl && InputActived)
		{
			InputManager.OnSwitchBulletTypeInput?.Invoke(dir);
		}
	}

	public void SetSwitchWeaponInput(int dir)
	{
		if ((bool)characterMainControl && InputActived)
		{
			InputManager.OnSwitchWeaponInput?.Invoke(dir);
			characterMainControl.SwitchWeapon(dir);
		}
	}

	public void SetSwitchInteractInput(int dir)
	{
		if ((bool)characterMainControl && InputActived)
		{
			characterMainControl.SwitchInteractSelection((dir <= 0) ? 1 : (-1));
		}
	}

	public void SetMoveInput(Vector2 axisInput)
	{
		moveAxisInput = axisInput;
		if (!characterMainControl)
		{
			return;
		}
		if (!InputActived)
		{
			characterMainControl.SetMoveInput(Vector3.zero);
			return;
		}
		worldMoveInput = TrnasAxisInputToWorld(axisInput);
		Vector3 normalized = worldMoveInput;
		if (normalized.magnitude > 0.02f)
		{
			normalized = normalized.normalized;
		}
		characterMainControl.SetMoveInput(normalized);
	}

	public void SetRunInput(bool run)
	{
		if ((bool)characterMainControl)
		{
			if (!InputActived)
			{
				runInput = false;
				runInptutThisFrame = false;
				characterMainControl.SetRunInput(_runInput: false);
			}
			else
			{
				runInptutThisFrame = !runInput && run;
				runInput = run;
			}
		}
	}

	public void SetAdsInput(bool ads)
	{
		if ((bool)characterMainControl)
		{
			if (!InputActived)
			{
				characterMainControl.SetAdsInput(_adsInput: false);
				adsInput = false;
			}
			else
			{
				adsInput = ads;
				characterMainControl.SetAdsInput(ads);
			}
		}
	}

	public void ToggleView()
	{
		if ((bool)characterMainControl && InputActived)
		{
			CameraArm.ToggleView();
		}
	}

	public void ToggleNightVision()
	{
		if ((bool)characterMainControl && InputActived)
		{
			characterMainControl.ToggleNightVision();
		}
	}

	public void SetAimInputUsingJoystick(Vector2 _joystickAxisInput)
	{
		if (InputDevice != InputDevices.mouseKeyboard && (bool)characterMainControl)
		{
			if (!InputActived)
			{
				joystickAxisInput = Vector3.zero;
			}
			else
			{
				joystickAxisInput = _joystickAxisInput;
			}
		}
	}

	private void UpdateJoystickAim()
	{
	}

	public void SetAimType(AimTypes aimType)
	{
		if ((bool)characterMainControl && InputActived)
		{
			SkillBase currentRunningSkill = characterMainControl.GetCurrentRunningSkill();
			if (aimType != characterMainControl.AimType && currentRunningSkill != null)
			{
				UnityEngine.Debug.Log("skill is running:" + currentRunningSkill.name);
			}
			else
			{
				characterMainControl.SetAimType(aimType);
			}
		}
	}

	public void SetMousePosition(Vector2 mousePosition)
	{
		inputMousePosition = mousePosition;
	}

	public void SetAimInputUsingMouse(Vector2 mouseDelta)
	{
		aimingEnemyHead = false;
		AimMousePosition += mouseDelta * OptionsManager.MouseSensitivity / 10f;
		if (!characterMainControl || !InputActived)
		{
			return;
		}
		ItemAgent_Gun gun = characterMainControl.GetGun();
		if ((bool)gun)
		{
			AimMousePosition = ProcessMousePosViaRecoil(AimMousePosition, mouseDelta, gun);
		}
		Vector2 deltaValue = default(Vector2);
		if (Application.isFocused && InputActived && !Application.isEditor)
		{
			Vector2 mousePosition = AimMousePosition;
			ClampMousePosInWindow(ref mousePosition, ref deltaValue);
			AimMousePosition = mousePosition;
		}
		aimScreenPoint = AimMousePosition;
		characterMainControl.GetCurrentRunningSkill();
		Ray ray = LevelManager.Instance.GameCamera.renderCamera.ScreenPointToRay(aimScreenPoint);
		Plane plane = new Plane(Vector3.up, Vector3.up * (characterMainControl.transform.position.y + 0.5f));
		float enter = 0f;
		plane.Raycast(ray, out enter);
		Vector3 vector = ray.origin + ray.direction * enter;
		UnityEngine.Debug.DrawLine(vector, vector + Vector3.up * 3f, Color.yellow);
		Vector3 aimPoint = vector;
		if ((bool)gun && characterMainControl.CanControlAim())
		{
			if (Physics.Raycast(ray, out hittedHead, 100f, 1 << LayerMask.NameToLayer("HeadCollider")))
			{
				aimingEnemyHead = true;
			}
			Vector3 position = characterMainControl.transform.position;
			if ((bool)gun)
			{
				position = gun.muzzle.transform.position;
			}
			Vector3 vector2 = vector - position;
			vector2.y = 0f;
			vector2.Normalize();
			Vector3 axis = Vector3.Cross(vector2, ray.direction);
			aimCheckLayers = GameplayDataSettings.Layers.damageReceiverLayerMask;
			for (int i = 0; (float)i < 45f; i++)
			{
				int num = i;
				if (i > 23)
				{
					num = -(i - 23);
				}
				float num2 = 1.5f;
				Vector3 vector3 = Quaternion.AngleAxis(-2f * (float)num, axis) * vector2;
				Ray ray2 = new Ray(position + num2 * vector3, vector3);
				if (Physics.SphereCast(ray2, 0.02f, out hittedCharacterDmgReceiverInfo, gun.BulletDistance, aimCheckLayers, QueryTriggerInteraction.Ignore) && hittedCharacterDmgReceiverInfo.distance > 0.1f && !Physics.SphereCast(ray2, 0.1f, out hittedObsticleInfo, hittedCharacterDmgReceiverInfo.distance, obsticleLayers, QueryTriggerInteraction.Ignore))
				{
					aimPoint = hittedCharacterDmgReceiverInfo.point;
					break;
				}
			}
		}
		if (aimingEnemyHead)
		{
			Vector3 direction = ray.direction;
			Vector3 rhs = hittedHead.collider.transform.position - hittedHead.point;
			float num3 = Vector3.Dot(direction, rhs);
			aimPoint = hittedHead.point + direction * num3 * 0.5f;
		}
		inputAimPoint = vector;
		characterMainControl.SetAimPoint(aimPoint);
		if (Application.isFocused && currentFocus && InputActived)
		{
			Mouse.current.WarpCursorPosition(AimMousePosition);
		}
	}

	private Vector2 ProcessMousePosViaCameraChange(Vector2 inputMousePos)
	{
		Camera renderCamera = LevelManager.Instance.GameCamera.renderCamera;
		if (fovCache < 0f)
		{
			fovCache = renderCamera.fieldOfView;
			return inputMousePos;
		}
		float fieldOfView = renderCamera.fieldOfView;
		Vector2 vector = new Vector2(inputMousePos.x / (float)Screen.width * 2f - 1f, inputMousePos.y / (float)Screen.height * 2f - 1f);
		float num = Mathf.Tan(fovCache * (MathF.PI / 180f) / 2f) / Mathf.Tan(fieldOfView * (MathF.PI / 180f) / 2f);
		Vector2 vector2 = vector * num;
		Vector2 result = new Vector2((vector2.x + 1f) * 0.5f * (float)Screen.width, (vector2.y + 1f) * 0.5f * (float)Screen.height);
		fovCache = fieldOfView;
		return result;
	}

	private void ClampMousePosInWindow(ref Vector2 mousePosition, ref Vector2 deltaValue)
	{
		Vector2 zero = Vector2.zero;
		zero.x = Mathf.Clamp(mousePosition.x, 0f, Screen.width);
		zero.y = Mathf.Clamp(mousePosition.y, 0f, Screen.height);
		deltaValue = zero - mousePosition;
		mousePosition = zero;
	}

	public void Interact()
	{
		if ((bool)characterMainControl && InputActived)
		{
			characterMainControl.Interact();
			OnInteractButtonDown?.Invoke();
		}
	}

	public void PutAway()
	{
		if ((bool)characterMainControl && InputActived)
		{
			characterMainControl.ChangeHoldItem(null);
		}
	}

	public void SwitchItemAgent(int index)
	{
		if ((bool)characterMainControl && InputActived)
		{
			switch (index)
			{
			case 1:
				characterMainControl.SwitchHoldAgentInSlot(PrimaryWeaponSlotHash);
				break;
			case 2:
				characterMainControl.SwitchHoldAgentInSlot(SecondaryWeaponSlotHash);
				break;
			case 3:
				characterMainControl.SwitchHoldAgentInSlot(MeleeWeaponSlotHash);
				break;
			}
		}
	}

	public void StopAction()
	{
		if (InputActived && (bool)characterMainControl.CurrentAction && characterMainControl.CurrentAction.IsStopable())
		{
			characterMainControl.CurrentAction.StopAction();
		}
	}

	private bool CheckInAimAngleAndNoObsticle()
	{
		if (!characterMainControl)
		{
			return false;
		}
		if (aimTarget == null || characterMainControl.CurrentUsingAimSocket == null)
		{
			return false;
		}
		Vector3 position = characterMainControl.CurrentUsingAimSocket.position;
		position.y = 0f;
		Vector3 position2 = aimTarget.position;
		position2.y = 0f;
		Vector3 vector = position2 - position;
		float magnitude = vector.magnitude;
		vector.Normalize();
		float num = Mathf.Atan(0.25f / magnitude) * 57.29578f;
		if (!(Vector3.Angle(characterMainControl.CurrentAimDirection, vector) < num))
		{
			return false;
		}
		Vector3 vector2 = position + Vector3.up * characterMainControl.CurrentUsingAimSocket.position.y;
		Vector3 vector3 = vector;
		UnityEngine.Debug.DrawLine(vector2, vector2 + vector3 * magnitude);
		return Physics.SphereCastNonAlloc(vector2, 0.1f, vector3, obsticleHits, magnitude, obsticleLayers, QueryTriggerInteraction.Ignore) <= 0;
	}

	public void ReleaseItemSkill()
	{
		if (InputActived)
		{
			characterMainControl.ReleaseSkill(SkillTypes.itemSkill);
		}
	}

	public void ReleaseCharacterSkill()
	{
		if (InputActived)
		{
			characterMainControl.ReleaseSkill(SkillTypes.characterSkill);
		}
	}

	public bool CancleSkill()
	{
		if (!characterMainControl)
		{
			return false;
		}
		return characterMainControl.CancleSkill();
	}

	public void Dash()
	{
		if ((bool)characterMainControl && InputActived)
		{
			characterMainControl.TryCatchFishInput();
			characterMainControl.Dash();
		}
	}

	public void StartCharacterSkillAim()
	{
		if ((bool)characterMainControl && InputActived && !(characterMainControl.skillAction.characterSkillKeeper.Skill == null) && characterMainControl.StartSkillAim(SkillTypes.characterSkill) && (bool)characterMainControl.skillAction.CurrentRunningSkill && characterMainControl.skillAction.CurrentRunningSkill.SkillContext.releaseOnStartAim)
		{
			characterMainControl.ReleaseSkill(SkillTypes.characterSkill);
		}
	}

	public void StartItemSkillAim()
	{
		if ((bool)characterMainControl && InputActived && (bool)characterMainControl.agentHolder.Skill && characterMainControl.StartSkillAim(SkillTypes.itemSkill) && (bool)characterMainControl.skillAction.CurrentRunningSkill && characterMainControl.skillAction.CurrentRunningSkill.SkillContext.releaseOnStartAim)
		{
			characterMainControl.ReleaseSkill(SkillTypes.itemSkill);
		}
	}

	public void AddRecoil(ItemAgent_Gun gun)
	{
		if ((bool)gun)
		{
			recoilGun = gun;
			float recoilMultiplier = LevelManager.Rule.RecoilMultiplier;
			recoilV = UnityEngine.Random.Range(gun.RecoilVMin, gun.RecoilVMax) * gun.RecoilScaleV * (1f / gun.CharacterRecoilControl) * recoilMultiplier;
			recoilH = UnityEngine.Random.Range(gun.RecoilHMin, gun.RecoilHMax) * gun.RecoilScaleH * (1f / gun.CharacterRecoilControl) * recoilMultiplier;
			recoilRecover = gun.RecoilRecover;
			recoilTime = Mathf.Min(gun.RecoilTime, 1f / gun.ShootSpeed);
			recoilRecoverTime = gun.RecoilRecoverTime;
			recoilTimer = 0f;
			newRecoil = true;
		}
	}

	private Vector2 ProcessMousePosViaRecoil(Vector2 mousePos, Vector2 mouseDelta, ItemAgent_Gun gun)
	{
		if (!gun || recoilGun != gun)
		{
			newRecoil = false;
			recoilNeedToRecover = Vector2.zero;
			return mousePos;
		}
		Vector3 position = characterMainControl.transform.position;
		if (newRecoil)
		{
			Vector2 vector = LevelManager.Instance.GameCamera.renderCamera.WorldToScreenPoint(position);
			Vector2 normalized = (mousePos - vector).normalized;
			recoilThisShot = normalized * recoilV + recoilH * -Vector2.Perpendicular(normalized);
		}
		Vector3.Distance(InputAimPoint, position);
		float num = Time.deltaTime;
		if (recoilTimer + num >= recoilTime)
		{
			num = recoilTime - recoilTimer;
		}
		if (num > 0f)
		{
			Vector2 vector2 = recoilThisShot * num / recoilTime * Screen.height / 1440f;
			mousePos += vector2;
			recoilNeedToRecover += vector2;
			Vector2 deltaValue = Vector2.zero;
			ClampMousePosInWindow(ref mousePos, ref deltaValue);
			recoilNeedToRecover += deltaValue;
		}
		if (num <= 0f && recoilTimer > recoilRecoverTime && recoilNeedToRecover.magnitude > 0f)
		{
			float num2 = Time.deltaTime;
			if (recoilTimer - num2 < recoilRecoverTime)
			{
				num2 = recoilTimer - recoilRecoverTime;
			}
			Vector2 vector3 = Vector2.MoveTowards(recoilNeedToRecover, Vector2.zero, num2 * recoilRecover * (float)Screen.height / 1440f);
			mousePos += vector3 - recoilNeedToRecover;
			recoilNeedToRecover = vector3;
		}
		float num3 = Vector2.Dot(-recoilNeedToRecover.normalized, mouseDelta);
		if (num3 > 0f)
		{
			_oppositeDelta = 0f;
			recoilNeedToRecover = Vector2.MoveTowards(recoilNeedToRecover, Vector2.zero, num3);
		}
		else
		{
			_oppositeDelta += mouseDelta.magnitude;
			if (_oppositeDelta > 15f * (float)Screen.height / 1440f)
			{
				_oppositeDelta = 0f;
				recoilNeedToRecover = Vector3.zero;
			}
		}
		recoilTimer += Time.deltaTime;
		newRecoil = false;
		return mousePos;
	}
}
public interface IInitializedQueryHandler
{
	bool HasInitialized();
}
public class LevelConfig : MonoBehaviour
{
	private static LevelConfig instance;

	[SerializeField]
	private bool isBaseLevel;

	[SerializeField]
	private bool isRaidMap = true;

	[SerializeField]
	private bool spawnTomb = true;

	[SerializeField]
	private int minExitCount;

	[SerializeField]
	private int maxExitCount;

	public TimeOfDayConfig timeOfDayConfig;

	[SerializeField]
	[Min(1f)]
	private float lootBoxHighQualityChanceMultiplier = 1f;

	[SerializeField]
	[Range(0.1f, 10f)]
	private float lootboxItemCountMultiplier = 1f;

	public static LevelConfig Instance
	{
		get
		{
			if (!instance)
			{
				SetInstance();
			}
			return instance;
		}
	}

	public float LootBoxQualityLowPercent => 1f - 1f / lootBoxHighQualityChanceMultiplier;

	public float LootboxItemCountMultiplier => lootboxItemCountMultiplier;

	public static bool IsBaseLevel
	{
		get
		{
			if (!Instance)
			{
				return false;
			}
			return Instance.isBaseLevel;
		}
	}

	public static bool IsRaidMap
	{
		get
		{
			if (!Instance)
			{
				return false;
			}
			return Instance.isRaidMap;
		}
	}

	public static int MinExitCount
	{
		get
		{
			if (!Instance)
			{
				return 0;
			}
			return Instance.minExitCount;
		}
	}

	public static bool SpawnTomb
	{
		get
		{
			if (!Instance)
			{
				return true;
			}
			return Instance.spawnTomb;
		}
	}

	public static int MaxExitCount
	{
		get
		{
			if (!Instance)
			{
				return 0;
			}
			return Instance.maxExitCount;
		}
	}

	private void Awake()
	{
		UnityEngine.Object.Instantiate(GameplayDataSettings.Prefabs.LevelManagerPrefab).transform.SetParent(base.transform);
	}

	private static void SetInstance()
	{
		if (!instance)
		{
			instance = UnityEngine.Object.FindFirstObjectByType<LevelConfig>();
			_ = (bool)instance;
		}
	}
}
public class LevelManager : MonoBehaviour
{
	[Serializable]
	public struct LevelInfo
	{
		public bool isBaseLevel;

		public string sceneName;

		public string activeSubSceneID;
	}

	private Transform _lootBoxInventoriesParent;

	private Dictionary<int, Inventory> _lootBoxInventories;

	[SerializeField]
	private Transform defaultStartPos;

	private static LevelManager instance;

	[SerializeField]
	private InputManager inputManager;

	[SerializeField]
	private CharacterCreator characterCreator;

	[SerializeField]
	private ExitCreator exitCreator;

	[SerializeField]
	private ExplosionManager explosionManager;

	[SerializeField]
	private CharacterModel characterModel;

	private CharacterMainControl mainCharacter;

	private CharacterMainControl petCharacter;

	[SerializeField]
	private GameCamera gameCamera;

	[SerializeField]
	private FogOfWarManager fowManager;

	[SerializeField]
	private TimeOfDayController timeOfDayController;

	[SerializeField]
	private AIMainBrain aiMainBrain;

	[SerializeField]
	private CharacterRandomPreset matePreset;

	private bool initingLevel;

	private bool isNewRaidLevel;

	private bool afterInit;

	[SerializeField]
	private CharacterRandomPreset petPreset;

	[SerializeField]
	private Sprite characterMapIcon;

	[SerializeField]
	private Color characterMapIconColor;

	[SerializeField]
	private Color characterMapShadowColor;

	[SerializeField]
	private MultiSceneLocation testTeleportTarget;

	[SerializeField]
	public SkillBase defaultSkill;

	[SerializeField]
	private PetProxy petProxy;

	[SerializeField]
	private CustomFaceManager customFaceManager;

	[SerializeField]
	private BulletPool bulletPool;

	private string _levelInitializingComment = "";

	public static int loadLevelBeaconIndex = 0;

	private bool levelInited;

	public const string MainCharacterItemSaveKey = "MainCharacterItemData";

	public const string MainCharacterHealthSaveKey = "MainCharacterHealth";

	private float levelStartTime = -0.1f;

	private static Ruleset rule;

	private static List<object> waitForInitializationList = new List<object>();

	private bool dieTask;

	public static LevelManager Instance
	{
		get
		{
			if (!instance)
			{
				SetInstance();
			}
			return instance;
		}
	}

	public static Transform LootBoxInventoriesParent
	{
		get
		{
			if (Instance._lootBoxInventoriesParent == null)
			{
				GameObject gameObject = new GameObject("Loot Box Inventories");
				gameObject.transform.SetParent(Instance.transform);
				Instance._lootBoxInventoriesParent = gameObject.transform;
				LootBoxInventories.Clear();
			}
			return Instance._lootBoxInventoriesParent;
		}
	}

	public static Dictionary<int, Inventory> LootBoxInventories
	{
		get
		{
			if (Instance._lootBoxInventories == null)
			{
				Instance._lootBoxInventories = new Dictionary<int, Inventory>();
			}
			return Instance._lootBoxInventories;
		}
	}

	public bool IsRaidMap => LevelConfig.IsRaidMap;

	public bool IsBaseLevel => LevelConfig.IsBaseLevel;

	public InputManager InputManager => inputManager;

	public CharacterCreator CharacterCreator => characterCreator;

	public ExitCreator ExitCreator => exitCreator;

	public ExplosionManager ExplosionManager => explosionManager;

	private int characterItemTypeID => GameplayDataSettings.ItemAssets.DefaultCharacterItemTypeID;

	public CharacterMainControl MainCharacter => mainCharacter;

	public CharacterMainControl PetCharacter => petCharacter;

	public GameCamera GameCamera => gameCamera;

	public FogOfWarManager FogOfWarManager => fowManager;

	public TimeOfDayController TimeOfDayController => timeOfDayController;

	public AIMainBrain AIMainBrain => aiMainBrain;

	public static bool LevelInitializing
	{
		get
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.initingLevel;
		}
	}

	public static bool AfterInit
	{
		get
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.afterInit;
		}
	}

	public PetProxy PetProxy => petProxy;

	public BulletPool BulletPool => bulletPool;

	public CustomFaceManager CustomFaceManager => customFaceManager;

	public static string LevelInitializingComment
	{
		get
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance._levelInitializingComment;
		}
		set
		{
			if (!(Instance == null))
			{
				Instance._levelInitializingComment = value;
				LevelManager.OnLevelInitializingCommentChanged?.Invoke(value);
				UnityEngine.Debug.Log("[Level Initialization] " + value);
			}
		}
	}

	public static bool LevelInited
	{
		get
		{
			if (instance == null)
			{
				return false;
			}
			return instance.levelInited;
		}
	}

	public float LevelTime => Time.time - levelStartTime;

	public static Ruleset Rule => rule;

	public static event Action OnLevelBeginInitializing;

	public static event Action OnLevelInitialized;

	public static event Action OnAfterLevelInitialized;

	public static event Action<string> OnLevelInitializingCommentChanged;

	public static event Action<EvacuationInfo> OnEvacuated;

	public static event Action<DamageInfo> OnMainCharacterDead;

	public static event Action OnNewGameReport;

	public static void RegisterWaitForInitialization<T>(T toWait) where T : class, IInitializedQueryHandler
	{
		if (toWait != null && toWait != null)
		{
			waitForInitializationList.Add(toWait);
		}
	}

	public static bool UnregisterWaitForInitialization<T>(T obj) where T : class
	{
		return waitForInitializationList.Remove(obj);
	}

	private void Start()
	{
		if (!SceneLoader.IsSceneLoading)
		{
			StartInit(default(SceneLoadingContext));
		}
		else
		{
			SceneLoader.onFinishedLoadingScene += StartInit;
		}
		if (!SavesSystem.Load<bool>("NewGameReported"))
		{
			SavesSystem.Save("NewGameReported", value: true);
			LevelManager.OnNewGameReport?.Invoke();
		}
		if (GameManager.newBoot)
		{
			OnNewBoot();
			GameManager.newBoot = false;
		}
	}

	private void OnDestroy()
	{
		SceneLoader.onFinishedLoadingScene -= StartInit;
		mainCharacter?.Health?.OnDeadEvent.RemoveListener(OnMainCharacterDie);
	}

	private void OnNewBoot()
	{
		UnityEngine.Debug.Log("New boot");
		GameClock.Instance.StepTimeTil(new TimeSpan(7, 0, 0));
	}

	private void StartInit(SceneLoadingContext context)
	{
		InitLevel(context).Forget();
	}

	private async UniTaskVoid InitLevel(SceneLoadingContext context)
	{
		if (initingLevel)
		{
			return;
		}
		LevelInitializingComment = "Starting up...";
		instance = this;
		_ = GameManager.Instance;
		initingLevel = true;
		LevelInitializingComment = "Invoking Beginning Event...";
		LevelManager.OnLevelBeginInitializing?.Invoke();
		await UniTask.Yield();
		LevelInitializingComment = "Setting up rule...";
		rule = GameRulesManager.Current;
		UnityEngine.Debug.Log($"Rule is:{rule.DisplayName},Recoil:{rule.RecoilMultiplier}");
		Vector3 startPos = defaultStartPos.position;
		if (context.useLocation && MultiSceneCore.Instance != null)
		{
			LevelInitializingComment = "Finding location for spawning...";
			MultiSceneLocation location = context.location;
			LevelInitializingComment = "Creating Character...";
			await CreateMainCharacterAsync(startPos, Quaternion.identity);
			LevelInitializingComment = "Teleporting to location...";
			await MultiSceneCore.Instance.LoadAndTeleport(location);
			startPos = location.GetLocationTransform().position;
		}
		else if (MultiSceneCore.Instance != null)
		{
			LevelInitializingComment = "Getting location...";
			(string, SubSceneEntry.Location) playerStartLocation = GetPlayerStartLocation();
			if (playerStartLocation.Item2 != null)
			{
				LevelInitializingComment = "Creating location info...";
				MultiSceneLocation location = new MultiSceneLocation
				{
					SceneID = playerStartLocation.Item1,
					LocationName = playerStartLocation.Item2.path
				};
				LevelInitializingComment = "Setting start position...";
				startPos = playerStartLocation.Item2.position;
				LevelInitializingComment = "Creating character at location...";
				await CreateMainCharacterAsync(playerStartLocation.Item2.position, Quaternion.identity);
				LevelInitializingComment = "Teleporting to location...";
				await MultiSceneCore.Instance.LoadAndTeleport(location);
			}
			else
			{
				LevelInitializingComment = "Setting default start position...";
				startPos = defaultStartPos.position;
				LevelInitializingComment = "Creating character at default position...";
				await CreateMainCharacterAsync(defaultStartPos.position, Quaternion.identity);
			}
		}
		else
		{
			LevelInitializingComment = "Creating character...";
			await CreateMainCharacterAsync(defaultStartPos.position, Quaternion.identity);
		}
		LevelInitializingComment = "Setting up character status...";
		mainCharacter.Health.OnDeadEvent.AddListener(OnMainCharacterDie);
		RefreshMainCharacterFace();
		LevelInitializingComment = "Setting up pet...";
		petCharacter = await petPreset.CreateCharacterAsync(mainCharacter.transform.position + Vector3.one * 99f, Vector3.forward, MultiSceneCore.MainScene.Value.buildIndex, null, isLeader: false);
		if (IsBaseLevel && petProxy != null)
		{
			petProxy.DestroyItemInBase();
		}
		petCharacter.Health.showHealthBar = false;
		petCharacter.Health.SetInvincible(value: true);
		LevelInitializingComment = "Setting character items...";
		SetCharacterItemsInspected();
		LevelInitializingComment = "Waiting for other initialization...";
		await WaitForOtherInitialization();
		mainCharacter.SwitchToFirstAvailableWeapon();
		if (MultiSceneCore.Instance != null)
		{
			while (MultiSceneCore.Instance.IsLoading)
			{
				await UniTask.Yield();
			}
		}
		initingLevel = false;
		levelInited = true;
		levelStartTime = Time.time;
		LevelInitializingComment = "Handling raid initialization...";
		HandleRaidInitialization();
		LevelInitializingComment = "Invoking initialized event...";
		LevelManager.OnLevelInitialized?.Invoke();
		LevelInitializingComment = "Healing...";
		float health = SavesSystem.Load<float>("MainCharacterHealth");
		mainCharacter.Health.SetHealth(health);
		if (IsBaseLevel || isNewRaidLevel)
		{
			mainCharacter.AddHealth(mainCharacter.Health.MaxHealth);
		}
		LevelInitializingComment = "Spawing exits...";
		if (MultiSceneCore.Instance != null)
		{
			exitCreator.Spawn();
		}
		LevelInitializingComment = "Creating map element...";
		CreateMainCharacterMapElement();
		LevelInitializingComment = "Setting character position...";
		await UniTask.WaitForSeconds(0.25f);
		mainCharacter.SetPosition(startPos);
		LevelInitializingComment = "Done!";
		try
		{
			LevelManager.OnAfterLevelInitialized?.Invoke();
			afterInit = true;
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	private async UniTask CreateMate()
	{
		if ((bool)matePreset)
		{
			AICharacterController componentInChildren = (await matePreset.CreateCharacterAsync(mainCharacter.transform.position + Vector3.one, Vector3.forward, MultiSceneCore.MainScene.Value.buildIndex, null, isLeader: false)).GetComponentInChildren<AICharacterController>();
			if ((bool)componentInChildren)
			{
				componentInChildren.leader = mainCharacter;
			}
		}
	}

	private async UniTask WaitForOtherInitialization()
	{
		while (waitForInitializationList.Any(delegate(object e)
		{
			if (e == null)
			{
				return false;
			}
			if (!(e is IInitializedQueryHandler initializedQueryHandler))
			{
				return false;
			}
			if (!initializedQueryHandler.HasInitialized())
			{
				LevelInitializingComment = "Waiting for " + e.GetType().Name + "...";
				return true;
			}
			return false;
		}))
		{
			await UniTask.Yield();
		}
	}

	private void HandleRaidInitialization()
	{
		RaidUtilities.RaidInfo currentRaid = RaidUtilities.CurrentRaid;
		if (IsRaidMap)
		{
			if (currentRaid.ended)
			{
				RaidUtilities.NewRaid();
				isNewRaidLevel = true;
			}
		}
		else if (IsBaseLevel && !currentRaid.ended)
		{
			RaidUtilities.NotifyEnd();
		}
	}

	public void RefreshMainCharacterFace()
	{
		if ((bool)mainCharacter.characterModel.CustomFace)
		{
			CustomFaceSettingData saveData = customFaceManager.LoadMainCharacterSetting();
			mainCharacter.characterModel.CustomFace.LoadFromData(saveData);
		}
	}

	private async UniTask CreateMainCharacterAsync(Vector3 position, Quaternion rotation)
	{
		Item itemInstance = await LoadOrCreateCharacterItemInstance();
		mainCharacter = await characterCreator.CreateCharacter(itemInstance, characterModel, position, rotation);
		if (!(mainCharacter == null))
		{
			if (IsBaseLevel)
			{
				mainCharacter.DestroyItemsThatNeededToBeDestriedInBase();
			}
			mainCharacter.SetTeam(Teams.player);
			mainCharacter.CharacterItem.Inventory.AcceptSticky = true;
			if (defaultSkill != null)
			{
				SkillBase skillBase = UnityEngine.Object.Instantiate(defaultSkill);
				skillBase.transform.SetParent(mainCharacter.transform, worldPositionStays: false);
				mainCharacter.SetSkill(SkillTypes.characterSkill, skillBase, skillBase.gameObject);
			}
			inputManager.characterMainControl = mainCharacter;
			inputManager.SwitchItemAgent(1);
			gameCamera.SetTarget(mainCharacter);
		}
	}

	private void SetCharacterItemsInspected()
	{
		foreach (Slot slot in mainCharacter.CharacterItem.Slots)
		{
			if (slot.Content != null)
			{
				slot.Content.Inspected = true;
			}
		}
		foreach (Item item in mainCharacter.CharacterItem.Inventory)
		{
			if (item != null)
			{
				item.Inspected = true;
			}
		}
		foreach (Item item2 in petProxy.Inventory)
		{
			if (item2 != null)
			{
				item2.Inspected = true;
			}
		}
	}

	private static void SetInstance()
	{
		if (!instance)
		{
			instance = UnityEngine.Object.FindFirstObjectByType<LevelManager>();
			_ = (bool)instance;
		}
	}

	private async UniTask<Item> LoadOrCreateCharacterItemInstance()
	{
		Item item = await ItemSavesUtilities.LoadItem("MainCharacterItemData");
		if (item == null)
		{
			item = await ItemAssetsCollection.InstantiateAsync(characterItemTypeID);
			UnityEngine.Debug.LogWarning("Item Loading failed");
		}
		return item;
	}

	public void NotifyEvacuated(EvacuationInfo info)
	{
		mainCharacter.Health.SetInvincible(value: true);
		LevelManager.OnEvacuated?.Invoke(info);
		SaveMainCharacter();
		SavesSystem.CollectSaveData();
		SavesSystem.SaveFile();
	}

	public void NotifySaveBeforeLoadScene(bool saveToFile)
	{
		SaveMainCharacter();
		SavesSystem.CollectSaveData();
		if (saveToFile)
		{
			SavesSystem.SaveFile();
		}
	}

	private void OnMainCharacterDie(DamageInfo dmgInfo)
	{
		if (!dieTask)
		{
			dieTask = true;
			CharacterDieTask(dmgInfo).Forget();
			LevelManager.OnMainCharacterDead?.Invoke(dmgInfo);
		}
	}

	private async UniTaskVoid CharacterDieTask(DamageInfo dmgInfo)
	{
		if (IsRaidMap)
		{
			RaidUtilities.NotifyDead();
			DeadBodyManager.RecordDeath(mainCharacter);
		}
		ItemSavesUtilities.SaveAsLastDeadCharacter(mainCharacter.CharacterItem);
		if (LevelConfig.SpawnTomb)
		{
			InteractableLootbox.CreateFromItem(mainCharacter.CharacterItem, mainCharacter.transform.position, mainCharacter.transform.rotation, moveToMainScene: true, GameplayDataSettings.Prefabs.LootBoxPrefab_Tomb, filterDontDropOnDead: true);
		}
		else
		{
			mainCharacter?.DropAllItems();
		}
		mainCharacter?.DestroyAllItem();
		SaveMainCharacter();
		SavesSystem.CollectSaveData();
		SavesSystem.SaveFile();
		await UniTask.WaitForSeconds(2.5f, ignoreTimeScale: true);
		await ClosureView.ShowAndReturnTask(dmgInfo);
		if (OverrideDeathSceneRouting.Instance != null)
		{
			UnityEngine.Debug.Log("死亡后的目标场景已被特殊脚本修改");
			SceneLoader.Instance.LoadScene(OverrideDeathSceneRouting.Instance.GetSceneID(), GameplayDataSettings.SceneManagement.FailLoadingScreenScene).Forget();
		}
		else
		{
			SceneLoader.Instance.LoadBaseScene(GameplayDataSettings.SceneManagement.FailLoadingScreenScene).Forget();
		}
	}

	internal void SaveMainCharacter()
	{
		mainCharacter.CharacterItem.Save("MainCharacterItemData");
		SavesSystem.Save("MainCharacterHealth", MainCharacter.Health.CurrentHealth);
	}

	private (string sceneID, SubSceneEntry.Location locationData) GetPlayerStartLocation()
	{
		List<(string, SubSceneEntry.Location)> list = new List<(string, SubSceneEntry.Location)>();
		string text = "StartPoints";
		if (loadLevelBeaconIndex > 0)
		{
			text = text + "_" + loadLevelBeaconIndex;
			loadLevelBeaconIndex = 0;
		}
		foreach (SubSceneEntry subScene in MultiSceneCore.Instance.SubScenes)
		{
			foreach (SubSceneEntry.Location cachedLocation in subScene.cachedLocations)
			{
				if (IsPathCompatible(cachedLocation, text))
				{
					list.Add((subScene.sceneID, cachedLocation));
				}
			}
		}
		if (list.Count == 0)
		{
			text = "StartPoints";
			foreach (SubSceneEntry subScene2 in MultiSceneCore.Instance.SubScenes)
			{
				foreach (SubSceneEntry.Location cachedLocation2 in subScene2.cachedLocations)
				{
					if (IsPathCompatible(cachedLocation2, text))
					{
						list.Add((subScene2.sceneID, cachedLocation2));
					}
				}
			}
		}
		return list.GetRandom();
	}

	private void CreateMainCharacterMapElement()
	{
		if (MultiSceneCore.Instance != null)
		{
			SimplePointOfInterest simplePointOfInterest = mainCharacter.gameObject.AddComponent<SimplePointOfInterest>();
			simplePointOfInterest.Color = characterMapIconColor;
			simplePointOfInterest.ShadowColor = characterMapShadowColor;
			simplePointOfInterest.ShadowDistance = 0f;
			simplePointOfInterest.Setup(characterMapIcon, "You", followActiveScene: true);
		}
	}

	private void OnSubSceneLoaded()
	{
	}

	private bool IsPathCompatible(SubSceneEntry.Location location, string keyWord)
	{
		string path = location.path;
		int num = path.IndexOf('/');
		if (num != -1 && path.Substring(0, num) == keyWord)
		{
			return true;
		}
		return false;
	}

	public void TestTeleport()
	{
		MultiSceneCore.Instance.LoadAndTeleport(testTeleportTarget).Forget();
	}

	private LevelInfo mGetInfo()
	{
		Scene? activeSubScene = MultiSceneCore.ActiveSubScene;
		string activeSubSceneID = (activeSubScene.HasValue ? activeSubScene.Value.name : "");
		return new LevelInfo
		{
			isBaseLevel = IsBaseLevel,
			sceneName = base.gameObject.scene.name,
			activeSubSceneID = activeSubSceneID
		};
	}

	public static LevelInfo GetCurrentLevelInfo()
	{
		if (Instance == null)
		{
			return default(LevelInfo);
		}
		return Instance.mGetInfo();
	}
}
[Serializable]
public struct EvacuationInfo
{
	public string subsceneID;

	public Vector3 position;

	public EvacuationInfo(string subsceneID, Vector3 position)
	{
		this.subsceneID = subsceneID;
		this.position = position;
	}
}
public class LootManager : MonoBehaviour
{
}
public class PetProxy : MonoBehaviour
{
	[SerializeField]
	private Inventory inventory;

	private float checkTimer = 0.02f;

	public static PetProxy Instance
	{
		get
		{
			if (LevelManager.Instance == null)
			{
				return null;
			}
			return LevelManager.Instance.PetProxy;
		}
	}

	public static Inventory PetInventory
	{
		get
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.Inventory;
		}
	}

	public Inventory Inventory => inventory;

	private void Start()
	{
		SavesSystem.OnCollectSaveData += OnCollectSaveData;
		ItemSavesUtilities.LoadInventory("Inventory_Safe", inventory).Forget();
	}

	private void OnDestroy()
	{
		SavesSystem.OnCollectSaveData -= OnCollectSaveData;
	}

	private void OnCollectSaveData()
	{
		inventory.Save("Inventory_Safe");
	}

	public void DestroyItemInBase()
	{
		if (!Inventory)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (Item item in Inventory)
		{
			list.Add(item);
		}
		foreach (Item item2 in list)
		{
			if (item2.Tags.Contains("DestroyInBase"))
			{
				item2.DestroyTree();
			}
		}
	}

	private void Update()
	{
		if (!LevelManager.LevelInited || LevelManager.Instance.PetCharacter == null)
		{
			return;
		}
		base.transform.position = LevelManager.Instance.PetCharacter.transform.position;
		if (checkTimer > 0f)
		{
			checkTimer -= Time.unscaledDeltaTime;
			return;
		}
		if (CharacterMainControl.Main.PetCapcity != inventory.Capacity)
		{
			inventory.SetCapacity(CharacterMainControl.Main.PetCapcity);
		}
		checkTimer = 1f;
	}
}
public class PlayerPositionBackupManager : MonoBehaviour
{
	private struct PlayerPositionBackupEntry
	{
		public int sceneID;

		public Vector3 position;
	}

	private List<PlayerPositionBackupEntry> backups;

	private CharacterMainControl mainCharacter;

	public float backupTimeSpace = 3f;

	public float minBackupDistance = 3f;

	private float backupTimer = 3f;

	public InteractableBase backupInteract;

	public int listSize = 20;

	private static event Action OnStartRecoverEvent;

	private void Awake()
	{
		backups = new List<PlayerPositionBackupEntry>();
		MultiSceneCore.OnSubSceneLoaded += OnSubSceneLoaded;
		OnStartRecoverEvent += OnStartRecover;
	}

	private void OnDestroy()
	{
		MultiSceneCore.OnSubSceneLoaded -= OnSubSceneLoaded;
		OnStartRecoverEvent -= OnStartRecover;
	}

	private void Update()
	{
		if (!LevelManager.LevelInited)
		{
			return;
		}
		if (!mainCharacter)
		{
			mainCharacter = CharacterMainControl.Main;
		}
		if ((bool)mainCharacter)
		{
			backupTimer -= Time.deltaTime;
			if (backupTimer < 0f && CheckCanBackup())
			{
				BackupCurrentPos();
			}
		}
	}

	private bool CheckCanBackup()
	{
		if (!mainCharacter)
		{
			return false;
		}
		if (!mainCharacter.IsOnGround)
		{
			return false;
		}
		if (Mathf.Abs(mainCharacter.Velocity.y) > 2f)
		{
			return false;
		}
		int count = backups.Count;
		if (count > 0)
		{
			Vector3 position = backups[count - 1].position;
			if (Vector3.Distance(mainCharacter.transform.position, position) < minBackupDistance)
			{
				return false;
			}
		}
		return true;
	}

	private void OnSubSceneLoaded(MultiSceneCore multiSceneCore, Scene scene)
	{
		backups.Clear();
		backupTimer = backupTimeSpace;
	}

	public void BackupCurrentPos()
	{
		if (LevelManager.LevelInited && (bool)mainCharacter)
		{
			backupTimer = backupTimeSpace;
			PlayerPositionBackupEntry item = new PlayerPositionBackupEntry
			{
				position = mainCharacter.transform.position,
				sceneID = SceneManager.GetActiveScene().buildIndex
			};
			backups.Add(item);
			if (backups.Count > listSize)
			{
				backups.RemoveAt(0);
			}
		}
	}

	public static void StartRecover()
	{
		PlayerPositionBackupManager.OnStartRecoverEvent?.Invoke();
	}

	private void OnStartRecover()
	{
		if (mainCharacter.CurrentAction != null && mainCharacter.CurrentAction.Running)
		{
			mainCharacter.CurrentAction.StopAction();
		}
		mainCharacter.Interact(backupInteract);
	}

	public void SetPlayerToBackupPos()
	{
		if (backups.Count > 0)
		{
			_ = SceneManager.GetActiveScene().buildIndex;
			Vector3 position = mainCharacter.transform.position;
			PlayerPositionBackupEntry playerPositionBackupEntry = backups[backups.Count - 1];
			backups.RemoveAt(backups.Count - 1);
			Vector3 position2 = playerPositionBackupEntry.position;
			if (Vector3.Distance(position, position2) > minBackupDistance)
			{
				mainCharacter.SetPosition(position2);
			}
			else
			{
				SetPlayerToBackupPos();
			}
		}
	}
}
public class PlayerPositionBackupProxy : MonoBehaviour
{
	public void StartRecoverInteract()
	{
		PauseMenu.Instance.Close();
		PlayerPositionBackupManager.StartRecover();
	}
}
public class BulletPool : MonoBehaviour
{
	public Dictionary<Projectile, UnityEngine.Pool.ObjectPool<Projectile>> pools = new Dictionary<Projectile, UnityEngine.Pool.ObjectPool<Projectile>>();

	private void Awake()
	{
	}

	public Projectile GetABullet(Projectile bulletPrefab)
	{
		return GetAPool(bulletPrefab).Get();
	}

	private UnityEngine.Pool.ObjectPool<Projectile> GetAPool(Projectile pfb)
	{
		if (pools.TryGetValue(pfb, out var value))
		{
			return value;
		}
		UnityEngine.Pool.ObjectPool<Projectile> objectPool = new UnityEngine.Pool.ObjectPool<Projectile>(() => CreateABulletInPool(pfb), OnGetABulletInPool, OnBulletRelease);
		pools.Add(pfb, objectPool);
		return objectPool;
	}

	private Projectile CreateABulletInPool(Projectile pfb)
	{
		Projectile projectile = UnityEngine.Object.Instantiate(pfb);
		projectile.transform.SetParent(base.transform);
		UnityEngine.Pool.ObjectPool<Projectile> aPool = GetAPool(pfb);
		projectile.SetPool(aPool);
		return projectile;
	}

	private void OnGetABulletInPool(Projectile bulletToGet)
	{
		bulletToGet.gameObject.SetActive(value: true);
	}

	private void OnBulletRelease(Projectile bulletToGet)
	{
		bulletToGet.transform.SetParent(base.transform);
		bulletToGet.gameObject.SetActive(value: false);
	}

	public bool Release(Projectile instance, Projectile prefab)
	{
		if (pools.TryGetValue(prefab, out var value))
		{
			value.Release(prefab);
			return true;
		}
		return false;
	}
}
public class CountDownArea : MonoBehaviour
{
	[SerializeField]
	private float requiredExtrationTime = 5f;

	[SerializeField]
	private bool disableWhenSucceed = true;

	public UnityEvent onCountDownSucceed;

	public UnityEvent onTickSecond;

	public UnityEvent<CountDownArea> onCountDownStarted;

	public UnityEvent<CountDownArea> onCountDownStopped;

	private bool countingDown;

	private float timeWhenCountDownBegan = float.MaxValue;

	private HashSet<CharacterMainControl> hoveringMainCharacters = new HashSet<CharacterMainControl>();

	public float RequiredExtrationTime => requiredExtrationTime;

	private float TimeSinceCountDownBegan => Time.time - timeWhenCountDownBegan;

	public float RemainingTime => Mathf.Clamp(RequiredExtrationTime - TimeSinceCountDownBegan, 0f, RequiredExtrationTime);

	public float Progress
	{
		get
		{
			if (requiredExtrationTime <= 0f)
			{
				return 1f;
			}
			return TimeSinceCountDownBegan / RequiredExtrationTime;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (base.enabled)
		{
			CharacterMainControl component = other.GetComponent<CharacterMainControl>();
			if (!(component == null) && component.IsMainCharacter())
			{
				hoveringMainCharacters.Add(component);
				OnHoveringMainCharactersChanged();
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (base.enabled)
		{
			CharacterMainControl component = other.GetComponent<CharacterMainControl>();
			if (!(component == null) && component.IsMainCharacter())
			{
				hoveringMainCharacters.Remove(component);
				OnHoveringMainCharactersChanged();
			}
		}
	}

	private void OnHoveringMainCharactersChanged()
	{
		if (!countingDown && hoveringMainCharacters.Count > 0)
		{
			BeginCountDown();
		}
		else if (countingDown && hoveringMainCharacters.Count < 1)
		{
			AbortCountDown();
		}
	}

	private void BeginCountDown()
	{
		countingDown = true;
		timeWhenCountDownBegan = Time.time;
		onCountDownStarted?.Invoke(this);
	}

	private void AbortCountDown()
	{
		countingDown = false;
		timeWhenCountDownBegan = float.MaxValue;
		onCountDownStopped?.Invoke(this);
	}

	private void UpdateCountDown()
	{
		if (hoveringMainCharacters.All((CharacterMainControl e) => e.Health.IsDead))
		{
			AbortCountDown();
		}
		if (TimeSinceCountDownBegan >= RequiredExtrationTime)
		{
			OnCountdownSucceed();
		}
		int num = (int)(RemainingTime + Time.deltaTime);
		if ((int)RemainingTime != num)
		{
			onTickSecond?.Invoke();
		}
	}

	private void OnCountdownSucceed()
	{
		onCountDownStopped?.Invoke(this);
		onCountDownSucceed?.Invoke();
		countingDown = false;
		if (disableWhenSucceed)
		{
			base.enabled = false;
		}
	}

	private void Update()
	{
		if (base.enabled && countingDown && View.ActiveView == null)
		{
			UpdateCountDown();
		}
	}
}
public class PetHouse : MonoBehaviour
{
	private static PetHouse instance;

	public Transform petMarker;

	private PetAI petTarget;

	public static PetHouse Instance => instance;

	private void Awake()
	{
		instance = this;
		if (LevelManager.LevelInited)
		{
			OnLevelInited();
		}
		else
		{
			LevelManager.OnLevelInitialized += OnLevelInited;
		}
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= OnLevelInited;
		if ((bool)petTarget)
		{
			petTarget.SetStandBy(_standBy: false, petTarget.transform.position);
		}
	}

	private void OnLevelInited()
	{
		CharacterMainControl petCharacter = LevelManager.Instance.PetCharacter;
		petCharacter.SetPosition(petMarker.position);
		petTarget = petCharacter.GetComponentInChildren<PetAI>();
		if (petTarget != null)
		{
			petTarget.SetStandBy(_standBy: true, petMarker.position);
		}
	}
}
public class NamedFormatTest : MonoBehaviour
{
	[Serializable]
	public struct Content
	{
		public string textA;

		public string textB;
	}

	public string format = "Displaying {textA} {textB}";

	public string format2 = "Displaying {0} {1}";

	public Content content;

	[SerializeField]
	private int loopCount = 100;

	private void Test()
	{
		string message = "";
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < loopCount; i++)
		{
			message = format.Format(content);
		}
		stopwatch.Stop();
		UnityEngine.Debug.Log("Time Consumed 1:" + stopwatch.ElapsedMilliseconds);
		stopwatch = Stopwatch.StartNew();
		for (int j = 0; j < loopCount; j++)
		{
			message = string.Format(format2, content.textA, content.textB);
		}
		stopwatch.Stop();
		UnityEngine.Debug.Log("Time Consumed 2:" + stopwatch.ElapsedMilliseconds);
		UnityEngine.Debug.Log(message);
	}

	private void Test2()
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		string message = format.Format(new { content.textA, content.textB });
		stopwatch.Stop();
		UnityEngine.Debug.Log("Time Consumed:" + stopwatch.ElapsedMilliseconds);
		UnityEngine.Debug.Log(message);
	}
}
public class EvacuationCountdownUIProxy : MonoBehaviour
{
	public void Request(CountDownArea target)
	{
		EvacuationCountdownUI.Request(target);
	}

	public void Release(CountDownArea target)
	{
		EvacuationCountdownUI.Release(target);
	}
}
public class LevelManagerProxy : MonoBehaviour
{
	public void NotifyEvacuated()
	{
		LevelManager.Instance?.NotifyEvacuated(new EvacuationInfo(MultiSceneCore.ActiveSubSceneID, base.transform.position));
	}
}
public class SceneLoaderProxy : MonoBehaviour
{
	[SceneID]
	[SerializeField]
	private string sceneID;

	[SerializeField]
	private bool useLocation;

	[SerializeField]
	private MultiSceneLocation location;

	[SerializeField]
	private bool showClosure = true;

	[SerializeField]
	private bool notifyEvacuation = true;

	[SerializeField]
	private SceneReference overrideCurtainScene;

	[SerializeField]
	private bool hideTips;

	[SerializeField]
	private bool circleFade = true;

	private bool saveToFile;

	public void LoadScene()
	{
		if (SceneLoader.Instance == null)
		{
			UnityEngine.Debug.LogWarning("没找到SceneLoader实例，已取消加载场景");
			return;
		}
		InputManager.DisableInput(base.gameObject);
		Task().Forget();
	}

	private async UniTask Task()
	{
		if ("Base" == sceneID)
		{
			saveToFile = true;
		}
		if (showClosure)
		{
			if (notifyEvacuation)
			{
				LevelManager.Instance?.NotifyEvacuated(new EvacuationInfo(MultiSceneCore.ActiveSubSceneID, base.transform.position));
			}
			await ClosureView.ShowAndReturnTask(1f);
		}
		if (notifyEvacuation)
		{
			overrideCurtainScene = GameplayDataSettings.SceneManagement.EvacuateScreenScene;
		}
		if (useLocation)
		{
			SceneLoader instance = SceneLoader.Instance;
			string text = sceneID;
			MultiSceneLocation multiSceneLocation = location;
			bool flag = notifyEvacuation;
			instance.LoadScene(overrideCurtainScene: overrideCurtainScene, clickToConinue: false, notifyEvacuation: flag, saveToFile: saveToFile, hideTips: hideTips, sceneID: text, location: multiSceneLocation, doCircleFade: circleFade).Forget();
		}
		else
		{
			SceneLoader instance2 = SceneLoader.Instance;
			string text2 = sceneID;
			bool flag2 = notifyEvacuation;
			instance2.LoadScene(overrideCurtainScene: overrideCurtainScene, clickToConinue: false, notifyEvacuation: flag2, saveToFile: saveToFile, hideTips: hideTips, sceneID: text2, doCircleFade: circleFade).Forget();
		}
	}

	public void LoadMainMenu()
	{
		SceneLoader.LoadMainMenu(circleFade);
	}
}
public class ViewsProxy : MonoBehaviour
{
	public void ShowInventoryView()
	{
		if (LevelManager.Instance.IsBaseLevel && (bool)PlayerStorage.Instance)
		{
			PlayerStorage.Instance.InteractableLootBox.InteractWithMainCharacter();
		}
		else
		{
			InventoryView.Show();
		}
	}

	public void ShowQuestView()
	{
		QuestView.Show();
	}

	public void ShowMapView()
	{
		MiniMapView.Show();
	}

	public void ShowKeyView()
	{
		MasterKeysView.Show();
	}

	public void ShowPlayerStats()
	{
		PlayerStatsView.Instance.Open();
	}

	public void ShowEndowmentView()
	{
		EndowmentSelectionPanel.Show();
	}

	public void ShowMapSelectionView()
	{
		MapSelectionView.Instance.Open();
	}

	public void ShowRepairView()
	{
		ItemRepairView.Instance.Open();
	}

	public void ShowFormulasIndexView()
	{
		FormulasIndexView.Show();
	}

	public void ShowBitcoinView()
	{
		BitcoinMinerView.Show();
	}

	public void ShowStorageDock()
	{
		StorageDock.Show();
	}

	public void ShowBlackMarket_Demands()
	{
		BlackMarketView.Show(BlackMarketView.Mode.Demand);
	}

	public void ShowBlackMarket_Supplies()
	{
		BlackMarketView.Show(BlackMarketView.Mode.Supply);
	}

	public void ShowSleepView()
	{
		SleepView.Show();
	}

	public void ShowATMView()
	{
		ATMView.Show();
	}

	public void ShowDecomposeView()
	{
		ItemDecomposeView.Show();
	}

	public void ShowGardenView(Garden garnden)
	{
		GardenView.Show(garnden);
	}

	public void ShowGamingConsoleView(GamingConsole console)
	{
		GamingConsoleView.Show(console);
	}
}
public class Condition_CharacterLevel : Condition
{
	private enum Relation
	{
		LessThan = 1,
		Equals = 2,
		GreaterThan = 4
	}

	[SerializeField]
	private Relation relation;

	[SerializeField]
	private int level;

	[LocalizationKey("Default")]
	private string DisplayTextFormatKey => relation switch
	{
		Relation.LessThan => "Condition_CharacterLevel_LessThan", 
		Relation.Equals => "Condition_CharacterLevel_Equals", 
		Relation.GreaterThan => "Condition_CharacterLevel_GreaterThan", 
		_ => "", 
	};

	private string DisplayTextFormat => DisplayTextFormatKey.ToPlainText();

	public override string DisplayText => DisplayTextFormat.Format(new { level });

	public override bool Evaluate()
	{
		int num = EXPManager.Level;
		return relation switch
		{
			Relation.LessThan => num <= level, 
			Relation.Equals => num == level, 
			Relation.GreaterThan => num >= level, 
			_ => false, 
		};
	}
}
public class Condition_HasBeenToScene : Condition
{
	[SceneID]
	public string sceneID;

	public override bool Evaluate()
	{
		return MultiSceneCore.GetVisited(sceneID);
	}
}
public class Condition_RaidDead : Condition
{
	public override bool Evaluate()
	{
		return RaidUtilities.CurrentRaid.dead;
	}
}
public class Condition_TimeOfDay : Condition
{
	[Range(0f, 24f)]
	public float from;

	[Range(0f, 24f)]
	public float to;

	public override bool Evaluate()
	{
		float num = (float)GameClock.TimeOfDay.TotalHours % 24f;
		if (!(num >= from) || !(num <= to))
		{
			if (to < from)
			{
				if (!(num >= from))
				{
					return num <= to;
				}
				return true;
			}
			return false;
		}
		return true;
	}
}
public class Condition_XiaoHeiZi : Condition
{
	[SerializeField]
	private int hairID = 6;

	[ItemTypeID]
	[SerializeField]
	private int armorID = 379;

	public override string DisplayText => "看看你是不是小黑子";

	public override bool Evaluate()
	{
		if (CharacterMainControl.Main == null)
		{
			return false;
		}
		CharacterMainControl main = CharacterMainControl.Main;
		CharacterModel characterModel = main.characterModel;
		if (!characterModel)
		{
			return false;
		}
		CustomFaceInstance customFace = characterModel.CustomFace;
		if (!customFace)
		{
			return false;
		}
		if (customFace.ConvertToSaveData().hairID != hairID)
		{
			return false;
		}
		Item armorItem = main.GetArmorItem();
		if (armorItem == null)
		{
			return false;
		}
		if (armorItem.TypeID != armorID)
		{
			return false;
		}
		return true;
	}
}
public class Conditon_BuildingConstructed : Condition
{
	public string buildingID;

	public bool not;

	public override bool Evaluate()
	{
		bool flag = BuildingManager.Any(buildingID);
		if (not)
		{
			flag = !flag;
		}
		return flag;
	}
}
public class RequireBeaconUnlocked : Condition
{
	[SerializeField]
	[SceneID]
	private string beaconID;

	[SerializeField]
	private int beaconIndex;

	public override bool Evaluate()
	{
		return BeaconManager.GetBeaconUnlocked(beaconID, beaconIndex);
	}
}
public class RequireEnemyKilled : Condition
{
	[SerializeField]
	private CharacterRandomPreset enemyPreset;

	[SerializeField]
	private int threshold = 1;

	public override bool Evaluate()
	{
		if (enemyPreset == null)
		{
			return false;
		}
		return SavesCounter.GetKillCount(enemyPreset.nameKey) >= threshold;
	}
}
public class RequireInLevelDataBool : Condition
{
	public string keyString = "";

	private int keyHash = -1;

	private bool keyHashInited;

	private bool isEmptyString;

	public override bool Evaluate()
	{
		if (!MultiSceneCore.Instance)
		{
			return false;
		}
		if (!keyHashInited)
		{
			InitKeyHash();
		}
		if (isEmptyString)
		{
			return false;
		}
		if (MultiSceneCore.Instance.inLevelData.TryGetValue(keyHash, out var value) && value is bool)
		{
			return (bool)value;
		}
		return false;
	}

	private void InitKeyHash()
	{
		if (keyString == "")
		{
			isEmptyString = true;
		}
		keyHash = keyString.GetHashCode();
		keyHashInited = true;
	}
}
public class RequireSaveDataBool : Condition
{
	[SerializeField]
	private string key;

	[SerializeField]
	private bool requireValue;

	public override bool Evaluate()
	{
		bool flag = SavesSystem.Load<bool>(key);
		UnityEngine.Debug.Log($"Load bool:{key}  value:{flag}");
		return flag == requireValue;
	}
}
public class RequireWeathers : Condition
{
	public List<Weather> weathers;

	public override bool Evaluate()
	{
		if (!LevelManager.LevelInited)
		{
			return false;
		}
		Weather currentWeather = LevelManager.Instance.TimeOfDayController.CurrentWeather;
		return weathers.Contains(currentWeather);
	}
}
public class TaskEvent
{
	public static event Action<string> OnTaskEvent;

	public static void EmitTaskEvent(string taskEventKey)
	{
		TaskEvent.OnTaskEvent?.Invoke(taskEventKey);
	}
}
public class TaskEventEmitter : MonoBehaviour
{
	[SerializeField]
	private string eventKey;

	[SerializeField]
	private bool emitOnAwake;

	public void SetKey(string key)
	{
		eventKey = key;
	}

	private void Awake()
	{
		if (emitOnAwake)
		{
			EmitEvent();
		}
	}

	public void EmitEvent()
	{
		UnityEngine.Debug.Log("TaskEvent:" + eventKey);
		TaskEvent.EmitTaskEvent(eventKey);
	}
}
public class QuestRequiredItem : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Image icon;

	[SerializeField]
	private TextMeshProUGUI text;

	public void Set(int itemTypeID, int count = 1)
	{
		if (itemTypeID <= 0 || count <= 0)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(itemTypeID);
		if (metaData.id == 0)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		icon.sprite = metaData.icon;
		text.text = $"{metaData.DisplayName} x{count}";
		base.gameObject.SetActive(value: true);
	}
}
public class UnlockEndowmentWhenQuestComplete : MonoBehaviour
{
	[SerializeField]
	private Quest quest;

	[SerializeField]
	private EndowmentIndex endowmentToUnlock;

	private void Awake()
	{
		if (quest == null)
		{
			quest = GetComponent<Quest>();
		}
		if (quest != null)
		{
			quest.onCompleted += OnQuestCompleted;
		}
	}

	private void Start()
	{
		if (quest.Complete && !EndowmentManager.GetEndowmentUnlocked(endowmentToUnlock))
		{
			EndowmentManager.UnlockEndowment(endowmentToUnlock);
		}
	}

	private void OnDestroy()
	{
		if (quest != null)
		{
			quest.onCompleted -= OnQuestCompleted;
		}
	}

	private void OnQuestCompleted(Quest quest)
	{
		if (!EndowmentManager.GetEndowmentUnlocked(endowmentToUnlock))
		{
			EndowmentManager.UnlockEndowment(endowmentToUnlock);
		}
	}
}
public class RestoreFailureDetectedIndicator : MonoBehaviour
{
	[SerializeField]
	private FadeGroup fadeGroup;

	private void OnEnable()
	{
		SavesSystem.OnRestoreFailureDetected += Refresh;
		SavesSystem.OnSetFile += Refresh;
		Refresh();
	}

	private void OnDisable()
	{
		SavesSystem.OnRestoreFailureDetected -= Refresh;
		SavesSystem.OnSetFile -= Refresh;
	}

	private void Refresh()
	{
		if (SavesSystem.RestoreFailureMarker)
		{
			fadeGroup.Show();
		}
		else
		{
			fadeGroup.Hide();
		}
	}
}
public class SavesCounter
{
	public static Action<string, int> OnKillCountChanged;

	public static int AddCount(string countKey)
	{
		int num = SavesSystem.Load<int>("Count/" + countKey);
		num++;
		SavesSystem.Save("Count/" + countKey, num);
		return num;
	}

	public static int GetCount(string countKey)
	{
		return SavesSystem.Load<int>("Count/" + countKey);
	}

	public static int AddKillCount(string key)
	{
		int num = AddCount("Kills/" + key);
		OnKillCountChanged?.Invoke(key, num);
		return num;
	}

	public static int GetKillCount(string key)
	{
		return GetCount("Kills/" + key);
	}
}
public class LoadUnitySceneOnStart : MonoBehaviour
{
	public int sceneIndex;

	private void Start()
	{
		SceneManager.LoadScene(sceneIndex);
	}
}
[CreateAssetMenu]
public class SceneInfoCollection : ScriptableObject
{
	public const string BaseSceneID = "Base";

	[SerializeField]
	private List<SceneInfoEntry> entries;

	internal static SceneInfoCollection Instance => GameplayDataSettings.SceneManagement?.SceneInfoCollection;

	public static List<SceneInfoEntry> Entries
	{
		get
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.entries;
		}
	}

	public SceneInfoEntry InstanceGetSceneInfo(string id)
	{
		return entries.Find((SceneInfoEntry e) => e.ID == id);
	}

	public string InstanceGetSceneID(int buildIndex)
	{
		return entries.Find(delegate(SceneInfoEntry e)
		{
			if (e == null)
			{
				return false;
			}
			return e.SceneReference.UnsafeReason == SceneReferenceUnsafeReason.None && e.SceneReference.BuildIndex == buildIndex;
		})?.ID;
	}

	internal string InstanceGetSceneID(SceneReference sceneRef)
	{
		if (sceneRef.UnsafeReason != SceneReferenceUnsafeReason.None)
		{
			return null;
		}
		return InstanceGetSceneID(sceneRef.BuildIndex);
	}

	internal SceneReference InstanceGetSceneReferencce(string requireSceneID)
	{
		return InstanceGetSceneInfo(requireSceneID)?.SceneReference;
	}

	public static SceneInfoEntry GetSceneInfo(string sceneID)
	{
		if (Instance == null)
		{
			return null;
		}
		return Instance.InstanceGetSceneInfo(sceneID);
	}

	public static string GetSceneID(SceneReference sceneRef)
	{
		if (Instance == null)
		{
			return null;
		}
		return Instance.InstanceGetSceneID(sceneRef);
	}

	public static string GetSceneID(int buildIndex)
	{
		if (Instance == null)
		{
			return null;
		}
		return Instance.InstanceGetSceneID(buildIndex);
	}

	internal static int GetBuildIndex(string overrideSceneID)
	{
		if (Instance == null)
		{
			return -1;
		}
		return Instance.InstanceGetSceneInfo(overrideSceneID)?.BuildIndex ?? (-1);
	}

	internal static SceneInfoEntry GetSceneInfo(int sceneBuildIndex)
	{
		if (Instance == null)
		{
			return null;
		}
		return Instance.entries.Find((SceneInfoEntry e) => e.BuildIndex == sceneBuildIndex);
	}
}
[Serializable]
public class SceneInfoEntry
{
	[SerializeField]
	private string id;

	[SerializeField]
	private SceneReference sceneReference;

	[LocalizationKey("Default")]
	[SerializeField]
	private string displayName;

	[LocalizationKey("Default")]
	[SerializeField]
	private string description;

	public int BuildIndex
	{
		get
		{
			if (sceneReference.UnsafeReason != SceneReferenceUnsafeReason.None)
			{
				return -1;
			}
			return sceneReference.BuildIndex;
		}
	}

	public string ID => id;

	public SceneReference SceneReference => sceneReference;

	public string Description => description.ToPlainText();

	public string DisplayName
	{
		get
		{
			if (string.IsNullOrEmpty(displayName))
			{
				return id;
			}
			return displayName.ToPlainText();
		}
	}

	public string DisplayNameRaw
	{
		get
		{
			if (string.IsNullOrEmpty(displayName))
			{
				return id;
			}
			return displayName;
		}
	}

	public bool IsLoaded
	{
		get
		{
			if (sceneReference == null)
			{
				return false;
			}
			if (sceneReference.UnsafeReason == SceneReferenceUnsafeReason.None)
			{
				return sceneReference.LoadedScene.isLoaded;
			}
			return false;
		}
	}

	public SceneInfoEntry()
	{
	}

	public SceneInfoEntry(string id, SceneReference sceneReference)
	{
		this.id = id;
		this.sceneReference = sceneReference;
	}
}
public struct SceneLoadingContext
{
	public string sceneName;

	public bool useLocation;

	public MultiSceneLocation location;
}
public class SceneLoader : MonoBehaviour
{
	public SceneReference defaultCurtainScene;

	[SerializeField]
	private OnPointerClick pointerClickEventRecevier;

	[SerializeField]
	private float minimumLoadingTime = 1f;

	[SerializeField]
	private float waitAfterSceneLoaded = 1f;

	[SerializeField]
	private FadeGroup content;

	[SerializeField]
	private FadeGroup loadingIndicator;

	[SerializeField]
	private FadeGroup clickIndicator;

	[SerializeField]
	private AnimationCurve fadeCurve1;

	[SerializeField]
	private AnimationCurve fadeCurve2;

	[SerializeField]
	private AnimationCurve fadeCurve3;

	[SerializeField]
	private AnimationCurve fadeCurve4;

	private string _loadingComment;

	[SerializeField]
	private SceneReference target;

	private bool clicked;

	public static SceneLoader Instance => GameManager.SceneLoader;

	public static bool IsSceneLoading { get; private set; }

	public static string LoadingComment
	{
		get
		{
			if (LevelManager.LevelInitializing)
			{
				return LevelManager.LevelInitializingComment;
			}
			if (Instance != null)
			{
				return Instance._loadingComment;
			}
			return null;
		}
		set
		{
			if (!(Instance == null))
			{
				Instance._loadingComment = value;
				SceneLoader.OnSetLoadingComment?.Invoke(value);
			}
		}
	}

	public static bool HideTips { get; private set; }

	public static event Action<SceneLoadingContext> onStartedLoadingScene;

	public static event Action<SceneLoadingContext> onFinishedLoadingScene;

	public static event Action<SceneLoadingContext> onBeforeSetSceneActive;

	public static event Action<SceneLoadingContext> onAfterSceneInitialize;

	public static event Action<string> OnSetLoadingComment;

	private void Awake()
	{
		if (Instance != this)
		{
			UnityEngine.Debug.LogError(base.gameObject.scene.name + " 场景中出现了应当删除的Scene Loader");
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			pointerClickEventRecevier.onPointerClick.AddListener(NotifyPointerClick);
			pointerClickEventRecevier.gameObject.SetActive(value: false);
			content.Hide();
		}
	}

	public async UniTask LoadScene(string sceneID, MultiSceneLocation location, SceneReference overrideCurtainScene = null, bool clickToConinue = false, bool notifyEvacuation = false, bool doCircleFade = true, bool saveToFile = true, bool hideTips = false)
	{
		await LoadScene(sceneID, overrideCurtainScene, clickToConinue, notifyEvacuation, doCircleFade, useLocation: true, location, saveToFile, hideTips);
	}

	public async UniTask LoadScene(string sceneID, SceneReference overrideCurtainScene = null, bool clickToConinue = false, bool notifyEvacuation = false, bool doCircleFade = true, bool useLocation = false, MultiSceneLocation location = default(MultiSceneLocation), bool saveToFile = true, bool hideTips = false)
	{
		SceneInfoEntry sceneInfo = SceneInfoCollection.GetSceneInfo(sceneID);
		if (sceneInfo != null && sceneInfo.SceneReference.UnsafeReason == SceneReferenceUnsafeReason.None)
		{
			await LoadScene(sceneInfo.SceneReference, overrideCurtainScene, clickToConinue, notifyEvacuation, doCircleFade, useLocation, location, saveToFile, hideTips);
		}
	}

	public async UniTask LoadScene(SceneReference sceneReference, SceneReference overrideCurtainScene = null, bool clickToConinue = false, bool notifyEvacuation = false, bool doCircleFade = true, bool useLocation = false, MultiSceneLocation location = default(MultiSceneLocation), bool saveToFile = true, bool hideTips = false)
	{
		SceneLoadingContext context = new SceneLoadingContext
		{
			sceneName = sceneReference.Name,
			useLocation = useLocation,
			location = location
		};
		if (IsSceneLoading)
		{
			UnityEngine.Debug.LogError("已经在加载场景了");
			return;
		}
		HideTips = hideTips;
		LoadingComment = "Handling pre-loading work...";
		AudioManager.StopBGM();
		LoadingComment = "Wrapping up level...";
		if ((bool)LevelManager.Instance)
		{
			LoadingComment = "Handling evacuation...";
			if (notifyEvacuation)
			{
				LevelManager.Instance.NotifyEvacuated(new EvacuationInfo(MultiSceneCore.ActiveSubSceneID, default(Vector3)));
			}
			LoadingComment = "Handling target scene...";
			if (SceneInfoCollection.GetSceneID(sceneReference) != null)
			{
				LoadingComment = "Notifying saves system...";
				LevelManager.Instance.NotifySaveBeforeLoadScene(saveToFile);
			}
		}
		LoadingComment = "Begin loading...";
		IsSceneLoading = true;
		LoadingComment = "Notifying start loading events...";
		SceneLoader.onStartedLoadingScene?.Invoke(context);
		LoadingComment = "Referencing curtain scene...";
		SceneReference curtainScene = ((overrideCurtainScene != null && overrideCurtainScene.UnsafeReason != SceneReferenceUnsafeReason.Empty) ? overrideCurtainScene : defaultCurtainScene);
		LoadingComment = "Showing black screen...";
		await BlackScreen.ShowAndReturnTask(fadeCurve1, doCircleFade ? 1 : 0);
		LoadingComment = "Wait for object returning...";
		if (Cost.TaskPending)
		{
			UnityEngine.Debug.LogError("SceneLoader: 检测到正在返还物品");
		}
		LoadingComment = "Showing loading indicator...";
		loadingIndicator.Show();
		LoadingComment = "Stopping tweens...";
		DOTween.KillAll();
		LoadingComment = "Loading curtain...";
		await SceneManager.LoadSceneAsync(curtainScene.Name, LoadSceneMode.Single);
		LoadingComment = "Showing curtain...";
		SceneManager.SetActiveScene(SceneManager.GetSceneByName(curtainScene.Name));
		LoadingComment = "Showing HUD...";
		content.Show();
		GameManager.EventSystem.gameObject.SetActive(value: false);
		await UniTask.WaitForEndOfFrame(this);
		GameManager.EventSystem.gameObject.SetActive(value: true);
		float timeWhenLoadingStarted = Time.unscaledTime;
		LoadingComment = "Waiting...";
		await UniTask.WaitForSeconds(0.1f, ignoreTimeScale: true);
		LoadingComment = "Handling audio...";
		AudioManager.SetState("GameStatus", "LoadingLevel");
		LoadingComment = "Hiding black screen...";
		await BlackScreen.HideAndReturnTask(fadeCurve2);
		LoadingComment = "Loading target scene...";
		UnityEngine.AsyncOperation loadSceneOperation = SceneManager.LoadSceneAsync(sceneReference.Name, LoadSceneMode.Additive);
		loadSceneOperation.allowSceneActivation = false;
		LoadingComment = "Waiting for scene loading operation...";
		while (loadSceneOperation.progress < 0.9f)
		{
			await UniTask.NextFrame();
		}
		LoadingComment = "Wait for an eternity...";
		while (TimeSinceLoadingStarted() < minimumLoadingTime)
		{
			await UniTask.NextFrame();
		}
		LoadingComment = "Hiding UI...";
		content.Hide();
		LoadingComment = "Handling click to continue...";
		if (clickToConinue)
		{
			LoadingComment = "Hiding loading indicator...";
			await loadingIndicator.HideAndReturnTask();
			LoadingComment = "Showing click indicator...";
			await clickIndicator.ShowAndReturnTask();
			LoadingComment = "Setting up click handler...";
			pointerClickEventRecevier.gameObject.SetActive(value: true);
			clicked = false;
			LoadingComment = "Wait for click...";
			while (!clicked)
			{
				await UniTask.NextFrame();
			}
			LoadingComment = "Handle click...";
			pointerClickEventRecevier.gameObject.SetActive(value: false);
			clickIndicator.Hide();
		}
		else
		{
			LoadingComment = "Hiding UI...";
			loadingIndicator.Hide();
		}
		AudioManager.StopBGM();
		LoadingComment = "Summoning black...";
		await BlackScreen.ShowAndReturnTask(fadeCurve3);
		LoadingComment = "Invoking before scene active...";
		SceneLoader.onBeforeSetSceneActive?.Invoke(context);
		LoadingComment = "Allowing activation...";
		loadSceneOperation.allowSceneActivation = true;
		LoadingComment = "Waiting for scene loading finish-up...";
		await loadSceneOperation.ToUniTask();
		LoadingComment = "Setting active scene...";
		SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneReference.Name));
		LoadingComment = "Pulling away curtain...";
		await SceneManager.UnloadSceneAsync(curtainScene.Name);
		IsSceneLoading = false;
		LoadingComment = "Calling stuff service...";
		SceneLoader.onFinishedLoadingScene?.Invoke(context);
		AudioManager.SetState("GameStatus", "Playing");
		LoadingComment = "Waiting for level initialization...";
		while (LevelManager.Instance != null && !LevelManager.LevelInited)
		{
			await UniTask.NextFrame();
		}
		SceneLoader.onAfterSceneInitialize?.Invoke(context);
		LoadingComment = "Getting ready...";
		await UniTask.WaitForSeconds(waitAfterSceneLoaded, ignoreTimeScale: true);
		pointerClickEventRecevier.gameObject.SetActive(value: false);
		LoadingComment = "Expelling the darkness...";
		await BlackScreen.HideAndReturnTask(fadeCurve4, doCircleFade ? 1 : 0);
		float TimeSinceLoadingStarted()
		{
			return Time.unscaledTime - timeWhenLoadingStarted;
		}
	}

	public void LoadTarget()
	{
		LoadScene(target).Forget();
	}

	public async UniTask LoadBaseScene(SceneReference overrideCurtainScene = null, bool doCircleFade = true)
	{
		SceneReference sceneReference = GameplayDataSettings.SceneManagement?.BaseScene;
		if (sceneReference == null)
		{
			UnityEngine.Debug.LogError("未配置基地场景(GameplayDataSettings/SceneManagement/BaseScene)");
		}
		await LoadScene(sceneReference, overrideCurtainScene, clickToConinue: true, notifyEvacuation: false, doCircleFade);
	}

	public void NotifyPointerClick(PointerEventData eventData)
	{
		clicked = true;
		AudioManager.Post("UI/sceneloader_click");
	}

	internal static void StaticLoadSingle(SceneReference sceneReference)
	{
		SceneManager.LoadScene(sceneReference.Name, LoadSceneMode.Single);
	}

	internal static void StaticLoadSingle(string sceneID)
	{
		SceneManager.LoadScene(SceneInfoCollection.GetBuildIndex(sceneID), LoadSceneMode.Single);
	}

	public static void LoadMainMenu(bool circleFade = true)
	{
		if ((bool)Instance)
		{
			Instance.LoadScene(GameplayDataSettings.SceneManagement.MainMenuScene, null, clickToConinue: false, notifyEvacuation: false, circleFade).Forget();
		}
	}
}
public class SceneLoadingEventsReceiver : MonoBehaviour
{
	public UnityEvent onStartLoadingScene;

	public UnityEvent onFinishedLoadingScene;

	private void OnEnable()
	{
		SceneLoader.onStartedLoadingScene += OnStartedLoadingScene;
		SceneLoader.onFinishedLoadingScene += OnFinishedLoadingScene;
	}

	private void OnDisable()
	{
		SceneLoader.onStartedLoadingScene -= OnStartedLoadingScene;
		SceneLoader.onFinishedLoadingScene -= OnFinishedLoadingScene;
	}

	private void OnStartedLoadingScene(SceneLoadingContext context)
	{
		onStartLoadingScene?.Invoke();
	}

	private void OnFinishedLoadingScene(SceneLoadingContext context)
	{
		onFinishedLoadingScene?.Invoke();
	}
}
public class ShowLocationInMap : MonoBehaviour
{
	[SerializeField]
	private string displayName;

	public string DisplayName => displayName;

	public string DisplayNameRaw => displayName;
}
[Serializable]
public class CharacterSkillKeeper
{
	private SkillBase skill;

	private GameObject skillBindingObject;

	public Action OnSkillChanged;

	public SkillBase Skill => skill;

	public void SetSkill(SkillBase _skill, GameObject _bindingObject)
	{
		skill = null;
		skillBindingObject = null;
		if (_skill != null && _bindingObject != null)
		{
			skill = _skill;
			skillBindingObject = _bindingObject;
		}
		OnSkillChanged?.Invoke();
	}

	public bool CheckSkillAndBinding()
	{
		if (skill != null && skillBindingObject != null)
		{
			return true;
		}
		skill = null;
		skillBindingObject = null;
		return false;
	}
}
[Serializable]
public struct SkillContext
{
	public float castRange;

	public bool movableWhileAim;

	public float skillReadyTime;

	public float effectRange;

	public bool isGrenade;

	public float grenageVerticleSpeed;

	public bool checkObsticle;

	public bool releaseOnStartAim;
}
public struct SkillReleaseContext
{
	public Vector3 releasePoint;
}
public abstract class SkillBase : MonoBehaviour
{
	public bool hasReleaseSound;

	public string onReleaseSound;

	public Sprite icon;

	public float staminaCost = 10f;

	public float coolDownTime = 1f;

	private float lastReleaseTime = -999f;

	[SerializeField]
	protected SkillContext skillContext;

	protected SkillReleaseContext skillReleaseContext;

	protected CharacterMainControl fromCharacter;

	[HideInInspector]
	public Item fromItem;

	public Action OnSkillReleasedEvent;

	public float LastReleaseTime => lastReleaseTime;

	public SkillContext SkillContext => skillContext;

	public void ReleaseSkill(SkillReleaseContext releaseContext, CharacterMainControl from)
	{
		lastReleaseTime = Time.time;
		skillReleaseContext = releaseContext;
		fromCharacter = from;
		fromCharacter.UseStamina(staminaCost);
		if (hasReleaseSound && fromCharacter != null && onReleaseSound != "")
		{
			AudioManager.Post(onReleaseSound, from.gameObject);
		}
		OnRelease();
		OnSkillReleasedEvent?.Invoke();
	}

	public abstract void OnRelease();
}
public class Skill_Grenade : SkillBase
{
	public bool canControlCastDistance = true;

	public float delay = 1f;

	public bool delayFromCollide;

	public Grenade grenadePfb;

	public bool createPickup;

	public bool isLandmine;

	public float landmineTriggerRange = 0.5f;

	public bool createExplosion = true;

	public bool canHurtSelf = true;

	[Range(0f, 1f)]
	public float explosionShakeStrength = 1f;

	public DamageInfo damageInfo;

	public int blastCount = 1;

	public float blastAngle;

	[Tooltip("当有多个手雷时，delay的间隔")]
	public float blastDelayTimeSpace = 0.2f;

	public override void OnRelease()
	{
		if (fromCharacter == null)
		{
			return;
		}
		Vector3 position = fromCharacter.CurrentUsingAimSocket.position;
		Vector3 releasePoint = skillReleaseContext.releasePoint;
		float y = releasePoint.y;
		Vector3 vector = releasePoint - fromCharacter.transform.position;
		vector.y = 0f;
		float num = vector.magnitude;
		if (!canControlCastDistance)
		{
			num = skillContext.castRange;
		}
		vector.Normalize();
		float num2 = 0f;
		if (blastCount <= 1)
		{
			blastCount = 1;
		}
		if (blastCount > 1)
		{
			num2 = ((!(blastAngle < 359f)) ? (blastAngle / (float)blastCount) : (blastAngle / (float)(blastCount - 1)));
		}
		UnityEngine.Debug.Log($"castDistance:{num}");
		for (int i = 0; i < blastCount; i++)
		{
			Vector3 vector2 = Quaternion.Euler(0f, (0f - blastAngle) * 0.5f + num2 * (float)i, 0f) * vector;
			Vector3 target = position + vector2 * num;
			target.y = y;
			Grenade grenade = UnityEngine.Object.Instantiate(grenadePfb, position, fromCharacter.CurrentUsingAimSocket.rotation);
			damageInfo.fromCharacter = fromCharacter;
			grenade.damageInfo = damageInfo;
			Vector3 velocity = CalculateVelocity(position, target, skillContext.grenageVerticleSpeed);
			grenade.createExplosion = createExplosion;
			grenade.explosionShakeStrength = explosionShakeStrength;
			grenade.damageRange = skillContext.effectRange;
			grenade.delayFromCollide = delayFromCollide;
			grenade.delayTime = delay + blastDelayTimeSpace * (float)i;
			grenade.isLandmine = isLandmine;
			grenade.landmineTriggerRange = landmineTriggerRange;
			grenade.Launch(position, velocity, fromCharacter, canHurtSelf);
			if (fromItem != null)
			{
				grenade.SetWeaponIdInfo(fromItem.TypeID);
			}
			if (i == 0 && createPickup && fromItem != null)
			{
				UnityEngine.Debug.Log("CreatePickup");
				fromItem.Detach();
				fromItem.AgentUtilities.ReleaseActiveAgent();
				ItemAgent itemAgent = fromItem.AgentUtilities.CreateAgent(GameplayDataSettings.Prefabs.PickupAgentNoRendererPrefab, ItemAgent.AgentTypes.pickUp);
				UnityEngine.Debug.Log("newAgent Created:" + itemAgent.name);
				grenade.BindAgent(itemAgent);
			}
		}
	}

	public Vector3 CalculateVelocity(Vector3 start, Vector3 target, float verticleSpeed)
	{
		float num = Physics.gravity.magnitude;
		if (num <= 0f)
		{
			num = 1f;
		}
		float num2 = verticleSpeed / num;
		float num3 = Mathf.Sqrt(2f * Mathf.Abs(num2 * verticleSpeed * 0.5f + start.y - target.y) / num);
		float num4 = num2 + num3;
		if (num4 <= 0f)
		{
			num4 = 0.001f;
		}
		Vector3 vector = start;
		vector.y = 0f;
		Vector3 vector2 = target;
		vector2.y = 0f;
		float num5 = Vector3.Distance(vector, vector2);
		float num6 = 0f;
		Vector3 vector3 = vector2 - vector;
		if (vector3.magnitude > 0f)
		{
			vector3 = vector3.normalized;
			num6 = num5 / num4;
		}
		else
		{
			vector3 = Vector3.zero;
		}
		return vector3 * num6 + Vector3.up * verticleSpeed;
	}
}
public class BaseSceneUtilities : MonoBehaviour
{
	[SerializeField]
	private float saveInterval = 5f;

	private float lastTimeSaved = float.MinValue;

	private float TimeSinceLastSave => Time.realtimeSinceStartup - lastTimeSaved;

	private void Save()
	{
		LevelManager.Instance.SaveMainCharacter();
		SavesSystem.CollectSaveData();
		SavesSystem.SaveFile();
		lastTimeSaved = Time.realtimeSinceStartup;
	}

	private void Awake()
	{
		lastTimeSaved = Time.realtimeSinceStartup;
	}

	private void Update()
	{
		if (LevelManager.LevelInited && TimeSinceLastSave > saveInterval)
		{
			Save();
		}
	}
}
public class OverrideDeathSceneRouting : MonoBehaviour
{
	[SceneID]
	[SerializeField]
	private string sceneID;

	public static OverrideDeathSceneRouting Instance { get; private set; }

	private void OnEnable()
	{
		if (Instance != null)
		{
			UnityEngine.Debug.LogError("存在多个OverrideDeathSceneRouting实例");
		}
		Instance = this;
	}

	private void OnDisable()
	{
		if (Instance == this)
		{
			Instance = null;
		}
	}

	public string GetSceneID()
	{
		return sceneID;
	}
}
[DisallowMultipleComponent]
public class SteamManager : MonoBehaviour
{
	public const bool SteamEnabled = true;

	public const int AppID_Int = 3167020;

	protected static bool s_EverInitialized;

	protected static SteamManager s_instance;

	protected bool m_bInitialized;

	protected SteamAPIWarningMessageHook_t m_SteamAPIWarningMessageHook;

	protected static SteamManager Instance
	{
		get
		{
			if (s_instance == null)
			{
				UnityEngine.Debug.Log("Creating steam manager");
				return new GameObject("SteamManager").AddComponent<SteamManager>();
			}
			return s_instance;
		}
	}

	public static bool Initialized => Instance.m_bInitialized;

	[MonoPInvokeCallback(typeof(SteamAPIWarningMessageHook_t))]
	protected static void SteamAPIDebugTextHook(int nSeverity, StringBuilder pchDebugText)
	{
		UnityEngine.Debug.LogWarning(pchDebugText);
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]
	private static void InitOnPlayMode()
	{
		s_EverInitialized = false;
		s_instance = null;
	}

	protected virtual void Awake()
	{
		if (s_instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		s_instance = this;
		if (s_EverInitialized)
		{
			throw new Exception("Tried to Initialize the SteamAPI twice in one session!");
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		if (!Packsize.Test())
		{
			UnityEngine.Debug.LogError("[Steamworks.NET] Packsize Test returned false, the wrong version of Steamworks.NET is being run in this platform.", this);
		}
		if (!DllCheck.Test())
		{
			UnityEngine.Debug.LogError("[Steamworks.NET] DllCheck Test returned false, One or more of the Steamworks binaries seems to be the wrong version.", this);
		}
		try
		{
			if (SteamAPI.RestartAppIfNecessary((AppId_t)3167020u))
			{
				UnityEngine.Debug.Log("[Steamworks.NET] Shutting down because RestartAppIfNecessary returned true. Steam will restart the application.");
				Application.Quit();
				return;
			}
		}
		catch (DllNotFoundException ex)
		{
			UnityEngine.Debug.LogError("[Steamworks.NET] Could not load [lib]steam_api.dll/so/dylib. It's likely not in the correct location. Refer to the README for more details.\n" + ex, this);
			Application.Quit();
			return;
		}
		m_bInitialized = SteamAPI.Init();
		if (!m_bInitialized)
		{
			UnityEngine.Debug.LogError("[Steamworks.NET] SteamAPI_Init() failed. Refer to Valve's documentation or the comment above this line for more information.", this);
			return;
		}
		s_EverInitialized = true;
		AchievementManager.OnAchievementUnlocked += OnAchievementUnlocked;
		AchievementManager.OnAchievementDataLoaded += OnAchievementDataLoaded;
		RichPresenceManager.OnInstanceChanged = (Action<RichPresenceManager>)Delegate.Combine(RichPresenceManager.OnInstanceChanged, new Action<RichPresenceManager>(OnRichPresenceChanged));
		PlatformInfo.GetIDFunc = GetID;
	}

	private static string GetID()
	{
		if (s_instance == null)
		{
			return null;
		}
		if (!Initialized)
		{
			return null;
		}
		return SteamUser.GetSteamID().ToString();
	}

	protected virtual void OnDestroy()
	{
		if (!(s_instance != this))
		{
			s_instance = null;
			if (m_bInitialized)
			{
				SteamAPI.Shutdown();
				AchievementManager.OnAchievementUnlocked -= OnAchievementUnlocked;
				AchievementManager.OnAchievementDataLoaded -= OnAchievementDataLoaded;
				RichPresenceManager.OnInstanceChanged = (Action<RichPresenceManager>)Delegate.Remove(RichPresenceManager.OnInstanceChanged, new Action<RichPresenceManager>(OnRichPresenceChanged));
			}
		}
	}

	private void OnRichPresenceChanged(RichPresenceManager manager)
	{
		if (Initialized && !(manager == null))
		{
			string steamDisplay = manager.GetSteamDisplay();
			if (!SteamFriends.SetRichPresence("steam_display", steamDisplay))
			{
				UnityEngine.Debug.LogError("Failed setting rich presence: level = " + steamDisplay);
			}
			if (!SteamFriends.SetRichPresence("level", manager.levelDisplayNameRaw))
			{
				UnityEngine.Debug.LogError("Failed setting rich presence: level = " + manager.levelDisplayNameRaw);
			}
		}
	}

	private void OnAchievementDataLoaded(AchievementManager manager)
	{
		if (!Initialized || manager == null)
		{
			return;
		}
		bool flag = false;
		foreach (string unlockedAchievement in manager.UnlockedAchievements)
		{
			if (SteamUserStats.GetAchievement(unlockedAchievement, out var pbAchieved) && !pbAchieved)
			{
				SteamUserStats.SetAchievement(unlockedAchievement);
				flag = true;
			}
		}
		if (flag)
		{
			SteamUserStats.StoreStats();
		}
	}

	private void OnAchievementUnlocked(string achievementKey)
	{
		if (Initialized)
		{
			SteamUserStats.SetAchievement(achievementKey);
			SteamUserStats.StoreStats();
		}
	}

	protected virtual void OnEnable()
	{
		if (s_instance == null)
		{
			s_instance = this;
		}
		if (m_bInitialized && m_SteamAPIWarningMessageHook == null)
		{
			m_SteamAPIWarningMessageHook = SteamAPIDebugTextHook;
			SteamClient.SetWarningMessageHook(m_SteamAPIWarningMessageHook);
		}
	}

	protected virtual void Update()
	{
		if (m_bInitialized)
		{
			SteamAPI.RunCallbacks();
		}
	}
}
public class DamageToSelf : MonoBehaviour
{
	public DamageInfo dmg;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.K))
		{
			dmg.fromCharacter = CharacterMainControl.Main;
			CharacterMainControl.Main.Health.Hurt(dmg);
		}
		if (Input.GetKeyDown(KeyCode.L))
		{
			float value = CharacterMainControl.Main.CharacterItem.GetStat("InventoryCapacity").Value;
			UnityEngine.Debug.Log($"InventorySize:{value}");
		}
	}
}
public class EnemyCreator : MonoBehaviour
{
	private CharacterMainControl character;

	[SerializeField]
	private List<RandomItemGenerateDescription> itemsToGenerate;

	[SerializeField]
	private ItemFilter bulletFilter;

	[SerializeField]
	private AudioManager.VoiceType voiceType;

	[SerializeField]
	private CharacterModel characterModel;

	[SerializeField]
	private AICharacterController aiController;

	private int characterItemTypeID => GameplayDataSettings.ItemAssets.DefaultCharacterItemTypeID;

	private void Start()
	{
		UnityEngine.Debug.LogError("This scripts shouldn't exist!", this);
		if (LevelManager.LevelInited)
		{
			StartCreate();
		}
		else
		{
			LevelManager.OnLevelInitialized += StartCreate;
		}
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= StartCreate;
	}

	private void StartCreate()
	{
		int creatorID = GetCreatorID();
		if (MultiSceneCore.Instance != null)
		{
			if (MultiSceneCore.Instance.usedCreatorIds.Contains(creatorID))
			{
				return;
			}
			MultiSceneCore.Instance.usedCreatorIds.Add(creatorID);
		}
		CreateCharacterAsync();
	}

	private async UniTaskVoid CreateCharacterAsync()
	{
		Item characterItemInstance = await LoadOrCreateCharacterItemInstance();
		List<Item> initialItems = await GenerateItems();
		character = await LevelManager.Instance.CharacterCreator.CreateCharacter(characterItemInstance, characterModel, base.transform.position, base.transform.rotation);
		character.SetTeam(Teams.scav);
		if ((bool)aiController)
		{
			UnityEngine.Object.Instantiate(aiController).Init(character, base.transform.position, voiceType);
		}
		await UniTask.NextFrame();
		if (initialItems != null)
		{
			foreach (Item item in initialItems)
			{
				if (!(item == null) && !characterItemInstance.TryPlug(item) && !characterItemInstance.Inventory.AddAndMerge(item))
				{
					item.DestroyTree();
				}
			}
		}
		await AddBullet();
		PlugAccessories();
		if (MultiSceneCore.MainScene.HasValue && MultiSceneCore.MainScene.Value != base.gameObject.scene)
		{
			MultiSceneCore.MoveToActiveWithScene(base.gameObject);
		}
	}

	private void PlugAccessories()
	{
		Item item = character.PrimWeaponSlot()?.Content;
		if (item == null)
		{
			return;
		}
		Inventory inventory = character?.CharacterItem?.Inventory;
		if (inventory == null)
		{
			return;
		}
		foreach (Item item2 in inventory)
		{
			if (!(item2 == null))
			{
				item.TryPlug(item2, emptyOnly: true);
			}
		}
	}

	private async UniTask AddBullet()
	{
		Item item = character.PrimWeaponSlot()?.Content;
		if (!(item != null))
		{
			return;
		}
		string text = item.Constants.GetString("Caliber");
		if (!string.IsNullOrEmpty(text))
		{
			bulletFilter.caliber = text;
			int[] array = ItemAssetsCollection.Search(bulletFilter);
			if (array.Length >= 1)
			{
				Item item2 = await ItemAssetsCollection.InstantiateAsync(array.GetRandom());
				character?.CharacterItem?.Inventory?.AddItem(item2);
			}
		}
	}

	private async UniTask<List<Item>> GenerateItems()
	{
		List<Item> items = new List<Item>();
		foreach (RandomItemGenerateDescription item in itemsToGenerate)
		{
			items.AddRange(await item.Generate());
		}
		return items;
	}

	private async UniTask<Item> LoadOrCreateCharacterItemInstance()
	{
		return await ItemAssetsCollection.InstantiateAsync(characterItemTypeID);
	}

	private int GetCreatorID()
	{
		Transform parent = base.transform.parent;
		string arg = base.transform.GetSiblingIndex().ToString();
		while (parent != null)
		{
			arg = $"{parent.GetSiblingIndex()}/{arg}";
			parent = parent.parent;
		}
		arg = $"{base.gameObject.scene.buildIndex}/{arg}";
		return arg.GetHashCode();
	}
}
public class LogOnEnableAndDisable : MonoBehaviour
{
	private void OnEnable()
	{
		UnityEngine.Debug.Log("OnEnable");
	}

	private void OnDisable()
	{
		UnityEngine.Debug.Log("OnDisable");
	}
}
public class MapImageToShader : MonoBehaviour
{
	public RectTransform rect;

	private Material material;

	private int zeroPointID = Shader.PropertyToID("_ZeroPoint");

	private int upVectorID = Shader.PropertyToID("_UpVector");

	private int rightVectorID = Shader.PropertyToID("_RightVector");

	private int scaleID = Shader.PropertyToID("_Scale");

	private void Start()
	{
	}

	private void Update()
	{
		if (!material)
		{
			material = GetComponent<UnityEngine.UI.Image>().material;
		}
		if ((bool)material)
		{
			Rect rect = this.rect.rect;
			Vector3 vector = rect.min;
			Vector3 vector2 = rect.max;
			Vector3 vector3 = new Vector3(vector.x, vector.y);
			Vector3 vector4 = new Vector3(vector.x, vector2.y);
			Vector3 vector5 = new Vector3(vector2.x, vector.y);
			Vector3 vector6 = base.transform.TransformPoint(vector3);
			Vector3 vector7 = base.transform.TransformVector(vector4 - vector3);
			Vector3 vector8 = base.transform.TransformVector(vector5 - vector3);
			material.SetVector(zeroPointID, vector6);
			material.SetVector(upVectorID, vector7);
			material.SetVector(rightVectorID, vector8);
			material.SetFloat(scaleID, this.rect.lossyScale.x);
		}
	}
}
public class OnDisableLog : MonoBehaviour
{
	private void OnDisable()
	{
		UnityEngine.Debug.Log("OnDisable");
	}
}
public class PlayableDirectorEvents : MonoBehaviour
{
	[SerializeField]
	private PlayableDirector playableDirector;

	[SerializeField]
	private UnityEvent onPlayed;

	[SerializeField]
	private UnityEvent onPaused;

	[SerializeField]
	private UnityEvent onStopped;

	private void OnEnable()
	{
		playableDirector.played += OnPlayed;
		playableDirector.paused += OnPaused;
		playableDirector.stopped += OnStopped;
	}

	private void OnDisable()
	{
		playableDirector.played -= OnPlayed;
		playableDirector.paused -= OnPaused;
		playableDirector.stopped -= OnStopped;
	}

	private void OnStopped(PlayableDirector director)
	{
		onStopped?.Invoke();
	}

	private void OnPaused(PlayableDirector director)
	{
		onPaused?.Invoke();
	}

	private void OnPlayed(PlayableDirector director)
	{
		onPlayed?.Invoke();
	}
}
public class BlueNoiseSetter : MonoBehaviour
{
	public List<Texture2D> blueNoises;

	private int index;

	private void Update()
	{
		Shader.SetGlobalTexture("GlobalBlueNoise", blueNoises[index]);
		index++;
		if (index >= blueNoises.Count)
		{
			index = 0;
		}
	}
}
public class BoundaryGenerator : MonoBehaviour
{
	public List<Vector3> points;

	[HideInInspector]
	public int lastSelectedPointIndex = -1;

	public float colliderHeight = 1f;

	public float yOffset;

	public float colliderThickness = 0.1f;

	public bool inverseFaceDirection;

	public bool provideContects;

	[SerializeField]
	[HideInInspector]
	private List<BoxCollider> colliderObjects;

	public void UpdateColliderParameters()
	{
		if (colliderObjects == null || colliderObjects.Count <= 0)
		{
			return;
		}
		for (int i = 0; i < colliderObjects.Count; i++)
		{
			if (i >= points.Count - 1)
			{
				continue;
			}
			BoxCollider boxCollider = colliderObjects[i];
			if (!(boxCollider == null))
			{
				boxCollider.gameObject.layer = base.gameObject.layer;
				Vector3 vector = base.transform.TransformPoint(points[i]);
				Vector3 vector2 = base.transform.TransformPoint(points[i + 1]);
				vector2.y = (vector.y = Mathf.Min(vector.y, vector2.y));
				Vector3 normalized = (vector2 - vector).normalized;
				float z = Vector3.Distance(vector, vector2);
				boxCollider.size = new Vector3(colliderThickness, colliderHeight, z);
				boxCollider.transform.forward = normalized;
				boxCollider.transform.position = (vector + vector2) / 2f + Vector3.up * 0.5f * colliderHeight + Vector3.up * yOffset + boxCollider.transform.right * 0.5f * colliderThickness * (inverseFaceDirection ? (-1f) : 1f);
				if (provideContects)
				{
					boxCollider.providesContacts = true;
				}
			}
		}
	}

	private void DestroyAllChildren()
	{
		while (base.transform.childCount > 0)
		{
			Transform child = base.transform.GetChild(0);
			child.SetParent(null);
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(child.gameObject);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(child.gameObject);
			}
		}
	}

	public void UpdateColliders()
	{
		DestroyAllChildren();
		if (colliderObjects == null)
		{
			colliderObjects = new List<BoxCollider>();
		}
		colliderObjects.Clear();
		for (int i = 0; i < points.Count - 1; i++)
		{
			GameObject obj = new GameObject($"Collider_{i}");
			obj.transform.parent = base.transform;
			BoxCollider item = obj.AddComponent<BoxCollider>();
			colliderObjects.Add(item);
		}
	}

	public void SetYtoZero()
	{
		for (int i = 0; i < points.Count; i++)
		{
			points[i] = new Vector3(points[i].x, 0f, points[i].z);
		}
	}

	public void OnPointsUpdated(bool OnValidate = false)
	{
		if (points == null)
		{
			points = new List<Vector3>();
		}
		if (base.transform.childCount != points.Count - 1 && !OnValidate)
		{
			UpdateColliders();
		}
		UpdateColliderParameters();
	}

	public void RemoveAllPoints()
	{
		points.Clear();
		OnPointsUpdated();
	}

	public void RespawnColliders()
	{
		DestroyAllChildren();
		colliderObjects.Clear();
		OnPointsUpdated();
	}

	private void OnValidate()
	{
		if (!Application.isPlaying)
		{
			OnPointsUpdated(OnValidate: true);
		}
	}

	public void OnDrawGizmos()
	{
		Gizmos.color = Color.green;
		if (colliderObjects == null || colliderObjects.Count <= 0)
		{
			return;
		}
		foreach (Vector3 point in points)
		{
			Gizmos.DrawCube(base.transform.TransformPoint(point), Vector3.one * 0.15f);
		}
	}
}
[DisallowMultipleComponent]
public class DecalAtlasSelector : MonoBehaviour
{
	[UnityEngine.Header("Atlas 设置")]
	[Min(1f)]
	public int rows = 1;

	[Min(1f)]
	public int columns = 1;

	[Min(0f)]
	public int index;

	private DecalProjector projector;

	private void OnValidate()
	{
		if (projector == null)
		{
			projector = GetComponent<DecalProjector>();
		}
		if (!(projector == null) && rows > 0 && columns > 0)
		{
			int num = rows * columns;
			int num2 = Mathf.Clamp(index, 0, num - 1);
			Vector2 uvScale = new Vector2(1f / (float)columns, 1f / (float)rows);
			Vector2 uvBias = new Vector2((float)(num2 % columns) * uvScale.x, 1f - uvScale.y - (float)(num2 / columns) * uvScale.y);
			projector.uvScale = uvScale;
			projector.uvBias = uvBias;
		}
	}
}
public class DestroyOvertime : MonoBehaviour
{
	public float life = 1f;

	private void Awake()
	{
		if (life <= 0f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Update()
	{
		life -= Time.deltaTime;
		if (life <= 0f)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void OnValidate()
	{
		ProcessParticleSystem();
	}

	private void ProcessParticleSystem()
	{
		float num = 0f;
		ParticleSystem component = GetComponent<ParticleSystem>();
		if (!component)
		{
			return;
		}
		if (component != null)
		{
			ParticleSystem.MainModule main = component.main;
			main.stopAction = ParticleSystemStopAction.None;
			if (main.startLifetime.constant > num)
			{
				num = main.startLifetime.constant;
			}
		}
		ParticleSystem[] componentsInChildren = base.transform.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			ParticleSystem.MainModule main2 = componentsInChildren[i].main;
			main2.stopAction = ParticleSystemStopAction.None;
			if (main2.startLifetime.constant > num)
			{
				num = main2.startLifetime.constant;
			}
		}
		life = num + 0.2f;
	}
}
public class DuckovScreenCapturer : MonoBehaviour
{
	private void Update()
	{
	}

	private void Shot()
	{
	}
}
public abstract class ShapeProvider : MonoBehaviour
{
	public abstract PipeRenderer.OrientedPoint[] GenerateShape();
}
[RequireComponent(typeof(EdgeCollider2D))]
[RequireComponent(typeof(ShapeProvider))]
[ExecuteInEditMode]
public class PipeCollider2D : MonoBehaviour
{
}
[RequireComponent(typeof(PipeRenderer))]
public class PipeDecoration : MonoBehaviour
{
	[Serializable]
	public class GameObjectOffset
	{
		public GameObject gameObject;

		public float offset;
	}

	public PipeRenderer pipeRenderer;

	[HideInInspector]
	public List<GameObjectOffset> decorations = new List<GameObjectOffset>();

	public Vector3 rotate;

	public Vector3 scale = Vector3.one;

	public float uniformScale = 1f;

	private void OnDrawGizmosSelected()
	{
		if (pipeRenderer == null)
		{
			pipeRenderer = GetComponent<PipeRenderer>();
		}
	}

	private void Refresh()
	{
		if (pipeRenderer.splineInUse == null || pipeRenderer.splineInUse.Length < 1)
		{
			return;
		}
		for (int i = 0; i < decorations.Count; i++)
		{
			GameObjectOffset gameObjectOffset = decorations[i];
			Quaternion rotation;
			Vector3 positionByOffset = pipeRenderer.GetPositionByOffset(gameObjectOffset.offset, out rotation);
			Vector3 position = pipeRenderer.transform.localToWorldMatrix.MultiplyPoint(positionByOffset);
			if (!(gameObjectOffset.gameObject == null))
			{
				gameObjectOffset.gameObject.transform.position = position;
				gameObjectOffset.gameObject.transform.localRotation = rotation;
				gameObjectOffset.gameObject.transform.Rotate(rotate);
				gameObjectOffset.gameObject.transform.localScale = scale * uniformScale;
			}
		}
	}

	public void OnValidate()
	{
		if (pipeRenderer == null)
		{
			pipeRenderer = GetComponent<PipeRenderer>();
		}
		Refresh();
	}
}
[RequireComponent(typeof(PipeRenderer))]
public class CircularExtrudeShape : ShapeProvider
{
	public PipeRenderer pipeRenderer;

	public float radius = 1f;

	public int subdivision = 12;

	public Vector3 offset = Vector3.zero;

	public override PipeRenderer.OrientedPoint[] GenerateShape()
	{
		Vector3 vector = Vector3.up * radius;
		float num = 360f / (float)subdivision;
		float num2 = 1f / (float)subdivision;
		PipeRenderer.OrientedPoint[] array = new PipeRenderer.OrientedPoint[subdivision + 1];
		for (int i = 0; i < subdivision; i++)
		{
			Quaternion quaternion = Quaternion.AngleAxis(num * (float)i, Vector3.forward);
			Vector3 position = quaternion * vector + offset;
			array[i] = new PipeRenderer.OrientedPoint
			{
				position = position,
				rotation = quaternion,
				uv = num2 * (float)i * Vector2.one
			};
		}
		array[subdivision] = new PipeRenderer.OrientedPoint
		{
			position = vector + offset,
			rotation = Quaternion.AngleAxis(0f, Vector3.forward),
			uv = Vector2.one
		};
		return array;
	}

	private void OnDrawGizmosSelected()
	{
		if (pipeRenderer == null)
		{
			pipeRenderer = GetComponent<PipeRenderer>();
		}
		if (pipeRenderer != null && pipeRenderer.extrudeShapeProvider == null)
		{
			pipeRenderer.extrudeShapeProvider = this;
		}
	}
}
public class MultiCirceExtrudeShape : ShapeProvider
{
	[Serializable]
	public struct Circle
	{
		public Vector3 origin;

		public float radius;
	}

	public Circle[] circles;

	public int subdivision = 4;

	public override PipeRenderer.OrientedPoint[] GenerateShape()
	{
		List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>();
		float num = 360f / (float)subdivision;
		float num2 = 1f / (float)(subdivision * circles.Length);
		for (int i = 0; i < circles.Length; i++)
		{
			Circle circle = circles[i];
			float radius = circle.radius;
			Vector3 origin = circle.origin;
			Vector3 vector = Vector3.up * radius;
			for (int j = 0; j < subdivision; j++)
			{
				Quaternion quaternion = Quaternion.AngleAxis(num * (float)j, Vector3.forward);
				Vector3 position = origin + quaternion * vector;
				list.Add(new PipeRenderer.OrientedPoint
				{
					position = position,
					rotation = quaternion,
					uv = num2 * (float)(i * subdivision + j) * Vector2.one
				});
			}
			list.Add(new PipeRenderer.OrientedPoint
			{
				position = vector,
				rotation = Quaternion.AngleAxis(0f, Vector3.forward),
				uv = num2 * (float)((i + 1) * subdivision) * Vector2.one
			});
		}
		return list.ToArray();
	}
}
public class RoundCornerRectExtrudeShape : ShapeProvider
{
	public Vector2 size = Vector2.one;

	public float bevelSize = 0.1f;

	public bool resample;

	[Range(0.1f, 1f)]
	public float stepLength = 0.25f;

	public override PipeRenderer.OrientedPoint[] GenerateShape()
	{
		float num = bevelSize;
		Vector2 vector = new Vector2((0f - size.x) / 2f + num, size.y / 2f - num);
		Vector2 vector2 = vector + new Vector2(-1f, 1f).normalized * num;
		Vector2 vector3 = vector + new Vector2(0f, 1f) * num;
		PipeRenderer.OrientedPoint orientedPoint = new PipeRenderer.OrientedPoint
		{
			position = vector2,
			normal = new Vector2(-1f, 1f),
			uv = Vector2.zero
		};
		PipeRenderer.OrientedPoint orientedPoint2 = new PipeRenderer.OrientedPoint
		{
			position = vector3,
			normal = new Vector3(0f, 1f),
			uv = num * Vector2.one
		};
		PipeRenderer.OrientedPoint orientedPoint3 = orientedPoint2;
		orientedPoint3.position.x = 0f - orientedPoint3.position.x;
		orientedPoint3.normal.x = 0f - orientedPoint3.normal.x;
		orientedPoint3.uv = Vector2.one - orientedPoint3.uv;
		PipeRenderer.OrientedPoint orientedPoint4 = orientedPoint;
		orientedPoint4.position.x = 0f - orientedPoint4.position.x;
		orientedPoint4.normal.x = 0f - orientedPoint4.normal.x;
		orientedPoint4.uv = Vector2.one;
		PipeRenderer.OrientedPoint item = orientedPoint4;
		item.uv = Vector2.zero;
		PipeRenderer.OrientedPoint orientedPoint5 = default(PipeRenderer.OrientedPoint);
		orientedPoint5.position = vector;
		orientedPoint5.position.x = 0f - orientedPoint5.position.x;
		orientedPoint5.position.x += num;
		orientedPoint5.normal = new Vector3(1f, 0f);
		orientedPoint5.uv = orientedPoint2.uv;
		PipeRenderer.OrientedPoint orientedPoint6 = orientedPoint5;
		orientedPoint6.position.y = 0f - orientedPoint6.position.y;
		orientedPoint6.uv = orientedPoint3.uv;
		PipeRenderer.OrientedPoint orientedPoint7 = orientedPoint4;
		orientedPoint7.position.y = 0f - orientedPoint7.position.y;
		orientedPoint7.normal = new Vector2(1f, -1f);
		orientedPoint7.uv = Vector2.one;
		PipeRenderer.OrientedPoint item2 = orientedPoint7;
		item2.uv = Vector2.zero;
		PipeRenderer.OrientedPoint item3 = orientedPoint3;
		item3.position.y = 0f - item3.position.y;
		item3.normal = Vector2.down;
		item3.uv = orientedPoint5.uv;
		PipeRenderer.OrientedPoint item4 = orientedPoint2;
		item4.position.y = 0f - item4.position.y;
		item4.normal = Vector2.down;
		item4.uv = orientedPoint3.uv;
		PipeRenderer.OrientedPoint orientedPoint8 = orientedPoint;
		orientedPoint8.position.y = 0f - orientedPoint8.position.y;
		orientedPoint8.normal = new Vector2(-1f, -1f);
		orientedPoint8.uv = Vector2.one;
		PipeRenderer.OrientedPoint item5 = orientedPoint8;
		item5.uv = Vector2.zero;
		PipeRenderer.OrientedPoint item6 = orientedPoint6;
		item6.position.x = 0f - item6.position.x;
		item6.normal = Vector2.left;
		item6.uv = orientedPoint2.uv;
		PipeRenderer.OrientedPoint orientedPoint9 = orientedPoint5;
		orientedPoint9.position.x = 0f - orientedPoint9.position.x;
		orientedPoint9.normal = Vector2.left;
		orientedPoint9.uv = orientedPoint3.uv;
		PipeRenderer.OrientedPoint item7 = orientedPoint9;
		item7.uv = Vector2.zero;
		List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>();
		list.Add(orientedPoint);
		list.Add(orientedPoint2);
		list.Add(orientedPoint3);
		list.Add(orientedPoint4);
		list.Add(item);
		list.Add(orientedPoint5);
		list.Add(orientedPoint6);
		list.Add(orientedPoint7);
		list.Add(item2);
		list.Add(item3);
		list.Add(item4);
		list.Add(orientedPoint8);
		list.Add(item5);
		list.Add(item6);
		list.Add(orientedPoint9);
		list.Add(item7);
		list.Reverse();
		if (resample)
		{
			list = Resample(list, stepLength);
		}
		return list.ToArray();
	}

	private List<PipeRenderer.OrientedPoint> Resample(List<PipeRenderer.OrientedPoint> original, float stepLength)
	{
		if (stepLength < 0.01f)
		{
			return new List<PipeRenderer.OrientedPoint>();
		}
		List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>();
		int i = 0;
		float num = 0f;
		for (; i < original.Count; i++)
		{
			PipeRenderer.OrientedPoint orientedPoint = original[i];
			PipeRenderer.OrientedPoint orientedPoint2 = ((i + 1 >= original.Count) ? original[0] : original[i + 1]);
			Vector3 vector = orientedPoint2.position - orientedPoint.position;
			Vector3 normalized = vector.normalized;
			float magnitude = vector.magnitude;
			for (float num2 = 0f; num2 < magnitude; num2 += stepLength)
			{
				Vector3 position = orientedPoint.position + normalized * num2;
				float t = num2 / magnitude;
				num += num2;
				PipeRenderer.OrientedPoint item = new PipeRenderer.OrientedPoint
				{
					position = position,
					normal = Vector3.Lerp(orientedPoint.normal, orientedPoint2.normal, t),
					uv = num * Vector2.one
				};
				list.Add(item);
			}
		}
		return list;
	}
}
public class RoundCornerSquareExtrudeShape : ShapeProvider
{
	public float size = 1f;

	public float bevelSize = 0.1f;

	public override PipeRenderer.OrientedPoint[] GenerateShape()
	{
		float num = size;
		float num2 = bevelSize;
		Vector2 vector = new Vector2((0f - num) / 2f + num2, num / 2f - num2);
		Vector2 vector2 = vector + new Vector2(-1f, 1f).normalized * num2;
		Vector2 vector3 = vector + new Vector2(0f, 1f) * num2;
		PipeRenderer.OrientedPoint orientedPoint = new PipeRenderer.OrientedPoint
		{
			position = vector2,
			normal = new Vector2(-1f, 1f),
			uv = Vector2.zero
		};
		PipeRenderer.OrientedPoint orientedPoint2 = new PipeRenderer.OrientedPoint
		{
			position = vector3,
			normal = new Vector3(0f, 1f),
			uv = num2 * Vector2.one
		};
		PipeRenderer.OrientedPoint orientedPoint3 = orientedPoint2;
		orientedPoint3.position.x = 0f - orientedPoint3.position.x;
		orientedPoint3.normal.x = 0f - orientedPoint3.normal.x;
		orientedPoint3.uv = Vector2.one - orientedPoint3.uv;
		PipeRenderer.OrientedPoint orientedPoint4 = orientedPoint;
		orientedPoint4.position.x = 0f - orientedPoint4.position.x;
		orientedPoint4.normal.x = 0f - orientedPoint4.normal.x;
		orientedPoint4.uv = Vector2.one;
		List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>();
		list.Add(orientedPoint);
		list.Add(orientedPoint2);
		list.Add(orientedPoint3);
		list.Add(orientedPoint4);
		for (int i = 1; i <= 3; i++)
		{
			PipeRenderer.OrientedPoint orientedPoint5 = orientedPoint;
			PipeRenderer.OrientedPoint orientedPoint6 = orientedPoint2;
			PipeRenderer.OrientedPoint orientedPoint7 = orientedPoint3;
			PipeRenderer.OrientedPoint orientedPoint8 = orientedPoint4;
			for (int j = 0; j < i; j++)
			{
				orientedPoint5 = Rotate(orientedPoint5);
				orientedPoint6 = Rotate(orientedPoint6);
				orientedPoint7 = Rotate(orientedPoint7);
				orientedPoint8 = Rotate(orientedPoint8);
			}
			orientedPoint5.uv += i * Vector2.one;
			orientedPoint6.uv += i * Vector2.one;
			orientedPoint7.uv += i * Vector2.one;
			orientedPoint8.uv += i * Vector2.one;
			list.Add(orientedPoint5);
			list.Add(orientedPoint6);
			list.Add(orientedPoint7);
			list.Add(orientedPoint8);
		}
		list.Reverse();
		return list.ToArray();
		static PipeRenderer.OrientedPoint Rotate(PipeRenderer.OrientedPoint original)
		{
			Quaternion quaternion = Quaternion.AngleAxis(-90f, Vector3.forward);
			PipeRenderer.OrientedPoint result = original;
			result.position = quaternion * original.position;
			result.normal = quaternion * original.normal;
			return result;
		}
	}
}
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
public class PipeRenderer : MonoBehaviour
{
	[Serializable]
	public struct OrientedPoint
	{
		public Vector3 position;

		public Quaternion rotation;

		public Vector3 tangent;

		public Vector3 rotationalAxisVector;

		public Vector3 normal;

		public Vector2 uv;
	}

	public MeshFilter meshFilter;

	public ShapeProvider splineShapeProvider;

	public ShapeProvider extrudeShapeProvider;

	[UnityEngine.Header("UV")]
	public float uvTwist;

	[UnityEngine.Header("Options")]
	public float extrudeShapeScale = 1f;

	public float sectionLength = 10f;

	public bool caps;

	public bool useExtrudeShapeScaleCurve;

	public AnimationCurve extrudeShapeScaleCurve = AnimationCurve.Constant(0f, 1f, 1f);

	public Color vertexColor = Color.white;

	public bool recalculateNormal = true;

	public bool revertFaces;

	[UnityEngine.Header("Gizmos")]
	public bool drawSplinePoints;

	public OrientedPoint[] splineInUse;

	public OrientedPoint[] extrudeShape
	{
		get
		{
			if (extrudeShapeProvider == null)
			{
				UnityEngine.Debug.LogWarning("Extrude shape is null, please add an extrude shape such as \"CircularExtrudeShape\"");
				return new OrientedPoint[1]
				{
					new OrientedPoint
					{
						position = Vector3.zero
					}
				};
			}
			return extrudeShapeProvider.GenerateShape();
		}
	}

	public OrientedPoint[] splineShape
	{
		get
		{
			if (splineShapeProvider == null)
			{
				UnityEngine.Debug.LogWarning("Spline shape is null, please add a spline shape such as \"Beveled Line Shape\"");
				return new OrientedPoint[1]
				{
					new OrientedPoint
					{
						position = Vector3.zero
					}
				};
			}
			return splineShapeProvider.GenerateShape();
		}
	}

	public float GetTotalLength()
	{
		return PipeHelperFunctions.GetTotalLength(splineInUse);
	}

	public static Mesh GeneratePipeMesh(OrientedPoint[] extrudeShape, OrientedPoint[] splineShape, Color vertexColor, float uvTwist = 0f, float extrudeShapeScale = 1f, AnimationCurve extrudeShapeScaleCurve = null, float sectionLength = 0f, bool caps = false, bool recalculateNormal = true, bool revertFaces = false)
	{
		List<Vector3> list = new List<Vector3>();
		List<Vector3> list2 = new List<Vector3>();
		List<int> list3 = new List<int>();
		List<Vector2> list4 = new List<Vector2>();
		float num = 0f;
		float totalLength = PipeHelperFunctions.GetTotalLength(splineShape);
		if (sectionLength <= 0f)
		{
			sectionLength = totalLength;
		}
		for (int i = 0; i < splineShape.Length; i++)
		{
			OrientedPoint orientedPoint = splineShape[i];
			Vector3 position = orientedPoint.position;
			Quaternion rotation = orientedPoint.rotation;
			if (i > 0)
			{
				OrientedPoint orientedPoint2 = splineShape[i - 1];
				num += (position - orientedPoint2.position).magnitude;
			}
			float time = num % sectionLength / sectionLength;
			float num2 = extrudeShapeScaleCurve?.Evaluate(time) ?? 1f;
			for (int j = 0; j < extrudeShape.Length; j++)
			{
				OrientedPoint orientedPoint3 = extrudeShape[j];
				Vector3 vector = position + extrudeShapeScale * num2 * (rotation * orientedPoint3.position);
				Vector3 vector2 = (recalculateNormal ? (vector - position).normalized : (rotation * orientedPoint3.normal));
				Vector2 item = new Vector2(orientedPoint3.uv.y + num * uvTwist, orientedPoint.uv.x);
				list.Add(vector);
				list2.Add(revertFaces ? (-vector2) : vector2);
				list4.Add(item);
			}
			if (i <= 0)
			{
				continue;
			}
			int num3 = i * extrudeShape.Length;
			for (int k = 0; k < extrudeShape.Length - 1; k++)
			{
				int num4 = num3 + k;
				int num5 = num3 + k + 1;
				int item2 = num5 - extrudeShape.Length;
				int item3 = num4 - extrudeShape.Length;
				if (revertFaces)
				{
					list3.Add(num5);
					list3.Add(item3);
					list3.Add(num4);
					list3.Add(item2);
					list3.Add(item3);
					list3.Add(num5);
				}
				else
				{
					list3.Add(num4);
					list3.Add(item3);
					list3.Add(num5);
					list3.Add(num5);
					list3.Add(item3);
					list3.Add(item2);
				}
			}
		}
		if (caps)
		{
			Vector3 item4 = -splineShape[0].tangent;
			int num6 = 0;
			int[] array = new int[extrudeShape.Length];
			for (int l = 0; l < extrudeShape.Length; l++)
			{
				int index = num6 + l;
				list.Add(list[index]);
				list2.Add(item4);
				list4.Add(list4[index]);
				array[l] = list.Count - 1;
			}
			Vector3 zero = Vector3.zero;
			for (int m = 0; m < array.Length; m++)
			{
				zero += list[m];
			}
			zero /= (float)array.Length;
			list.Add(zero);
			list2.Add(item4);
			list4.Add(Vector2.one * 0f / 5f);
			int item5 = list.Count - 1;
			for (int n = 0; n < array.Length - 1; n++)
			{
				list3.Add(item5);
				list3.Add(array[n + 1]);
				list3.Add(array[n]);
			}
			item4 = splineShape[^1].tangent;
			num6 = extrudeShape.Length * (splineShape.Length - 1);
			for (int num7 = 0; num7 < extrudeShape.Length; num7++)
			{
				int index2 = num6 + num7;
				list.Add(list[index2]);
				list2.Add(item4);
				list4.Add(list4[index2]);
				array[num7] = list.Count - 1;
			}
			zero = Vector3.zero;
			for (int num8 = 0; num8 < array.Length; num8++)
			{
				zero += list[array[num8]];
			}
			zero /= (float)array.Length;
			list.Add(zero);
			list2.Add(item4);
			list4.Add(Vector2.one * 0f / 5f);
			item5 = list.Count - 1;
			for (int num9 = 0; num9 < array.Length - 1; num9++)
			{
				list3.Add(array[num9]);
				list3.Add(array[num9 + 1]);
				list3.Add(item5);
			}
		}
		Color[] array2 = new Color[list.Count];
		for (int num10 = 0; num10 < array2.Length; num10++)
		{
			array2[num10] = vertexColor;
		}
		Mesh mesh = new Mesh();
		mesh.vertices = list.ToArray();
		mesh.uv = list4.ToArray();
		mesh.triangles = list3.ToArray();
		mesh.normals = list2.ToArray();
		mesh.RecalculateTangents();
		mesh.colors = array2;
		mesh.name = "Generated Mesh";
		return mesh;
	}

	private void OnDrawGizmosSelected()
	{
		if (meshFilter == null)
		{
			meshFilter = GetComponent<MeshFilter>();
		}
		splineInUse = splineShape;
		meshFilter.mesh = GeneratePipeMesh(extrudeShape, splineInUse, vertexColor, uvTwist, extrudeShapeScale, useExtrudeShapeScaleCurve ? extrudeShapeScaleCurve : null, sectionLength, caps, recalculateNormal, revertFaces);
		if (drawSplinePoints)
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			for (int i = 0; i < splineInUse.Length; i++)
			{
				OrientedPoint orientedPoint = splineInUse[i];
				Vector3 vector = localToWorldMatrix.MultiplyPoint(orientedPoint.position);
				Gizmos.DrawWireCube(vector, Vector3.one * 0.01f);
				Vector3 vector2 = localToWorldMatrix.MultiplyVector(orientedPoint.tangent);
				Gizmos.DrawLine(vector, vector + vector2 * 0.02f);
			}
		}
	}

	private void Start()
	{
		if (meshFilter == null)
		{
			meshFilter = GetComponent<MeshFilter>();
		}
	}

	public Vector3 GetPositionByOffset(float offset, out Quaternion rotation)
	{
		if (splineInUse == null || splineInUse.Length < 1)
		{
			rotation = Quaternion.identity;
			return Vector3.zero;
		}
		if (offset <= 0f)
		{
			rotation = splineInUse[0].rotation;
			return splineInUse[0].position;
		}
		float num = 0f;
		for (int i = 1; i < splineInUse.Length; i++)
		{
			OrientedPoint orientedPoint = splineInUse[i];
			OrientedPoint orientedPoint2 = splineInUse[i - 1];
			float num2 = num;
			float magnitude = (orientedPoint.position - orientedPoint2.position).magnitude;
			num += magnitude;
			float num3 = num;
			if (num3 > offset)
			{
				float num4 = num3 - num2;
				float num5 = (offset - num2) / num4;
				rotation = Quaternion.Lerp(orientedPoint2.rotation, orientedPoint.rotation, num5);
				return orientedPoint2.position + (orientedPoint.position - orientedPoint2.position) * num5;
			}
		}
		rotation = splineInUse[splineInUse.Length - 1].rotation;
		return splineInUse[splineInUse.Length - 1].position;
	}
}
public class BezierSpline : ShapeProvider
{
	public PipeRenderer pipeRenderer;

	public Vector3[] points = new Vector3[4];

	public int subdivisions = 12;

	public bool drawGizmos;

	public static Vector3 GetPoint(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float t)
	{
		float num = Mathf.Pow(1f - t, 3f);
		float num2 = 3f * t * (1f - t) * (1f - t);
		float num3 = 3f * t * t * (1f - t);
		float num4 = t * t * t;
		return num * p1 + num2 * p2 + num3 * p3 + num4 * p4;
	}

	public static Vector3 GetTangent(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float t)
	{
		float num = -3f * (1f - t) * (1f - t);
		float num2 = 3f * (1f - t) * (1f - t) - 6f * t * (1f - t);
		float num3 = 6f * t * (1f - t) - 3f * t * t;
		float num4 = 3f * t * t;
		return num * p1 + num2 * p2 + num3 * p3 + num4 * p4;
	}

	public static Vector3 GetNormal(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float t)
	{
		Vector3 tangent = GetTangent(p1, p2, p3, p4, t);
		Vector3 vector = 6f * (1f - t) * p1 - (6f * (1f - t) + (6f - 12f * t)) * p2 + (6f - 12f * t - 6f * t) * p3 + 6f * t * p4;
		Vector3 normalized = tangent.normalized;
		Vector3 normalized2 = (normalized + vector).normalized;
		return Vector3.Cross(Vector3.Cross(normalized, normalized2), normalized).normalized;
	}

	public static PipeRenderer.OrientedPoint[] GenerateShape(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, int subdivisions)
	{
		List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>();
		float num = 1f / (float)subdivisions;
		float num2 = 0f;
		Vector3 vector = Vector3.zero;
		for (int i = 0; i <= subdivisions; i++)
		{
			float t = (float)i * num;
			Vector3 point = GetPoint(p0, p1, p2, p3, t);
			Vector3 tangent = GetTangent(p0, p1, p2, p3, t);
			Vector3 normal = GetNormal(p0, p1, p2, p3, t);
			if (i > 0)
			{
				num2 += (point - vector).magnitude;
			}
			Quaternion identity = Quaternion.identity;
			identity = Quaternion.LookRotation(tangent, normal);
			PipeRenderer.OrientedPoint item = new PipeRenderer.OrientedPoint
			{
				position = point,
				tangent = tangent,
				normal = normal,
				rotation = identity,
				rotationalAxisVector = Vector3.forward,
				uv = Vector2.one * num2
			};
			list.Add(item);
			vector = point;
		}
		PipeRenderer.OrientedPoint[] result = list.ToArray();
		PipeHelperFunctions.RecalculateNormals(ref result);
		return result;
	}

	public override PipeRenderer.OrientedPoint[] GenerateShape()
	{
		List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>();
		float num = 1f / (float)subdivisions;
		Vector3 p = points[0];
		Vector3 p2 = points[1];
		Vector3 p3 = points[2];
		Vector3 p4 = points[3];
		float num2 = 0f;
		Vector3 vector = Vector3.zero;
		for (int i = 0; i <= subdivisions; i++)
		{
			float t = (float)i * num;
			Vector3 point = GetPoint(p, p2, p3, p4, t);
			Vector3 tangent = GetTangent(p, p2, p3, p4, t);
			Vector3 normal = GetNormal(p, p2, p3, p4, t);
			if (i > 0)
			{
				num2 += (point - vector).magnitude;
			}
			Quaternion identity = Quaternion.identity;
			identity = Quaternion.LookRotation(tangent, normal);
			PipeRenderer.OrientedPoint item = new PipeRenderer.OrientedPoint
			{
				position = point,
				tangent = tangent,
				normal = normal,
				rotation = identity,
				rotationalAxisVector = Vector3.forward,
				uv = Vector2.one * num2
			};
			list.Add(item);
			vector = point;
		}
		PipeRenderer.OrientedPoint[] result = list.ToArray();
		PipeHelperFunctions.RecalculateNormals(ref result);
		return result;
	}

	private void OnDrawGizmosSelected()
	{
		if (drawGizmos)
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			for (int i = 0; i < points.Length; i++)
			{
				Gizmos.DrawWireCube(localToWorldMatrix.MultiplyPoint(points[i]), Vector3.one * 0.1f);
			}
			float num = 1f / (float)subdivisions;
			for (int j = 0; j < subdivisions; j++)
			{
				Vector3 point = GetPoint(points[0], points[1], points[2], points[3], num * (float)j);
				Vector3 point2 = GetPoint(points[0], points[1], points[2], points[3], num * (float)(j + 1));
				point = localToWorldMatrix.MultiplyPoint(point);
				point2 = localToWorldMatrix.MultiplyPoint(point2);
				Gizmos.DrawLine(point, point2);
				Vector3 tangent = GetTangent(points[0], points[1], points[2], points[3], num * (float)j);
				tangent = localToWorldMatrix.MultiplyVector(tangent);
				Vector3 to = point + tangent * 0.1f;
				Gizmos.DrawLine(point, to);
			}
		}
	}
}
public class MultipleBezierShape : ShapeProvider
{
	public Vector3[] points;

	public int subdivisions = 16;

	public bool lockedHandles;

	public float rotationOffset;

	public float twist;

	public bool edit;

	public override PipeRenderer.OrientedPoint[] GenerateShape()
	{
		List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>();
		for (int i = 0; i < points.Length / 4; i++)
		{
			Vector3 p = points[i * 4];
			Vector3 p2 = points[i * 4 + 1];
			Vector3 p3 = points[i * 4 + 2];
			Vector3 p4 = points[i * 4 + 3];
			PipeRenderer.OrientedPoint[] collection = BezierSpline.GenerateShape(p, p2, p3, p4, subdivisions);
			if (list.Count > 0)
			{
				list.RemoveAt(list.Count - 1);
			}
			list.AddRange(collection);
		}
		PipeRenderer.OrientedPoint[] result = list.ToArray();
		PipeHelperFunctions.RecalculateNormals(ref result);
		PipeHelperFunctions.RecalculateUvs(ref result);
		PipeHelperFunctions.RotatePoints(ref result, rotationOffset, twist);
		return result;
	}
}
public class PipeHelperFunctions
{
	public static void RecalculateNormals(ref PipeRenderer.OrientedPoint[] points)
	{
		for (int i = 0; i < points.Length - 1; i++)
		{
			PipeRenderer.OrientedPoint orientedPoint = points[i];
			PipeRenderer.OrientedPoint orientedPoint2 = points[i + 1];
			Vector3 vector = orientedPoint2.position - orientedPoint.position;
			float num = Vector3.Dot(vector, vector);
			Vector3 vector2 = orientedPoint.rotationalAxisVector - vector * 2f / num * Vector3.Dot(vector, orientedPoint.rotationalAxisVector);
			Vector3 vector3 = orientedPoint.tangent - vector * 2f / num * Vector3.Dot(vector, orientedPoint.tangent);
			Vector3 vector4 = orientedPoint2.tangent - vector3;
			float num2 = Vector3.Dot(vector4, vector4);
			orientedPoint2.rotationalAxisVector = vector2 - vector4 * 2f / num2 * Vector3.Dot(vector4, vector2);
			orientedPoint2.normal = Vector3.Cross(orientedPoint2.rotationalAxisVector, orientedPoint2.tangent);
			orientedPoint2.rotation = Quaternion.LookRotation(orientedPoint2.tangent, orientedPoint2.rotationalAxisVector);
			if (i == 0)
			{
				orientedPoint.rotation = Quaternion.LookRotation(orientedPoint.tangent, orientedPoint.rotationalAxisVector);
			}
			points[i] = orientedPoint;
			points[i + 1] = orientedPoint2;
		}
	}

	public static void RecalculateUvs(ref PipeRenderer.OrientedPoint[] points, float factor = 1f, float offset = 0f)
	{
		float num = 0f;
		for (int i = 0; i < points.Length; i++)
		{
			if (i > 0)
			{
				num += (points[i].position - points[i - 1].position).magnitude;
			}
			points[i].uv = Vector3.one * (num * factor + offset);
		}
	}

	public static void RotatePoints(ref PipeRenderer.OrientedPoint[] points, float offset, float step)
	{
		for (int i = 0; i < points.Length; i++)
		{
			PipeRenderer.OrientedPoint orientedPoint = points[i];
			Vector3 tangent = orientedPoint.tangent;
			Vector3 rotationalAxisVector = orientedPoint.rotationalAxisVector;
			points[i].rotationalAxisVector = Quaternion.AngleAxis(offset + step * (float)i, tangent) * rotationalAxisVector;
			points[i].rotation = Quaternion.LookRotation(tangent, points[i].rotationalAxisVector);
		}
	}

	public static PipeRenderer.OrientedPoint[] RemoveDuplicates(PipeRenderer.OrientedPoint[] points, float threshold = 0.0001f)
	{
		List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>(points);
		for (int i = 0; i < list.Count - 1; i++)
		{
			PipeRenderer.OrientedPoint orientedPoint = list[i];
			PipeRenderer.OrientedPoint orientedPoint2 = list[i + 1];
			if ((orientedPoint2.position - orientedPoint.position).magnitude < threshold)
			{
				list.RemoveAt(i);
				if (i == list.Count - 1)
				{
					_ = list[i - 1];
					orientedPoint2.rotation = Quaternion.LookRotation(orientedPoint2.tangent, Vector3.up);
				}
			}
		}
		return list.ToArray();
	}

	public static Vector2[] GenerateUV2(PipeRenderer.OrientedPoint[] points)
	{
		float num = Mathf.Sqrt(GetTotalLength(points));
		Vector2[] array = new Vector2[points.Length];
		float num2 = 0f;
		int num3 = 0;
		for (int i = 0; i < points.Length; i++)
		{
			PipeRenderer.OrientedPoint orientedPoint = points[i];
			if (i > 0)
			{
				PipeRenderer.OrientedPoint orientedPoint2 = points[i - 1];
				num2 += (orientedPoint2.position - orientedPoint.position).magnitude;
			}
			if (num2 > num)
			{
				num2 -= num;
				num3++;
			}
			array[i] = new Vector2(num3, num2);
		}
		return array;
	}

	public static float GetTotalLength(PipeRenderer.OrientedPoint[] points)
	{
		float num = 0f;
		for (int i = 1; i < points.Length; i++)
		{
			PipeRenderer.OrientedPoint orientedPoint = points[i - 1];
			num += (points[i].position - orientedPoint.position).magnitude;
		}
		return num;
	}
}
public class UVCylinder : MonoBehaviour
{
	public float radius = 1f;

	public float height = 2f;

	public int subdivision = 16;

	private Mesh mesh;

	private void Generate()
	{
		if (mesh == null)
		{
			mesh = new Mesh();
		}
		mesh.Clear();
		new List<Vector3>();
		new List<Vector2>();
		new List<Vector3>();
		new List<int>();
		for (int i = 0; i < subdivision; i++)
		{
		}
	}
}
public class Points : MonoBehaviour
{
	public List<Vector3> points;

	[HideInInspector]
	public int lastSelectedPointIndex = -1;

	public bool worldSpace = true;

	public bool syncToSelectedPoint;

	public void SetYtoZero()
	{
		for (int i = 0; i < points.Count; i++)
		{
			points[i] = new Vector3(points[i].x, 0f, points[i].z);
		}
	}

	public void RemoveAllPoints()
	{
		points = new List<Vector3>();
	}

	public List<Vector3> GetRandomPoints(int count)
	{
		List<Vector3> list = new List<Vector3>();
		list.AddRange(points);
		List<Vector3> list2 = new List<Vector3>();
		while (list2.Count < count && list.Count > 0)
		{
			int index = UnityEngine.Random.Range(0, list.Count);
			Vector3 item = PointToWorld(list[index]);
			list2.Add(item);
			list.RemoveAt(index);
		}
		return list2;
	}

	public Vector3 GetRandomPoint()
	{
		int index = UnityEngine.Random.Range(0, points.Count);
		return GetPoint(index);
	}

	public Vector3 GetPoint(int index)
	{
		if (index >= points.Count)
		{
			return Vector3.zero;
		}
		Vector3 point = points[index];
		return PointToWorld(point);
	}

	private Vector3 PointToWorld(Vector3 point)
	{
		if (!worldSpace)
		{
			point = base.transform.TransformPoint(point);
		}
		return point;
	}

	public void SendPointsChangedMessage()
	{
		GetComponent<IOnPointsChanged>()?.OnPointsChanged();
	}
}
public interface IOnPointsChanged
{
	void OnPointsChanged();
}
[RequireComponent(typeof(Points))]
[ExecuteInEditMode]
public class PrefabLineGenrator : MonoBehaviour, IOnPointsChanged
{
	[Serializable]
	public struct SapwnInfo
	{
		public List<PrefabPair> prefabs;

		public float rotateOffset;

		[Range(0f, 1f)]
		public float flatten;

		public Vector3 posOffset;

		public GameObject GetRandomPrefab()
		{
			if (prefabs.Count < 1)
			{
				return null;
			}
			float num = 0f;
			for (int i = 0; i < prefabs.Count; i++)
			{
				num += prefabs[i].weight;
			}
			float num2 = UnityEngine.Random.Range(0f, num);
			for (int j = 0; j < prefabs.Count; j++)
			{
				if (num2 <= prefabs[j].weight)
				{
					return prefabs[j].prefab;
				}
				num2 -= prefabs[j].weight;
			}
			return prefabs[prefabs.Count - 1].prefab;
		}
	}

	[Serializable]
	public struct PrefabPair
	{
		public GameObject prefab;

		public float weight;
	}

	[SerializeField]
	private float prefabLength = 2f;

	public SapwnInfo spawnPrefab;

	public SapwnInfo startPrefab;

	public SapwnInfo endPrefab;

	[SerializeField]
	private Points points;

	[SerializeField]
	[HideInInspector]
	private List<BoxCollider> colliderObjects;

	[SerializeField]
	private float updateTick = 0.5f;

	private float lastModifyTime;

	private bool dirty;

	public List<Vector3> searchedPointsLocalSpace;

	private List<Vector3> originPoints => points.points;

	public void OnPointsChanged()
	{
	}
}
public class ScalableMesh : MonoBehaviour
{
}
public class SetActiveOnAwake : MonoBehaviour
{
	public GameObject target;

	private void Awake()
	{
		target.SetActive(value: true);
	}
}
public class ToggleHUD : MonoBehaviour
{
	public List<GameObject> toggleTargets;

	private void Awake()
	{
		foreach (GameObject toggleTarget in toggleTargets)
		{
			if (toggleTarget != null && !toggleTarget.activeInHierarchy)
			{
				toggleTarget.SetActive(value: true);
			}
		}
	}
}
[CreateAssetMenu(menuName = "Duckov/Stock Shop Database")]
public class StockShopDatabase : ScriptableObject
{
	[Serializable]
	public class MerchantProfile
	{
		public string merchantID;

		public List<ItemEntry> entries = new List<ItemEntry>();
	}

	[Serializable]
	public class ItemEntry
	{
		[ItemTypeID]
		public int typeID;

		public int maxStock;

		public bool forceUnlock;

		public float priceFactor;

		public float possibility;

		public bool lockInDemo;
	}

	public List<MerchantProfile> merchantProfiles;

	public static StockShopDatabase Instance => GameplayDataSettings.StockshopDatabase;

	public MerchantProfile GetMerchantProfile(string merchantID)
	{
		return merchantProfiles.Find((MerchantProfile e) => e.merchantID == merchantID);
	}
}
public class CanvasScalerController : MonoBehaviour
{
	[SerializeField]
	private CanvasScaler canvasScaler;

	private Vector2Int cachedResolution;

	private void OnValidate()
	{
		if (canvasScaler == null)
		{
			canvasScaler = GetComponent<CanvasScaler>();
		}
	}

	private void Awake()
	{
		OnValidate();
	}

	private void OnEnable()
	{
		Refresh();
	}

	private void Refresh()
	{
		if (!(canvasScaler == null))
		{
			Vector2Int currentResolution = GetCurrentResolution();
			float num = (float)currentResolution.x / (float)currentResolution.y;
			Vector2 referenceResolution = canvasScaler.referenceResolution;
			float num2 = referenceResolution.x / referenceResolution.y;
			if (num > num2)
			{
				canvasScaler.matchWidthOrHeight = 1f;
			}
			else
			{
				canvasScaler.matchWidthOrHeight = 0f;
			}
			cachedResolution = currentResolution;
		}
	}

	private void FixedUpdate()
	{
		if (!ResolutionMatch())
		{
			Refresh();
		}
	}

	private bool ResolutionMatch()
	{
		Vector2Int currentResolution = GetCurrentResolution();
		if (cachedResolution.x == currentResolution.x)
		{
			return cachedResolution.y == currentResolution.y;
		}
		return false;
	}

	private Vector2Int GetCurrentResolution()
	{
		return new Vector2Int(Display.main.renderingWidth, Display.main.renderingHeight);
	}
}
public class UIPanel : MonoBehaviour
{
	[SerializeField]
	protected FadeGroup fadeGroup;

	[SerializeField]
	private bool hideWhenChildActive;

	private UIPanel parent;

	private UIPanel activeChild;

	protected virtual void OnOpen()
	{
	}

	protected virtual void OnClose()
	{
	}

	protected virtual void OnChildOpened(UIPanel child)
	{
	}

	protected virtual void OnChildClosed(UIPanel child)
	{
	}

	internal void Open(UIPanel parent = null, bool controlFadeGroup = true)
	{
		this.parent = parent;
		OnOpen();
		if (controlFadeGroup)
		{
			fadeGroup?.Show();
		}
	}

	public void Close()
	{
		if (activeChild != null)
		{
			activeChild.Close();
		}
		OnClose();
		parent?.NotifyChildClosed(this);
		fadeGroup?.Hide();
	}

	public void OpenChild(UIPanel childPanel)
	{
		if (!(childPanel == null))
		{
			if (activeChild != null)
			{
				activeChild.Close();
			}
			activeChild = childPanel;
			childPanel.Open(this);
			OnChildOpened(childPanel);
			if (hideWhenChildActive)
			{
				fadeGroup?.Hide();
			}
		}
	}

	private void NotifyChildClosed(UIPanel child)
	{
		OnChildClosed(child);
		if (hideWhenChildActive)
		{
			fadeGroup?.Show();
		}
	}
}
public class UIPanelButton_OpenChildPanel : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private UIPanel master;

	[SerializeField]
	private UIPanel target;

	private void Awake()
	{
		if (master == null)
		{
			master = GetComponentInParent<UIPanel>();
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		master?.OpenChild(target);
		eventData.Use();
	}
}
public class ItemPropertiesDisplay : MonoBehaviour
{
	[SerializeField]
	private LabelAndValue entryTemplate;

	private PrefabPool<LabelAndValue> _entryPool;

	private PrefabPool<LabelAndValue> EntryPool
	{
		get
		{
			if (_entryPool == null)
			{
				_entryPool = new PrefabPool<LabelAndValue>(entryTemplate);
			}
			return _entryPool;
		}
	}

	private void Awake()
	{
		entryTemplate.gameObject.SetActive(value: false);
	}

	internal void Setup(Item targetItem)
	{
		EntryPool.ReleaseAll();
		if (targetItem == null)
		{
			return;
		}
		foreach (var item in targetItem.GetPropertyValueTextPair())
		{
			EntryPool.Get().Setup(item.name, item.value, item.polarity);
		}
	}
}
public class LabelAndValue : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI labelText;

	[SerializeField]
	private TextMeshProUGUI valueText;

	[SerializeField]
	private Color colorNeutral;

	[SerializeField]
	private Color colorPositive;

	[SerializeField]
	private Color colorNegative;

	public void Setup(string label, string value, Polarity valuePolarity)
	{
		labelText.text = label;
		valueText.text = value;
		Color color = colorNeutral;
		switch (valuePolarity)
		{
		case Polarity.Neutral:
			color = colorNeutral;
			break;
		case Polarity.Negative:
			color = colorNegative;
			break;
		case Polarity.Positive:
			color = colorPositive;
			break;
		}
		valueText.color = color;
	}
}
public class LongPressButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IPointerExitHandler
{
	[SerializeField]
	private UnityEngine.UI.Image fill;

	[SerializeField]
	private float pressTime = 1f;

	public UnityEvent onPressStarted;

	public UnityEvent onPressCanceled;

	public UnityEvent onPressFullfilled;

	private float timeWhenPressStarted;

	private bool pressed;

	private float TimeSincePressStarted => Time.unscaledTime - timeWhenPressStarted;

	private float Progress
	{
		get
		{
			if (!pressed)
			{
				return 0f;
			}
			return TimeSincePressStarted / pressTime;
		}
	}

	private void Update()
	{
		fill.fillAmount = Progress;
		if (pressed && Progress >= 1f)
		{
			onPressFullfilled?.Invoke();
			pressed = false;
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		pressed = true;
		timeWhenPressStarted = Time.unscaledTime;
		onPressStarted?.Invoke();
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		if (pressed)
		{
			pressed = false;
			onPressCanceled?.Invoke();
		}
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (pressed)
		{
			pressed = false;
			onPressCanceled?.Invoke();
		}
	}
}
public class CostDisplay : MonoBehaviour
{
	[SerializeField]
	private GameObject moneyContainer;

	[SerializeField]
	private GameObject itemsContainer;

	[SerializeField]
	private UnityEngine.UI.Image background;

	[SerializeField]
	private UnityEngine.UI.Image moneyBackground;

	[SerializeField]
	private TextMeshProUGUI money;

	[SerializeField]
	private ItemAmountDisplay itemAmountTemplate;

	[SerializeField]
	private Color normalColor;

	[SerializeField]
	private Color enoughColor;

	[SerializeField]
	private Color money_normalColor;

	[SerializeField]
	private Color money_enoughColor;

	private PrefabPool<ItemAmountDisplay> _itemPool;

	private Cost cost;

	private PrefabPool<ItemAmountDisplay> ItemPool
	{
		get
		{
			if (_itemPool == null)
			{
				_itemPool = new PrefabPool<ItemAmountDisplay>(itemAmountTemplate);
			}
			return _itemPool;
		}
	}

	private void OnEnable()
	{
		EconomyManager.OnMoneyChanged += OnMoneyChanged;
		ItemUtilities.OnPlayerItemOperation += OnItemOperation;
		LevelManager.OnLevelInitialized += OnLevelInitialized;
	}

	private void OnDisable()
	{
		EconomyManager.OnMoneyChanged -= OnMoneyChanged;
		ItemUtilities.OnPlayerItemOperation -= OnItemOperation;
		LevelManager.OnLevelInitialized -= OnLevelInitialized;
	}

	private void OnLevelInitialized()
	{
		RefreshBackground();
	}

	private void OnItemOperation()
	{
		RefreshBackground();
	}

	private void RefreshBackground()
	{
		if (!(background == null))
		{
			background.color = (cost.Enough ? enoughColor : normalColor);
		}
	}

	private void OnMoneyChanged(long arg1, long arg2)
	{
		RefreshMoneyBackground();
		RefreshBackground();
	}

	public void Setup(Cost cost, int multiplier = 1)
	{
		this.cost = cost;
		moneyContainer.SetActive(cost.money > 0);
		money.text = (cost.money * multiplier).ToString("n0");
		itemsContainer.SetActive(cost.items != null && cost.items.Length != 0);
		ItemPool.ReleaseAll();
		if (cost.items != null)
		{
			Cost.ItemEntry[] items = cost.items;
			for (int i = 0; i < items.Length; i++)
			{
				Cost.ItemEntry itemEntry = items[i];
				ItemAmountDisplay itemAmountDisplay = ItemPool.Get();
				itemAmountDisplay.Setup(itemEntry.id, itemEntry.amount * multiplier);
				itemAmountDisplay.transform.SetAsLastSibling();
			}
		}
		RefreshMoneyBackground();
		RefreshBackground();
	}

	private void RefreshMoneyBackground()
	{
		bool flag = cost.money <= EconomyManager.Money;
		moneyBackground.color = (flag ? money_enoughColor : money_normalColor);
	}

	internal void Clear()
	{
		cost = default(Cost);
		moneyContainer.SetActive(value: false);
		ItemPool.ReleaseAll();
	}
}
public class ItemAmountDisplay : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IItemMetaDataProvider
{
	[SerializeField]
	private UnityEngine.UI.Image background;

	[SerializeField]
	private UnityEngine.UI.Image icon;

	[SerializeField]
	private TextMeshProUGUI amountText;

	[SerializeField]
	private string amountFormat = "( {possess} / {amount} )";

	[SerializeField]
	private Color normalColor;

	[SerializeField]
	private Color enoughColor;

	private int typeID;

	private long amount;

	private ItemMetaData metaData;

	public int TypeID => typeID;

	public ItemMetaData MetaData => metaData;

	public static event Action<ItemAmountDisplay> OnMouseEnter;

	public static event Action<ItemAmountDisplay> OnMouseExit;

	public ItemMetaData GetMetaData()
	{
		return metaData;
	}

	private void Awake()
	{
		ItemUtilities.OnPlayerItemOperation += Refresh;
		LevelManager.OnLevelInitialized += Refresh;
	}

	private void OnDestroy()
	{
		ItemUtilities.OnPlayerItemOperation -= Refresh;
		LevelManager.OnLevelInitialized -= Refresh;
	}

	public void Setup(int itemTypeID, long amount)
	{
		typeID = itemTypeID;
		this.amount = amount;
		Refresh();
	}

	private void Refresh()
	{
		int itemCount = ItemUtilities.GetItemCount(typeID);
		metaData = ItemAssetsCollection.GetMetaData(typeID);
		icon.sprite = metaData.icon;
		amountText.text = amountFormat.Format(new
		{
			amount = amount,
			possess = itemCount
		});
		bool flag = itemCount >= amount;
		background.color = (flag ? enoughColor : normalColor);
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		ItemAmountDisplay.OnMouseEnter?.Invoke(this);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		ItemAmountDisplay.OnMouseExit?.Invoke(this);
	}
}
public class ReselectButton : MonoBehaviour
{
	[SerializeField]
	private GameObject setActiveGroup;

	[SerializeField]
	private UnityEngine.UI.Button button;

	[SerializeField]
	[SceneID]
	private string prepareSceneID = "Prepare";

	private void Awake()
	{
		button.onClick.AddListener(OnButtonClicked);
	}

	private void OnEnable()
	{
		setActiveGroup.SetActive((bool)LevelManager.Instance && LevelManager.Instance.IsBaseLevel);
	}

	private void OnDisable()
	{
	}

	private void OnButtonClicked()
	{
		SceneLoader.Instance.LoadScene(prepareSceneID).Forget();
		if ((bool)PauseMenu.Instance && PauseMenu.Instance.Shown)
		{
			PauseMenu.Hide();
		}
	}
}
public class RuleIndexDisplay : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI text;

	private void Awake()
	{
		LocalizationManager.OnSetLanguage += OnLanguageChanged;
	}

	private void OnDestroy()
	{
		LocalizationManager.OnSetLanguage -= OnLanguageChanged;
	}

	private void OnLanguageChanged(SystemLanguage language)
	{
		Refresh();
	}

	private void OnEnable()
	{
		Refresh();
	}

	private void Refresh()
	{
		text.text = $"Rule_{GameRulesManager.SelectedRuleIndex}".ToPlainText();
	}
}
public class DragHandler : MonoBehaviour, IDragHandler, IEventSystemHandler
{
	public UnityEvent<PointerEventData> onDrag;

	public void OnDrag(PointerEventData eventData)
	{
		onDrag?.Invoke(eventData);
	}
}
public interface ISingleSelectionMenu<EntryType> where EntryType : class
{
	EntryType GetSelection();

	bool SetSelection(EntryType selection);
}
public interface IItemDragSource : IBeginDragHandler, IEventSystemHandler, IEndDragHandler, IDragHandler
{
	static event Action<Item> OnStartDragItem;

	static event Action<Item> OnEndDragItem;

	bool IsEditable();

	Item GetItem();

	void IBeginDragHandler.OnBeginDrag(PointerEventData eventData)
	{
		if (IsEditable() && eventData.button == PointerEventData.InputButton.Left)
		{
			Item item = GetItem();
			IItemDragSource.OnStartDragItem?.Invoke(item);
			if (!(item == null))
			{
				ItemUIUtilities.NotifyPutItem(item, pickup: true);
			}
		}
	}

	void IEndDragHandler.OnEndDrag(PointerEventData eventData)
	{
		if (eventData.button == PointerEventData.InputButton.Left)
		{
			Item item = GetItem();
			IItemDragSource.OnEndDragItem?.Invoke(item);
		}
	}
}
public class ItemDraggingPointerDisplay : MonoBehaviour
{
	[SerializeField]
	private RectTransform rectTransform;

	[SerializeField]
	private RectTransform parentRectTransform;

	[SerializeField]
	private ItemDisplay display;

	private Item target;

	private void Awake()
	{
		rectTransform = base.transform as RectTransform;
		parentRectTransform = base.transform.parent as RectTransform;
		IItemDragSource.OnStartDragItem += OnStartDragItem;
		IItemDragSource.OnEndDragItem += OnEndDragItem;
		base.gameObject.SetActive(value: false);
	}

	private void OnDestroy()
	{
		IItemDragSource.OnStartDragItem -= OnStartDragItem;
		IItemDragSource.OnEndDragItem -= OnEndDragItem;
	}

	private void Update()
	{
		RefreshPosition();
		if (Mouse.current.leftButton.wasReleasedThisFrame)
		{
			OnEndDragItem(null);
		}
	}

	private void RefreshPosition()
	{
		RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform.parent as RectTransform, UnityEngine.InputSystem.Pointer.current.position.value, null, out var localPoint);
		rectTransform.localPosition = localPoint;
	}

	private void OnStartDragItem(Item item)
	{
		target = item;
		if (!(target == null))
		{
			display.Setup(target);
			RefreshPosition();
			base.gameObject.SetActive(value: true);
		}
	}

	private void OnEndDragItem(Item item)
	{
		target = null;
		base.gameObject.SetActive(value: false);
	}
}
public class ItemPickerDebug : MonoBehaviour
{
	public void PickPlayerInventoryAndLog()
	{
		Pick().Forget();
	}

	private async UniTask Pick()
	{
		Item item = await ItemPicker.Pick((LevelManager.Instance?.MainCharacter?.CharacterItem?.Inventory).AsReadOnlyList());
		if (item == null)
		{
			UnityEngine.Debug.Log("Nothing is selected");
		}
		else
		{
			UnityEngine.Debug.Log(item.DisplayName);
		}
	}
}
public class LevelInitializingIndicator : MonoBehaviour
{
	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private TextMeshProUGUI levelInitializationCommentText;

	private void Awake()
	{
		SceneLoader.onBeforeSetSceneActive += SceneLoader_onBeforeSetSceneActive;
		SceneLoader.onAfterSceneInitialize += SceneLoader_onAfterSceneInitialize;
		LevelManager.OnLevelInitializingCommentChanged += OnCommentChanged;
		SceneLoader.OnSetLoadingComment += OnSetLoadingComment;
		fadeGroup.SkipHide();
	}

	private void OnSetLoadingComment(string comment)
	{
		levelInitializationCommentText.text = SceneLoader.LoadingComment;
	}

	private void OnCommentChanged(string comment)
	{
		levelInitializationCommentText.text = SceneLoader.LoadingComment;
	}

	private void OnDestroy()
	{
		SceneLoader.onBeforeSetSceneActive -= SceneLoader_onBeforeSetSceneActive;
		SceneLoader.onAfterSceneInitialize -= SceneLoader_onAfterSceneInitialize;
		LevelManager.OnLevelInitializingCommentChanged -= OnCommentChanged;
		SceneLoader.OnSetLoadingComment -= OnSetLoadingComment;
	}

	private void SceneLoader_onBeforeSetSceneActive(SceneLoadingContext obj)
	{
		fadeGroup.Show();
		levelInitializationCommentText.text = LevelManager.LevelInitializingComment;
	}

	private void SceneLoader_onAfterSceneInitialize(SceneLoadingContext obj)
	{
		fadeGroup.Hide();
	}
}
public class AddToWishListButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	private const string url = "https://store.steampowered.com/app/3167020/";

	private const string CNUrl = "https://game.bilibili.com/duckov/";

	private const string ENUrl = "https://www.duckov.com";

	private const uint appid = 3167020u;

	public void OnPointerClick(PointerEventData eventData)
	{
		if (eventData.button == PointerEventData.InputButton.Left)
		{
			ShowPage();
		}
	}

	public static void ShowPage()
	{
		if (SteamManager.Initialized)
		{
			SteamFriends.ActivateGameOverlayToStore(new AppId_t(3167020u), EOverlayToStoreFlag.k_EOverlayToStoreFlag_None);
		}
		else if (GameMetaData.Instance.Platform == Duckov.Platform.Steam)
		{
			Application.OpenURL("https://store.steampowered.com/app/3167020/");
		}
		else if (LocalizationManager.CurrentLanguage == SystemLanguage.ChineseSimplified)
		{
			Application.OpenURL("https://game.bilibili.com/duckov/");
		}
		else
		{
			Application.OpenURL("https://www.duckov.com");
		}
	}

	private void Start()
	{
		if (!SteamManager.Initialized)
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class CopyTextOnClick : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private string content => System.IO.Path.Combine(Application.persistentDataPath, "Saves");

	public void OnPointerClick(PointerEventData eventData)
	{
		GUIUtility.systemCopyBuffer = content;
	}
}
public class DeleteSaveDataButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
{
	[SerializeField]
	private float totalTime = 3f;

	[SerializeField]
	private UnityEngine.UI.Image barFill;

	[SerializeField]
	private FadeGroup saveDeletedNotifierFadeGroup;

	private float timeWhenStartedHolding = float.MaxValue;

	private bool holding;

	private float TimeSinceStartedHolding => Time.unscaledTime - timeWhenStartedHolding;

	private float T
	{
		get
		{
			if (totalTime <= 0f)
			{
				return 1f;
			}
			return Mathf.Clamp01(TimeSinceStartedHolding / totalTime);
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		holding = true;
		timeWhenStartedHolding = Time.unscaledTime;
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		holding = false;
		timeWhenStartedHolding = float.MaxValue;
		RefreshProgressBar();
	}

	private void Start()
	{
		barFill.fillAmount = 0f;
	}

	private void Update()
	{
		if (holding)
		{
			RefreshProgressBar();
			if (T >= 1f)
			{
				Execute();
			}
		}
	}

	private void Execute()
	{
		holding = false;
		DeleteCurrentSaveData();
		RefreshProgressBar();
		NotifySaveDeleted().Forget();
	}

	private async UniTask NotifySaveDeleted()
	{
		await saveDeletedNotifierFadeGroup.ShowAndReturnTask();
		await UniTask.WaitForSeconds(2);
		await saveDeletedNotifierFadeGroup.HideAndReturnTask();
	}

	private void DeleteCurrentSaveData()
	{
		SavesSystem.DeleteCurrentSave();
	}

	private void RefreshProgressBar()
	{
		barFill.fillAmount = T;
	}
}
public class FadeGroupButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private FadeGroup closeOnClick;

	[SerializeField]
	private FadeGroup openOnClick;

	[SerializeField]
	private bool triggerWhenCancel;

	private void OnEnable()
	{
		UIInputManager.OnCancel += OnCancel;
	}

	private void OnDisable()
	{
		UIInputManager.OnCancel -= OnCancel;
	}

	private void OnCancel(UIInputEventData data)
	{
		if (base.isActiveAndEnabled && !data.Used && triggerWhenCancel)
		{
			Execute();
			data.Use();
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		Execute();
	}

	private void Execute()
	{
		if ((bool)closeOnClick)
		{
			closeOnClick.Hide();
		}
		if ((bool)openOnClick)
		{
			openOnClick.Show();
		}
	}
}
public class MainMenu : MonoBehaviour
{
	public static Action OnMainMenuAwake;

	public static Action OnMainMenuDestroy;

	private void Awake()
	{
		OnMainMenuAwake?.Invoke();
	}

	private void OnDestroy()
	{
		OnMainMenuDestroy?.Invoke();
	}
}
public class SavesBackupRestoreInvoker : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Button mainButton;

	[SerializeField]
	private FadeGroup menuFadeGroup;

	[SerializeField]
	private UnityEngine.UI.Button buttonSlot1;

	[SerializeField]
	private UnityEngine.UI.Button buttonSlot2;

	[SerializeField]
	private UnityEngine.UI.Button buttonSlot3;

	[SerializeField]
	private SavesBackupRestorePanel restorePanel;

	private void Awake()
	{
		mainButton.onClick.AddListener(OnMainButtonClicked);
		buttonSlot1.onClick.AddListener(delegate
		{
			OnButtonClicked(1);
		});
		buttonSlot2.onClick.AddListener(delegate
		{
			OnButtonClicked(2);
		});
		buttonSlot3.onClick.AddListener(delegate
		{
			OnButtonClicked(3);
		});
	}

	private void OnMainButtonClicked()
	{
		menuFadeGroup.Toggle();
	}

	private void OnButtonClicked(int index)
	{
		menuFadeGroup.Hide();
		SavesSystem.SetFile(index);
		restorePanel.Open(index);
	}
}
public class Title : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private PlayableDirector timelineToTitle;

	[SerializeField]
	private PlayableDirector timelineToMainMenu;

	private string sfx_PressStart = "UI/game_start";

	private void Start()
	{
		StartTask().Forget();
	}

	private async UniTask StartTask()
	{
		timelineToTitle.Play();
		await WaitForTimeline(timelineToTitle);
		fadeGroup.Show();
		timelineToTitle.gameObject.SetActive(value: false);
	}

	private async UniTask ContinueTask()
	{
		fadeGroup.Hide();
		AudioManager.Post(sfx_PressStart);
		timelineToTitle.gameObject.SetActive(value: false);
		timelineToMainMenu.gameObject.SetActive(value: true);
		timelineToMainMenu.Play();
		AudioManager.PlayBGM("mus_title");
		await WaitForTimeline(timelineToMainMenu);
		if (timelineToMainMenu != null)
		{
			timelineToMainMenu.gameObject.SetActive(value: false);
		}
	}

	private async UniTask WaitForTimeline(PlayableDirector timeline)
	{
		while (timeline != null && timeline.state == PlayState.Playing)
		{
			await UniTask.NextFrame();
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		if (fadeGroup.IsShown)
		{
			ContinueTask().Forget();
		}
	}
}
public class OnPointerClick : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public UnityEvent<PointerEventData> onPointerClick;

	void IPointerClickHandler.OnPointerClick(PointerEventData eventData)
	{
		onPointerClick?.Invoke(eventData);
	}
}
public class PauseMenu : UIPanel
{
	public static PauseMenu Instance => GameManager.PauseMenu;

	public bool Shown
	{
		get
		{
			if (fadeGroup == null)
			{
				return false;
			}
			return fadeGroup.IsShown;
		}
	}

	public static void Show()
	{
		Instance.Open();
	}

	public static void Hide()
	{
		Instance.Close();
	}

	public static void Toggle()
	{
		if (Instance.fadeGroup.IsShown)
		{
			Hide();
		}
		else
		{
			Show();
		}
	}
}
public class Button_LoadMainMenu : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Button button;

	[SerializeField]
	private ConfirmDialogue dialogue;

	private UniTask task;

	private void Awake()
	{
		button.onClick.AddListener(BeginQuitting);
		dialogue.SkipHide();
	}

	private void BeginQuitting()
	{
		if (task.Status != UniTaskStatus.Pending)
		{
			UnityEngine.Debug.Log("Quitting");
			task = QuitTask();
		}
	}

	private async UniTask QuitTask()
	{
		if (LevelManager.Instance != null && LevelManager.Instance.IsBaseLevel)
		{
			LevelManager.Instance.SaveMainCharacter();
			SavesSystem.CollectSaveData();
			SavesSystem.SaveFile();
		}
		else if (!(await dialogue.Execute()))
		{
			return;
		}
		while (SavesSystem.IsSaving)
		{
			await UniTask.Yield();
		}
		SceneLoader.LoadMainMenu();
		PauseMenu.Hide();
	}
}
public class Button_QuitGame : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Button button;

	[SerializeField]
	private ConfirmDialogue dialogue;

	private UniTask task;

	private void Awake()
	{
		button.onClick.AddListener(BeginQuitting);
		if ((bool)dialogue)
		{
			dialogue.SkipHide();
		}
	}

	private void BeginQuitting()
	{
		if (task.Status != UniTaskStatus.Pending)
		{
			UnityEngine.Debug.Log("Quitting");
			task = QuitTask();
		}
	}

	private async UniTask QuitTask()
	{
		if (LevelManager.Instance != null && LevelManager.Instance.IsBaseLevel)
		{
			LevelManager.Instance.SaveMainCharacter();
			SavesSystem.CollectSaveData();
			SavesSystem.SaveFile();
		}
		else if ((bool)dialogue && !(await dialogue.Execute()))
		{
			return;
		}
		while (SavesSystem.IsSaving)
		{
			await UniTask.Yield();
		}
		if (Application.isEditor)
		{
			UnityEngine.Debug.Log("即将调用Application.Quit()。但因为是Editor，不会真的退出。");
		}
		Application.Quit();
	}
}
public class ConfirmDialogue : MonoBehaviour
{
	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private UnityEngine.UI.Button btnConfirm;

	[SerializeField]
	private UnityEngine.UI.Button btnCancel;

	private bool canceled;

	private bool confirmed;

	private bool executing;

	private void Awake()
	{
		btnConfirm.onClick.AddListener(OnConfirmed);
		btnCancel.onClick.AddListener(OnCanceled);
	}

	private void OnCanceled()
	{
		canceled = true;
	}

	private void OnConfirmed()
	{
		confirmed = true;
	}

	public async UniTask<bool> Execute()
	{
		if (executing)
		{
			return false;
		}
		executing = true;
		bool result = await DoExecute();
		executing = false;
		return result;
	}

	private async UniTask<bool> DoExecute()
	{
		UnityEngine.Debug.Log("Executing confirm dialogue");
		await fadeGroup.ShowAndReturnTask();
		canceled = false;
		confirmed = false;
		while (!canceled && !confirmed)
		{
			await UniTask.Yield();
		}
		bool result = false;
		if (confirmed)
		{
			result = true;
		}
		fadeGroup.Hide();
		return result;
	}

	internal void SkipHide()
	{
		fadeGroup.SkipHide();
	}
}
public interface INeedInspection
{
	bool NeedInspection
	{
		get
		{
			return false;
		}
		set
		{
		}
	}
}
public class SetActiveByInputDevice : MonoBehaviour
{
	public InputManager.InputDevices activeIfDeviceIs;

	private void Awake()
	{
		OnInputDeviceChanged();
		InputManager.OnInputDeviceChanged += OnInputDeviceChanged;
	}

	private void OnDestroy()
	{
		InputManager.OnInputDeviceChanged -= OnInputDeviceChanged;
	}

	private void OnInputDeviceChanged()
	{
		if (InputManager.InputDevice == activeIfDeviceIs)
		{
			base.gameObject.SetActive(value: true);
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
	}
}
public class UIInputManager : MonoBehaviour
{
	private static bool instantiated;

	private InputAction inputActionNavigate;

	private InputAction inputActionConfirm;

	private InputAction inputActionCancel;

	private InputAction inputActionPoint;

	private InputAction inputActionMouseDelta;

	private InputAction inputActionMouseClick;

	private InputAction inputActionFastPick;

	private InputAction inputActionDropItem;

	private InputAction inputActionUseItem;

	private InputAction inputActionToggleIndicatorHUD;

	private InputAction inputActionToggleCameraMode;

	private InputAction inputActionWishlistHoveringItem;

	private InputAction inputActionNextPage;

	private InputAction inputActionPreviousPage;

	private InputAction inputActionLockInventoryIndex;

	private InputAction inputActionInteract;

	public static UIInputManager Instance => GameManager.UiInputManager;

	public static bool Ctrl
	{
		get
		{
			if (Keyboard.current == null)
			{
				return false;
			}
			return Keyboard.current.ctrlKey.isPressed;
		}
	}

	public static bool Alt
	{
		get
		{
			if (Keyboard.current == null)
			{
				return false;
			}
			return Keyboard.current.altKey.isPressed;
		}
	}

	public static bool Shift
	{
		get
		{
			if (Keyboard.current == null)
			{
				return false;
			}
			return Keyboard.current.shiftKey.isPressed;
		}
	}

	public static Vector2 Point
	{
		get
		{
			if (!Application.isPlaying)
			{
				return default(Vector2);
			}
			if (Instance == null)
			{
				return default(Vector2);
			}
			if (Instance.inputActionPoint == null)
			{
				return default(Vector2);
			}
			return Instance.inputActionPoint.ReadValue<Vector2>();
		}
	}

	public static Vector2 MouseDelta
	{
		get
		{
			if (!Application.isPlaying)
			{
				return default(Vector2);
			}
			if (Instance == null)
			{
				return default(Vector2);
			}
			if (Instance.inputActionMouseDelta == null)
			{
				return default(Vector2);
			}
			return Instance.inputActionMouseDelta.ReadValue<Vector2>();
		}
	}

	public static bool WasClickedThisFrame
	{
		get
		{
			if (!Application.isPlaying)
			{
				return false;
			}
			if (Instance == null)
			{
				return false;
			}
			if (Instance.inputActionMouseClick == null)
			{
				return false;
			}
			return Instance.inputActionMouseClick.WasPressedThisFrame();
		}
	}

	public static event Action<UIInputEventData> OnNavigate;

	public static event Action<UIInputEventData> OnConfirm;

	public static event Action<UIInputEventData> OnToggleIndicatorHUD;

	public static event Action<UIInputEventData> OnCancelEarly;

	public static event Action<UIInputEventData> OnCancel;

	public static event Action<UIInputEventData> OnFastPick;

	public static event Action<UIInputEventData> OnDropItem;

	public static event Action<UIInputEventData> OnUseItem;

	public static event Action<UIInputEventData> OnToggleCameraMode;

	public static event Action<UIInputEventData> OnWishlistHoveringItem;

	public static event Action<UIInputEventData> OnNextPage;

	public static event Action<UIInputEventData> OnPreviousPage;

	public static event Action<UIInputEventData> OnLockInventoryIndex;

	public static event Action<UIInputEventData, int> OnShortcutInput;

	public static event Action<InputAction.CallbackContext> OnInteractInputContext;

	public static Ray GetPointRay()
	{
		if (Instance == null)
		{
			return default(Ray);
		}
		GameCamera instance = GameCamera.Instance;
		if (instance == null)
		{
			return default(Ray);
		}
		return instance.renderCamera.ScreenPointToRay(Point);
	}

	private void Awake()
	{
		if (!(Instance != this))
		{
			InputActionAsset actions = GameManager.MainPlayerInput.actions;
			inputActionNavigate = actions["UI_Navigate"];
			inputActionConfirm = actions["UI_Confirm"];
			inputActionCancel = actions["UI_Cancel"];
			inputActionPoint = actions["Point"];
			inputActionFastPick = actions["Interact"];
			inputActionDropItem = actions["UI_Item_Drop"];
			inputActionUseItem = actions["UI_Item_use"];
			inputActionToggleIndicatorHUD = actions["UI_ToggleIndicatorHUD"];
			inputActionToggleCameraMode = actions["UI_ToggleCameraMode"];
			inputActionWishlistHoveringItem = actions["UI_WishlistHoveringItem"];
			inputActionNextPage = actions["UI_NextPage"];
			inputActionPreviousPage = actions["UI_PreviousPage"];
			inputActionLockInventoryIndex = actions["UI_LockInventoryIndex"];
			inputActionMouseDelta = actions["MouseDelta"];
			inputActionMouseClick = actions["Click"];
			inputActionInteract = actions["Interact"];
			Bind(inputActionNavigate, OnInputActionNavigate);
			Bind(inputActionConfirm, OnInputActionConfirm);
			Bind(inputActionCancel, OnInputActionCancel);
			Bind(inputActionFastPick, OnInputActionFastPick);
			Bind(inputActionDropItem, OnInputActionDropItem);
			Bind(inputActionUseItem, OnInputActionUseItem);
			Bind(inputActionToggleIndicatorHUD, OnInputActionToggleIndicatorHUD);
			Bind(inputActionToggleCameraMode, OnInputActionToggleCameraMode);
			Bind(inputActionWishlistHoveringItem, OnInputWishlistHoveringItem);
			Bind(inputActionNextPage, OnInputActionNextPage);
			Bind(inputActionPreviousPage, OnInputActionPrevioursPage);
			Bind(inputActionLockInventoryIndex, OnInputActionLockInventoryIndex);
			Bind(inputActionInteract, OnInputActionInteract);
		}
	}

	private void OnDestroy()
	{
		UnBind(inputActionNavigate, OnInputActionNavigate);
		UnBind(inputActionConfirm, OnInputActionConfirm);
		UnBind(inputActionCancel, OnInputActionCancel);
		UnBind(inputActionFastPick, OnInputActionFastPick);
		UnBind(inputActionUseItem, OnInputActionUseItem);
		UnBind(inputActionToggleIndicatorHUD, OnInputActionToggleIndicatorHUD);
		UnBind(inputActionToggleCameraMode, OnInputActionToggleCameraMode);
		UnBind(inputActionWishlistHoveringItem, OnInputWishlistHoveringItem);
		UnBind(inputActionNextPage, OnInputActionNextPage);
		UnBind(inputActionPreviousPage, OnInputActionPrevioursPage);
		UnBind(inputActionLockInventoryIndex, OnInputActionLockInventoryIndex);
		UnBind(inputActionInteract, OnInputActionInteract);
	}

	private void OnInputActionInteract(InputAction.CallbackContext context)
	{
		UIInputManager.OnInteractInputContext?.Invoke(context);
	}

	private void OnInputActionLockInventoryIndex(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnLockInventoryIndex?.Invoke(new UIInputEventData());
		}
	}

	private void OnInputActionNextPage(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnNextPage?.Invoke(new UIInputEventData());
		}
	}

	private void OnInputActionPrevioursPage(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnPreviousPage?.Invoke(new UIInputEventData());
		}
	}

	private void OnInputWishlistHoveringItem(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnWishlistHoveringItem?.Invoke(new UIInputEventData());
		}
	}

	private void OnInputActionToggleCameraMode(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnToggleCameraMode?.Invoke(new UIInputEventData());
		}
	}

	private void OnInputActionDropItem(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnDropItem?.Invoke(new UIInputEventData());
		}
	}

	private void OnInputActionUseItem(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnUseItem?.Invoke(new UIInputEventData());
		}
	}

	private void OnInputActionFastPick(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnFastPick?.Invoke(new UIInputEventData());
		}
	}

	private void OnInputActionCancel(InputAction.CallbackContext context)
	{
		if (!context.started)
		{
			return;
		}
		UIInputEventData uIInputEventData = new UIInputEventData
		{
			cancel = true
		};
		UIInputManager.OnCancelEarly?.Invoke(uIInputEventData);
		if (!uIInputEventData.Used)
		{
			UIInputManager.OnCancel?.Invoke(uIInputEventData);
			if (!uIInputEventData.Used && LevelManager.Instance != null && View.ActiveView == null)
			{
				PauseMenu.Toggle();
			}
		}
	}

	private void OnInputActionConfirm(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnConfirm?.Invoke(new UIInputEventData
			{
				confirm = true
			});
		}
	}

	private void OnInputActionNavigate(InputAction.CallbackContext context)
	{
		Vector2 vector = context.ReadValue<Vector2>();
		UIInputManager.OnNavigate?.Invoke(new UIInputEventData
		{
			vector = vector
		});
	}

	private void OnInputActionToggleIndicatorHUD(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			UIInputManager.OnToggleIndicatorHUD?.Invoke(new UIInputEventData());
		}
	}

	private void Bind(InputAction inputAction, Action<InputAction.CallbackContext> action)
	{
		inputAction.Enable();
		inputAction.started += action;
		inputAction.performed += action;
		inputAction.canceled += action;
	}

	private void UnBind(InputAction inputAction, Action<InputAction.CallbackContext> action)
	{
		if (inputAction != null)
		{
			inputAction.started -= action;
			inputAction.performed -= action;
			inputAction.canceled -= action;
		}
	}

	internal static void NotifyShortcutInput(int index)
	{
		UIInputManager.OnShortcutInput(new UIInputEventData
		{
			confirm = true
		}, index);
	}
}
public class UIInputEventData
{
	private bool used;

	public Vector2 vector;

	public bool confirm;

	public bool cancel;

	public bool Used => used;

	public void Use()
	{
		used = true;
	}
}
public static class RaidUtilities
{
	[Serializable]
	public struct RaidInfo
	{
		public bool valid;

		public uint ID;

		public bool dead;

		public bool ended;

		public float raidBeginTime;

		public float raidEndTime;

		public float totalTime;

		public long expOnBegan;

		public long expOnEnd;

		public long expGained;
	}

	public static Action<RaidInfo> OnNewRaid;

	public static Action<RaidInfo> OnRaidDead;

	public static Action<RaidInfo> OnRaidEnd;

	private const string SaveID = "RaidInfo";

	public static RaidInfo CurrentRaid
	{
		get
		{
			RaidInfo result = SavesSystem.Load<RaidInfo>("RaidInfo");
			result.totalTime = Time.unscaledTime - result.raidBeginTime;
			result.expOnEnd = EXPManager.EXP;
			result.expGained = result.expOnEnd - result.expOnBegan;
			return result;
		}
		private set
		{
			SavesSystem.Save("RaidInfo", value);
		}
	}

	public static void NewRaid()
	{
		RaidInfo currentRaid = CurrentRaid;
		RaidInfo obj = (CurrentRaid = new RaidInfo
		{
			valid = true,
			ID = currentRaid.ID + 1,
			dead = false,
			ended = false,
			raidBeginTime = Time.unscaledTime,
			raidEndTime = 0f,
			expOnBegan = EXPManager.EXP
		});
		OnNewRaid?.Invoke(obj);
	}

	public static void NotifyDead()
	{
		RaidInfo currentRaid = CurrentRaid;
		currentRaid.dead = true;
		currentRaid.ended = true;
		currentRaid.raidEndTime = Time.unscaledTime;
		currentRaid.totalTime = currentRaid.raidEndTime - currentRaid.raidBeginTime;
		currentRaid.expOnEnd = EXPManager.EXP;
		currentRaid.expGained = currentRaid.expOnEnd - currentRaid.expOnBegan;
		CurrentRaid = currentRaid;
		OnRaidEnd?.Invoke(currentRaid);
		OnRaidDead?.Invoke(currentRaid);
	}

	public static void NotifyEnd()
	{
		RaidInfo currentRaid = CurrentRaid;
		currentRaid.ended = true;
		currentRaid.raidEndTime = Time.unscaledTime;
		currentRaid.totalTime = currentRaid.raidEndTime - currentRaid.raidBeginTime;
		currentRaid.expOnEnd = EXPManager.EXP;
		currentRaid.expGained = currentRaid.expOnEnd - currentRaid.expOnBegan;
		CurrentRaid = currentRaid;
		OnRaidEnd?.Invoke(currentRaid);
	}
}
public class BowAnimation : MonoBehaviour
{
	public ItemAgent_Gun gunAgent;

	public Animator animator;

	private int hash_Loaded = "Loaded".GetHashCode();

	private int hash_Aiming = "Aiming".GetHashCode();

	private int hash_Shoot = "Shoot".GetHashCode();

	private void Start()
	{
		if (gunAgent != null)
		{
			gunAgent.OnShootEvent += OnShoot;
			gunAgent.OnLoadedEvent += OnLoaded;
			if (gunAgent.BulletCount > 0)
			{
				OnLoaded();
			}
		}
	}

	private void OnDestroy()
	{
		if (gunAgent != null)
		{
			gunAgent.OnShootEvent -= OnShoot;
			gunAgent.OnLoadedEvent -= OnLoaded;
		}
	}

	private void OnShoot()
	{
		animator.SetTrigger("Shoot");
		if (gunAgent.BulletCount <= 0)
		{
			animator.SetBool("Loaded", value: false);
		}
	}

	private void OnLoaded()
	{
		animator.SetBool("Loaded", value: true);
	}
}
public class BuffVFX : MonoBehaviour
{
	public Buff buff;

	public GameObject shockFxPfb;

	private GameObject shockFxInstance;

	public Vector3 offsetFromCharacter;

	private void Awake()
	{
		if (!buff)
		{
			buff = GetComponent<Buff>();
		}
		buff.OnSetupEvent.AddListener(OnSetup);
	}

	private void OnSetup()
	{
		if (shockFxInstance != null)
		{
			UnityEngine.Object.Destroy(shockFxInstance);
		}
		if ((bool)buff && (bool)buff.Character && (bool)shockFxPfb)
		{
			shockFxInstance = UnityEngine.Object.Instantiate(shockFxPfb, buff.Character.transform);
			shockFxInstance.transform.localPosition = offsetFromCharacter;
			shockFxInstance.transform.localRotation = Quaternion.identity;
		}
	}

	private void OnDestroy()
	{
		if (shockFxInstance != null)
		{
			UnityEngine.Object.Destroy(shockFxInstance);
		}
	}

	public void AutoSetup()
	{
		buff = GetComponent<Buff>();
	}
}
public class BunkerDoorVisual : MonoBehaviour
{
	[LocalizationKey("Dialogues")]
	public string welcomeText;

	[LocalizationKey("Dialogues")]
	public string leaveText;

	public Transform textBubblePoint;

	public bool inRange = true;

	public Animator animator;

	private void Awake()
	{
		animator.SetBool("InRange", inRange);
	}

	public void OnEnter()
	{
		if (!inRange)
		{
			inRange = true;
			animator.SetBool("InRange", inRange);
			PopText(welcomeText.ToPlainText(), 0.5f, inRange).Forget();
		}
	}

	public void OnExit()
	{
		if (inRange)
		{
			inRange = false;
			animator.SetBool("InRange", inRange);
			PopText(leaveText.ToPlainText(), 0f, inRange).Forget();
		}
	}

	private async UniTask PopText(string text, float delay, bool _inRange)
	{
		await UniTask.WaitForSeconds(delay);
		if (inRange == _inRange)
		{
			DialogueBubblesManager.Show(text, textBubblePoint).Forget();
		}
	}
}
public class CameraShaker : MonoBehaviour
{
	public enum CameraShakeTypes
	{
		recoil,
		explosion,
		meleeAttackHit
	}

	private static CameraShaker _instance;

	public CinemachineImpulseSource recoilSource;

	public CinemachineImpulseSource meleeAttackSource;

	public CinemachineImpulseSource explosionSource;

	private void Awake()
	{
		_instance = this;
	}

	public static void Shake(Vector3 velocity, CameraShakeTypes shakeType)
	{
		if (!(_instance == null))
		{
			switch (shakeType)
			{
			case CameraShakeTypes.recoil:
				_instance.recoilSource.GenerateImpulseWithVelocity(velocity);
				break;
			case CameraShakeTypes.explosion:
				_instance.explosionSource.GenerateImpulseWithVelocity(velocity);
				break;
			case CameraShakeTypes.meleeAttackHit:
				_instance.meleeAttackSource.GenerateImpulseWithVelocity(velocity);
				break;
			}
		}
	}
}
public class DarkRoomFade : MonoBehaviour
{
	public float maxRange = 100f;

	public float speed = 20f;

	public Renderer[] renderers;

	private Vector3 startPos;

	private float range;

	private bool started;

	public void StartFade()
	{
		started = true;
		base.enabled = true;
		startPos = CharacterMainControl.Main.transform.position;
	}

	private void Awake()
	{
		range = 0f;
		UpdateMaterial();
		if (!started)
		{
			base.enabled = false;
		}
	}

	private void Update()
	{
		if (!started)
		{
			base.enabled = false;
		}
		range += speed * Time.deltaTime;
		UpdateMaterial();
		if (range > maxRange)
		{
			base.enabled = false;
		}
	}

	private void UpdateMaterial()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetFloat("_Range", range);
		materialPropertyBlock.SetVector("_CenterPos", startPos);
		Renderer[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetPropertyBlock(materialPropertyBlock);
		}
	}

	private void Collect()
	{
		renderers = GetComponentsInChildren<Renderer>();
		Renderer[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].sharedMaterial.SetFloat("_Range", 0f);
		}
	}

	public void SetRenderers(bool enable)
	{
		Renderer[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = enable;
		}
	}

	public static void SetRenderersEnable(bool enable)
	{
		DarkRoomFade[] array = UnityEngine.Object.FindObjectsByType<DarkRoomFade>(FindObjectsSortMode.None);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetRenderers(enable);
		}
	}
}
public class DPSDisplayer : MonoBehaviour
{
	[SerializeField]
	private TextMeshPro dpsText;

	private bool empty;

	private float totalDamage;

	private float firstTimeMarker;

	private float lastTimeMarker;

	private void Awake()
	{
		Health.OnHurt += OnHurt;
	}

	private void Update()
	{
		if (Time.time - lastTimeMarker > 3f)
		{
			empty = true;
			totalDamage = 0f;
			RefreshDisplay();
		}
	}

	private void OnDestroy()
	{
		Health.OnHurt -= OnHurt;
	}

	private void OnHurt(Health health, DamageInfo dmgInfo)
	{
		if ((bool)dmgInfo.fromCharacter && dmgInfo.fromCharacter.IsMainCharacter)
		{
			totalDamage += dmgInfo.finalDamage;
			if (empty)
			{
				firstTimeMarker = Time.time;
				lastTimeMarker = Time.time;
				empty = false;
			}
			else
			{
				lastTimeMarker = Time.time;
				RefreshDisplay();
			}
		}
	}

	private void RefreshDisplay()
	{
		float num = CalculateDPS();
		dpsText.text = num.ToString("00000");
	}

	private float CalculateDPS()
	{
		if (empty)
		{
			return 0f;
		}
		float num = lastTimeMarker - firstTimeMarker;
		if (num <= 0f)
		{
			return 0f;
		}
		return totalDamage / num;
	}
}
public class DuckovHider : HiderBehavior
{
	public CharacterMainControl character;

	private float hideDelay = 0.2f;

	private bool targetHide;

	private bool mainCharacterDied;

	protected override void Awake()
	{
		base.Awake();
		LevelManager.OnMainCharacterDead += OnMainCharacterDie;
	}

	private void OnDestroy()
	{
		LevelManager.OnMainCharacterDead -= OnMainCharacterDie;
	}

	protected override void OnHide()
	{
		if ((bool)LevelManager.Instance && LevelManager.Instance.IsRaidMap && !mainCharacterDied)
		{
			targetHide = true;
			HideDelay();
		}
	}

	protected override void OnReveal()
	{
		targetHide = false;
		character.Show();
	}

	private async UniTask HideDelay()
	{
		await UniTask.WaitForSeconds(hideDelay);
		if (targetHide && character != null)
		{
			character.Hide();
		}
	}

	private void OnMainCharacterDie(DamageInfo damageInfo)
	{
		mainCharacterDied = true;
		OnReveal();
	}
}
public class FogOfWarManager : MonoBehaviour
{
	[FormerlySerializedAs("mianVis")]
	public FogOfWarRevealer3D mainVis;

	public float mianVisYOffset = 1f;

	private CharacterMainControl character;

	public FogOfWarWorld fogOfWar;

	private float viewAgnel = -1f;

	private float senseRange = -1f;

	private float viewDistance = -1f;

	private TimeOfDayController timeOfDayController;

	private bool allVision;

	private bool inited;

	private void Start()
	{
		LevelManager.OnMainCharacterDead += OnCharacterDie;
	}

	private void OnDestroy()
	{
		LevelManager.OnMainCharacterDead -= OnCharacterDie;
	}

	private void Init()
	{
		inited = true;
		if (!LevelManager.Instance.IsRaidMap || !LevelManager.Rule.FogOfWar)
		{
			allVision = true;
		}
	}

	private void Update()
	{
		if (!LevelManager.LevelInited)
		{
			return;
		}
		if (!character)
		{
			character = CharacterMainControl.Main;
			if (!character)
			{
				return;
			}
		}
		if (!inited)
		{
			Init();
		}
		if (!timeOfDayController)
		{
			timeOfDayController = LevelManager.Instance.TimeOfDayController;
			if (!timeOfDayController)
			{
				return;
			}
		}
		Vector3 position = character.transform.position + Vector3.up * mianVisYOffset;
		mainVis.transform.position = position;
		position = new Vector3(Mathf.RoundToInt(position.x), Mathf.RoundToInt(position.y), Mathf.RoundToInt(position.z));
		fogOfWar.UpdateWorldBounds(position, new Vector3(128f, 1f, 128f));
		Vector3 forward = character.GetCurrentAimPoint() - character.transform.position;
		UnityEngine.Debug.DrawLine(character.GetCurrentAimPoint(), character.GetCurrentAimPoint() + Vector3.up * 2f, Color.green, 0.2f);
		forward.y = 0f;
		forward.Normalize();
		float t = Mathf.Clamp01(character.NightVisionAbility + (character.FlashLight ? 0.3f : 0f));
		float viewAngle = character.ViewAngle;
		float num = character.SenseRange;
		float num2 = character.ViewDistance;
		viewAngle *= Mathf.Lerp(TimeOfDayController.NightViewAngleFactor, 1f, t);
		num *= Mathf.Lerp(TimeOfDayController.NightSenseRangeFactor, 1f, t);
		num2 *= Mathf.Lerp(TimeOfDayController.NightViewDistanceFactor, 1f, t);
		if (num2 < num - 2.5f)
		{
			num2 = num - 2.5f;
		}
		if (allVision)
		{
			viewAngle = 360f;
			num = 50f;
			num2 = 50f;
		}
		if (viewAngle != viewAgnel)
		{
			if (viewAgnel < 0f)
			{
				viewAgnel = viewAngle;
			}
			viewAgnel = Mathf.MoveTowards(viewAgnel, viewAngle, 120f * Time.deltaTime);
			mainVis.ViewAngle = viewAgnel;
		}
		if (num != senseRange)
		{
			if (senseRange < 0f)
			{
				senseRange = num;
			}
			senseRange = Mathf.MoveTowards(senseRange, num, 2f * Time.deltaTime);
			mainVis.UnobscuredRadius = senseRange;
		}
		if (num2 != viewDistance)
		{
			if (viewDistance < 0f)
			{
				viewDistance = num2;
			}
			viewDistance = Mathf.MoveTowards(viewDistance, num2, 30f * Time.deltaTime);
			mainVis.ViewRadius = viewDistance;
		}
		mainVis.transform.rotation = Quaternion.LookRotation(forward, Vector3.up);
	}

	private void OnCharacterDie(DamageInfo dmgInfo)
	{
		LevelManager.OnMainCharacterDead -= OnCharacterDie;
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class HandheldSprite : MonoBehaviour
{
	public DuckovItemAgent agent;

	public SpriteRenderer spriteRenderer;

	private void Start()
	{
		if ((bool)agent.Item)
		{
			spriteRenderer.sprite = agent.Item.Icon;
		}
	}
}
public class LightCookieMove : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class MainCharacterFace : MonoBehaviour
{
	public CustomFaceManager customFaceManager;

	public CustomFaceInstance customFace;

	private void Start()
	{
		CustomFaceSettingData saveData = customFaceManager.LoadMainCharacterSetting();
		customFace.LoadFromData(saveData);
	}

	private void Update()
	{
	}
}
public class MainMenuCamera : MonoBehaviour
{
	public Vector2 yawRange;

	public Vector2 pitchRange;

	public Transform pitchRoot;

	[FormerlySerializedAs("posRange")]
	public Vector2 posRangeX;

	public Vector2 posRangeY;

	private void Update()
	{
		Vector3 mousePosition = Input.mousePosition;
		float num = Screen.width;
		float num2 = Screen.height;
		float t = mousePosition.x / num;
		float t2 = mousePosition.y / num2;
		base.transform.localRotation = quaternion.Euler(0f, Mathf.Lerp(yawRange.x, yawRange.y, t) * (MathF.PI / 180f), 0f);
		if ((bool)pitchRoot)
		{
			pitchRoot.localRotation = quaternion.Euler(Mathf.Lerp(pitchRange.x, pitchRange.y, t2) * (MathF.PI / 180f), 0f, 0f);
		}
		base.transform.localPosition = new Vector3(Mathf.Lerp(posRangeX.x, posRangeX.y, t), Mathf.Lerp(posRangeY.x, posRangeY.y, t2), 0f);
	}
}
public class MiningMachineCardDisplay : MonoBehaviour
{
	public enum CardTypes
	{
		normal,
		potato
	}

	public GameObject activeVisual;

	public GameObject deactiveVisual;

	public GameObject normalGPU;

	public GameObject potatoGPU;

	public void SetVisualActive(bool active, CardTypes cardType)
	{
		activeVisual.SetActive(active);
		deactiveVisual.SetActive(!active);
		switch (cardType)
		{
		case CardTypes.normal:
			normalGPU.SetActive(value: true);
			potatoGPU.SetActive(value: false);
			break;
		case CardTypes.potato:
			normalGPU.SetActive(value: false);
			potatoGPU.SetActive(value: true);
			break;
		default:
			throw new ArgumentOutOfRangeException("cardType", cardType, null);
		}
	}
}
public class MiningMachineVisual : MonoBehaviour
{
	public List<MiningMachineCardDisplay> cardsDisplay;

	private bool inited;

	private SlotCollection slots;

	private Item minnerItem;

	private void Update()
	{
		if (!inited && (bool)BitcoinMiner.Instance && BitcoinMiner.Instance.Item != null)
		{
			inited = true;
			minnerItem = BitcoinMiner.Instance.Item;
			minnerItem.onSlotContentChanged += OnSlotContentChanged;
			slots = minnerItem.Slots;
			OnSlotContentChanged(minnerItem, null);
		}
	}

	private void OnDestroy()
	{
		if ((bool)minnerItem)
		{
			minnerItem.onSlotContentChanged -= OnSlotContentChanged;
		}
	}

	private void OnSlotContentChanged(Item minnerItem, Slot changedSlot)
	{
		for (int i = 0; i < slots.Count; i++)
		{
			if (cardsDisplay[i] == null)
			{
				continue;
			}
			Item content = slots[i].Content;
			MiningMachineCardDisplay.CardTypes cardType = MiningMachineCardDisplay.CardTypes.normal;
			if (content != null)
			{
				ItemSetting_GPU component = content.GetComponent<ItemSetting_GPU>();
				if ((bool)component)
				{
					cardType = component.cardType;
				}
			}
			cardsDisplay[i].SetVisualActive(content != null, cardType);
		}
	}
}
public class MoveRing : MonoBehaviour
{
	public Renderer ring;

	public float runThreshold;

	private Material ringMat;

	private InputManager inputManager;

	private CharacterMainControl character => inputManager.characterMainControl;

	public void SetThreshold(float threshold)
	{
		runThreshold = threshold;
	}

	public void LateUpdate()
	{
		if (!inputManager)
		{
			if (!(LevelManager.Instance == null))
			{
				inputManager = LevelManager.Instance.InputManager;
			}
			return;
		}
		if (!character)
		{
			SetMove(Vector3.zero, 0f);
			return;
		}
		base.transform.position = character.transform.position + Vector3.up * 0.02f;
		SetThreshold(inputManager.runThreshold);
		SetMove(inputManager.WorldMoveInput.normalized, inputManager.WorldMoveInput.magnitude);
		SetRunning(character.Running);
		if (ring.enabled != character.gameObject.activeInHierarchy)
		{
			ring.enabled = character.gameObject.activeInHierarchy;
		}
	}

	public void SetMove(Vector3 direction, float value)
	{
		if (!ringMat)
		{
			if ((bool)ring)
			{
				ringMat = ring.material;
			}
		}
		else
		{
			ringMat.SetVector("_Direction", direction);
			ringMat.SetFloat("_Distance", value);
			ringMat.SetFloat("_Threshold", runThreshold);
		}
	}

	public void SetRunning(bool running)
	{
		ringMat.SetFloat("_Running", running ? 1 : 0);
	}
}
public class MoveVisual : MonoBehaviour
{
	[SerializeField]
	private CharacterModel characterModel;

	public List<ParticleSystem> runParticles;

	private bool running;

	private CharacterMainControl Character
	{
		get
		{
			if (!characterModel)
			{
				return null;
			}
			return characterModel.characterMainControl;
		}
	}

	private void Awake()
	{
		foreach (ParticleSystem runParticle in runParticles)
		{
			ParticleSystem.EmissionModule emission = runParticle.emission;
			emission.enabled = running;
		}
	}

	private void Update()
	{
		if (!Character || Character.Running == running)
		{
			return;
		}
		running = Character.Running;
		foreach (ParticleSystem runParticle in runParticles)
		{
			ParticleSystem.EmissionModule emission = runParticle.emission;
			emission.enabled = running;
		}
	}
}
public class NightVisionVisual : MonoBehaviour
{
	[Serializable]
	public struct NightVisionType
	{
		public string intro;

		public VolumeProfile profile;

		[FormerlySerializedAs("thermalCharacter")]
		public bool thermalOn;

		public bool thermalBackground;
	}

	private int nightVisionType;

	public Volume thermalVolume;

	public NightVisionType[] nightVisionTypes;

	private CharacterMainControl character;

	public ScriptableRendererData rendererData;

	public List<string> renderFeatureNames;

	private ScriptableRendererFeature thermalCharacterRednerFeature;

	private ScriptableRendererFeature thermalBackgroundRednerFeature;

	public Transform nightVisionLight;

	public string thermalCharacterRednerFeatureKey = "ThermalCharacter";

	public string thermalBackgroundRednerFeatureKey = "ThermalBackground";

	private bool levelInited;

	public void Awake()
	{
		CollectRendererData();
		Refresh();
	}

	private void OnDestroy()
	{
		nightVisionType = 0;
		Refresh();
	}

	private void CollectRendererData()
	{
		if (rendererData == null)
		{
			return;
		}
		for (int i = 0; i < rendererData.rendererFeatures.Count; i++)
		{
			if (rendererData.rendererFeatures[i].name == thermalCharacterRednerFeatureKey)
			{
				thermalCharacterRednerFeature = rendererData.rendererFeatures[i];
			}
			else if (rendererData.rendererFeatures[i].name == thermalBackgroundRednerFeatureKey)
			{
				thermalBackgroundRednerFeature = rendererData.rendererFeatures[i];
			}
		}
	}

	private void Update()
	{
		bool flag = false;
		int num = CheckNightVisionType();
		if (num >= nightVisionTypes.Length)
		{
			num = 1;
		}
		if (nightVisionType != num)
		{
			nightVisionType = num;
			flag = true;
		}
		if (LevelManager.LevelInited != levelInited)
		{
			levelInited = LevelManager.LevelInited;
			flag = true;
		}
		if (flag)
		{
			Refresh();
		}
		if ((bool)character && nightVisionLight.gameObject.activeInHierarchy)
		{
			nightVisionLight.transform.position = character.transform.position + Vector3.up * 2f;
		}
	}

	private int CheckNightVisionType()
	{
		if (!character)
		{
			if (LevelManager.LevelInited)
			{
				character = CharacterMainControl.Main;
			}
			return 0;
		}
		return Mathf.RoundToInt(character.NightVisionType);
	}

	public void Refresh()
	{
		bool flag = this.nightVisionType > 0;
		thermalVolume.gameObject.SetActive(flag);
		nightVisionLight.gameObject.SetActive(flag);
		NightVisionType nightVisionType = nightVisionTypes[this.nightVisionType];
		bool flag2 = nightVisionType.thermalOn && flag;
		bool active = nightVisionType.thermalBackground && flag;
		thermalVolume.profile = nightVisionType.profile;
		thermalCharacterRednerFeature.SetActive(flag2);
		thermalBackgroundRednerFeature.SetActive(active);
		Shader.SetGlobalFloat("ThermalOn", flag2 ? 1f : 0f);
		if (LevelManager.LevelInited)
		{
			if (flag2)
			{
				LevelManager.Instance.FogOfWarManager.mainVis.ObstacleMask = GameplayDataSettings.Layers.fowBlockLayersWithThermal;
			}
			else
			{
				LevelManager.Instance.FogOfWarManager.mainVis.ObstacleMask = GameplayDataSettings.Layers.fowBlockLayers;
			}
		}
	}
}
public class OcclusionFadeChecker : MonoBehaviour
{
	private void OnTriggerEnter(Collider other)
	{
		OcclusionFadeTrigger component = other.GetComponent<OcclusionFadeTrigger>();
		if ((bool)component)
		{
			component.Enter();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		OcclusionFadeTrigger component = other.GetComponent<OcclusionFadeTrigger>();
		if ((bool)component)
		{
			component.Leave();
		}
	}
}
public class OcclusionFadeManager : MonoBehaviour
{
	private static OcclusionFadeManager instance;

	public OcclusionFadeChecker aimOcclusionFadeChecker;

	public OcclusionFadeChecker characterOcclusionFadeChecker;

	private CharacterMainControl character;

	private Camera cam;

	public Dictionary<Material, Material> materialDic;

	public List<Shader> supportedShaders;

	public Shader maskedShader;

	public Material testMat;

	[Range(0f, 4f)]
	public float viewRange;

	[Range(0f, 8f)]
	public float viewFadeRange;

	public Texture2D fadeNoiseTexture;

	public float heightFadeRange;

	private int aimViewDirHash = Shader.PropertyToID("OC_AimViewDir");

	private int aimPosHash = Shader.PropertyToID("OC_AimPos");

	private int characterViewDirHash = Shader.PropertyToID("OC_CharacterViewDir");

	private int charactetrPosHash = Shader.PropertyToID("OC_CharacterPos");

	private int viewRangeHash = Shader.PropertyToID("ViewRange");

	private int viewFadeRangeHash = Shader.PropertyToID("ViewFadeRange");

	private int startFadeHeightHash = Shader.PropertyToID("StartFadeHeight");

	private int heightFadeRangeHash = Shader.PropertyToID("HeightFadeRange");

	public static OcclusionFadeManager Instance
	{
		get
		{
			if (!instance)
			{
				instance = UnityEngine.Object.FindFirstObjectByType<OcclusionFadeManager>();
			}
			return instance;
		}
	}

	public float startFadeHeight
	{
		get
		{
			CharacterMainControl main = CharacterMainControl.Main;
			if (!main || !main.gameObject.activeInHierarchy)
			{
				return 0.25f;
			}
			return main.transform.position.y + 0.25f;
		}
	}

	private void Awake()
	{
		materialDic = new Dictionary<Material, Material>();
		aimOcclusionFadeChecker.gameObject.layer = LayerMask.NameToLayer("VisualOcclusion");
		characterOcclusionFadeChecker.gameObject.layer = LayerMask.NameToLayer("VisualOcclusion");
		SetShader();
		Shader.SetGlobalTexture("FadeNoiseTexture", fadeNoiseTexture);
	}

	private void OnValidate()
	{
		SetShader();
	}

	private void SetShader()
	{
		Shader.SetGlobalFloat(viewRangeHash, viewRange);
		Shader.SetGlobalFloat(viewFadeRangeHash, viewFadeRange);
		Shader.SetGlobalFloat(startFadeHeightHash, startFadeHeight);
		Shader.SetGlobalFloat(heightFadeRangeHash, heightFadeRange);
	}

	private void Update()
	{
		if (!character)
		{
			if ((bool)LevelManager.Instance)
			{
				character = LevelManager.Instance.MainCharacter;
				cam = LevelManager.Instance.GameCamera.renderCamera;
			}
			return;
		}
		aimOcclusionFadeChecker.transform.position = LevelManager.Instance.InputManager.InputAimPoint;
		Vector3 normalized = (aimOcclusionFadeChecker.transform.position - cam.transform.position).normalized;
		aimOcclusionFadeChecker.transform.rotation = Quaternion.LookRotation(-normalized);
		Shader.SetGlobalVector(aimViewDirHash, normalized);
		Shader.SetGlobalVector(aimPosHash, aimOcclusionFadeChecker.transform.position);
		characterOcclusionFadeChecker.transform.position = character.transform.position;
		Vector3 normalized2 = (characterOcclusionFadeChecker.transform.position - cam.transform.position).normalized;
		characterOcclusionFadeChecker.transform.rotation = Quaternion.LookRotation(-normalized2);
		Shader.SetGlobalVector(characterViewDirHash, normalized2);
		Shader.SetGlobalFloat(startFadeHeightHash, startFadeHeight);
		Shader.SetGlobalVector(charactetrPosHash, character.transform.position);
	}

	public Material GetMaskedMaterial(Material mat)
	{
		if (mat == null)
		{
			return null;
		}
		if (!supportedShaders.Contains(mat.shader))
		{
			return mat;
		}
		if (materialDic.ContainsKey(mat))
		{
			return materialDic[mat];
		}
		Material material = new Material(maskedShader);
		material.CopyPropertiesFromMaterial(mat);
		materialDic.Add(mat, material);
		return material;
	}
}
public enum OcclusionFadeTypes
{
	Fade,
	ShadowOnly
}
public class OcclusionFadeObject : MonoBehaviour
{
	public OcclusionFadeTypes fadeType;

	public string topName = "Fade";

	public OcclusionFadeTrigger[] triggers;

	public Renderer[] renderers;

	public List<Material> originMaterials;

	private List<Material> tempMaterials;

	private Transform topTransform;

	private int enterCounter;

	private bool hiding;

	private bool triggerEnabled = true;

	private void Collect()
	{
		CollectTriggers();
		CollectRenderers();
	}

	private void CollectTriggers()
	{
		triggers = new OcclusionFadeTrigger[0];
		triggers = GetComponentsInChildren<OcclusionFadeTrigger>();
		if (triggers.Length == 0)
		{
			return;
		}
		OcclusionFadeTrigger[] array = triggers;
		foreach (OcclusionFadeTrigger obj in array)
		{
			obj.parent = this;
			Collider[] componentsInChildren = obj.GetComponentsInChildren<Collider>(includeInactive: true);
			if (componentsInChildren.Length != 0)
			{
				Collider[] array2 = componentsInChildren;
				for (int j = 0; j < array2.Length; j++)
				{
					array2[j].isTrigger = true;
				}
			}
		}
	}

	private void CollectRenderers()
	{
		topTransform = FindFirst(base.transform, topName);
		if (!(topTransform == null))
		{
			renderers = topTransform.GetComponentsInChildren<Renderer>(includeInactive: true);
			originMaterials.Clear();
			Renderer[] array = renderers;
			foreach (Renderer renderer in array)
			{
				originMaterials.AddRange(renderer.sharedMaterials);
			}
		}
	}

	public void OnEnter()
	{
		enterCounter++;
		Refresh();
	}

	public void OnLeave()
	{
		enterCounter--;
		Refresh();
	}

	private void Refresh()
	{
		SyncEnable();
		if (!triggerEnabled)
		{
			hiding = false;
			Sync();
		}
		else if (enterCounter > 0 && !hiding)
		{
			hiding = true;
			Sync();
		}
		else if (enterCounter <= 0 && hiding)
		{
			hiding = false;
			Sync();
		}
	}

	private void OnEnable()
	{
		SyncEnable();
	}

	private void OnDisable()
	{
		SyncEnable();
	}

	private void SyncEnable()
	{
		if (triggerEnabled != base.enabled)
		{
			OcclusionFadeTrigger[] array = triggers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].gameObject.SetActive(base.enabled);
			}
			triggerEnabled = base.enabled;
		}
	}

	private void Sync()
	{
		SyncEnable();
		switch (fadeType)
		{
		case OcclusionFadeTypes.Fade:
		{
			if (tempMaterials == null)
			{
				tempMaterials = new List<Material>();
			}
			Renderer[] array;
			if (hiding)
			{
				int num = 0;
				array = renderers;
				foreach (Renderer renderer3 in array)
				{
					if (!(renderer3 == null))
					{
						tempMaterials.Clear();
						for (int j = 0; j < renderer3.materials.Length; j++)
						{
							Material mat = originMaterials[num];
							Material maskedMaterial = OcclusionFadeManager.Instance.GetMaskedMaterial(mat);
							tempMaterials.Add(maskedMaterial);
							num++;
						}
						renderer3.SetSharedMaterials(tempMaterials);
					}
				}
				break;
			}
			int num2 = 0;
			array = renderers;
			foreach (Renderer renderer4 in array)
			{
				if (!(renderer4 == null))
				{
					tempMaterials.Clear();
					for (int k = 0; k < renderer4.materials.Length; k++)
					{
						tempMaterials.Add(originMaterials[num2]);
						num2++;
					}
					renderer4.SetSharedMaterials(tempMaterials);
				}
			}
			break;
		}
		case OcclusionFadeTypes.ShadowOnly:
		{
			Renderer[] array;
			if (hiding)
			{
				array = renderers;
				foreach (Renderer renderer in array)
				{
					if (!(renderer == null))
					{
						renderer.shadowCastingMode = ShadowCastingMode.ShadowsOnly;
					}
				}
				break;
			}
			array = renderers;
			foreach (Renderer renderer2 in array)
			{
				if (!(renderer2 == null))
				{
					renderer2.shadowCastingMode = ShadowCastingMode.On;
				}
			}
			break;
		}
		}
	}

	private void Hide()
	{
		for (int i = 0; i < renderers.Length; i++)
		{
			renderers[i]?.gameObject.SetActive(value: false);
		}
	}

	private void Show()
	{
		for (int i = 0; i < renderers.Length; i++)
		{
			renderers[i]?.gameObject.SetActive(value: true);
		}
	}

	private Transform FindFirst(Transform root, string checkName)
	{
		for (int i = 0; i < root.childCount; i++)
		{
			Transform child = root.GetChild(i);
			if (child.name == checkName)
			{
				return child;
			}
			if (child.childCount > 0)
			{
				Transform transform = FindFirst(child, checkName);
				if (transform != null)
				{
					return transform;
				}
			}
		}
		return null;
	}
}
public class OcclusionFadeTrigger : MonoBehaviour
{
	public OcclusionFadeObject parent;

	private void Awake()
	{
		base.gameObject.layer = LayerMask.NameToLayer("VisualOcclusion");
	}

	public void Enter()
	{
		parent.OnEnter();
	}

	public void Leave()
	{
		parent.OnLeave();
	}
}
public class Ending
{
	public static int endingIndex;
}
public class SetActiveByEnding : MonoBehaviour
{
	public GameObject target;

	public List<int> endingIndexs;

	private void Start()
	{
		target.SetActive(endingIndexs.Contains(Ending.endingIndex));
	}
}
public class ShootRangeRing : MonoBehaviour
{
	private CharacterMainControl character;

	public MeshRenderer ringRenderer;

	private ItemAgent_Gun gunAgent;

	private void Awake()
	{
	}

	private void Update()
	{
		if (!character)
		{
			character = LevelManager.Instance.MainCharacter;
			character.OnHoldAgentChanged += OnAgentChanged;
			OnAgentChanged(character.CurrentHoldItemAgent);
		}
		else if (ringRenderer.gameObject.activeInHierarchy && !gunAgent)
		{
			ringRenderer.gameObject.SetActive(value: false);
		}
	}

	private void LateUpdate()
	{
		if ((bool)character)
		{
			base.transform.rotation = Quaternion.LookRotation(character.CurrentAimDirection, Vector3.up);
			base.transform.position = character.transform.position;
		}
	}

	private void OnDestroy()
	{
		if ((bool)character)
		{
			character.OnHoldAgentChanged -= OnAgentChanged;
		}
	}

	private void OnAgentChanged(DuckovItemAgent agent)
	{
		if (!(agent == null))
		{
			gunAgent = character.GetGun();
			if ((bool)gunAgent)
			{
				ringRenderer.gameObject.SetActive(value: true);
				ringRenderer.transform.localScale = Vector3.one * character.GetAimRange() * 0.5f;
			}
			else
			{
				ringRenderer.gameObject.SetActive(value: false);
			}
		}
	}
}
public class StormWeather : MonoBehaviour
{
	public Buff buff;

	public float addBuffTimeSpace = 1f;

	private float addBuffTimer;

	private CharacterMainControl target;

	private bool onlyOutDoor = true;

	public float stormProtectionThreshold = 0.9f;

	private void Update()
	{
		if (!LevelManager.LevelInited)
		{
			return;
		}
		SubSceneEntry subSceneInfo = MultiSceneCore.Instance.GetSubSceneInfo();
		if (onlyOutDoor && subSceneInfo.IsInDoor)
		{
			return;
		}
		if (!target)
		{
			target = CharacterMainControl.Main;
			if (!target)
			{
				return;
			}
		}
		addBuffTimer -= Time.deltaTime;
		if (addBuffTimer <= 0f)
		{
			addBuffTimer = addBuffTimeSpace;
			if (!(target.StormProtection > stormProtectionThreshold))
			{
				target.AddBuff(buff);
			}
		}
	}
}
public class TimeOfDayConfig : MonoBehaviour
{
	[SerializeField]
	private TimeOfDayEntry defaultEntry;

	[SerializeField]
	private TimeOfDayEntry cloudyEntry;

	[SerializeField]
	private TimeOfDayEntry rainyEntry;

	[SerializeField]
	private TimeOfDayEntry stormIEntry;

	[SerializeField]
	private TimeOfDayEntry stormIIEntry;

	public bool forceSetTime;

	[Range(0f, 24f)]
	public int forceSetTimeTo = 8;

	public bool forceSetWeather;

	public Weather forceSetWeatherTo;

	[SerializeField]
	private Volume lookDevVolume;

	[SerializeField]
	private TimePhaseTags debugPhase;

	[SerializeField]
	private Weather debugWeather;

	public TimeOfDayEntry GetCurrentEntry(Weather weather)
	{
		return weather switch
		{
			Weather.Sunny => defaultEntry, 
			Weather.Cloudy => cloudyEntry, 
			Weather.Rainy => rainyEntry, 
			Weather.Stormy_I => stormIEntry, 
			Weather.Stormy_II => stormIIEntry, 
			_ => defaultEntry, 
		};
	}

	public void InvokeDebug()
	{
		TimeOfDayEntry currentEntry = GetCurrentEntry(debugWeather);
		if (!currentEntry)
		{
			UnityEngine.Debug.Log("No entry found");
			return;
		}
		TimeOfDayPhase phase = currentEntry.GetPhase(debugPhase);
		if (!Application.isPlaying)
		{
			if ((bool)lookDevVolume && lookDevVolume.profile != phase.volumeProfile)
			{
				lookDevVolume.profile = phase.volumeProfile;
			}
			return;
		}
		int num = 9;
		num = debugPhase switch
		{
			TimePhaseTags.day => 9, 
			TimePhaseTags.dawn => 17, 
			TimePhaseTags.night => 22, 
			_ => throw new ArgumentOutOfRangeException(), 
		};
		WeatherManager.SetForceWeather(forceWeather: true, debugWeather);
		TimeSpan time = new TimeSpan(num, 10, 0);
		GameClock.Instance.StepTimeTil(time);
		UnityEngine.Debug.Log($"Set Weather to {debugWeather},and time to {num}");
	}
}
public class TimeOfDayController : MonoBehaviour
{
	private TimeOfDayConfig config;

	private bool atNight;

	[FormerlySerializedAs("volumeControl")]
	[SerializeField]
	private TimeOfDayVolumeControl weatherVolumeControl;

	private TimeOfDayPhase currentPhase;

	private Weather currentWeather;

	public float morningStart = 5f;

	public float dawnStart = 16f;

	public float nightStart = 19f;

	public static float NightViewAngleFactor;

	public static float NightViewDistanceFactor;

	public static float NightSenseRangeFactor;

	[LocalizationKey("Default")]
	public string timePhaseKey_Day;

	[LocalizationKey("Default")]
	public string timePhaseKey_Dawn;

	[LocalizationKey("Default")]
	public string timePhaseKey_Night;

	[LocalizationKey("Default")]
	public string WeatherKey_Sunny;

	[LocalizationKey("Default")]
	public string WeatherKey_Cloudy;

	[LocalizationKey("Default")]
	public string WeatherKey_Rainy;

	[LocalizationKey("Default")]
	public string WeatherKey_Storm_I;

	[LocalizationKey("Default")]
	public string WeatherKey_Storm_II;

	private string stormPhaseISoundKey = "Music/Stinger/stg_storm_1";

	private string stormPhaseIISoundKey = "Music/Stinger/stg_storm_2";

	public GameObject stormIObject;

	public GameObject stormIIObject;

	private float time;

	public static TimeOfDayController Instance
	{
		get
		{
			if (!LevelManager.Instance)
			{
				return null;
			}
			return LevelManager.Instance.TimeOfDayController;
		}
	}

	public bool AtNight => atNight;

	public TimeOfDayPhase CurrentPhase => currentPhase;

	public Weather CurrentWeather => currentWeather;

	public float Time => time;

	private void Start()
	{
		config = LevelConfig.Instance.timeOfDayConfig;
		if (config.forceSetTime)
		{
			TimeSpan timeSpan = new TimeSpan(0, config.forceSetTimeTo, 0, 0);
			GameClock.Instance.StepTimeTil(timeSpan);
		}
		if (config.forceSetWeather)
		{
			WeatherManager.SetForceWeather(forceWeather: true, config.forceSetWeatherTo);
		}
		time = (float)GameClock.TimeOfDay.TotalHours % 24f;
		TimePhaseTags timePhaseTagByTime = GetTimePhaseTagByTime(time);
		atNight = timePhaseTagByTime == TimePhaseTags.night;
		currentWeather = WeatherManager.GetWeather();
		OnWeatherChanged(currentWeather);
		currentPhase = config.GetCurrentEntry(CurrentWeather).GetPhase(timePhaseTagByTime);
		weatherVolumeControl.ForceSetProfile(currentPhase.volumeProfile);
	}

	private void Update()
	{
		time = (float)GameClock.TimeOfDay.TotalHours % 24f;
		TimePhaseTags timePhaseTagByTime = GetTimePhaseTagByTime(time);
		atNight = timePhaseTagByTime == TimePhaseTags.night;
		Weather weather = WeatherManager.GetWeather();
		if (weather != currentWeather)
		{
			currentWeather = weather;
			OnWeatherChanged(currentWeather);
		}
		currentPhase = config.GetCurrentEntry(CurrentWeather).GetPhase(timePhaseTagByTime);
		if (weatherVolumeControl.CurrentProfile != currentPhase.volumeProfile && weatherVolumeControl.BufferTargetProfile != currentPhase.volumeProfile)
		{
			weatherVolumeControl.SetTargetProfile(currentPhase.volumeProfile);
		}
	}

	private void OnWeatherChanged(Weather newWeather)
	{
		bool flag = false;
		if ((bool)MultiSceneCore.Instance)
		{
			SubSceneEntry subSceneInfo = MultiSceneCore.Instance.GetSubSceneInfo();
			if (subSceneInfo != null)
			{
				flag = subSceneInfo.IsInDoor;
			}
		}
		switch (newWeather)
		{
		case Weather.Stormy_I:
			stormIObject.SetActive(value: true);
			stormIIObject.SetActive(value: false);
			NotificationText.Push("Weather_Storm_I".ToPlainText());
			if (!flag && LevelManager.AfterInit)
			{
				AudioManager.Post(stormPhaseISoundKey, base.gameObject);
			}
			break;
		case Weather.Stormy_II:
			stormIObject.SetActive(value: false);
			stormIIObject.SetActive(value: true);
			NotificationText.Push("Weather_Storm_II".ToPlainText());
			if (!flag && LevelManager.AfterInit)
			{
				AudioManager.Post(stormPhaseIISoundKey, base.gameObject);
			}
			break;
		default:
			stormIObject.SetActive(value: false);
			stormIIObject.SetActive(value: false);
			break;
		}
	}

	private TimePhaseTags GetTimePhaseTagByTime(float hourTime)
	{
		hourTime %= 24f;
		if (hourTime < morningStart || hourTime >= nightStart)
		{
			return TimePhaseTags.night;
		}
		if (hourTime >= morningStart && hourTime < dawnStart)
		{
			return TimePhaseTags.day;
		}
		if (hourTime >= dawnStart && hourTime < nightStart)
		{
			return TimePhaseTags.dawn;
		}
		return TimePhaseTags.day;
	}

	public static string GetTimePhaseNameByPhaseTag(TimePhaseTags phaseTag)
	{
		TimeOfDayController instance = Instance;
		if (!instance)
		{
			return string.Empty;
		}
		return phaseTag switch
		{
			TimePhaseTags.day => instance.timePhaseKey_Day.ToPlainText(), 
			TimePhaseTags.dawn => instance.timePhaseKey_Dawn.ToPlainText(), 
			TimePhaseTags.night => instance.timePhaseKey_Night.ToPlainText(), 
			_ => instance.timePhaseKey_Day.ToPlainText(), 
		};
	}

	public static string GetWeatherNameByWeather(Weather weather)
	{
		TimeOfDayController instance = Instance;
		if (!instance)
		{
			return string.Empty;
		}
		return weather switch
		{
			Weather.Sunny => instance.WeatherKey_Sunny.ToPlainText(), 
			Weather.Rainy => instance.WeatherKey_Rainy.ToPlainText(), 
			Weather.Cloudy => instance.WeatherKey_Cloudy.ToPlainText(), 
			Weather.Stormy_I => instance.WeatherKey_Storm_I.ToPlainText(), 
			Weather.Stormy_II => instance.WeatherKey_Storm_II.ToPlainText(), 
			_ => instance.WeatherKey_Sunny.ToPlainText(), 
		};
	}
}
public class TimeOfDayEntry : MonoBehaviour
{
	[SerializeField]
	private List<TimeOfDayPhase> phases;

	private void Start()
	{
		if (phases.Count > 0)
		{
			TimeOfDayPhase value = phases[0];
			phases[0] = value;
		}
	}

	public TimeOfDayPhase GetPhase(TimePhaseTags timePhaseTags)
	{
		for (int i = 0; i < phases.Count; i++)
		{
			TimeOfDayPhase result = phases[i];
			if (result.timePhaseTag == timePhaseTags)
			{
				return result;
			}
		}
		if (timePhaseTags == TimePhaseTags.dawn)
		{
			return GetPhase(TimePhaseTags.day);
		}
		return phases[0];
	}
}
public enum TimePhaseTags
{
	day,
	dawn,
	night
}
[Serializable]
public struct TimeOfDayPhase
{
	[FormerlySerializedAs("phaseTag")]
	public TimePhaseTags timePhaseTag;

	public VolumeProfile volumeProfile;
}
public class TimeOfDayVolumeControl : MonoBehaviour
{
	private VolumeProfile currentProfile;

	private VolumeProfile blendingTargetProfile;

	private VolumeProfile bufferTargetProfile;

	public Volume fromVolume;

	public Volume toVolume;

	private bool blending;

	private float blendTimer;

	public float blendTime = 2f;

	public AnimationCurve blendCurve;

	public VolumeProfile CurrentProfile => currentProfile;

	public VolumeProfile BufferTargetProfile => bufferTargetProfile;

	private void Update()
	{
		if (!blending && bufferTargetProfile != null)
		{
			StartBlendToBufferdTarget();
		}
		if (blending)
		{
			UpdateBlending(Time.deltaTime);
		}
		if (!blending && fromVolume.gameObject.activeSelf)
		{
			fromVolume.gameObject.SetActive(value: false);
		}
	}

	private void UpdateBlending(float deltaTime)
	{
		blendTimer += deltaTime;
		float num = blendTimer / blendTime;
		if (num > 1f)
		{
			num = 1f;
			blending = false;
		}
		toVolume.weight = blendCurve.Evaluate(num);
	}

	public void SetTargetProfile(VolumeProfile profile)
	{
		bufferTargetProfile = profile;
	}

	private void StartBlendToBufferdTarget()
	{
		blending = true;
		blendingTargetProfile = bufferTargetProfile;
		bufferTargetProfile = null;
		currentProfile = blendingTargetProfile;
		fromVolume.gameObject.SetActive(value: true);
		fromVolume.profile = toVolume.profile;
		fromVolume.weight = 1f;
		toVolume.profile = blendingTargetProfile;
		toVolume.weight = 0f;
		blendTimer = 0f;
	}

	public void ForceSetProfile(VolumeProfile profile)
	{
		bufferTargetProfile = profile;
		StartBlendToBufferdTarget();
		UpdateBlending(999f);
	}
}
public class VolumesControl : MonoBehaviour
{
	public Volume interactVolume;

	private CharacterMainControl character;

	private bool currentInteracting;

	private void Update()
	{
	}
}
public class WeatherFxControl : MonoBehaviour
{
	public ParticleSystem[] rainyFxParticles;

	[HideInInspector]
	public float[] rainingParticleRate;

	public Weather targetWeather;

	private float targetParticleRate;

	private float lerpValue;

	public float lerpTime = 5f;

	public float deactiveDelay = 10f;

	private float overTimer;

	private bool fxActive;

	private bool inited;

	private FMOD.Studio.EventInstance? weatherSoundInstace;

	public string rainSoundKey = "Amb/amb_rain";

	private bool audioPlaying;

	[FormerlySerializedAs("onlyInDoor")]
	public bool onlyOutDoor = true;

	private void Start()
	{
	}

	private void Init()
	{
		inited = true;
		rainingParticleRate = new float[rainyFxParticles.Length];
		for (int i = 0; i < rainyFxParticles.Length; i++)
		{
			ParticleSystem.EmissionModule emission = rainyFxParticles[i].emission;
			rainingParticleRate[i] = emission.rateOverTime.constant;
		}
		SetFxActive(active: false);
	}

	private void OnSubSceneChanged()
	{
	}

	private void Update()
	{
		if (!inited)
		{
			if ((bool)LevelManager.Instance && LevelManager.LevelInited)
			{
				Init();
				SetFxActive(active: false);
			}
		}
		else
		{
			if (!TimeOfDayController.Instance || !MultiSceneCore.Instance)
			{
				return;
			}
			bool flag = TimeOfDayController.Instance.CurrentWeather == targetWeather;
			SubSceneEntry subSceneInfo = MultiSceneCore.Instance.GetSubSceneInfo();
			if (onlyOutDoor && subSceneInfo.IsInDoor)
			{
				flag = false;
				lerpValue = 0f;
			}
			if (flag)
			{
				overTimer = deactiveDelay;
				if (!fxActive)
				{
					SetFxActive(active: true);
				}
			}
			else if (lerpValue <= 0.01f)
			{
				overTimer -= Time.deltaTime;
				if (overTimer <= 0f)
				{
					SetFxActive(active: false);
				}
			}
			if (!fxActive)
			{
				return;
			}
			lerpValue = Mathf.MoveTowards(lerpValue, flag ? 1f : 0f, Time.deltaTime / lerpTime);
			for (int i = 0; i < rainyFxParticles.Length; i++)
			{
				ParticleSystem.EmissionModule emission = rainyFxParticles[i].emission;
				float b = rainingParticleRate[i];
				emission.rateOverTime = Mathf.Lerp(0f, b, lerpValue);
			}
			if (flag != audioPlaying)
			{
				audioPlaying = flag;
				if (flag)
				{
					weatherSoundInstace = AudioManager.Post(rainSoundKey, base.gameObject);
				}
				else if (weatherSoundInstace.HasValue)
				{
					weatherSoundInstace.Value.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
				}
			}
		}
	}

	private void SetFxActive(bool active)
	{
		ParticleSystem[] array = rainyFxParticles;
		foreach (ParticleSystem particleSystem in array)
		{
			if (!(particleSystem == null))
			{
				particleSystem.gameObject.SetActive(active);
			}
		}
		fxActive = active;
	}

	private void OnDestroy()
	{
		if (weatherSoundInstace.HasValue)
		{
			weatherSoundInstace.Value.stop(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
		}
	}
}
public class Workbench : InteractableBase
{
	protected override void OnInteractFinished()
	{
		ItemCustomizeSelectionView.Show();
	}
}
public class DummyFish : MonoBehaviour, IAquariumContent
{
	[SerializeField]
	private Rigidbody rigidbody;

	[SerializeField]
	private float rotateForce = 10f;

	[SerializeField]
	private float swimForce = 10f;

	[SerializeField]
	private float deadZone = 2f;

	[SerializeField]
	private float rotationDamping = 0.1f;

	[UnityEngine.Header("Control")]
	[SerializeField]
	private Transform target;

	[Range(0f, 1f)]
	[SerializeField]
	private float swim;

	private float rotVelocityX;

	private float rotVelocityY;

	private Aquarium master;

	private Vector3 _debug_idealRotForward;

	private Vector3 _debug_projectedForward;

	private Vector3 TargetPosition => target.position;

	private void Awake()
	{
		rigidbody.useGravity = false;
	}

	public void Setup(Aquarium master)
	{
		this.master = master;
	}

	private void FixedUpdate()
	{
		Vector3 up = Vector3.up;
		Vector3 forward = base.transform.forward;
		Vector3 right = base.transform.right;
		Vector3 vector = TargetPosition - rigidbody.position;
		Vector3 normalized = vector.normalized;
		Vector3 vector2 = Vector3.Cross(up, normalized);
		float b = Vector3.Dot(normalized, forward);
		float num = Mathf.Max(0f, b);
		swim = ((vector.magnitude > deadZone) ? 1f : (vector.magnitude / deadZone)) * num;
		Vector3 vector3 = -(Vector3.Dot(vector2, rigidbody.velocity) * vector2);
		rigidbody.velocity += forward * swimForce * swim * Time.deltaTime + vector3 * 0.5f;
		rigidbody.angularVelocity = Vector3.zero;
		Vector3 vector4 = vector;
		vector4.y = 0f;
		float num2 = Mathf.Clamp01(vector4.magnitude / deadZone - 0.5f);
		Vector3 to = (_debug_idealRotForward = Vector3.Lerp(_debug_projectedForward = Vector3.ProjectOnPlane(forward, Vector3.up).normalized, normalized, num2));
		float num3 = Vector3.SignedAngle(forward, to, right);
		float num4 = Vector3.SignedAngle(forward, to, Vector3.up);
		float num5 = rotateForce * num3;
		float num6 = rotateForce * num4;
		rotVelocityX += num5 * Time.fixedDeltaTime;
		rotVelocityY += num6 * Time.fixedDeltaTime * num2;
		rotVelocityX *= 1f - rotationDamping;
		rotVelocityY *= 1f - rotationDamping;
		Vector3 eulerAngles = rigidbody.rotation.eulerAngles;
		eulerAngles.y += rotVelocityY * Time.deltaTime;
		eulerAngles.x += rotVelocityX * Time.deltaTime;
		if (eulerAngles.x < -179f)
		{
			eulerAngles.x += 360f;
		}
		if (eulerAngles.x > 179f)
		{
			eulerAngles.x -= 360f;
		}
		eulerAngles.x = Mathf.Clamp(eulerAngles.x, -45f, 45f);
		eulerAngles.z = 0f;
		Quaternion rot = Quaternion.Euler(eulerAngles);
		rigidbody.MoveRotation(rot);
	}

	private void OnDrawGizmos()
	{
		Gizmos.DrawLine(base.transform.position, base.transform.position + _debug_idealRotForward);
		Gizmos.color = Color.red;
		Gizmos.DrawLine(base.transform.position, base.transform.position + _debug_projectedForward);
	}
}
public class ATMPanel : MonoBehaviour
{
	private const int CashItemTypeID = 451;

	[SerializeField]
	private TextMeshProUGUI balanceAmountText;

	[SerializeField]
	private TextMeshProUGUI cashAmountText;

	[SerializeField]
	private UnityEngine.UI.Button btnSelectSave;

	[SerializeField]
	private UnityEngine.UI.Button btnSelectDraw;

	[SerializeField]
	private FadeGroup selectPanel;

	[SerializeField]
	private ATMPanel_SavePanel savePanel;

	[SerializeField]
	private ATMPanel_DrawPanel drawPanel;

	private int _cachedCashAmount = -1;

	private static bool drawingMoney;

	public const long MaxDrawAmount = 10000000L;

	private int CashAmount
	{
		get
		{
			if (_cachedCashAmount < 0)
			{
				_cachedCashAmount = ItemUtilities.GetItemCount(451);
			}
			return _cachedCashAmount;
		}
	}

	private void Awake()
	{
		btnSelectSave.onClick.AddListener(ShowSavePanel);
		btnSelectDraw.onClick.AddListener(ShowDrawPanel);
		savePanel.onQuit += SavePanel_onQuit;
		drawPanel.onQuit += DrawPanel_onQuit;
	}

	private void DrawPanel_onQuit(ATMPanel_DrawPanel panel)
	{
		ShowSelectPanel();
	}

	private void SavePanel_onQuit(ATMPanel_SavePanel obj)
	{
		ShowSelectPanel();
	}

	private void HideAllPanels(bool skip = false)
	{
		if (skip)
		{
			selectPanel.SkipHide();
		}
		else
		{
			selectPanel.Hide();
		}
		savePanel.Hide(skip);
		drawPanel.Hide(skip);
	}

	public void ShowSelectPanel(bool skipHideOthers = false)
	{
		HideAllPanels(skipHideOthers);
		selectPanel.Show();
	}

	public void ShowDrawPanel()
	{
		HideAllPanels();
		drawPanel.Show();
	}

	public void ShowSavePanel()
	{
		HideAllPanels();
		savePanel.Show();
	}

	private void OnEnable()
	{
		EconomyManager.OnMoneyChanged += OnMoneyChanged;
		ItemUtilities.OnPlayerItemOperation += OnPlayerItemOperation;
		RefreshCash();
		RefreshBalance();
		ShowSelectPanel();
	}

	private void OnDisable()
	{
		EconomyManager.OnMoneyChanged -= OnMoneyChanged;
		ItemUtilities.OnPlayerItemOperation -= OnPlayerItemOperation;
	}

	private void OnPlayerItemOperation()
	{
		RefreshCash();
	}

	private void OnMoneyChanged(long oldMoney, long changedMoney)
	{
		RefreshBalance();
	}

	private void RefreshCash()
	{
		_cachedCashAmount = ItemUtilities.GetItemCount(451);
		cashAmountText.text = $"{CashAmount:n0}";
	}

	private void RefreshBalance()
	{
		balanceAmountText.text = $"{EconomyManager.Money:n0}";
	}

	public static async UniTask<bool> Draw(long amount)
	{
		if (drawingMoney)
		{
			return false;
		}
		if (amount > 10000000)
		{
			UnityEngine.Debug.LogError($"Drawing amount {amount} greater than max draw amount {10000000L}. Clamping draw amount down.");
			amount = 10000000L;
		}
		drawingMoney = true;
		try
		{
			Cost cost = new Cost(amount);
			if (!cost.Enough)
			{
				return false;
			}
			await new Cost((451, amount)).Return(directToBuffer: false, toPlayerInventory: true);
			cost.Pay(accountAvaliable: true, cashAvaliable: false);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
		drawingMoney = false;
		return true;
	}

	public static bool Save(long amount)
	{
		Cost cost = new Cost(0L, new(int, long)[1] { (451, amount) });
		if (!cost.Pay(accountAvaliable: false))
		{
			return false;
		}
		EconomyManager.Add(amount);
		return true;
	}
}
public class ATMPanel_DrawPanel : MonoBehaviour
{
	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private DigitInputPanel inputPanel;

	[SerializeField]
	private UnityEngine.UI.Button confirmButton;

	[SerializeField]
	private GameObject insufficientIndicator;

	[SerializeField]
	private UnityEngine.UI.Button quitButton;

	public event Action<ATMPanel_DrawPanel> onQuit;

	private void OnEnable()
	{
		EconomyManager.OnMoneyChanged += OnMoneyChanged;
		Refresh();
	}

	private void OnDisable()
	{
		EconomyManager.OnMoneyChanged -= OnMoneyChanged;
	}

	private void Awake()
	{
		inputPanel.onInputFieldValueChanged += OnInputValueChanged;
		inputPanel.maxFunction = delegate
		{
			long num = EconomyManager.Money;
			if (num > 10000000)
			{
				num = 10000000L;
			}
			return num;
		};
		confirmButton.onClick.AddListener(OnConfirmButtonClicked);
		quitButton.onClick.AddListener(OnQuitButtonClicked);
	}

	private void OnQuitButtonClicked()
	{
		this.onQuit?.Invoke(this);
	}

	private void OnMoneyChanged(long arg1, long arg2)
	{
		Refresh();
	}

	private void OnConfirmButtonClicked()
	{
		if (inputPanel.Value <= 0)
		{
			inputPanel.Clear();
			return;
		}
		long num = EconomyManager.Money;
		if (num > 10000000)
		{
			num = 10000000L;
		}
		if (inputPanel.Value <= num)
		{
			DrawTask(inputPanel.Value).Forget();
		}
	}

	private async UniTask DrawTask(long value)
	{
		if (await ATMPanel.Draw(value))
		{
			inputPanel.Clear();
		}
	}

	private void OnInputValueChanged(string v)
	{
		Refresh();
	}

	private void Refresh()
	{
		bool flag = EconomyManager.Money >= inputPanel.Value;
		flag &= inputPanel.Value <= 10000000;
		flag &= inputPanel.Value >= 0;
		insufficientIndicator.SetActive(!flag);
	}

	internal void Show()
	{
		fadeGroup.Show();
	}

	internal void Hide(bool skip)
	{
		if (skip)
		{
			fadeGroup.SkipHide();
		}
		else
		{
			fadeGroup.Hide();
		}
	}
}
public class ATMPanel_SavePanel : MonoBehaviour
{
	private const int CashItemTypeID = 451;

	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private DigitInputPanel inputPanel;

	[SerializeField]
	private UnityEngine.UI.Button confirmButton;

	[SerializeField]
	private GameObject insufficientIndicator;

	[SerializeField]
	private UnityEngine.UI.Button quitButton;

	private int _cachedCashAmount = -1;

	private int CashAmount
	{
		get
		{
			if (_cachedCashAmount < 0)
			{
				_cachedCashAmount = ItemUtilities.GetItemCount(451);
			}
			return _cachedCashAmount;
		}
	}

	public event Action<ATMPanel_SavePanel> onQuit;

	private void OnEnable()
	{
		ItemUtilities.OnPlayerItemOperation += OnPlayerItemOperation;
		RefreshCash();
		Refresh();
	}

	private void OnDisable()
	{
		ItemUtilities.OnPlayerItemOperation -= OnPlayerItemOperation;
	}

	private void OnPlayerItemOperation()
	{
		RefreshCash();
		Refresh();
	}

	private void RefreshCash()
	{
		_cachedCashAmount = ItemUtilities.GetItemCount(451);
	}

	private void Awake()
	{
		inputPanel.onInputFieldValueChanged += OnInputValueChanged;
		inputPanel.maxFunction = () => CashAmount;
		confirmButton.onClick.AddListener(OnConfirmButtonClicked);
		quitButton.onClick.AddListener(OnQuitButtonClicked);
	}

	private void OnQuitButtonClicked()
	{
		this.onQuit?.Invoke(this);
	}

	private void OnConfirmButtonClicked()
	{
		if (inputPanel.Value <= 0)
		{
			inputPanel.Clear();
		}
		else if (inputPanel.Value <= CashAmount && ATMPanel.Save(inputPanel.Value))
		{
			inputPanel.Clear();
		}
	}

	private void OnInputValueChanged(string v)
	{
		Refresh();
	}

	private void Refresh()
	{
		bool flag = CashAmount >= inputPanel.Value;
		flag &= inputPanel.Value >= 0;
		insufficientIndicator.SetActive(!flag);
	}

	internal void Hide(bool skip = false)
	{
		if (skip)
		{
			fadeGroup.SkipHide();
		}
		else
		{
			fadeGroup.Hide();
		}
	}

	internal void Show()
	{
		fadeGroup.Show();
	}
}
public class ATMView : View
{
	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private ATMPanel atmPanel;

	public static ATMView Instance => View.GetViewInstance<ATMView>();

	protected override void Awake()
	{
		base.Awake();
	}

	public static void Show()
	{
		ATMView instance = Instance;
		if (!(instance == null))
		{
			instance.Open();
		}
	}

	protected override void OnOpen()
	{
		base.OnOpen();
		fadeGroup.Show();
		atmPanel.ShowSelectPanel(skipHideOthers: true);
	}

	protected override void OnClose()
	{
		base.OnClose();
		fadeGroup.Hide();
	}
}
public class DigitInputPanel : MonoBehaviour
{
	[SerializeField]
	private TMP_InputField inputField;

	[SerializeField]
	private UnityEngine.UI.Button clearButton;

	[SerializeField]
	private UnityEngine.UI.Button backspaceButton;

	[SerializeField]
	private UnityEngine.UI.Button maximumButton;

	[SerializeField]
	private UnityEngine.UI.Button[] numKeys;

	public Func<long> maxFunction;

	public long Value
	{
		get
		{
			string text = inputField.text;
			if (string.IsNullOrEmpty(text))
			{
				return 0L;
			}
			if (!long.TryParse(text, out var result))
			{
				return 0L;
			}
			return result;
		}
	}

	public event Action<string> onInputFieldValueChanged;

	private void Awake()
	{
		inputField.onValueChanged.AddListener(OnInputFieldValueChanged);
		for (int i = 0; i < numKeys.Length; i++)
		{
			int v = i;
			numKeys[i].onClick.AddListener(delegate
			{
				OnNumKeyClicked(v);
			});
		}
		clearButton.onClick.AddListener(OnClearButtonClicked);
		backspaceButton.onClick.AddListener(OnBackspaceButtonClicked);
		maximumButton.onClick.AddListener(Max);
	}

	private void OnBackspaceButtonClicked()
	{
		if (!string.IsNullOrEmpty(inputField.text))
		{
			inputField.text = inputField.text.Substring(0, inputField.text.Length - 1);
		}
	}

	private void OnClearButtonClicked()
	{
		inputField.text = string.Empty;
	}

	private void OnNumKeyClicked(long v)
	{
		inputField.text = $"{inputField.text}{v}";
	}

	private void OnInputFieldValueChanged(string value)
	{
		if (long.TryParse(value, out var result) && result == 0L)
		{
			inputField.SetTextWithoutNotify(string.Empty);
		}
		this.onInputFieldValueChanged?.Invoke(value);
	}

	public void Setup(long value, Func<long> maxFunc = null)
	{
		maxFunction = maxFunc;
		inputField.text = $"{value}";
	}

	public void Max()
	{
		if (maxFunction != null)
		{
			long num = maxFunction();
			inputField.text = $"{num}";
		}
	}

	internal void Clear()
	{
		inputField.text = string.Empty;
	}
}
public class FmodEventTester : MonoBehaviour
{
	[SerializeField]
	private string e;

	public void PlayEvent()
	{
		AudioManager.Post(e, base.gameObject);
	}
}
public class PostAudioEventOnEnter : StateMachineBehaviour
{
	[SerializeField]
	private string eventName;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		base.OnStateEnter(animator, stateInfo, layerIndex);
		AudioManager.Post(eventName, animator.gameObject);
	}
}
public class BuilderViewInvoker : InteractableBase
{
	[SerializeField]
	private BuildingArea buildingArea;

	protected override void OnInteractFinished()
	{
		if (!(buildingArea == null))
		{
			BuilderView.Show(buildingArea);
		}
	}
}
public class BitcoinMinerView : View
{
	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private InventoryDisplay inventoryDisplay;

	[SerializeField]
	private InventoryDisplay storageDisplay;

	[SerializeField]
	private ItemSlotCollectionDisplay minerSlotsDisplay;

	[SerializeField]
	private InventoryDisplay minerInventoryDisplay;

	[SerializeField]
	private TextMeshProUGUI commentText;

	[SerializeField]
	private TextMeshProUGUI remainingTimeText;

	[SerializeField]
	private TextMeshProUGUI timeEachCoinText;

	[SerializeField]
	private TextMeshProUGUI performanceText;

	[SerializeField]
	private UnityEngine.UI.Image fill;

	public static BitcoinMinerView Instance => View.GetViewInstance<BitcoinMinerView>();

	[LocalizationKey("Default")]
	private string ActiveCommentKey
	{
		get
		{
			return "UI_BitcoinMiner_Active";
		}
		set
		{
		}
	}

	[LocalizationKey("Default")]
	private string StoppedCommentKey
	{
		get
		{
			return "UI_BitcoinMiner_Stopped";
		}
		set
		{
		}
	}

	protected override void Awake()
	{
		base.Awake();
		minerInventoryDisplay.onDisplayDoubleClicked += OnMinerInventoryEntryDoubleClicked;
		inventoryDisplay.onDisplayDoubleClicked += OnPlayerItemsDoubleClicked;
		storageDisplay.onDisplayDoubleClicked += OnPlayerItemsDoubleClicked;
		minerSlotsDisplay.onElementDoubleClicked += OnMinerSlotEntryDoubleClicked;
	}

	private void OnMinerSlotEntryDoubleClicked(ItemSlotCollectionDisplay display1, SlotDisplay slotDisplay)
	{
		Slot target = slotDisplay.Target;
		if (target != null)
		{
			Item content = target.Content;
			if (!(content == null))
			{
				ItemUtilities.SendToPlayer(content, dontMerge: false, PlayerStorage.Instance != null);
			}
		}
	}

	private void OnPlayerItemsDoubleClicked(InventoryDisplay display, InventoryEntry entry, PointerEventData data)
	{
		Item content = entry.Content;
		if (!(content == null))
		{
			Item item = BitcoinMiner.Instance.Item;
			if (!(item == null))
			{
				item.TryPlug(content, emptyOnly: true, content.InInventory);
			}
		}
	}

	private void OnMinerInventoryEntryDoubleClicked(InventoryDisplay display, InventoryEntry entry, PointerEventData data)
	{
		Item content = entry.Content;
		if (!(content == null) && data.button == PointerEventData.InputButton.Left)
		{
			ItemUtilities.SendToPlayer(content);
		}
	}

	public static void Show()
	{
		if (!(Instance == null) && !(BitcoinMiner.Instance == null))
		{
			Instance.Open();
		}
	}

	protected override void OnOpen()
	{
		base.OnOpen();
		CharacterMainControl main = CharacterMainControl.Main;
		if (!(main == null))
		{
			Item characterItem = main.CharacterItem;
			if (!(characterItem == null))
			{
				BitcoinMiner instance = BitcoinMiner.Instance;
				if (!instance.Loading)
				{
					Item item = instance.Item;
					if (!(item == null))
					{
						inventoryDisplay.Setup(characterItem.Inventory);
						if (PlayerStorage.Inventory != null)
						{
							storageDisplay.gameObject.SetActive(value: true);
							storageDisplay.Setup(PlayerStorage.Inventory);
						}
						else
						{
							storageDisplay.gameObject.SetActive(value: false);
						}
						minerSlotsDisplay.Setup(item);
						minerInventoryDisplay.Setup(item.Inventory);
						fadeGroup.Show();
						return;
					}
				}
			}
		}
		UnityEngine.Debug.Log("Failed");
		Close();
	}

	protected override void OnClose()
	{
		base.OnClose();
		fadeGroup.Hide();
	}

	private void FixedUpdate()
	{
		RefreshStatus();
	}

	private void RefreshStatus()
	{
		if (BitcoinMiner.Instance.WorkPerSecond > 0.0)
		{
			TimeSpan remainingTime = BitcoinMiner.Instance.RemainingTime;
			TimeSpan timePerCoin = BitcoinMiner.Instance.TimePerCoin;
			remainingTimeText.text = $"{Mathf.FloorToInt((float)remainingTime.TotalHours):00}:{remainingTime.Minutes:00}:{remainingTime.Seconds:00}";
			timeEachCoinText.text = $"{Mathf.FloorToInt((float)timePerCoin.TotalHours):00}:{timePerCoin.Minutes:00}:{timePerCoin.Seconds:00}";
			performanceText.text = $"{BitcoinMiner.Instance.Performance:0.#}";
			commentText.text = ActiveCommentKey.ToPlainText();
		}
		else
		{
			remainingTimeText.text = "--:--:--";
			timeEachCoinText.text = "--:--:--";
			commentText.text = StoppedCommentKey.ToPlainText();
			performanceText.text = $"{BitcoinMiner.Instance.Performance:0.#}";
		}
		fill.fillAmount = BitcoinMiner.Instance.NormalizedProgress;
	}
}
public class CameraMode : MonoBehaviour
{
	public static Action OnCameraModeActivated;

	public static Action OnCameraModeDeactivated;

	public static Action<bool> OnCameraModeChanged;

	private bool active;

	public static CameraMode Instance { get; private set; }

	public static bool Active
	{
		get
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.active;
		}
	}

	private void Awake()
	{
		if (Instance != null)
		{
			UnityEngine.Debug.LogError("检测到多个Camera Mode", base.gameObject);
			return;
		}
		Shader.SetGlobalFloat("CameraModeOn", 0f);
		Instance = this;
		UIInputManager.OnToggleCameraMode += OnToggleCameraMode;
		UIInputManager.OnCancel += OnUICancel;
		ManagedUIElement.onOpen += OnViewOpen;
	}

	private void OnDestroy()
	{
		Shader.SetGlobalFloat("CameraModeOn", 0f);
		UIInputManager.OnToggleCameraMode -= OnToggleCameraMode;
		UIInputManager.OnCancel -= OnUICancel;
		ManagedUIElement.onOpen -= OnViewOpen;
		Shader.SetGlobalFloat("CameraModeOn", 0f);
	}

	private void OnViewOpen(ManagedUIElement element)
	{
		if (Active)
		{
			Deactivate();
		}
	}

	private void OnUICancel(UIInputEventData data)
	{
		if (!data.Used && Active)
		{
			Deactivate();
			data.Use();
		}
	}

	private void OnToggleCameraMode(UIInputEventData data)
	{
		if (Active)
		{
			Deactivate();
		}
		else
		{
			Activate();
		}
		data.Use();
	}

	private void MActivate()
	{
		if (!(View.ActiveView != null))
		{
			active = true;
			Shader.SetGlobalFloat("CameraModeOn", 1f);
			OnCameraModeActivated?.Invoke();
			OnCameraModeChanged?.Invoke(active);
		}
	}

	private void MDeactivate()
	{
		active = false;
		Shader.SetGlobalFloat("CameraModeOn", 0f);
		OnCameraModeDeactivated?.Invoke();
		OnCameraModeChanged?.Invoke(active);
	}

	public static void Activate()
	{
		if (!(Instance == null))
		{
			Shader.SetGlobalFloat("CameraModeOn", 1f);
			Instance.MActivate();
		}
	}

	public static void Deactivate()
	{
		Shader.SetGlobalFloat("CameraModeOn", 0f);
		if (!(Instance == null))
		{
			Instance.MDeactivate();
		}
	}
}
public class CameraModeController : MonoBehaviour
{
	public CinemachineVirtualCamera vCam;

	private bool actived;

	public Transform dofTarget;

	private Vector3 dofTargetPoint;

	public InputActionAsset inputActionAsset;

	public LayerMask dofLayerMask;

	private Vector2 moveInput;

	private float upDownInput;

	private bool focusInput;

	private bool captureInput;

	private bool fastInput;

	private bool openFolderInput;

	public GameObject focusMesh;

	public float focusMeshSize = 0.3f;

	private float focusMeshCurrentSize = 0.3f;

	public float focusMeshAppearTime = 1f;

	private float focusMeshTimer = 0.3f;

	private float fovInput;

	private Vector2 aimInput;

	public float moveSpeed;

	public float fastMoveSpeed;

	public float aimSpeed;

	private float yaw;

	private float pitch;

	private bool shootting;

	public ColorPunch colorPunch;

	public Vector2 fovRange = new Vector2(5f, 60f);

	[Range(0.01f, 0.5f)]
	public float fovChangeSpeed = 10f;

	public UnityEngine.CanvasGroup indicatorGroup;

	public UnityEvent OnCapturedEvent;

	private static string filePath
	{
		get
		{
			if (GameMetaData.Instance.Platform == Duckov.Platform.WeGame)
			{
				return Application.streamingAssetsPath + "/ScreenShots";
			}
			return Application.persistentDataPath + "/ScreenShots";
		}
	}

	private void UpdateInput()
	{
		moveInput = inputActionAsset["CameraModeMove"].ReadValue<Vector2>();
		focusInput = inputActionAsset["CameraModeFocus"].IsPressed();
		upDownInput = inputActionAsset["CameraModeUpDown"].ReadValue<float>();
		fovInput = inputActionAsset["CameraModeFOV"].ReadValue<float>();
		aimInput = inputActionAsset["CameraModeAim"].ReadValue<Vector2>();
		captureInput = inputActionAsset["CameraModeCapture"].WasPressedThisFrame();
		fastInput = inputActionAsset["CameraModeFaster"].IsPressed();
		openFolderInput = inputActionAsset["CameraModeOpenFolder"].WasPressedThisFrame();
	}

	private void Awake()
	{
		CameraMode.OnCameraModeActivated = (Action)Delegate.Combine(CameraMode.OnCameraModeActivated, new Action(OnCameraModeActivated));
		CameraMode.OnCameraModeDeactivated = (Action)Delegate.Combine(CameraMode.OnCameraModeDeactivated, new Action(OnCameraModeDeactivated));
		inputActionAsset.Enable();
		vCam.gameObject.SetActive(value: true);
		base.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (!actived)
		{
			return;
		}
		UpdateInput();
		if (!shootting)
		{
			UpdateMove();
			UpdateLook();
			UpdateFov();
			if (captureInput)
			{
				Shot().Forget();
			}
			if (openFolderInput)
			{
				OpenFolder();
				openFolderInput = false;
			}
		}
	}

	private void LateUpdate()
	{
		UpdateFocus();
	}

	private void UpdateMove()
	{
		Vector3 forward = vCam.transform.forward;
		forward.y = 0f;
		forward.Normalize();
		Vector3 right = vCam.transform.right;
		right.y = 0f;
		right.Normalize();
		Vector3 vector = right * moveInput.x + forward * moveInput.y;
		vector.Normalize();
		vector += upDownInput * Vector3.up;
		vCam.transform.position += Time.unscaledDeltaTime * vector * (fastInput ? fastMoveSpeed : moveSpeed);
	}

	private void UpdateLook()
	{
		pitch += (0f - aimInput.y) * aimSpeed * Time.unscaledDeltaTime;
		pitch = Mathf.Clamp(pitch, -89.9f, 89.9f);
		yaw += aimInput.x * aimSpeed * Time.unscaledDeltaTime;
		vCam.transform.localRotation = Quaternion.Euler(pitch, yaw, 0f);
	}

	private void UpdateFocus()
	{
		if (focusInput)
		{
			if (Physics.Raycast(vCam.transform.position, vCam.transform.forward, out var hitInfo, 100f, dofLayerMask))
			{
				dofTargetPoint = hitInfo.point + vCam.transform.forward * -0.2f;
				dofTarget.position = dofTargetPoint;
			}
			focusMeshTimer = focusMeshAppearTime;
			if (!focusMesh.gameObject.activeSelf)
			{
				focusMesh.gameObject.SetActive(value: true);
			}
		}
		else if (focusMeshTimer > 0f)
		{
			focusMeshTimer -= Time.unscaledDeltaTime;
			if (focusMeshTimer <= 0f)
			{
				focusMeshTimer = 0f;
				focusMesh.gameObject.SetActive(value: false);
			}
		}
		if (focusMesh.gameObject.activeSelf)
		{
			focusMesh.transform.localScale = Vector3.one * focusMeshSize * focusMeshTimer / focusMeshAppearTime;
		}
	}

	private void UpdateFov()
	{
		float fieldOfView = vCam.m_Lens.FieldOfView;
		fieldOfView += (0f - fovChangeSpeed) * fovInput;
		fieldOfView = Mathf.Clamp(fieldOfView, fovRange.x, fovRange.y);
		vCam.m_Lens.FieldOfView = fieldOfView;
	}

	private void OnDestroy()
	{
		CameraMode.OnCameraModeActivated = (Action)Delegate.Remove(CameraMode.OnCameraModeActivated, new Action(OnCameraModeActivated));
		CameraMode.OnCameraModeDeactivated = (Action)Delegate.Remove(CameraMode.OnCameraModeDeactivated, new Action(OnCameraModeDeactivated));
	}

	private void OnCameraModeActivated()
	{
		GameCamera instance = GameCamera.Instance;
		if (instance != null)
		{
			CameraArm mianCameraArm = instance.mianCameraArm;
			yaw = mianCameraArm.yaw;
			pitch = mianCameraArm.pitch;
			vCam.transform.position = instance.renderCamera.transform.position;
			dofTargetPoint = instance.target.transform.position;
			actived = true;
			vCam.m_Lens.FieldOfView = instance.renderCamera.fieldOfView;
			base.gameObject.SetActive(value: true);
		}
	}

	public static void OpenFolder()
	{
		GUIUtility.systemCopyBuffer = filePath;
		NotificationText.Push(filePath ?? "");
	}

	private void OnCameraModeDeactivated()
	{
		actived = false;
		base.gameObject.SetActive(value: false);
	}

	private async UniTaskVoid Shot()
	{
		if (!shootting)
		{
			indicatorGroup.alpha = 0f;
			await UniTask.WaitForEndOfFrame(this);
			shootting = true;
			int num = 0;
			_ = Screen.currentResolution.height;
			_ = 1440;
			if (PlayerPrefs.HasKey("ScreenShotIndex"))
			{
				num = PlayerPrefs.GetInt("ScreenShotIndex");
			}
			if (!Directory.Exists(filePath))
			{
				Directory.CreateDirectory(filePath);
			}
			ScreenCapture.CaptureScreenshot($"{filePath}/ScreenShot_{num:0000}.png", 2);
			num++;
			PlayerPrefs.SetInt("ScreenShotIndex", num);
			await UniTask.WaitForEndOfFrame(this);
			await UniTask.WaitForEndOfFrame(this);
			await UniTask.WaitForEndOfFrame(this);
			indicatorGroup.alpha = 1f;
			colorPunch.Punch();
			OnCapturedEvent?.Invoke();
			await UniTask.WaitForSeconds(0.3f, ignoreTimeScale: true);
			shootting = false;
		}
	}
}
[Serializable]
public struct CraftingFormula
{
	[Serializable]
	public struct ItemEntry
	{
		[ItemTypeID]
		public int id;

		public int amount;
	}

	public string id;

	public ItemEntry result;

	public string[] tags;

	[SerializeField]
	public Cost cost;

	public bool unlockByDefault;

	public bool lockInDemo;

	public string requirePerk;

	public bool hideInIndex;

	public bool IDValid => !string.IsNullOrEmpty(id);
}
[CreateAssetMenu]
public class CraftingFormulaCollection : ScriptableObject
{
	[SerializeField]
	private List<CraftingFormula> list;

	private ReadOnlyCollection<CraftingFormula> _entries_ReadOnly;

	public static CraftingFormulaCollection Instance => GameplayDataSettings.CraftingFormulas;

	public ReadOnlyCollection<CraftingFormula> Entries
	{
		get
		{
			if (_entries_ReadOnly == null)
			{
				_entries_ReadOnly = new ReadOnlyCollection<CraftingFormula>(list);
			}
			return _entries_ReadOnly;
		}
	}

	public static bool TryGetFormula(string id, out CraftingFormula formula)
	{
		if (!(Instance == null))
		{
			CraftingFormula craftingFormula = Instance.list.FirstOrDefault((CraftingFormula e) => e.id == id);
			if (!string.IsNullOrEmpty(craftingFormula.id))
			{
				formula = craftingFormula;
				return true;
			}
		}
		formula = default(CraftingFormula);
		return false;
	}
}
public class CraftingManager : MonoBehaviour
{
	public static Action<CraftingFormula, Item> OnItemCrafted;

	public static Action<string> OnFormulaUnlocked;

	private const string SaveKey = "Crafting/UnlockedFormulaIDs";

	private List<string> unlockedFormulaIDs = new List<string>();

	private static CraftingFormulaCollection FormulaCollection => CraftingFormulaCollection.Instance;

	public static CraftingManager Instance { get; private set; }

	public static IEnumerable<string> UnlockedFormulaIDs
	{
		get
		{
			if (Instance == null)
			{
				yield break;
			}
			foreach (CraftingFormula entry in CraftingFormulaCollection.Instance.Entries)
			{
				if (IsFormulaUnlocked(entry.id))
				{
					yield return entry.id;
				}
			}
		}
	}

	private void Awake()
	{
		Instance = this;
		Load();
		SavesSystem.OnCollectSaveData += Save;
	}

	private void OnDestroy()
	{
		SavesSystem.OnCollectSaveData -= Save;
	}

	private void Save()
	{
		SavesSystem.Save("Crafting/UnlockedFormulaIDs", unlockedFormulaIDs);
	}

	private void Load()
	{
		unlockedFormulaIDs = SavesSystem.Load<List<string>>("Crafting/UnlockedFormulaIDs");
		if (unlockedFormulaIDs == null)
		{
			unlockedFormulaIDs = new List<string>();
		}
		foreach (CraftingFormula entry in FormulaCollection.Entries)
		{
			if (entry.unlockByDefault && !unlockedFormulaIDs.Contains(entry.id))
			{
				unlockedFormulaIDs.Add(entry.id);
			}
		}
		unlockedFormulaIDs.Sort();
	}

	public static void UnlockFormula(string formulaID)
	{
		if (Instance == null)
		{
			return;
		}
		if (string.IsNullOrEmpty(formulaID))
		{
			UnityEngine.Debug.LogError("Invalid formula ID");
			return;
		}
		CraftingFormula craftingFormula = FormulaCollection.Entries.FirstOrDefault((CraftingFormula e) => e.id == formulaID);
		if (!craftingFormula.IDValid)
		{
			UnityEngine.Debug.LogError("Invalid formula ID: " + formulaID);
		}
		else if (craftingFormula.unlockByDefault)
		{
			UnityEngine.Debug.LogError("Formula is unlocked by default: " + formulaID);
		}
		else if (!Instance.unlockedFormulaIDs.Contains(formulaID))
		{
			Instance.unlockedFormulaIDs.Add(formulaID);
			OnFormulaUnlocked?.Invoke(formulaID);
		}
	}

	private async UniTask<List<Item>> Craft(CraftingFormula formula)
	{
		if (!formula.cost.Enough)
		{
			return null;
		}
		Cost cost = new Cost((formula.result.id, formula.result.amount));
		if (!formula.cost.Pay())
		{
			return null;
		}
		List<Item> generatedBuffer = new List<Item>();
		await cost.Return(directToBuffer: false, toPlayerInventory: true, 1, generatedBuffer);
		foreach (Item item in generatedBuffer)
		{
			if (!(item == null))
			{
				OnItemCrafted?.Invoke(formula, item);
			}
		}
		return generatedBuffer;
	}

	public async UniTask<List<Item>> Craft(string id)
	{
		if (!CraftingFormulaCollection.TryGetFormula(id, out var formula))
		{
			return null;
		}
		return await Craft(formula);
	}

	internal static bool IsFormulaUnlocked(string value)
	{
		if (Instance == null)
		{
			return false;
		}
		if (string.IsNullOrEmpty(value))
		{
			return false;
		}
		return Instance.unlockedFormulaIDs.Contains(value);
	}

	internal static CraftingFormula GetFormula(string id)
	{
		if (CraftingFormulaCollection.TryGetFormula(id, out var formula))
		{
			return formula;
		}
		return default(CraftingFormula);
	}
}
[CreateAssetMenu]
public class DecomposeDatabase : ScriptableObject
{
	[SerializeField]
	private DecomposeFormula[] entries;

	private Dictionary<int, DecomposeFormula> _dic;

	public static DecomposeDatabase Instance => GameplayDataSettings.DecomposeDatabase;

	private Dictionary<int, DecomposeFormula> Dic
	{
		get
		{
			if (_dic == null)
			{
				RebuildDictionary();
			}
			return _dic;
		}
	}

	public void RebuildDictionary()
	{
		_dic = new Dictionary<int, DecomposeFormula>();
		DecomposeFormula[] array = entries;
		for (int i = 0; i < array.Length; i++)
		{
			DecomposeFormula value = array[i];
			_dic[value.item] = value;
		}
	}

	public DecomposeFormula GetFormula(int itemTypeID)
	{
		if (!Dic.TryGetValue(itemTypeID, out var value))
		{
			return default(DecomposeFormula);
		}
		return value;
	}

	public static async UniTask<bool> Decompose(Item item, int count)
	{
		if (Instance == null)
		{
			return false;
		}
		DecomposeFormula formula = Instance.GetFormula(item.TypeID);
		if (!formula.valid)
		{
			return false;
		}
		Item splitedItem = item;
		if (item.Stackable)
		{
			int stackCount = item.StackCount;
			if (stackCount <= count)
			{
				count = stackCount;
			}
			else
			{
				splitedItem = await item.Split(count);
			}
		}
		Cost result = formula.result;
		await result.Return(directToBuffer: false, toPlayerInventory: true, (!splitedItem.Stackable) ? 1 : splitedItem.StackCount);
		splitedItem.Detach();
		splitedItem.DestroyTree();
		return true;
	}

	public static bool CanDecompose(int itemTypeID)
	{
		if (Instance == null)
		{
			return false;
		}
		return Instance.GetFormula(itemTypeID).valid;
	}

	public static bool CanDecompose(Item item)
	{
		if (item == null)
		{
			return false;
		}
		return CanDecompose(item.TypeID);
	}

	public static DecomposeFormula GetDecomposeFormula(int itemTypeID)
	{
		if (Instance == null)
		{
			return default(DecomposeFormula);
		}
		return Instance.GetFormula(itemTypeID);
	}

	public void SetData(List<DecomposeFormula> formulas)
	{
		entries = formulas.ToArray();
	}
}
[Serializable]
public struct DecomposeFormula
{
	[ItemTypeID]
	public int item;

	public bool valid;

	public Cost result;
}
public class InteractCrafter : InteractableBase
{
	public string requireTag;

	protected override void Awake()
	{
		base.Awake();
		finishWhenTimeOut = true;
	}

	protected override void OnInteractFinished()
	{
		base.OnInteractFinished();
		CraftView.SetupAndOpenView(FilterCraft);
	}

	private bool FilterCraft(CraftingFormula formula)
	{
		if (requireTag.IsNullOrWhitespace())
		{
			return true;
		}
		if (formula.tags.Contains(requireTag))
		{
			return true;
		}
		return false;
	}
}
public class CraftView : View, ISingleSelectionMenu<CraftView_ListEntry>
{
	[Serializable]
	public struct FilterInfo
	{
		[LocalizationKey("Default")]
		[SerializeField]
		public string displayNameKey;

		[SerializeField]
		public Sprite icon;

		[SerializeField]
		public Tag[] requireTags;
	}

	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private CraftView_ListEntry listEntryTemplate;

	private PrefabPool<CraftView_ListEntry> _listEntryPool;

	[SerializeField]
	private FadeGroup detailsFadeGroup;

	[SerializeField]
	private FadeGroup loadingIndicator;

	[SerializeField]
	private FadeGroup placeHolderFadeGroup;

	[SerializeField]
	private ItemDetailsDisplay detailsDisplay;

	[SerializeField]
	private CostDisplay costDisplay;

	[SerializeField]
	private Color crafableColor;

	[SerializeField]
	private Color notCraftableColor;

	[SerializeField]
	private UnityEngine.UI.Image buttonImage;

	[SerializeField]
	private UnityEngine.UI.Button craftButton;

	[LocalizationKey("Default")]
	[SerializeField]
	private string notificationFormatKey;

	[SerializeField]
	private CraftViewFilterBtnEntry filterBtnTemplate;

	[SerializeField]
	private FilterInfo[] filters;

	private PrefabPool<CraftViewFilterBtnEntry> _filterBtnPool;

	private int currentFilterIndex;

	private bool crafting;

	private Predicate<CraftingFormula> predicate;

	private CraftView_ListEntry selectedEntry;

	private int refreshTaskToken;

	private Item tempItem;

	private static CraftView Instance => View.GetViewInstance<CraftView>();

	private PrefabPool<CraftView_ListEntry> ListEntryPool
	{
		get
		{
			if (_listEntryPool == null)
			{
				_listEntryPool = new PrefabPool<CraftView_ListEntry>(listEntryTemplate);
			}
			return _listEntryPool;
		}
	}

	private string NotificationFormat => notificationFormatKey.ToPlainText();

	private PrefabPool<CraftViewFilterBtnEntry> FilterBtnPool
	{
		get
		{
			if (_filterBtnPool == null)
			{
				_filterBtnPool = new PrefabPool<CraftViewFilterBtnEntry>(filterBtnTemplate);
			}
			return _filterBtnPool;
		}
	}

	private FilterInfo CurrentFilter
	{
		get
		{
			if (currentFilterIndex < 0 || currentFilterIndex >= filters.Length)
			{
				currentFilterIndex = 0;
			}
			return filters[currentFilterIndex];
		}
	}

	public void SetFilter(int index)
	{
		if (index >= 0 && index < filters.Length)
		{
			currentFilterIndex = index;
			selectedEntry = null;
			RefreshDetails();
			RefreshList(predicate);
			RefreshFilterButtons();
		}
	}

	private static bool CheckFilter(CraftingFormula formula, FilterInfo filter)
	{
		if (filter.requireTags.Length == 0)
		{
			return true;
		}
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(formula.result.id);
		Tag[] requireTags = filter.requireTags;
		foreach (Tag value in requireTags)
		{
			if (metaData.tags.Contains(value))
			{
				return true;
			}
		}
		return false;
	}

	protected override void Awake()
	{
		base.Awake();
		listEntryTemplate.gameObject.SetActive(value: false);
		craftButton.onClick.AddListener(OnCraftButtonClicked);
	}

	private void OnCraftButtonClicked()
	{
		CraftTask().Forget();
	}

	private async UniTask CraftTask()
	{
		if (!crafting && !(selectedEntry == null) && !(CraftingManager.Instance == null))
		{
			crafting = true;
			List<Item> list = await CraftingManager.Instance.Craft(selectedEntry.Formula.id);
			if (list != null)
			{
				foreach (Item item in list)
				{
					OnCraftFinished(item);
				}
			}
		}
		crafting = false;
	}

	private void OnCraftFinished(Item item)
	{
		if (!(item == null))
		{
			string displayName = item.DisplayName;
			NotificationText.Push(NotificationFormat.Format(new
			{
				itemDisplayName = displayName
			}));
		}
	}

	protected override void OnOpen()
	{
		base.OnOpen();
		fadeGroup.Show();
		SetFilter(0);
	}

	protected override void OnClose()
	{
		base.OnClose();
		fadeGroup.Hide();
	}

	public static void SetupAndOpenView(Predicate<CraftingFormula> predicate)
	{
		if ((bool)Instance)
		{
			Instance.SetupAndOpen(predicate);
		}
	}

	public void SetupAndOpen(Predicate<CraftingFormula> predicate)
	{
		this.predicate = predicate;
		detailsFadeGroup.SkipHide();
		loadingIndicator.SkipHide();
		placeHolderFadeGroup.SkipShow();
		selectedEntry = null;
		RefreshDetails();
		RefreshList(predicate);
		RefreshFilterButtons();
		Open();
	}

	private void RefreshList(Predicate<CraftingFormula> predicate)
	{
		ListEntryPool.ReleaseAll();
		IEnumerable<string> unlockedFormulaIDs = CraftingManager.UnlockedFormulaIDs;
		FilterInfo currentFilter = CurrentFilter;
		bool flag = currentFilter.requireTags != null && currentFilter.requireTags.Length != 0;
		foreach (string item in unlockedFormulaIDs)
		{
			if (CraftingFormulaCollection.TryGetFormula(item, out var formula) && predicate(formula) && (!flag || CheckFilter(formula, currentFilter)))
			{
				ListEntryPool.Get().Setup(this, formula);
			}
		}
	}

	private int CountFilter(FilterInfo filter)
	{
		IEnumerable<string> unlockedFormulaIDs = CraftingManager.UnlockedFormulaIDs;
		bool flag = filter.requireTags != null && filter.requireTags.Length != 0;
		int num = 0;
		foreach (string item in unlockedFormulaIDs)
		{
			if (CraftingFormulaCollection.TryGetFormula(item, out var formula) && predicate(formula) && (!flag || CheckFilter(formula, filter)))
			{
				num++;
			}
		}
		return num;
	}

	private void RefreshFilterButtons()
	{
		FilterBtnPool.ReleaseAll();
		int num = 0;
		FilterInfo[] array = filters;
		foreach (FilterInfo filterInfo in array)
		{
			if (CountFilter(filterInfo) < 1)
			{
				num++;
				continue;
			}
			FilterBtnPool.Get().Setup(this, filterInfo, num, num == currentFilterIndex);
			num++;
		}
	}

	public CraftView_ListEntry GetSelection()
	{
		return selectedEntry;
	}

	public bool SetSelection(CraftView_ListEntry selection)
	{
		if (selectedEntry != null)
		{
			CraftView_ListEntry craftView_ListEntry = selectedEntry;
			selectedEntry = null;
			craftView_ListEntry.NotifyUnselected();
		}
		selectedEntry = selection;
		selectedEntry.NotifySelected();
		RefreshDetails();
		return true;
	}

	private void RefreshDetails()
	{
		RefreshTask(NewRefreshToken()).Forget();
	}

	private int NewRefreshToken()
	{
		int num;
		do
		{
			num = UnityEngine.Random.Range(0, int.MaxValue);
		}
		while (num == refreshTaskToken);
		refreshTaskToken = num;
		return num;
	}

	private async UniTask RefreshTask(int token)
	{
		if (selectedEntry == null)
		{
			detailsFadeGroup.Hide();
			loadingIndicator.Hide();
			placeHolderFadeGroup.Show();
			return;
		}
		detailsFadeGroup.Hide();
		placeHolderFadeGroup.Hide();
		loadingIndicator.Show();
		if (tempItem != null)
		{
			UnityEngine.Object.Destroy(tempItem);
		}
		CraftingFormula formula = selectedEntry.Formula;
		int itemID = formula.result.id;
		tempItem = await ItemAssetsCollection.InstantiateAsync(itemID);
		if (token != refreshTaskToken)
		{
			return;
		}
		if (tempItem == null)
		{
			UnityEngine.Debug.LogError($"Failed to create item of id {itemID}");
			return;
		}
		if (tempItem.Stackable)
		{
			tempItem.StackCount = formula.result.amount;
		}
		buttonImage.color = (selectedEntry.Formula.cost.Enough ? crafableColor : notCraftableColor);
		detailsDisplay.Setup(tempItem);
		costDisplay.Setup(formula.cost);
		detailsFadeGroup.Show();
		loadingIndicator.Hide();
	}

	private void TestShow()
	{
		CraftingManager.UnlockFormula("Biscuit");
		CraftingManager.UnlockFormula("Character");
		SetupAndOpen((CraftingFormula e) => true);
	}
}
public class CraftViewFilterBtnEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private UnityEngine.UI.Image icon;

	[SerializeField]
	private TextMeshProUGUI displayNameText;

	[SerializeField]
	private GameObject selectedIndicator;

	private CraftView.FilterInfo info;

	private CraftView master;

	private int index;

	public void OnPointerClick(PointerEventData eventData)
	{
		if (!(master == null))
		{
			master.SetFilter(index);
		}
	}

	public void Setup(CraftView master, CraftView.FilterInfo filterInfo, int index, bool selected)
	{
		this.master = master;
		info = filterInfo;
		this.index = index;
		icon.sprite = filterInfo.icon;
		displayNameText.text = filterInfo.displayNameKey.ToPlainText();
		selectedIndicator.SetActive(selected);
	}
}
public class CraftView_ListEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private Color normalColor;

	[SerializeField]
	private Color selectedColor;

	[SerializeField]
	private UnityEngine.UI.Image icon;

	[SerializeField]
	private UnityEngine.UI.Image background;

	[SerializeField]
	private TextMeshProUGUI nameText;

	public CraftView Master { get; private set; }

	public CraftingFormula Formula { get; private set; }

	public void Setup(CraftView master, CraftingFormula formula)
	{
		Master = master;
		Formula = formula;
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(Formula.result.id);
		icon.sprite = metaData.icon;
		nameText.text = $"{metaData.DisplayName} x{formula.result.amount}";
		Refresh();
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		Master?.SetSelection(this);
	}

	internal void NotifyUnselected()
	{
		Refresh();
	}

	internal void NotifySelected()
	{
		Refresh();
	}

	private void Refresh()
	{
		if (!(Master == null))
		{
			bool flag = Master.GetSelection() == this;
			background.color = (flag ? selectedColor : normalColor);
		}
	}
}
public class Temp : MonoBehaviour
{
	private void Calculate(float fps = 100f)
	{
		float num = 1f / fps;
		int num2 = 7;
		float num3 = 3f;
		float num4 = 3f;
		int num5 = 2;
		int num6 = 15;
		List<float> list = new List<float>();
		List<float> list2 = new List<float>();
		for (float num7 = 0f; num7 <= 100f; num7 += num)
		{
			while (num6 >= num2)
			{
				num6 -= num2;
				list.Add(0f);
			}
			for (int i = 0; i < list.Count; i++)
			{
				float num8 = list[i];
				num8 += num;
				if (num8 >= num3)
				{
					list.RemoveAt(i);
					i--;
					list2.Add(0f);
				}
				else
				{
					list[i] = num8;
				}
			}
			for (int j = 0; j < list2.Count; j++)
			{
				float num9 = list2[j];
				num9 += num;
				while (num9 > num4)
				{
					num9 -= num4;
					num6 += num5;
				}
				list2[j] = num9;
			}
		}
		UnityEngine.Debug.Log($"{list2.Count} {num6}");
	}
}
public class ItemTest : MonoBehaviour
{
	public Item characterTemplate;

	public Item swordTemplate;

	public Item characterInstance;

	public Item swordInstance;

	public void DoInstantiate()
	{
		characterInstance = characterTemplate.CreateInstance();
		swordInstance = swordTemplate.CreateInstance();
	}

	public void EquipSword()
	{
		characterInstance.Slots["Weapon"].Plug(swordInstance, out var _);
	}

	public void UequipSword()
	{
		characterInstance.Slots["Weapon"].Unplug();
	}

	public void DestroyInstances()
	{
		if ((bool)characterInstance)
		{
			characterInstance.DestroyTreeImmediate();
		}
		if ((bool)swordInstance)
		{
			swordInstance.DestroyTreeImmediate();
		}
	}
}
public class DialogueBubbleProxy : MonoBehaviour
{
	[LocalizationKey("Dialogues")]
	public string textKey;

	public float yOffset;

	public float duration = 2f;

	public void Pop()
	{
		DialogueBubblesManager.Show(textKey.ToPlainText(), base.transform, yOffset, needInteraction: false, skippable: false, -1f, duration).Forget();
	}

	public void Pop(string text, float speed = -1f)
	{
		DialogueBubblesManager.Show(text, base.transform, yOffset, needInteraction: false, skippable: false, speed).Forget();
	}

	private void OnDrawGizmos()
	{
		Gizmos.color = Color.blue;
		Gizmos.DrawCube(base.transform.position + Vector3.up * yOffset, Vector3.one * 0.2f);
	}
}
public class CutScene : MonoBehaviour
{
	public enum PlayTiming
	{
		Start = 0,
		OnTriggerEnter = 2,
		Manual = 3
	}

	[SerializeField]
	private string id;

	[SerializeField]
	private bool playOnce = true;

	[SerializeField]
	private bool setActiveFalseWhenFinished = true;

	[SerializeField]
	private bool setupActorReferencesUsingIDs;

	[SerializeField]
	private Collider trigger;

	[SerializeField]
	private List<Condition> prerequisites = new List<Condition>();

	[SerializeField]
	private FSMOwner fsmOwner;

	[SerializeField]
	private DialogueTreeController dialogueTreeOwner;

	[SerializeField]
	private PlayTiming playTiming;

	private bool playing;

	private string SaveKey => "CutScene_" + id;

	private bool UseTrigger => playTiming == PlayTiming.OnTriggerEnter;

	private bool HideFSMOwnerField
	{
		get
		{
			if (!fsmOwner)
			{
				return dialogueTreeOwner;
			}
			return false;
		}
	}

	private bool HideDialogueTreeOwnerField
	{
		get
		{
			if ((bool)fsmOwner)
			{
				return !dialogueTreeOwner;
			}
			return false;
		}
	}

	private bool Played => SavesSystem.Load<bool>(SaveKey);

	public void MarkPlayed()
	{
		if (!string.IsNullOrWhiteSpace(id))
		{
			SavesSystem.Save(SaveKey, value: true);
		}
	}

	private void OnEnable()
	{
	}

	private void Awake()
	{
		if (UseTrigger)
		{
			InitializeTrigger();
		}
	}

	private void InitializeTrigger()
	{
		if (trigger == null)
		{
			UnityEngine.Debug.LogError("CutScene想要使用Trigger触发，但没有配置Trigger引用。", this);
		}
		OnTriggerEnterEvent onTriggerEnterEvent = trigger.AddComponent<OnTriggerEnterEvent>();
		onTriggerEnterEvent.onlyMainCharacter = true;
		onTriggerEnterEvent.triggerOnce = true;
		onTriggerEnterEvent.DoOnTriggerEnter.AddListener(PlayIfNessisary);
	}

	private void Start()
	{
		if (playTiming == PlayTiming.Start)
		{
			PlayIfNessisary();
		}
	}

	private void Update()
	{
		if (!playing)
		{
			return;
		}
		if ((bool)fsmOwner)
		{
			if (!fsmOwner.isRunning)
			{
				playing = false;
				OnPlayFinished();
			}
		}
		else if ((bool)dialogueTreeOwner && !dialogueTreeOwner.isRunning)
		{
			playing = false;
			OnPlayFinished();
		}
	}

	private void OnPlayFinished()
	{
		MarkPlayed();
		if (setActiveFalseWhenFinished)
		{
			base.gameObject.SetActive(value: false);
		}
		if (playOnce && string.IsNullOrWhiteSpace(id))
		{
			UnityEngine.Debug.LogError("CutScene没有填写ID，无法记录", base.gameObject);
		}
	}

	public void PlayIfNessisary()
	{
		if (playOnce && Played)
		{
			base.gameObject.SetActive(value: false);
		}
		else if (prerequisites.Satisfied())
		{
			Play();
		}
	}

	public void Play()
	{
		if ((bool)fsmOwner)
		{
			fsmOwner.StartBehaviour();
			playing = true;
		}
		else if ((bool)dialogueTreeOwner)
		{
			if (setupActorReferencesUsingIDs)
			{
				SetupActors();
			}
			dialogueTreeOwner.StartBehaviour();
			playing = true;
		}
	}

	private void SetupActors()
	{
		if (dialogueTreeOwner == null)
		{
			return;
		}
		if (dialogueTreeOwner.behaviour == null)
		{
			UnityEngine.Debug.LogError("Dialoguetree没有配置", dialogueTreeOwner);
			return;
		}
		foreach (DialogueTree.ActorParameter actorParameter in dialogueTreeOwner.behaviour.actorParameters)
		{
			string text = actorParameter.name;
			if (!string.IsNullOrEmpty(text))
			{
				DuckovDialogueActor duckovDialogueActor = DuckovDialogueActor.Get(text);
				if (duckovDialogueActor == null)
				{
					UnityEngine.Debug.LogError("未找到actor ID:" + text);
				}
				else
				{
					dialogueTreeOwner.SetActorReference(text, duckovDialogueActor);
				}
			}
		}
	}
}
public class DuckovDialogueActor : MonoBehaviour, IDialogueActor
{
	private static List<DuckovDialogueActor> _activeActors;

	[SerializeField]
	private string id;

	[SerializeField]
	private Sprite _portraitSprite;

	[SerializeField]
	[LocalizationKey("Default")]
	private string nameKey;

	[SerializeField]
	private Vector3 offset;

	private static List<DuckovDialogueActor> ActiveActors
	{
		get
		{
			if (_activeActors == null)
			{
				_activeActors = new List<DuckovDialogueActor>();
			}
			return _activeActors;
		}
	}

	public string ID => id;

	public Vector3 Offset => offset;

	public string NameKey => nameKey;

	public Texture2D portrait => null;

	public Sprite portraitSprite => _portraitSprite;

	public Color dialogueColor => default(Color);

	public Vector3 dialoguePosition => default(Vector3);

	public static void Register(DuckovDialogueActor actor)
	{
		if (ActiveActors.Contains(actor))
		{
			UnityEngine.Debug.Log("Actor " + actor.nameKey + " 在重复注册", actor);
		}
		else
		{
			ActiveActors.Add(actor);
		}
	}

	public static void Unregister(DuckovDialogueActor actor)
	{
		ActiveActors.Remove(actor);
	}

	public static DuckovDialogueActor Get(string id)
	{
		return ActiveActors.Find((DuckovDialogueActor e) => e.ID == id);
	}

	private void OnEnable()
	{
		Register(this);
	}

	private void OnDisable()
	{
		Unregister(this);
	}

	string IDialogueActor.get_name()
	{
		return base.name;
	}

	Transform IDialogueActor.get_transform()
	{
		return base.transform;
	}
}
public class AT_SetBlackScreen : ActionTask
{
	public bool show;

	private UniTask task;

	protected override void OnExecute()
	{
		if (show)
		{
			task = BlackScreen.ShowAndReturnTask();
		}
		else
		{
			task = BlackScreen.HideAndReturnTask();
		}
	}

	protected override void OnUpdate()
	{
		if (task.Status != UniTaskStatus.Pending)
		{
			EndAction();
		}
	}
}
public class AT_SetVirtualCamera : ActionTask
{
	private static CinemachineVirtualCamera cachedVCam;

	public BBParameter<CinemachineVirtualCamera> target;

	protected override string info => "Set camera :" + ((target.value == null) ? "Empty" : target.value.name);

	protected override void OnExecute()
	{
		base.OnExecute();
		if (cachedVCam != null)
		{
			cachedVCam.gameObject.SetActive(value: false);
		}
		if (target.value != null)
		{
			target.value.gameObject.SetActive(value: true);
			cachedVCam = target.value;
		}
		else
		{
			cachedVCam = null;
		}
		EndAction();
	}
}
public class FormulasDetailsDisplay : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI nameText;

	[SerializeField]
	private UnityEngine.UI.Image image;

	[SerializeField]
	private TextMeshProUGUI descriptionText;

	[SerializeField]
	private CostDisplay costDisplay;

	[SerializeField]
	private FadeGroup contentFadeGroup;

	[SerializeField]
	private FadeGroup placeHolderFadeGroup;

	[SerializeField]
	private Sprite unknownImage;

	private CraftingFormula formula;

	private void SetupEmpty()
	{
		contentFadeGroup.Hide();
		placeHolderFadeGroup.Show();
	}

	private void SetupFormula(CraftingFormula formula)
	{
		this.formula = formula;
		RefreshContent();
		contentFadeGroup.Show();
		placeHolderFadeGroup.Hide();
	}

	private void RefreshContent()
	{
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(formula.result.id);
		nameText.text = metaData.DisplayName;
		descriptionText.text = metaData.Description;
		image.sprite = metaData.icon;
		costDisplay.Setup(formula.cost);
	}

	public void Setup(CraftingFormula? formula)
	{
		if (!formula.HasValue)
		{
			SetupEmpty();
		}
		else if (!CraftingManager.IsFormulaUnlocked(formula.Value.id))
		{
			SetupUnknown();
		}
		else
		{
			SetupFormula(formula.Value);
		}
	}

	private void SetupUnknown()
	{
		nameText.text = "???";
		descriptionText.text = "???";
		image.sprite = unknownImage;
		contentFadeGroup.Show();
		placeHolderFadeGroup.Hide();
		costDisplay.Setup(default(Cost));
	}
}
public class FormulasRegisterViewInvoker : InteractableBase
{
	[SerializeField]
	private List<Tag> additionalTags;

	protected override void Awake()
	{
		base.Awake();
		finishWhenTimeOut = true;
	}

	protected override void OnInteractFinished()
	{
		FormulasRegisterView.Show(additionalTags);
	}
}
public class DevCam : MonoBehaviour
{
	public Camera devCamera;

	public Transform postTarget;

	private bool active;

	public Transform root;

	public static bool devCamOn;

	private float timer = 1.5f;

	private int pressCounter;

	private void Awake()
	{
		root.gameObject.SetActive(value: false);
		Shader.SetGlobalFloat("DevCamOn", 0f);
		devCamOn = false;
	}

	private void Toggle()
	{
		active = true;
		devCamOn = active;
		Shader.SetGlobalFloat("DevCamOn", active ? 1f : 0f);
		root.gameObject.SetActive(active);
		for (int i = 0; i < Display.displays.Length; i++)
		{
			if (i == 1 && active)
			{
				Display.displays[i].Activate();
			}
		}
		UniversalRenderPipelineAsset universalRenderPipelineAsset = GraphicsSettings.currentRenderPipeline as UniversalRenderPipelineAsset;
		if (universalRenderPipelineAsset != null)
		{
			universalRenderPipelineAsset.shadowDistance = 500f;
		}
	}

	private void OnDestroy()
	{
		devCamOn = false;
	}

	private void Update()
	{
		if (!LevelManager.LevelInited || Gamepad.all.Count <= 0)
		{
			return;
		}
		timer -= Time.deltaTime;
		if (timer <= 0f)
		{
			timer = 0f;
			pressCounter = 0;
		}
		if (Gamepad.current.leftStickButton.isPressed && Gamepad.current.rightStickButton.wasPressedThisFrame)
		{
			pressCounter++;
			timer = 1.5f;
			UnityEngine.Debug.Log("Toggle Dev Cam");
			if (pressCounter >= 2)
			{
				pressCounter = 0;
				Toggle();
			}
		}
		if (CharacterMainControl.Main != null)
		{
			postTarget.position = CharacterMainControl.Main.transform.position;
		}
	}
}
public class FreeCameraController : MonoBehaviour
{
	[SerializeField]
	private CameraPropertiesControl propertiesControl;

	[SerializeField]
	private float moveSpeed = 10f;

	[SerializeField]
	private float rotateSpeed = 180f;

	[SerializeField]
	private float smoothTime = 2f;

	[SerializeField]
	private Vector2 minMaxXRotation = new Vector2(-89f, 89f);

	[SerializeField]
	private bool projectMovementOnXZPlane;

	[Range(-180f, 180f)]
	private float yaw;

	[Range(-89f, 89f)]
	private float pitch;

	[SerializeField]
	private CinemachineVirtualCamera vCamera;

	private bool followCharacter;

	private Vector3 offsetFromCharacter;

	private Vector3 worldPosTarget;

	private Vector3 velocityWorldSpace;

	private Vector3 velocityLocalSpace;

	private float yawVelocity;

	private float pitchVelocity;

	private float yawTarget;

	private float pitchTarget;

	private Gamepad Gamepad => Gamepad.current;

	private void Awake()
	{
		if (!propertiesControl)
		{
			propertiesControl = GetComponent<CameraPropertiesControl>();
		}
	}

	private void OnEnable()
	{
		SetRotation(base.transform.rotation);
		SnapToMainCamera();
	}

	public void SetRotation(Quaternion rotation)
	{
		Vector3 eulerAngles = rotation.eulerAngles;
		yaw = eulerAngles.y;
		pitch = eulerAngles.x;
		yawTarget = yaw;
		pitchTarget = pitch;
		if (pitch > 180f)
		{
			pitch -= 360f;
		}
		if (pitch < -180f)
		{
			pitch += 360f;
		}
		pitch = Mathf.Clamp(pitch, -89f, 89f);
		base.transform.rotation = Quaternion.Euler(pitch, yaw, 0f);
	}

	private void Update()
	{
		if (Gamepad == null)
		{
			return;
		}
		bool isPressed = Gamepad.rightShoulder.isPressed;
		float num = moveSpeed * (float)((!isPressed) ? 1 : 2);
		CharacterMainControl main = CharacterMainControl.Main;
		Vector2 value = Gamepad.leftStick.value;
		float num2 = Gamepad.rightTrigger.value - Gamepad.leftTrigger.value;
		Vector3 vector = new Vector3(value.x * num, 0f, value.y * num) * Time.unscaledDeltaTime;
		Vector3 obj = (projectMovementOnXZPlane ? Vector3.ProjectOnPlane(base.transform.forward, Vector3.up).normalized : base.transform.forward);
		Vector3 vector2 = (projectMovementOnXZPlane ? Vector3.ProjectOnPlane(base.transform.right, Vector3.up).normalized : base.transform.right);
		Vector3 vector3 = num2 * Vector3.up * num * 0.5f * Time.unscaledDeltaTime;
		Vector3 vector4 = obj * vector.z + vector2 * vector.x + vector3;
		if (!followCharacter || main == null)
		{
			worldPosTarget += vector4;
			base.transform.position = Vector3.SmoothDamp(base.transform.position, worldPosTarget, ref velocityWorldSpace, smoothTime, 20f, 10f * Time.unscaledDeltaTime);
			if (main == null)
			{
				followCharacter = false;
			}
		}
		else
		{
			offsetFromCharacter += vector4;
			base.transform.position = Vector3.SmoothDamp(base.transform.position, main.transform.position + offsetFromCharacter, ref velocityLocalSpace, smoothTime, 20f, 10f * Time.unscaledDeltaTime);
		}
		Vector3 vector5 = Gamepad.rightStick.value * rotateSpeed * vCamera.m_Lens.FieldOfView / 60f;
		yawTarget += vector5.x * Time.unscaledDeltaTime;
		yaw = Mathf.SmoothDamp(yaw, yawTarget, ref yawVelocity, smoothTime, 20f, 10f * Time.unscaledDeltaTime);
		pitchTarget += (0f - vector5.y) * Time.unscaledDeltaTime;
		pitch = Mathf.SmoothDamp(pitch, pitchTarget, ref pitchVelocity, smoothTime, 20f, 10f * Time.unscaledDeltaTime);
		pitch = Mathf.Clamp(pitch, -89f, 89f);
		base.transform.rotation = Quaternion.Euler(pitch, yaw, 0f);
		if (Gamepad.buttonNorth.wasPressedThisFrame)
		{
			SnapToMainCamera();
		}
		if (Gamepad.buttonEast.wasPressedThisFrame)
		{
			ToggleFollowTarget();
		}
	}

	private void OnDestroy()
	{
	}

	private void ToggleFollowTarget()
	{
		CharacterMainControl main = CharacterMainControl.Main;
		if (!(main == null))
		{
			followCharacter = !followCharacter;
			if (followCharacter)
			{
				offsetFromCharacter = base.transform.position - main.transform.position;
			}
			worldPosTarget = base.transform.position;
		}
	}

	private void SnapToMainCamera()
	{
		if (GameCamera.Instance == null)
		{
			return;
		}
		Camera renderCamera = GameCamera.Instance.renderCamera;
		if (!(renderCamera == null))
		{
			base.transform.position = renderCamera.transform.position;
			worldPosTarget = renderCamera.transform.position;
			vCamera.m_Lens.FieldOfView = renderCamera.fieldOfView;
			SetRotation(renderCamera.transform.rotation);
			CharacterMainControl main = CharacterMainControl.Main;
			if (main != null && followCharacter)
			{
				offsetFromCharacter = base.transform.position - main.transform.position;
			}
		}
	}
}
public class FXPool : MonoBehaviour
{
	private class Pool
	{
		private ParticleSystem prefab;

		private Transform parent;

		private UnityEngine.Pool.ObjectPool<ParticleSystem> pool;

		private Action<ParticleSystem> onCreate;

		private Action<ParticleSystem> onGet;

		private Action<ParticleSystem> onRelease;

		private Action<ParticleSystem> onDestroy;

		private List<ParticleSystem> activeEntries = new List<ParticleSystem>();

		public Pool(ParticleSystem prefab, Transform parent, Action<ParticleSystem> onCreate = null, Action<ParticleSystem> onGet = null, Action<ParticleSystem> onRelease = null, Action<ParticleSystem> onDestroy = null, bool collectionCheck = true, int defaultCapacity = 10, int maxSize = 100)
		{
			this.prefab = prefab;
			this.parent = parent;
			pool = new UnityEngine.Pool.ObjectPool<ParticleSystem>(Create, OnEntryGet, OnEntryRelease, OnEntryDestroy, collectionCheck, defaultCapacity, maxSize);
			this.onCreate = onCreate;
			this.onGet = onGet;
			this.onRelease = onRelease;
			this.onDestroy = onDestroy;
		}

		private ParticleSystem Create()
		{
			ParticleSystem particleSystem = UnityEngine.Object.Instantiate(prefab, parent);
			onCreate?.Invoke(particleSystem);
			return particleSystem;
		}

		public void OnEntryGet(ParticleSystem obj)
		{
			activeEntries.Add(obj);
		}

		public void OnEntryRelease(ParticleSystem obj)
		{
			activeEntries.Remove(obj);
			obj.gameObject.SetActive(value: false);
		}

		public void OnEntryDestroy(ParticleSystem obj)
		{
			onDestroy?.Invoke(obj);
		}

		public ParticleSystem Get()
		{
			return pool.Get();
		}

		public void Release(ParticleSystem obj)
		{
			pool.Release(obj);
		}

		public void Tick()
		{
			List<ParticleSystem> list = new List<ParticleSystem>();
			foreach (ParticleSystem activeEntry in activeEntries)
			{
				if (!activeEntry.isPlaying)
				{
					list.Add(activeEntry);
				}
			}
			foreach (ParticleSystem item in list)
			{
				Release(item);
			}
		}
	}

	private Dictionary<ParticleSystem, Pool> poolsDic;

	public static FXPool Instance { get; private set; }

	private void Awake()
	{
		Instance = this;
	}

	private void FixedUpdate()
	{
		if (poolsDic == null)
		{
			return;
		}
		foreach (Pool value in poolsDic.Values)
		{
			value.Tick();
		}
	}

	private Pool GetOrCreatePool(ParticleSystem prefab)
	{
		if (poolsDic == null)
		{
			poolsDic = new Dictionary<ParticleSystem, Pool>();
		}
		if (poolsDic.TryGetValue(prefab, out var value))
		{
			return value;
		}
		Pool pool = new Pool(prefab, base.transform);
		poolsDic[prefab] = pool;
		return pool;
	}

	private static ParticleSystem Get(ParticleSystem prefab)
	{
		if (Instance == null)
		{
			return null;
		}
		return Instance.GetOrCreatePool(prefab).Get();
	}

	public static ParticleSystem Play(ParticleSystem prefab, Vector3 postion, Quaternion rotation)
	{
		if (Instance == null)
		{
			return null;
		}
		if (prefab == null)
		{
			return null;
		}
		ParticleSystem particleSystem = Get(prefab);
		particleSystem.transform.position = postion;
		particleSystem.transform.rotation = rotation;
		particleSystem.gameObject.SetActive(value: true);
		particleSystem.Play();
		return particleSystem;
	}

	public static ParticleSystem Play(ParticleSystem prefab, Vector3 postion, Quaternion rotation, Color color)
	{
		if (Instance == null)
		{
			return null;
		}
		if (prefab == null)
		{
			return null;
		}
		ParticleSystem particleSystem = Get(prefab);
		particleSystem.transform.position = postion;
		particleSystem.transform.rotation = rotation;
		particleSystem.gameObject.SetActive(value: true);
		ParticleSystem.MainModule main = particleSystem.main;
		main.startColor = color;
		particleSystem.Play();
		return particleSystem;
	}
}
public class GameClock : MonoBehaviour
{
	[Serializable]
	private struct SaveData
	{
		public long days;

		public double secondsOfDay;

		public long realTimePlayedTicks;

		public TimeSpan RealTimePlayed => TimeSpan.FromTicks(realTimePlayedTicks);
	}

	public float clockTimeScale = 60f;

	private long days;

	private double secondsOfDay;

	private TimeSpan realTimePlayed;

	private const double SecondsPerDay = 86300.0;

	public static GameClock Instance { get; private set; }

	private static string SaveKey => "GameClock";

	private TimeSpan RealTimePlayed => realTimePlayed;

	private static double SecondsOfDay
	{
		get
		{
			if (Instance == null)
			{
				return 0.0;
			}
			return Instance.secondsOfDay;
		}
	}

	[TimeSpan]
	private long _TimeOfDayTicks => TimeOfDay.Ticks;

	public static TimeSpan TimeOfDay => TimeSpan.FromSeconds(SecondsOfDay);

	public static long Day
	{
		get
		{
			if (Instance == null)
			{
				return 0L;
			}
			return Instance.days;
		}
	}

	public static TimeSpan Now => TimeOfDay + TimeSpan.FromDays(Day);

	public static int Hour => TimeOfDay.Hours;

	public static int Minut => TimeOfDay.Minutes;

	public static int Seconds => TimeOfDay.Seconds;

	public static int Milliseconds => TimeOfDay.Milliseconds;

	public static event Action OnGameClockStep;

	private void Awake()
	{
		if (Instance != null)
		{
			UnityEngine.Debug.LogError("检测到多个Game Clock");
			return;
		}
		Instance = this;
		SavesSystem.OnCollectSaveData += Save;
		Load();
	}

	private void OnDestroy()
	{
		SavesSystem.OnCollectSaveData -= Save;
	}

	private void Save()
	{
		SavesSystem.Save(SaveKey, new SaveData
		{
			days = days,
			secondsOfDay = secondsOfDay,
			realTimePlayedTicks = RealTimePlayed.Ticks
		});
	}

	private void Load()
	{
		SaveData saveData = SavesSystem.Load<SaveData>(SaveKey);
		days = saveData.days;
		secondsOfDay = saveData.secondsOfDay;
		realTimePlayed = saveData.RealTimePlayed;
		GameClock.OnGameClockStep?.Invoke();
	}

	public static TimeSpan GetRealTimePlayedOfSaveSlot(int saveSlot)
	{
		return SavesSystem.Load<SaveData>(SaveKey, saveSlot).RealTimePlayed;
	}

	private void Update()
	{
		StepTime(Time.deltaTime * clockTimeScale);
		realTimePlayed += TimeSpan.FromSeconds(Time.unscaledDeltaTime);
	}

	private void StepTime(float deltaTime)
	{
		secondsOfDay += deltaTime;
		while (secondsOfDay > 86300.0)
		{
			days++;
			secondsOfDay -= 86300.0;
		}
		GameClock.OnGameClockStep?.Invoke();
	}

	public void StepTimeTil(TimeSpan time)
	{
		if (time.Days > 0)
		{
			time = new TimeSpan(time.Hours, time.Minutes, time.Seconds);
		}
		StepTime((float)((!(time > TimeOfDay)) ? (time + TimeSpan.FromDays(1.0) - TimeOfDay) : (time - TimeOfDay)).TotalSeconds);
	}

	internal static void Step(float seconds)
	{
		if (!(Instance == null))
		{
			Instance.StepTime(seconds);
		}
	}
}
public class GameClockDisplay : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI text;

	private void Awake()
	{
		Refresh();
	}

	private void OnEnable()
	{
		GameClock.OnGameClockStep += Refresh;
	}

	private void OnDisable()
	{
		GameClock.OnGameClockStep -= Refresh;
	}

	private void Refresh()
	{
		string text = ((!(GameClock.Instance == null)) ? $"{GameClock.Hour:00}:{GameClock.Minut:00}" : "--:--");
		this.text.text = text;
	}
}
public class InputRebinder : MonoBehaviour
{
	[UnityEngine.Header("Debug")]
	[SerializeField]
	private string action = "MoveAxis";

	[SerializeField]
	private int index = 2;

	[SerializeField]
	private string[] excludes = new string[5] { "<Mouse>/leftButton", "<Mouse>/rightButton", "<Pointer>/position", "<Pointer>/delta", "<Pointer>/Press" };

	public static Action<InputAction> OnRebindBegin;

	public static Action<InputAction> OnRebindComplete;

	public static Action OnBindingChanged;

	private static InputActionRebindingExtensions.RebindingOperation operation = new InputActionRebindingExtensions.RebindingOperation();

	private const string SaveKey = "InputBinding";

	private static PlayerInput PlayerInput => GameManager.MainPlayerInput;

	private static bool OperationPending
	{
		get
		{
			if (operation.started)
			{
				if (!operation.canceled)
				{
					return !operation.completed;
				}
				return false;
			}
			return false;
		}
	}

	public void Rebind()
	{
		RebindAsync(action, index, excludes).Forget();
	}

	private void Awake()
	{
		Load();
		UIInputManager.OnCancelEarly += OnUICancel;
	}

	private void OnDestroy()
	{
		UIInputManager.OnCancelEarly -= OnUICancel;
	}

	private void OnUICancel(UIInputEventData data)
	{
		if (OperationPending)
		{
			data.Use();
		}
	}

	public static void Load()
	{
		string text = SavesSystem.LoadGlobal<string>("InputBinding");
		string.IsNullOrEmpty(text);
		try
		{
			PlayerInput.actions.LoadBindingOverridesFromJson(text);
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
			PlayerInput.actions.RemoveAllBindingOverrides();
		}
	}

	public static void Save()
	{
		string text = PlayerInput.actions.SaveBindingOverridesAsJson();
		SavesSystem.SaveGlobal("InputBinding", text);
		UnityEngine.Debug.Log(text);
	}

	public static void Clear()
	{
		PlayerInput.actions.RemoveAllBindingOverrides();
		OnBindingChanged?.Invoke();
		InputIndicator.NotifyBindingChanged();
	}

	private static void Rebind(string name, int index, string[] excludes = null)
	{
		if (OperationPending)
		{
			return;
		}
		InputAction inputAction = PlayerInput.actions[name];
		if (inputAction == null)
		{
			UnityEngine.Debug.LogError("找不到名为 " + name + " 的 action");
			return;
		}
		OnRebindBegin?.Invoke(inputAction);
		UnityEngine.Debug.Log("Resetting");
		operation.Reset();
		UnityEngine.Debug.Log("Settingup");
		inputAction.actionMap.Disable();
		operation.WithCancelingThrough("<Keyboard>/escape").WithAction(inputAction).WithTargetBinding(index)
			.OnComplete(OnComplete)
			.OnCancel(OnCancel);
		if (excludes != null)
		{
			foreach (string path in excludes)
			{
				operation.WithControlsExcluding(path);
			}
		}
		UnityEngine.Debug.Log("Starting");
		operation.Start();
	}

	public static async UniTask<bool> RebindAsync(string name, int index, string[] excludes = null, bool save = false)
	{
		if (OperationPending)
		{
			return false;
		}
		Rebind(name, index, excludes);
		while (OperationPending)
		{
			await UniTask.Yield();
		}
		if (save && operation.completed)
		{
			Save();
		}
		return operation.completed;
	}

	private static void OnCancel(InputActionRebindingExtensions.RebindingOperation operation)
	{
		UnityEngine.Debug.Log(operation.action.name + " binding canceled");
		operation.action.actionMap.Enable();
		OnRebindComplete?.Invoke(operation.action);
	}

	private static void OnComplete(InputActionRebindingExtensions.RebindingOperation operation)
	{
		UnityEngine.Debug.Log(operation.action.name + " bind to " + operation.selectedControl.name);
		operation.action.actionMap.Enable();
		OnRebindComplete?.Invoke(operation.action);
		OnBindingChanged?.Invoke();
		InputIndicator.NotifyRebindComplete(operation.action);
	}
}
public class InputRebinderIndicator : MonoBehaviour
{
	[SerializeField]
	private FadeGroup fadeGroup;

	private void Awake()
	{
		InputRebinder.OnRebindBegin = (Action<InputAction>)Delegate.Combine(InputRebinder.OnRebindBegin, new Action<InputAction>(OnRebindBegin));
		InputRebinder.OnRebindComplete = (Action<InputAction>)Delegate.Combine(InputRebinder.OnRebindComplete, new Action<InputAction>(OnRebindComplete));
		fadeGroup.SkipHide();
	}

	private void OnRebindComplete(InputAction action)
	{
		fadeGroup.Hide();
	}

	private void OnRebindBegin(InputAction action)
	{
		fadeGroup.Show();
	}
}
public class ItemWishlist : MonoBehaviour
{
	public struct WishlistInfo
	{
		public int itemTypeID;

		public bool isManuallyWishlisted;

		public bool isQuestRequired;

		public bool isBuildingRequired;
	}

	private List<int> manualWishList = new List<int>();

	private HashSet<int> _questRequiredItems = new HashSet<int>();

	private HashSet<int> _buildingRequiredItems = new HashSet<int>();

	private const string SaveKey = "ItemWishlist_Manual";

	public static ItemWishlist Instance { get; private set; }

	public static event Action<int> OnWishlistChanged;

	private void Awake()
	{
		Instance = this;
		QuestManager.onQuestListsChanged += OnQuestListChanged;
		BuildingManager.OnBuildingListChanged += OnBuildingListChanged;
		SavesSystem.OnCollectSaveData += Save;
		UIInputManager.OnWishlistHoveringItem += OnWishlistHoveringItem;
		Load();
	}

	private void OnDestroy()
	{
		QuestManager.onQuestListsChanged -= OnQuestListChanged;
		SavesSystem.OnCollectSaveData -= Save;
		UIInputManager.OnWishlistHoveringItem -= OnWishlistHoveringItem;
	}

	private void OnWishlistHoveringItem(UIInputEventData data)
	{
		if (ItemHoveringUI.Shown)
		{
			int displayingItemID = ItemHoveringUI.DisplayingItemID;
			if (IsManuallyWishlisted(displayingItemID))
			{
				RemoveFromWishlist(displayingItemID);
			}
			else
			{
				AddToWishList(displayingItemID);
			}
			ItemHoveringUI.NotifyRefreshWishlistInfo();
		}
	}

	private void Load()
	{
		manualWishList.Clear();
		List<int> list = SavesSystem.Load<List<int>>("ItemWishlist_Manual");
		if (list != null)
		{
			manualWishList.AddRange(list);
		}
	}

	private void Save()
	{
		SavesSystem.Save("ItemWishlist_Manual", manualWishList);
	}

	private void Start()
	{
		CacheQuestItems();
		CacheBuildingItems();
	}

	private void OnQuestListChanged(QuestManager obj)
	{
		CacheQuestItems();
	}

	private void OnBuildingListChanged()
	{
		CacheBuildingItems();
	}

	private void CacheQuestItems()
	{
		_questRequiredItems = Enumerable.ToHashSet(QuestManager.GetAllRequiredItems());
	}

	private void CacheBuildingItems()
	{
		_buildingRequiredItems.Clear();
		BuildingInfo[] buildingsToDisplay = BuildingSelectionPanel.GetBuildingsToDisplay();
		for (int i = 0; i < buildingsToDisplay.Length; i++)
		{
			BuildingInfo buildingInfo = buildingsToDisplay[i];
			if (buildingInfo.RequirementsSatisfied() && buildingInfo.TokenAmount + buildingInfo.CurrentAmount < buildingInfo.maxAmount)
			{
				Cost.ItemEntry[] items = buildingInfo.cost.items;
				for (int j = 0; j < items.Length; j++)
				{
					Cost.ItemEntry itemEntry = items[j];
					_buildingRequiredItems.Add(itemEntry.id);
				}
			}
		}
	}

	private IEnumerable<int> IterateAll()
	{
		foreach (int manualWish in manualWishList)
		{
			yield return manualWish;
		}
		IEnumerable<int> allRequiredItems = QuestManager.GetAllRequiredItems();
		foreach (int item in allRequiredItems)
		{
			yield return item;
		}
	}

	public bool IsQuestRequired(int itemTypeID)
	{
		return _questRequiredItems.Contains(itemTypeID);
	}

	public bool IsManuallyWishlisted(int itemTypeID)
	{
		return manualWishList.Contains(itemTypeID);
	}

	public bool IsBuildingRequired(int itemTypeID)
	{
		return _buildingRequiredItems.Contains(itemTypeID);
	}

	public static void AddToWishList(int itemTypeID)
	{
		if (!(Instance == null) && !Instance.manualWishList.Contains(itemTypeID))
		{
			Instance.manualWishList.Add(itemTypeID);
			ItemWishlist.OnWishlistChanged?.Invoke(itemTypeID);
		}
	}

	public static bool RemoveFromWishlist(int itemTypeID)
	{
		if (Instance == null)
		{
			return false;
		}
		bool num = Instance.manualWishList.Remove(itemTypeID);
		if (num)
		{
			Action<int> onWishlistChanged = ItemWishlist.OnWishlistChanged;
			if (onWishlistChanged == null)
			{
				return num;
			}
			onWishlistChanged(itemTypeID);
		}
		return num;
	}

	public static WishlistInfo GetWishlistInfo(int itemTypeID)
	{
		if (Instance == null)
		{
			return default(WishlistInfo);
		}
		bool isManuallyWishlisted = Instance.IsManuallyWishlisted(itemTypeID);
		bool isQuestRequired = Instance.IsQuestRequired(itemTypeID);
		bool isBuildingRequired = Instance.IsBuildingRequired(itemTypeID);
		return new WishlistInfo
		{
			itemTypeID = itemTypeID,
			isManuallyWishlisted = isManuallyWishlisted,
			isQuestRequired = isQuestRequired,
			isBuildingRequired = isBuildingRequired
		};
	}
}
public class GamingConsoleView : View
{
	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private InventoryDisplay characterInventory;

	[SerializeField]
	private InventoryDisplay petInventory;

	[SerializeField]
	private InventoryDisplay storageInventory;

	[SerializeField]
	private SlotDisplay monitorSlotDisplay;

	[SerializeField]
	private SlotDisplay consoleSlotDisplay;

	[SerializeField]
	private ItemSlotCollectionDisplay consoleSlotCollectionDisplay;

	private GamingConsole target;

	private bool isBeingDestroyed;

	public static GamingConsoleView Instance => View.GetViewInstance<GamingConsoleView>();

	protected override void OnOpen()
	{
		base.OnOpen();
		fadeGroup.Show();
		Setup(target);
		if ((bool)CharacterMainControl.Main)
		{
			characterInventory.Setup(CharacterMainControl.Main.CharacterItem.Inventory);
		}
		if ((bool)PetProxy.PetInventory)
		{
			petInventory.Setup(PetProxy.PetInventory);
		}
		if ((bool)PlayerStorage.Inventory)
		{
			storageInventory.Setup(PlayerStorage.Inventory);
		}
		RefreshConsole();
	}

	protected override void OnClose()
	{
		base.OnClose();
		fadeGroup.Hide();
	}

	private void SetTarget(GamingConsole target)
	{
		if (this.target != null)
		{
			this.target.onContentChanged -= OnTargetContentChanged;
		}
		if (target != null)
		{
			this.target = target;
		}
		else
		{
			this.target = UnityEngine.Object.FindObjectOfType<GamingConsole>();
		}
	}

	private void Setup(GamingConsole target)
	{
		SetTarget(target);
		if (!(this.target == null))
		{
			this.target.onContentChanged += OnTargetContentChanged;
			consoleSlotDisplay.Setup(this.target.ConsoleSlot);
			monitorSlotDisplay.Setup(this.target.MonitorSlot);
			RefreshConsole();
		}
	}

	private void OnTargetContentChanged(GamingConsole console)
	{
		RefreshConsole();
	}

	private void RefreshConsole()
	{
		if (isBeingDestroyed)
		{
			return;
		}
		Slot consoleSlot = target.ConsoleSlot;
		if (consoleSlot != null)
		{
			Item content = consoleSlot.Content;
			consoleSlotCollectionDisplay.gameObject.SetActive(content);
			if ((bool)content)
			{
				consoleSlotCollectionDisplay.Setup(content);
			}
		}
	}

	internal static void Show(GamingConsole console)
	{
		Instance.target = console;
		Instance.Open();
	}

	protected override void OnDestroy()
	{
		base.OnDestroy();
		isBeingDestroyed = true;
	}
}
public interface IMiniMapDataProvider
{
	Sprite CombinedSprite { get; }

	List<IMiniMapEntry> Maps { get; }

	float PixelSize { get; }

	Vector3 CombinedCenter { get; }
}
public interface IMiniMapEntry
{
	Sprite Sprite { get; }

	float PixelSize { get; }

	Vector2 Offset { get; }

	string SceneID { get; }

	bool Hide { get; }

	bool NoSignal { get; }
}
public class MapMarkerPanelButton : MonoBehaviour
{
	[SerializeField]
	private GameObject selectionIndicator;

	[SerializeField]
	private UnityEngine.UI.Image image;

	[SerializeField]
	private UnityEngine.UI.Button button;

	public UnityEngine.UI.Image Image => image;

	public void Setup(UnityAction action, bool selected)
	{
		button.onClick.RemoveAllListeners();
		button.onClick.AddListener(action);
		selectionIndicator.gameObject.SetActive(selected);
	}
}
public class MapMarkerSettingsPanel : MonoBehaviour
{
	[SerializeField]
	private Color[] colors;

	[SerializeField]
	private MapMarkerPanelButton iconBtnTemplate;

	[SerializeField]
	private MapMarkerPanelButton colorBtnTemplate;

	private PrefabPool<MapMarkerPanelButton> _iconBtnPool;

	private PrefabPool<MapMarkerPanelButton> _colorBtnPool;

	private List<Sprite> Icons => MapMarkerManager.Icons;

	private PrefabPool<MapMarkerPanelButton> IconBtnPool
	{
		get
		{
			if (_iconBtnPool == null)
			{
				_iconBtnPool = new PrefabPool<MapMarkerPanelButton>(iconBtnTemplate);
			}
			return _iconBtnPool;
		}
	}

	private PrefabPool<MapMarkerPanelButton> ColorBtnPool
	{
		get
		{
			if (_colorBtnPool == null)
			{
				_colorBtnPool = new PrefabPool<MapMarkerPanelButton>(colorBtnTemplate);
			}
			return _colorBtnPool;
		}
	}

	private void OnEnable()
	{
		Setup();
		MapMarkerManager.OnColorChanged = (Action<Color>)Delegate.Combine(MapMarkerManager.OnColorChanged, new Action<Color>(OnColorChanged));
		MapMarkerManager.OnIconChanged = (Action<int>)Delegate.Combine(MapMarkerManager.OnIconChanged, new Action<int>(OnIconChanged));
	}

	private void OnDisable()
	{
		MapMarkerManager.OnColorChanged = (Action<Color>)Delegate.Remove(MapMarkerManager.OnColorChanged, new Action<Color>(OnColorChanged));
		MapMarkerManager.OnIconChanged = (Action<int>)Delegate.Remove(MapMarkerManager.OnIconChanged, new Action<int>(OnIconChanged));
	}

	private void OnIconChanged(int obj)
	{
		Setup();
	}

	private void OnColorChanged(Color color)
	{
		Setup();
	}

	private void Setup()
	{
		if (MapMarkerManager.Instance == null)
		{
			return;
		}
		IconBtnPool.ReleaseAll();
		ColorBtnPool.ReleaseAll();
		Color[] array = colors;
		foreach (Color cur in array)
		{
			MapMarkerPanelButton mapMarkerPanelButton = ColorBtnPool.Get();
			mapMarkerPanelButton.Image.color = cur;
			mapMarkerPanelButton.Setup(delegate
			{
				MapMarkerManager.SelectColor(cur);
			}, cur == MapMarkerManager.SelectedColor);
		}
		for (int num = 0; num < Icons.Count; num++)
		{
			Sprite sprite = Icons[num];
			if (!(sprite == null))
			{
				MapMarkerPanelButton mapMarkerPanelButton2 = IconBtnPool.Get();
				UnityEngine.UI.Image image = mapMarkerPanelButton2.Image;
				image.sprite = sprite;
				image.color = MapMarkerManager.SelectedColor;
				int index = num;
				mapMarkerPanelButton2.Setup(delegate
				{
					MapMarkerManager.SelectIcon(index);
				}, index == MapMarkerManager.SelectedIconIndex);
			}
		}
	}
}
public class PackedMapData : ScriptableObject, IMiniMapDataProvider
{
	[Serializable]
	public class Entry : IMiniMapEntry
	{
		[SerializeField]
		private Sprite sprite;

		[SerializeField]
		private float pixelSize;

		[SerializeField]
		private Vector2 offset;

		[SerializeField]
		private string sceneID;

		[SerializeField]
		private bool hide;

		[SerializeField]
		private bool noSignal;

		public Sprite Sprite => sprite;

		public float PixelSize => pixelSize;

		public Vector2 Offset => offset;

		public string SceneID => sceneID;

		public bool Hide => hide;

		public bool NoSignal => noSignal;

		public Entry()
		{
		}

		public Entry(Sprite sprite, float pixelSize, Vector2 offset, string sceneID, bool hide, bool noSignal)
		{
			this.sprite = sprite;
			this.pixelSize = pixelSize;
			this.offset = offset;
			this.sceneID = sceneID;
			this.hide = hide;
			this.noSignal = noSignal;
		}
	}

	[SerializeField]
	private Sprite combinedSprite;

	[SerializeField]
	private float pixelSize;

	[SerializeField]
	private Vector3 combinedCenter;

	[SerializeField]
	private List<Entry> maps = new List<Entry>();

	public Sprite CombinedSprite => combinedSprite;

	public float PixelSize => pixelSize;

	public Vector3 CombinedCenter => combinedCenter;

	public List<IMiniMapEntry> Maps => ((IEnumerable<IMiniMapEntry>)maps).ToList();

	internal void Setup(IMiniMapDataProvider origin)
	{
		combinedSprite = origin.CombinedSprite;
		pixelSize = origin.PixelSize;
		combinedCenter = origin.CombinedCenter;
		maps.Clear();
		foreach (IMiniMapEntry map in origin.Maps)
		{
			Entry item = new Entry(map.Sprite, map.PixelSize, map.Offset, map.SceneID, map.Hide, map.NoSignal);
			maps.Add(item);
		}
	}
}
public class ModUploadPanel : MonoBehaviour
{
	[SerializeField]
	private FadeGroup fgMain;

	[SerializeField]
	private FadeGroup fgLoading;

	[SerializeField]
	private FadeGroup fgContent;

	[SerializeField]
	private TextMeshProUGUI txtTitle;

	[SerializeField]
	private TextMeshProUGUI txtDescription;

	[SerializeField]
	private RawImage preview;

	[SerializeField]
	private TextMeshProUGUI txtModName;

	[SerializeField]
	private TextMeshProUGUI txtPath;

	[SerializeField]
	private TextMeshProUGUI txtPublishedFileID;

	[SerializeField]
	private GameObject indicatorNew;

	[SerializeField]
	private GameObject indicatorUpdate;

	[SerializeField]
	private GameObject indicatorOwnershipWarning;

	[SerializeField]
	private GameObject indicatorInvalidContent;

	[SerializeField]
	private UnityEngine.UI.Button btnUpload;

	[SerializeField]
	private UnityEngine.UI.Button btnCancel;

	[SerializeField]
	private FadeGroup fgButtonMain;

	[SerializeField]
	private FadeGroup fgProgressBar;

	[SerializeField]
	private TextMeshProUGUI progressText;

	[SerializeField]
	private UnityEngine.UI.Image progressBarFill;

	[SerializeField]
	private FadeGroup fgSucceed;

	[SerializeField]
	private FadeGroup fgFailed;

	[SerializeField]
	private float closeAfterSeconds = 2f;

	[SerializeField]
	private Texture2D defaultPreviewTexture;

	private bool cancelClicked;

	private bool uploadClicked;

	private bool waitingForUpload;

	private void Awake()
	{
		btnCancel.onClick.AddListener(OnCancelBtnClick);
		btnUpload.onClick.AddListener(OnUploadBtnClick);
	}

	private void OnUploadBtnClick()
	{
		uploadClicked = true;
	}

	private void OnCancelBtnClick()
	{
		cancelClicked = true;
	}

	public async UniTask Execute(ModInfo info)
	{
		string path = info.path;
		SteamWorkshopManager workshopManager = SteamWorkshopManager.Instance;
		if (workshopManager == null || !SteamManager.Initialized)
		{
			UnityEngine.Debug.LogError("Cannot execute uplaod panel. SteamWorkshopManager and SteamManager are required.");
		}
		Clean();
		fgMain.Show();
		fgLoading.Show();
		bool flag = ModManager.TryProcessModFolder(path, out info, isSteamItem: false, 0uL);
		txtPath.text = path.Replace('\\', '/');
		btnUpload.gameObject.SetActive(flag);
		if (flag)
		{
			txtTitle.text = info.displayName;
			txtDescription.text = info.description;
			txtPublishedFileID.text = ((info.publishedFileId != 0) ? info.publishedFileId.ToString() : "-");
			txtModName.text = info.name;
			preview.texture = info.preview;
		}
		else
		{
			txtTitle.text = "???";
			txtDescription.text = "???";
			txtPublishedFileID.text = "???";
			txtModName.text = "???";
			preview.texture = defaultPreviewTexture;
		}
		bool flag2 = flag && info.publishedFileId == 0;
		bool flag3 = SteamWorkshopManager.IsOwner(info);
		indicatorNew.SetActive(flag2);
		indicatorUpdate.SetActive(!flag2);
		indicatorOwnershipWarning.SetActive(!flag3);
		indicatorInvalidContent.SetActive(!flag);
		await fgLoading.HideAndReturnTask();
		fgContent.Show();
		fgButtonMain.Show();
		cancelClicked = false;
		uploadClicked = false;
		while (!cancelClicked && !uploadClicked)
		{
			await UniTask.Yield();
		}
		if (cancelClicked)
		{
			fgMain.Hide();
			return;
		}
		fgButtonMain.Hide();
		fgProgressBar.Show();
		waitingForUpload = true;
		bool num = await workshopManager.UploadWorkshopItem(path, "");
		waitingForUpload = false;
		fgProgressBar.Hide();
		if (num)
		{
			if (ModManager.TryProcessModFolder(path, out var info2, isSteamItem: false, 0uL))
			{
				txtPublishedFileID.text = $"{info2.publishedFileId}";
			}
			fgSucceed.Show();
		}
		else
		{
			fgFailed.Show();
		}
		await UniTask.WaitForSeconds(closeAfterSeconds);
		fgMain.Hide();
	}

	private void Update()
	{
		if (waitingForUpload)
		{
			progressBarFill.fillAmount = SteamWorkshopManager.UploadingProgress;
			ulong punBytesProcess = SteamWorkshopManager.punBytesProcess;
			ulong punBytesTotal = SteamWorkshopManager.punBytesTotal;
			progressText.text = FormatBytes(punBytesProcess) + " / " + FormatBytes(punBytesTotal);
		}
	}

	private static string FormatBytes(ulong bytes)
	{
		if (bytes < 1024)
		{
			return $"{bytes}bytes";
		}
		if (bytes < 1048576)
		{
			return $"{(float)bytes / 1024f:0.0}KB";
		}
		if (bytes < 1073741824)
		{
			return $"{(float)bytes / 1048576f:0.0}MB";
		}
		return $"{(float)bytes / 1.0737418E+09f:0.0}GB";
	}

	private void Clean()
	{
		fgLoading.SkipHide();
		fgContent.SkipHide();
		indicatorNew.SetActive(value: false);
		indicatorUpdate.SetActive(value: false);
		indicatorOwnershipWarning.SetActive(value: false);
		indicatorInvalidContent.SetActive(value: false);
		txtPublishedFileID.text = "-";
		txtPath.text = "-";
		fgButtonMain.SkipHide();
		fgProgressBar.SkipHide();
		fgSucceed.SkipHide();
		fgFailed.SkipHide();
		waitingForUpload = false;
	}
}
public class OpenSaveFolder : MonoBehaviour
{
	private string filePath => Application.persistentDataPath;

	private void Update()
	{
		if (Keyboard.current.leftCtrlKey.isPressed && Keyboard.current.lKey.isPressed)
		{
			OpenFolder();
		}
	}

	public void OpenFolder()
	{
		Process.Start(new ProcessStartInfo
		{
			FileName = filePath,
			UseShellExecute = true
		});
	}
}
public class ScrollWheelOptionsProvider : OptionsProviderBase
{
	public override string Key => "Input_ScrollWheelBehaviour";

	public override string GetCurrentOption()
	{
		return ScrollWheelBehaviour.GetDisplayName(ScrollWheelBehaviour.CurrentBehaviour);
	}

	public override string[] GetOptions()
	{
		ScrollWheelBehaviour.Behaviour[] array = (ScrollWheelBehaviour.Behaviour[])Enum.GetValues(typeof(ScrollWheelBehaviour.Behaviour));
		string[] array2 = new string[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array2[i] = ScrollWheelBehaviour.GetDisplayName(array[i]);
		}
		return array2;
	}

	public override void Set(int index)
	{
		ScrollWheelBehaviour.CurrentBehaviour = ((ScrollWheelBehaviour.Behaviour[])Enum.GetValues(typeof(ScrollWheelBehaviour.Behaviour)))[index];
	}
}
public static class ScrollWheelBehaviour
{
	public enum Behaviour
	{
		AmmoAndInteract,
		Weapon
	}

	public static Behaviour CurrentBehaviour
	{
		get
		{
			return OptionsManager.Load("ScrollWheelBehaviour", Behaviour.AmmoAndInteract);
		}
		set
		{
			OptionsManager.Save("ScrollWheelBehaviour", value);
		}
	}

	public static string GetDisplayName(Behaviour behaviour)
	{
		return $"ScrollWheelBehaviour_{behaviour}".ToPlainText();
	}
}
public class LanguageOptionsProvider : OptionsProviderBase
{
	private string[] cache;

	public override string Key => "Language";

	public override string GetCurrentOption()
	{
		return LocalizationManager.CurrentLanguageDisplayName;
	}

	public override string[] GetOptions()
	{
		LocalizationDatabase instance = LocalizationDatabase.Instance;
		if (instance == null)
		{
			return new string[1] { "?" };
		}
		return cache = instance.GetLanguageDisplayNameList();
	}

	public override void Set(int index)
	{
		if (cache == null)
		{
			GetOptions();
		}
		if (index < 0 || index >= cache.Length)
		{
			UnityEngine.Debug.LogError("语言越界");
		}
		else
		{
			LocalizationManager.SetLanguage(index);
		}
	}
}
public abstract class OptionsProviderBase : MonoBehaviour
{
	public abstract string Key { get; }

	public abstract string[] GetOptions();

	public abstract string GetCurrentOption();

	public abstract void Set(int index);
}
public class FullScreenOptions : OptionsProviderBase
{
	public override string Key => ResolutionSetter.Key_ScreenMode;

	public override string GetCurrentOption()
	{
		return ResolutionSetter.ScreenModeToName(OptionsManager.Load(Key, ResolutionSetter.screenModes.Borderless));
	}

	public override string[] GetOptions()
	{
		return ResolutionSetter.GetScreenModes();
	}

	public override void Set(int index)
	{
		OptionsManager.Save(Key, (ResolutionSetter.screenModes)index);
	}
}
public class ResolutionOptions : OptionsProviderBase
{
	private DuckovResolution[] avaliableResolutions;

	public override string Key => ResolutionSetter.Key_Resolution;

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, new DuckovResolution(Screen.resolutions[Screen.resolutions.Length - 1])).ToString();
	}

	public override string[] GetOptions()
	{
		avaliableResolutions = ResolutionSetter.GetResolutions();
		string[] array = new string[avaliableResolutions.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = avaliableResolutions[i].ToString();
		}
		return array;
	}

	public override void Set(int index)
	{
		if (avaliableResolutions == null || index >= avaliableResolutions.Length)
		{
			UnityEngine.Debug.Log("设置分辨率流程错误");
			index = 0;
		}
		DuckovResolution obj = avaliableResolutions[index];
		OptionsManager.Save(Key, obj);
	}
}
public class ResolutionSetter : MonoBehaviour
{
	public enum screenModes
	{
		Borderless,
		Window
	}

	public static string Key_Resolution = "Resolution";

	public static string Key_ScreenMode = "ScreenMode";

	public static bool currentFullScreen = false;

	private static float fullScreenChangeCheckCoolTimer = 1f;

	private static float fullScreenChangeCheckCoolTime = 1f;

	public Vector2Int debugDisplayRes = new Vector2Int(0, 0);

	public Vector2Int debugScreenRes = new Vector2Int(0, 0);

	public Vector2Int debugmMaxRes = new Vector2Int(0, 0);

	public DuckovResolution[] testRes;

	public static DuckovResolution MaxResolution
	{
		get
		{
			Resolution[] resolutions = Screen.resolutions;
			resolutions.Sort(delegate(Resolution A, Resolution B)
			{
				if (A.height > B.height)
				{
					return -1;
				}
				if (A.height < B.height)
				{
					return 1;
				}
				if (A.width > B.width)
				{
					return -1;
				}
				return (A.width < B.width) ? 1 : 0;
			});
			Resolution res = new Resolution
			{
				width = Screen.currentResolution.width,
				height = Screen.currentResolution.height
			};
			Resolution res2 = Screen.resolutions[resolutions.Length - 1];
			DuckovResolution result = ((res.width <= res2.width) ? new DuckovResolution(res2) : new DuckovResolution(res));
			if ((float)result.width / (float)result.height < 1.4f)
			{
				result.width = Mathf.RoundToInt(result.height * 16 / 9);
			}
			return result;
		}
	}

	private void Test()
	{
		debugDisplayRes = new Vector2Int(Display.main.systemWidth, Display.main.systemHeight);
		debugmMaxRes = new Vector2Int(MaxResolution.width, MaxResolution.height);
		debugScreenRes = new Vector2Int(Screen.currentResolution.width, Screen.currentResolution.height);
		testRes = GetResolutions();
	}

	public static Resolution GetResByHeight(int height, DuckovResolution maxRes)
	{
		return new Resolution
		{
			height = height,
			width = (int)((float)maxRes.width * (float)height / (float)maxRes.height)
		};
	}

	public static DuckovResolution[] GetResolutions()
	{
		DuckovResolution maxResolution = MaxResolution;
		List<Resolution> list = Screen.resolutions.ToList();
		list.Add(GetResByHeight(1080, maxResolution));
		list.Add(GetResByHeight(900, maxResolution));
		list.Add(GetResByHeight(720, maxResolution));
		list.Add(GetResByHeight(540, maxResolution));
		List<DuckovResolution> list2 = new List<DuckovResolution>();
		bool flag = OptionsManager.Load(Key_ScreenMode, screenModes.Window) != screenModes.Window;
		foreach (Resolution item in list)
		{
			DuckovResolution duckovResolution = new DuckovResolution(item);
			if (!list2.Contains(duckovResolution) && !((float)duckovResolution.width / (float)duckovResolution.height < 1.4f) && (!flag || duckovResolution.CheckRotioFit(duckovResolution, maxResolution)))
			{
				list2.Add(duckovResolution);
			}
		}
		list2.Sort(delegate(DuckovResolution A, DuckovResolution B)
		{
			if (A.height > B.height)
			{
				return -1;
			}
			if (A.height < B.height)
			{
				return 1;
			}
			if (A.width > B.width)
			{
				return -1;
			}
			return (A.width < B.width) ? 1 : 0;
		});
		return list2.ToArray();
	}

	private void Update()
	{
		UpdateFullScreenCheck();
	}

	private void UpdateFullScreenCheck()
	{
		fullScreenChangeCheckCoolTimer -= Time.unscaledDeltaTime;
		if (!(fullScreenChangeCheckCoolTimer > 0f) && currentFullScreen != (Screen.fullScreenMode == FullScreenMode.FullScreenWindow || Screen.fullScreenMode == FullScreenMode.ExclusiveFullScreen))
		{
			currentFullScreen = !currentFullScreen;
			OptionsManager.Save(Key_ScreenMode, (!currentFullScreen) ? screenModes.Window : screenModes.Borderless);
			fullScreenChangeCheckCoolTimer = fullScreenChangeCheckCoolTime;
		}
	}

	public static void UpdateResolutionAndScreenMode()
	{
		fullScreenChangeCheckCoolTimer = fullScreenChangeCheckCoolTime;
		DuckovResolution duckovResolution = OptionsManager.Load(Key_Resolution, new DuckovResolution(Screen.resolutions[Screen.resolutions.Length - 1]));
		if ((float)duckovResolution.width / (float)duckovResolution.height < 1.3666667f)
		{
			duckovResolution.width = Mathf.RoundToInt(duckovResolution.height * 16 / 9);
		}
		screenModes screenModes = OptionsManager.Load(Key_ScreenMode, screenModes.Borderless);
		currentFullScreen = screenModes == screenModes.Borderless;
		Screen.SetResolution(duckovResolution.width, duckovResolution.height, ScreenModeToFullScreenMode(screenModes));
	}

	private static FullScreenMode ScreenModeToFullScreenMode(screenModes screenMode)
	{
		return screenMode switch
		{
			screenModes.Borderless => FullScreenMode.FullScreenWindow, 
			screenModes.Window => FullScreenMode.Windowed, 
			_ => FullScreenMode.ExclusiveFullScreen, 
		};
	}

	public static string[] GetScreenModes()
	{
		return new string[2]
		{
			("Option_ScreenMode_" + screenModes.Borderless).ToPlainText(),
			("Option_ScreenMode_" + screenModes.Window).ToPlainText()
		};
	}

	public static string ScreenModeToName(screenModes mode)
	{
		return ("Option_ScreenMode_" + mode).ToPlainText();
	}

	private void Awake()
	{
		UpdateResolutionAndScreenMode();
		OptionsManager.OnOptionsChanged += OnOptionsChanged;
	}

	private void OnDestroy()
	{
		OptionsManager.OnOptionsChanged -= OnOptionsChanged;
	}

	private void OnOptionsChanged(string key)
	{
		if (key == Key_Resolution || key == Key_ScreenMode)
		{
			UpdateResolutionAndScreenMode();
		}
	}
}
[Serializable]
public struct DuckovResolution
{
	public int width;

	public int height;

	public override bool Equals(object obj)
	{
		if (obj is DuckovResolution duckovResolution && duckovResolution.height == height && duckovResolution.width == width)
		{
			return true;
		}
		return false;
	}

	public override string ToString()
	{
		return $"{width} x {height}";
	}

	public DuckovResolution(Resolution res)
	{
		height = res.height;
		width = res.width;
	}

	public DuckovResolution(int _width, int _height)
	{
		height = _height;
		width = _width;
	}

	public bool CheckRotioFit(DuckovResolution newRes, DuckovResolution defaultRes)
	{
		float num = (float)newRes.height / (float)newRes.width;
		if (Mathf.Abs((float)defaultRes.height - num * (float)defaultRes.width) <= 2f)
		{
			return true;
		}
		return false;
	}
}
public class DisableCameraOffset : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string onKey = "Options_On";

	[LocalizationKey("Default")]
	public string offKey = "Options_Off";

	public static bool disableCameraOffset;

	public override string Key => "DisableCameraOffset";

	public override string[] GetOptions()
	{
		return new string[2]
		{
			onKey.ToPlainText(),
			offKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 1) switch
		{
			0 => onKey.ToPlainText(), 
			1 => offKey.ToPlainText(), 
			_ => offKey.ToPlainText(), 
		};
	}

	public override void Set(int index)
	{
		switch (index)
		{
		case 0:
			disableCameraOffset = true;
			break;
		case 1:
			disableCameraOffset = false;
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}
}
public class EdgeLightEntry : MonoBehaviour
{
	private static bool settingEnabled = true;

	private static event Action OnSettingChangedEvent;

	public static void SetEnabled(bool enabled)
	{
		settingEnabled = enabled;
		EdgeLightEntry.OnSettingChangedEvent?.Invoke();
	}

	private void Awake()
	{
		OnSettingChangedEvent += OnSettingChanged;
		base.gameObject.SetActive(settingEnabled);
	}

	private void OnDestroy()
	{
		OnSettingChangedEvent -= OnSettingChanged;
	}

	private void OnSettingChanged()
	{
		base.gameObject.SetActive(settingEnabled);
	}
}
public class EdgeLightSettings : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string onKey = "Options_On";

	[LocalizationKey("Default")]
	public string offKey = "Options_Off";

	public override string Key => "EdgeLightSetting";

	public override string[] GetOptions()
	{
		return new string[2]
		{
			offKey.ToPlainText(),
			onKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 1) switch
		{
			0 => offKey.ToPlainText(), 
			1 => onKey.ToPlainText(), 
			_ => onKey.ToPlainText(), 
		};
	}

	public override void Set(int index)
	{
		switch (index)
		{
		case 0:
			EdgeLightEntry.SetEnabled(enabled: false);
			break;
		case 1:
			EdgeLightEntry.SetEnabled(enabled: true);
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}
}
public class FrameRateSetting : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string optionUnlimitKey = "FrameRateUnlimit";

	public override string Key => "FrameRateSetting";

	public override string[] GetOptions()
	{
		return new string[6]
		{
			"60",
			"90",
			"120",
			"144",
			"240",
			optionUnlimitKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 1) switch
		{
			0 => "60", 
			1 => "90", 
			2 => "120", 
			3 => "144", 
			4 => "240", 
			5 => optionUnlimitKey.ToPlainText(), 
			_ => "60", 
		};
	}

	public override void Set(int index)
	{
		switch (index)
		{
		case 0:
			Application.targetFrameRate = 60;
			break;
		case 1:
			Application.targetFrameRate = 90;
			break;
		case 2:
			Application.targetFrameRate = 120;
			break;
		case 3:
			Application.targetFrameRate = 144;
			break;
		case 4:
			Application.targetFrameRate = 240;
			break;
		case 5:
			Application.targetFrameRate = 500;
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}
}
public class FsrSetting : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string offKey = "fsr_Off";

	[LocalizationKey("Default")]
	public string qualityKey = "fsr_Quality";

	[LocalizationKey("Default")]
	public string balancedKey = "fsr_Balanced";

	[LocalizationKey("Default")]
	public string performanceKey = "fsr_Performance";

	[LocalizationKey("Default")]
	public string ultraPerformanceKey = "fsr_UltraPerformance";

	private static bool gameOn;

	public override string Key => "FsrSetting";

	public override string[] GetOptions()
	{
		return new string[5]
		{
			offKey.ToPlainText(),
			qualityKey.ToPlainText(),
			balancedKey.ToPlainText(),
			performanceKey.ToPlainText(),
			ultraPerformanceKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 0) switch
		{
			0 => offKey.ToPlainText(), 
			1 => qualityKey.ToPlainText(), 
			2 => balancedKey.ToPlainText(), 
			3 => performanceKey.ToPlainText(), 
			4 => ultraPerformanceKey.ToPlainText(), 
			_ => offKey.ToPlainText(), 
		};
	}

	public override void Set(int index)
	{
		UniversalRenderPipelineAsset universalRenderPipelineAsset = (UniversalRenderPipelineAsset)GraphicsSettings.currentRenderPipeline;
		int num = index;
		if (gameOn)
		{
			num = 0;
		}
		switch (num)
		{
		case 0:
			if (universalRenderPipelineAsset != null)
			{
				universalRenderPipelineAsset.renderScale = 1f;
				universalRenderPipelineAsset.upscalingFilter = UpscalingFilterSelection.Linear;
			}
			break;
		case 1:
			if (universalRenderPipelineAsset != null)
			{
				universalRenderPipelineAsset.renderScale = 0.67f;
				universalRenderPipelineAsset.upscalingFilter = UpscalingFilterSelection.FSR;
			}
			break;
		case 2:
			if (universalRenderPipelineAsset != null)
			{
				universalRenderPipelineAsset.renderScale = 0.58f;
				universalRenderPipelineAsset.upscalingFilter = UpscalingFilterSelection.FSR;
			}
			break;
		case 3:
			if (universalRenderPipelineAsset != null)
			{
				universalRenderPipelineAsset.renderScale = 0.5f;
				universalRenderPipelineAsset.upscalingFilter = UpscalingFilterSelection.FSR;
			}
			break;
		case 4:
			if (universalRenderPipelineAsset != null)
			{
				universalRenderPipelineAsset.renderScale = 0.33f;
				universalRenderPipelineAsset.upscalingFilter = UpscalingFilterSelection.FSR;
			}
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		RefreshOnLevelInited();
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
		GamingConsole.OnGamingConsoleInteractChanged += OnGamingConsoleInteractChanged;
	}

	private void OnGamingConsoleInteractChanged(bool _gameOn)
	{
		gameOn = _gameOn;
		SyncSetting();
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void SyncSetting()
	{
		int index = OptionsManager.Load(Key, 0);
		Set(index);
	}

	private void RefreshOnLevelInited()
	{
		SyncSetting();
	}
}
public class GrassOptions : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string offKey = "GrassOptions_Off";

	[LocalizationKey("Default")]
	public string onKey = "GrassOptions_On";

	public UniversalRendererData rendererData;

	public override string Key => "GrassSettings";

	public override string[] GetOptions()
	{
		return new string[2]
		{
			offKey.ToPlainText(),
			onKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 1) switch
		{
			0 => offKey.ToPlainText(), 
			1 => onKey.ToPlainText(), 
			_ => offKey.ToPlainText(), 
		};
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}

	public override void Set(int index)
	{
		ScriptableRendererFeature scriptableRendererFeature = rendererData.rendererFeatures.Find((ScriptableRendererFeature e) => e is TastyGrassShaderGlobalSettings);
		if (scriptableRendererFeature != null)
		{
			TastyGrassShaderGlobalSettings tastyGrassShaderGlobalSettings = scriptableRendererFeature as TastyGrassShaderGlobalSettings;
			switch (index)
			{
			case 0:
				tastyGrassShaderGlobalSettings.SetActive(active: false);
				TgsManager.Enable = false;
				break;
			case 1:
				tastyGrassShaderGlobalSettings.SetActive(active: true);
				TgsManager.Enable = true;
				break;
			}
		}
		OptionsManager.Save(Key, index);
	}
}
public class HBAOSettings : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string offKey = "HBAOSettings_Off";

	[LocalizationKey("Default")]
	public string lowKey = "HBAOSettings_Low";

	[LocalizationKey("Default")]
	public string normalKey = "HBAOSettings_Normal";

	[LocalizationKey("Default")]
	public string highKey = "HBAOSettings_High";

	public VolumeProfile GlobalVolumePorfile;

	public override string Key => "HBAOSettings";

	public override string[] GetOptions()
	{
		return new string[4]
		{
			offKey.ToPlainText(),
			lowKey.ToPlainText(),
			normalKey.ToPlainText(),
			highKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 2) switch
		{
			0 => offKey.ToPlainText(), 
			1 => lowKey.ToPlainText(), 
			2 => normalKey.ToPlainText(), 
			3 => highKey.ToPlainText(), 
			_ => offKey.ToPlainText(), 
		};
	}

	public override void Set(int index)
	{
		if (GlobalVolumePorfile.TryGet<HBAO>(out var component))
		{
			switch (index)
			{
			case 0:
				component.EnableHBAO(enable: false);
				break;
			case 1:
				component.EnableHBAO(enable: true);
				component.resolution = new HBAO.ResolutionParameter(HBAO.Resolution.Half);
				component.bias.value = 64f;
				break;
			case 2:
				component.EnableHBAO(enable: true);
				component.resolution = new HBAO.ResolutionParameter(HBAO.Resolution.Half);
				component.bias.value = 128f;
				break;
			case 3:
				component.EnableHBAO(enable: true);
				component.resolution = new HBAO.ResolutionParameter(HBAO.Resolution.Full);
				component.bias.value = 128f;
				break;
			}
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}
}
public class MoveDirectionOptions : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string cameraModeKey = "MoveDirectionMode_Camera";

	[LocalizationKey("Default")]
	public string aimModeKey = "MoveDirectionMode_Aim";

	private static bool moveViaCharacterDirection;

	public override string Key => "MoveDirModeSettings";

	public static bool MoveViaCharacterDirection => moveViaCharacterDirection;

	public override string[] GetOptions()
	{
		return new string[2]
		{
			cameraModeKey.ToPlainText(),
			aimModeKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 0) switch
		{
			0 => cameraModeKey.ToPlainText(), 
			1 => aimModeKey.ToPlainText(), 
			_ => cameraModeKey.ToPlainText(), 
		};
	}

	public override void Set(int index)
	{
		switch (index)
		{
		case 0:
			moveViaCharacterDirection = false;
			break;
		case 1:
			moveViaCharacterDirection = true;
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 0);
		Set(index);
	}
}
public class RunInputOptions : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string holdModeKey = "RunInputMode_Hold";

	[LocalizationKey("Default")]
	public string switchModeKey = "RunInputMode_Switch";

	public override string Key => "RunInputModeSettings";

	public override string[] GetOptions()
	{
		return new string[2]
		{
			holdModeKey.ToPlainText(),
			switchModeKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 0) switch
		{
			0 => holdModeKey.ToPlainText(), 
			1 => switchModeKey.ToPlainText(), 
			_ => holdModeKey.ToPlainText(), 
		};
	}

	public override void Set(int index)
	{
		switch (index)
		{
		case 0:
			InputManager.useRunInputBuffer = false;
			break;
		case 1:
			InputManager.useRunInputBuffer = true;
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}
}
public class ShadowSetting : OptionsProviderBase
{
	public UmbraProfile umbraProfile;

	public float onDistance = 100f;

	[LocalizationKey("Default")]
	public string highKey = "Options_High";

	[LocalizationKey("Default")]
	public string middleKey = "Options_Middle";

	[LocalizationKey("Default")]
	public string lowKey = "Options_Low";

	[LocalizationKey("Default")]
	public string offKey = "Options_Off";

	public override string Key => "ShadowSettings";

	public override string[] GetOptions()
	{
		return new string[4]
		{
			offKey.ToPlainText(),
			lowKey.ToPlainText(),
			middleKey.ToPlainText(),
			highKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 2) switch
		{
			0 => offKey.ToPlainText(), 
			1 => lowKey.ToPlainText(), 
			2 => middleKey.ToPlainText(), 
			3 => highKey.ToPlainText(), 
			_ => highKey.ToPlainText(), 
		};
	}

	private void SetShadow(bool on, int res, float shadowDistance, bool softShadow, bool softShadowDownSample, bool contactShadow, int pointLightCount)
	{
		UniversalRenderPipelineAsset universalRenderPipelineAsset = (UniversalRenderPipelineAsset)GraphicsSettings.currentRenderPipeline;
		if (universalRenderPipelineAsset != null)
		{
			universalRenderPipelineAsset.shadowDistance = (on ? shadowDistance : 0f);
			universalRenderPipelineAsset.mainLightShadowmapResolution = res;
			universalRenderPipelineAsset.additionalLightsShadowmapResolution = res;
			universalRenderPipelineAsset.maxAdditionalLightsCount = pointLightCount;
		}
		if ((bool)umbraProfile)
		{
			umbraProfile.shadowSource = (softShadow ? ShadowSource.UmbraShadows : ShadowSource.UnityShadows);
			umbraProfile.downsample = softShadowDownSample;
			umbraProfile.contactShadows = contactShadow;
		}
	}

	public override void Set(int index)
	{
		switch (index)
		{
		case 0:
			SetShadow(on: false, 512, 0f, softShadow: false, softShadowDownSample: false, contactShadow: false, 0);
			break;
		case 1:
			SetShadow(on: true, 1024, 70f, softShadow: false, softShadowDownSample: false, contactShadow: false, 0);
			break;
		case 2:
			SetShadow(on: true, 2048, 80f, softShadow: true, softShadowDownSample: true, contactShadow: true, 5);
			break;
		case 3:
			SetShadow(on: true, 4096, 90f, softShadow: true, softShadowDownSample: false, contactShadow: true, 6);
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 2);
		Set(index);
	}
}
public class SoftShadowOptions : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string offKey = "SoftShadowOptions_Off";

	[LocalizationKey("Default")]
	public string onKey = "SoftShadowOptions_On";

	public override string Key => "SoftShadowSettings";

	public override string[] GetOptions()
	{
		return new string[2]
		{
			offKey.ToPlainText(),
			onKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 1) switch
		{
			0 => offKey.ToPlainText(), 
			1 => onKey.ToPlainText(), 
			_ => offKey.ToPlainText(), 
		};
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}

	public override void Set(int index)
	{
	}
}
public class SunFogEntry : MonoBehaviour
{
	private static bool settingEnabled = true;

	private static event Action OnSettingChangedEvent;

	public static void SetEnabled(bool enabled)
	{
		settingEnabled = enabled;
		SunFogEntry.OnSettingChangedEvent?.Invoke();
	}

	private void Awake()
	{
		OnSettingChangedEvent += OnSettingChanged;
		base.gameObject.SetActive(settingEnabled);
	}

	private void OnDestroy()
	{
		OnSettingChangedEvent -= OnSettingChanged;
	}

	private void OnSettingChanged()
	{
		base.gameObject.SetActive(settingEnabled);
	}
}
public class SunFogSettings : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string onKey = "Options_On";

	[LocalizationKey("Default")]
	public string offKey = "Options_Off";

	public override string Key => "SunFogSetting";

	public override string[] GetOptions()
	{
		return new string[2]
		{
			offKey.ToPlainText(),
			onKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		return OptionsManager.Load(Key, 1) switch
		{
			0 => offKey.ToPlainText(), 
			1 => onKey.ToPlainText(), 
			_ => onKey.ToPlainText(), 
		};
	}

	public override void Set(int index)
	{
		switch (index)
		{
		case 0:
			SunFogEntry.SetEnabled(enabled: false);
			break;
		case 1:
			SunFogEntry.SetEnabled(enabled: true);
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}
}
public class UIShadowOptions : OptionsProviderBase
{
	private const string key = "UIShadow";

	public override string Key => "UIShadow";

	public static bool Active
	{
		get
		{
			return OptionsManager.Load("UIShadow", defaultValue: true);
		}
		set
		{
			OptionsManager.Save("UIShadow", value);
		}
	}

	public string ActiveText => "Options_On".ToPlainText();

	public string InactiveText => "Options_Off".ToPlainText();

	public static void Apply()
	{
		TrueShadow.ExternalActive = Active;
	}

	public override string GetCurrentOption()
	{
		if (Active)
		{
			return ActiveText;
		}
		return InactiveText;
	}

	public override string[] GetOptions()
	{
		return new string[2] { InactiveText, ActiveText };
	}

	public override void Set(int index)
	{
		if (index <= 0)
		{
			Active = false;
		}
		else
		{
			Active = true;
		}
	}
}
public class vSyncSetting : OptionsProviderBase
{
	[LocalizationKey("Default")]
	public string onKey = "gSync_On";

	[LocalizationKey("Default")]
	public string offKey = "gSync_Off";

	public GameObject setActiveIfOn;

	public override string Key => "GSyncSetting";

	public override string[] GetOptions()
	{
		return new string[2]
		{
			onKey.ToPlainText(),
			offKey.ToPlainText()
		};
	}

	public override string GetCurrentOption()
	{
		switch (OptionsManager.Load(Key, 1))
		{
		case 0:
			SyncObjectActive(active: true);
			return onKey.ToPlainText();
		case 1:
			SyncObjectActive(active: false);
			return offKey.ToPlainText();
		default:
			return offKey.ToPlainText();
		}
	}

	public override void Set(int index)
	{
		switch (index)
		{
		case 0:
			QualitySettings.vSyncCount = 1;
			SyncObjectActive(active: true);
			break;
		case 1:
			QualitySettings.vSyncCount = 0;
			SyncObjectActive(active: false);
			break;
		}
		OptionsManager.Save(Key, index);
	}

	private void SyncObjectActive(bool active)
	{
		if ((bool)setActiveIfOn)
		{
			setActiveIfOn.SetActive(active);
		}
	}

	private void Awake()
	{
		LevelManager.OnLevelInitialized += RefreshOnLevelInited;
	}

	private void OnDestroy()
	{
		LevelManager.OnLevelInitialized -= RefreshOnLevelInited;
	}

	private void RefreshOnLevelInited()
	{
		int index = OptionsManager.Load(Key, 1);
		Set(index);
	}
}
public class UIButtonRevertBinding : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Button button;

	private void Awake()
	{
		if (button == null)
		{
			button = GetComponent<UnityEngine.UI.Button>();
		}
		button.onClick.AddListener(OnBtnClick);
	}

	public void OnBtnClick()
	{
		InputRebinder.Clear();
		InputRebinder.Save();
	}
}
public class UIKeybindingEntry : MonoBehaviour
{
	[SerializeField]
	private InputActionReference actionRef;

	[SerializeField]
	private int index;

	[SerializeField]
	private string overrideDisplayNameKey;

	private string[] excludes = new string[6] { "<Mouse>/leftButton", "<Mouse>/rightButton", "<Pointer>/position", "<Pointer>/delta", "<Pointer>/press", "<Mouse>/scroll" };

	[SerializeField]
	private TextMeshProUGUI label;

	[SerializeField]
	private UnityEngine.UI.Button rebindButton;

	[SerializeField]
	private InputIndicator indicator;

	[LocalizationKey("UIText")]
	private string displayNameKey
	{
		get
		{
			if (!string.IsNullOrEmpty(overrideDisplayNameKey))
			{
				return overrideDisplayNameKey;
			}
			if (actionRef == null)
			{
				return "?";
			}
			return "Input_" + actionRef.action.name;
		}
		set
		{
		}
	}

	private void Awake()
	{
		rebindButton.onClick.AddListener(OnButtonClick);
		Setup();
		LocalizationManager.OnSetLanguage += OnLanguageChanged;
	}

	private void OnDestroy()
	{
		LocalizationManager.OnSetLanguage -= OnLanguageChanged;
	}

	private void OnLanguageChanged(SystemLanguage language)
	{
		label.text = displayNameKey.ToPlainText();
	}

	private void OnButtonClick()
	{
		InputRebinder.RebindAsync(actionRef.action.name, index, excludes, save: true).Forget();
	}

	private void OnValidate()
	{
		Setup();
	}

	private void Setup()
	{
		indicator.Setup(actionRef, index);
		label.text = displayNameKey.ToPlainText();
	}
}
public class OptionsPanel_TabButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private GameObject selectedIndicator;

	[SerializeField]
	private GameObject tab;

	public Action<OptionsPanel_TabButton, PointerEventData> onClicked;

	public void OnPointerClick(PointerEventData eventData)
	{
		onClicked?.Invoke(this, eventData);
	}

	internal void NotifySelectionChanged(OptionsPanel optionsPanel, OptionsPanel_TabButton selection)
	{
		bool active = selection == this;
		tab.SetActive(active);
		selectedIndicator.SetActive(active);
	}
}
public class RuleEntry_Bool : OptionsProviderBase
{
	[SerializeField]
	private string fieldName;

	private FieldInfo field;

	public override string Key => fieldName;

	private void Awake()
	{
		field = typeof(Ruleset).GetField(fieldName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
	}

	public override string GetCurrentOption()
	{
		Ruleset current = GameRulesManager.Current;
		if ((bool)field.GetValue(current))
		{
			return "Options_On".ToPlainText();
		}
		return "Options_Off".ToPlainText();
	}

	public override string[] GetOptions()
	{
		return new string[2]
		{
			"Options_Off".ToPlainText(),
			"Options_On".ToPlainText()
		};
	}

	public override void Set(int index)
	{
		bool flag = index > 0;
		Ruleset current = GameRulesManager.Current;
		field.SetValue(current, flag);
	}
}
public class UIShadowSetter : MonoBehaviour
{
	private void Awake()
	{
		UIShadowOptions.Apply();
	}
}
public class UnlockStockShopItem : PerkBehaviour
{
	[ItemTypeID]
	[SerializeField]
	private int itemTypeID;

	private string DescriptionFormat => "PerkBehaviour_UnlockStockShopItem".ToPlainText();

	public override string Description => DescriptionFormat.Format(new { ItemDisplayName });

	private string ItemDisplayName => ItemAssetsCollection.GetMetaData(itemTypeID).DisplayName;

	private void Start()
	{
		if (base.Master.Unlocked && !EconomyManager.IsUnlocked(itemTypeID))
		{
			EconomyManager.Unlock(itemTypeID, needConfirm: false, showUI: false);
		}
	}

	protected override void OnUnlocked()
	{
		base.OnUnlocked();
		EconomyManager.Unlock(itemTypeID, needConfirm: false);
	}
}
public class PerkTreeManager : MonoBehaviour
{
	private static PerkTreeManager instance;

	public List<PerkTree> perkTrees;

	public static PerkTreeManager Instance => instance;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else
		{
			UnityEngine.Debug.LogError("检测到多个PerkTreeManager");
		}
	}

	public static PerkTree GetPerkTree(string id)
	{
		if (instance == null)
		{
			return null;
		}
		PerkTree perkTree = instance.perkTrees.FirstOrDefault((PerkTree e) => e != null && e.ID == id);
		if (perkTree == null)
		{
			UnityEngine.Debug.LogError("未找到PerkTree id:" + id);
		}
		return perkTree;
	}
}
public class PreUnlockPerkTree : MonoBehaviour
{
	public void Start()
	{
	}

	private void Update()
	{
	}
}
public class GamePrepareProcess : MonoBehaviour
{
	[SerializeField]
	private DifficultySelection difficultySelection;

	[SerializeField]
	[SceneID]
	private string introScene;

	[SerializeField]
	[SceneID]
	private string guideScene;

	public bool goToBaseSceneIfVisted;

	[SerializeField]
	[SceneID]
	private string baseScene;

	public SceneReference overrideCurtainScene;

	private async UniTask Execute()
	{
		difficultySelection.SkipHide();
		await difficultySelection.Execute();
		if (goToBaseSceneIfVisted && !string.IsNullOrEmpty(baseScene) && MultiSceneCore.GetVisited(baseScene))
		{
			SceneLoader.Instance.LoadScene(baseScene, overrideCurtainScene).Forget();
		}
		else if (goToBaseSceneIfVisted && !string.IsNullOrEmpty(guideScene) && MultiSceneCore.GetVisited(guideScene))
		{
			SceneLoader.Instance.LoadScene(guideScene, overrideCurtainScene).Forget();
		}
		else
		{
			SceneLoader.Instance.LoadScene(introScene, overrideCurtainScene).Forget();
		}
	}

	private void Start()
	{
		Execute().Forget();
	}
}
public class Soda_Joysticks : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
{
	public bool usable = true;

	private int verticalRes;

	[Range(0f, 0.5f)]
	public float joystickRangePercent = 0.3f;

	[Range(0f, 0.5f)]
	public float cancleRangePercent = 0.4f;

	public bool fixedPositon = true;

	public bool followFinger;

	public bool canCancle;

	private float joystickRangePixel;

	private float cancleRangePixel;

	[SerializeField]
	private Transform backGround;

	[SerializeField]
	private UnityEngine.UI.Image joyImage;

	[SerializeField]
	private UnityEngine.CanvasGroup cancleRangeCanvasGroup;

	private bool holding;

	private Vector2 downPoint;

	private int currentPointerID;

	private Vector2 inputValue;

	[SerializeField]
	private float rotValue = 10f;

	[Range(0f, 1f)]
	public float deadZone;

	[Range(0f, 1f)]
	public float fullZone = 1f;

	public bool hideWhenNotTouch;

	public UnityEngine.CanvasGroup canvasGroup;

	private bool triggeringCancle;

	public UnityEvent<Vector2, bool> UpdateValueEvent;

	public UnityEvent OnTouchEvent;

	public UnityEvent<bool> OnUpEvent;

	public bool Holding => holding;

	public Vector2 InputValue => inputValue;

	private void Start()
	{
		joyImage.gameObject.SetActive(value: false);
		if (hideWhenNotTouch)
		{
			canvasGroup.alpha = 0f;
		}
		if ((bool)cancleRangeCanvasGroup)
		{
			cancleRangeCanvasGroup.alpha = 0f;
		}
	}

	private void Update()
	{
		if (holding && !usable)
		{
			Revert();
		}
	}

	private void OnEnable()
	{
		if ((bool)cancleRangeCanvasGroup)
		{
			cancleRangeCanvasGroup.alpha = 0f;
		}
		triggeringCancle = false;
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		if (usable && !holding)
		{
			holding = true;
			currentPointerID = eventData.pointerId;
			downPoint = eventData.position;
			verticalRes = Screen.height;
			joystickRangePixel = (float)verticalRes * joystickRangePercent;
			cancleRangePixel = (float)verticalRes * cancleRangePercent;
			if (!fixedPositon)
			{
				backGround.transform.position = downPoint;
			}
			joyImage.transform.position = backGround.transform.position;
			backGround.transform.rotation = Quaternion.Euler(Vector3.zero);
			joyImage.gameObject.SetActive(value: true);
			UpdateValueEvent?.Invoke(Vector2.zero, arg1: true);
			if (hideWhenNotTouch)
			{
				canvasGroup.alpha = 1f;
			}
			if (canCancle && (bool)cancleRangeCanvasGroup)
			{
				cancleRangeCanvasGroup.alpha = 0.12f;
			}
			triggeringCancle = false;
			OnTouchEvent?.Invoke();
		}
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (usable)
		{
			OnUpEvent?.Invoke(!triggeringCancle);
			UpdateValueEvent?.Invoke(Vector2.zero, arg1: false);
			if (holding && currentPointerID == eventData.pointerId)
			{
				Revert();
			}
		}
	}

	private void Revert()
	{
		UpdateValueEvent?.Invoke(Vector2.zero, arg1: false);
		if (holding)
		{
			OnUpEvent?.Invoke(arg0: false);
		}
		if (usable)
		{
			joyImage.transform.position = backGround.transform.position;
			inputValue = Vector2.zero;
			holding = false;
			backGround.transform.rotation = Quaternion.Euler(Vector3.zero);
			if (joyImage.gameObject.activeSelf)
			{
				joyImage.gameObject.SetActive(value: false);
			}
			if (hideWhenNotTouch)
			{
				canvasGroup.alpha = 0f;
			}
			if ((bool)cancleRangeCanvasGroup)
			{
				cancleRangeCanvasGroup.alpha = 0f;
			}
		}
	}

	public void CancleTouch()
	{
		Revert();
	}

	public void OnDisable()
	{
		Revert();
	}

	public void OnDrag(PointerEventData eventData)
	{
		if (!holding || eventData.pointerId != currentPointerID)
		{
			return;
		}
		Vector2 position = eventData.position;
		if (position == downPoint)
		{
			inputValue = Vector2.zero;
			return;
		}
		float num = Vector2.Distance(position, downPoint);
		float num2 = num;
		Vector2 normalized = (position - downPoint).normalized;
		if (num > joystickRangePixel)
		{
			if (followFinger)
			{
				downPoint += (num - joystickRangePixel) * normalized;
			}
			if (!fixedPositon && followFinger)
			{
				backGround.transform.position = downPoint;
			}
			num2 = joystickRangePixel;
		}
		position = downPoint + normalized * num2;
		Vector2 vector = Vector2.zero;
		if (joystickRangePixel > 0f)
		{
			vector = normalized * num2 / joystickRangePixel;
		}
		joyImage.transform.position = backGround.transform.position + (Vector3)normalized * num2;
		Vector3 zero = Vector3.zero;
		zero.y = 0f - vector.x;
		zero.x = vector.y;
		zero *= rotValue;
		backGround.transform.rotation = Quaternion.Euler(zero);
		float magnitude = vector.magnitude;
		magnitude = Mathf.InverseLerp(deadZone, fullZone, magnitude);
		inputValue = magnitude * normalized;
		UpdateValueEvent?.Invoke(inputValue, arg1: true);
		if (canCancle && (bool)cancleRangeCanvasGroup)
		{
			if (num >= cancleRangePixel)
			{
				cancleRangeCanvasGroup.alpha = 1f;
				triggeringCancle = true;
			}
			else
			{
				cancleRangeCanvasGroup.alpha = 0.12f;
				triggeringCancle = false;
			}
		}
	}
}
public class SteamStatsAPITest : MonoBehaviour
{
	private Callback<UserStatsReceived_t> onStatsReceivedCallback;

	private Callback<UserStatsStored_t> onStatsStoredCallback;

	private void Awake()
	{
		onStatsReceivedCallback = Callback<UserStatsReceived_t>.Create(OnUserStatReceived);
		onStatsStoredCallback = Callback<UserStatsStored_t>.Create(OnUserStatStored);
	}

	private void OnUserStatStored(UserStatsStored_t param)
	{
		UnityEngine.Debug.Log("Stat Stored!");
	}

	private void OnUserStatReceived(UserStatsReceived_t param)
	{
		CSteamID steamIDUser = param.m_steamIDUser;
		UnityEngine.Debug.Log("Stat Fetched:" + steamIDUser.ToString() + " " + param.m_nGameID);
	}

	private void Start()
	{
		SteamUserStats.RequestGlobalStats(60);
	}

	private void Test()
	{
		UnityEngine.Debug.Log(SteamUserStats.GetStat("game_finished", out int pData) + " " + pData);
		bool flag = SteamUserStats.SetStat("game_finished", pData + 1);
		UnityEngine.Debug.Log($"Set: {flag}");
		SteamUserStats.StoreStats();
	}

	private void GetGlobalStat()
	{
		if (SteamUserStats.GetGlobalStat("game_finished", out long pData))
		{
			UnityEngine.Debug.Log($"game finished: {pData}");
		}
		else
		{
			UnityEngine.Debug.Log("Failed");
		}
	}
}
public class EventIfSteamChina : MonoBehaviour
{
	public UnityEvent onStart_IsSteamChina;

	public UnityEvent onStart_IsNotSteamChina;

	private void Start()
	{
		if (SteamManager.Initialized)
		{
			if (SteamUtils.IsSteamChinaLauncher())
			{
				onStart_IsSteamChina.Invoke();
			}
			else
			{
				onStart_IsNotSteamChina.Invoke();
			}
		}
	}
}
public class SteamLogoImage : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Image image;

	[SerializeField]
	private Sprite steamLogo;

	[SerializeField]
	private Sprite steamChinaLogo;

	private void Start()
	{
		Refresh();
	}

	private void Refresh()
	{
		if (!SteamManager.Initialized)
		{
			image.sprite = steamLogo;
		}
		else if (SteamUtils.IsSteamChinaLauncher())
		{
			image.sprite = steamChinaLogo;
		}
		else
		{
			image.sprite = steamLogo;
		}
	}
}
public class TaskSkipperUI : MonoBehaviour
{
	[SerializeField]
	private TaskList target;

	[SerializeField]
	private UnityEngine.CanvasGroup canvasGroup;

	[SerializeField]
	private UnityEngine.UI.Image fill;

	[SerializeField]
	private float totalTime = 2f;

	[SerializeField]
	private float hideAfterSeconds = 2f;

	private float pressTime;

	private float alpha;

	private float hideTimer;

	private bool show;

	private IDisposable anyButtonListener;

	private bool pressing;

	private bool skipped;

	private void Awake()
	{
		UIInputManager.OnInteractInputContext += OnInteractInputContext;
		anyButtonListener = InputSystem.onAnyButtonPress.Call(OnAnyButton);
		skipped = false;
		alpha = 0f;
	}

	private void OnAnyButton(InputControl control)
	{
		Show();
	}

	private void OnDestroy()
	{
		UIInputManager.OnInteractInputContext -= OnInteractInputContext;
		anyButtonListener.Dispose();
	}

	private void OnInteractInputContext(InputAction.CallbackContext context)
	{
		if (context.started)
		{
			pressing = true;
		}
		if (context.canceled)
		{
			pressing = false;
		}
	}

	private void Update()
	{
		UpdatePressing();
		UpdateFill();
		UpdateCanvasGroup();
	}

	private void Show()
	{
		show = true;
		hideTimer = hideAfterSeconds;
	}

	private void UpdatePressing()
	{
		if (UIInputManager.Instance == null)
		{
			pressing = Keyboard.current.fKey.isPressed;
		}
		if (pressing && !skipped)
		{
			pressTime += Time.deltaTime;
			if (pressTime >= totalTime)
			{
				skipped = true;
				target.Skip();
			}
			Show();
		}
		else if (!skipped)
		{
			pressTime = Mathf.MoveTowards(pressTime, 0f, Time.deltaTime);
		}
	}

	private void UpdateFill()
	{
		float fillAmount = pressTime / totalTime;
		fill.fillAmount = fillAmount;
	}

	private void UpdateCanvasGroup()
	{
		if (show)
		{
			alpha = Mathf.MoveTowards(alpha, 1f, 10f * Time.deltaTime);
			hideTimer = Mathf.MoveTowards(hideTimer, 0f, Time.deltaTime);
			if (hideTimer < 0.01f)
			{
				show = false;
			}
		}
		else
		{
			alpha = Mathf.MoveTowards(alpha, 0f, 10f * Time.deltaTime);
		}
		canvasGroup.alpha = alpha;
	}
}
public class DateTimeAttribute : Attribute
{
}
public class TimeSpanAttribute : Attribute
{
}
public class ColorPunch : MonoBehaviour
{
	[SerializeField]
	private Graphic graphic;

	[SerializeField]
	private float duration;

	[SerializeField]
	private Gradient gradient;

	[SerializeField]
	private Color tint = Color.white;

	private Color resetColor;

	private int activeToken;

	private void Awake()
	{
		if (graphic == null)
		{
			graphic = GetComponent<Graphic>();
		}
		resetColor = graphic.color;
	}

	public void Punch()
	{
		DoTask().Forget();
	}

	private int NewToken()
	{
		activeToken = UnityEngine.Random.Range(1, int.MaxValue);
		return activeToken;
	}

	private async UniTask DoTask()
	{
		int token = NewToken();
		float time = 0f;
		if (!(duration <= 0f))
		{
			while (time < duration)
			{
				time += Time.unscaledDeltaTime;
				float time2 = time / duration;
				graphic.color = gradient.Evaluate(time2) * tint;
				await UniTask.NextFrame();
				if (token != activeToken)
				{
					return;
				}
			}
		}
		graphic.color = resetColor;
	}
}
public interface IItemMetaDataProvider
{
	ItemMetaData GetMetaData();
}
public class InventoryFilterDisplay : MonoBehaviour, ISingleSelectionMenu<InventoryFilterDisplayEntry>
{
	[SerializeField]
	private InventoryFilterDisplayEntry template;

	private PrefabPool<InventoryFilterDisplayEntry> _pool;

	private InventoryDisplay targetDisplay;

	private InventoryFilterProvider provider;

	private List<InventoryFilterDisplayEntry> entries = new List<InventoryFilterDisplayEntry>();

	private InventoryFilterDisplayEntry selection;

	private PrefabPool<InventoryFilterDisplayEntry> Pool
	{
		get
		{
			if (_pool == null)
			{
				_pool = new PrefabPool<InventoryFilterDisplayEntry>(template);
			}
			return _pool;
		}
	}

	private void Awake()
	{
		template.gameObject.SetActive(value: false);
	}

	public void Setup(InventoryDisplay target)
	{
		Pool.ReleaseAll();
		entries.Clear();
		if (target == null)
		{
			return;
		}
		targetDisplay = target;
		provider = target.Target.GetComponent<InventoryFilterProvider>();
		if (!(provider == null))
		{
			InventoryFilterProvider.FilterEntry[] array = provider.entries;
			foreach (InventoryFilterProvider.FilterEntry filter in array)
			{
				InventoryFilterDisplayEntry inventoryFilterDisplayEntry = Pool.Get();
				inventoryFilterDisplayEntry.Setup(OnEntryClicked, filter);
				entries.Add(inventoryFilterDisplayEntry);
			}
			selection = null;
		}
	}

	private void OnEntryClicked(InventoryFilterDisplayEntry entry, PointerEventData data)
	{
		SetSelection(entry);
	}

	internal void Select(int i)
	{
		if (i >= 0 && i < entries.Count)
		{
			SetSelection(entries[i]);
		}
	}

	public InventoryFilterDisplayEntry GetSelection()
	{
		return selection;
	}

	public bool SetSelection(InventoryFilterDisplayEntry selection)
	{
		if (selection == null)
		{
			return false;
		}
		this.selection = selection;
		InventoryFilterProvider.FilterEntry filter = selection.Filter;
		targetDisplay.SetFilter(filter.GetFunction());
		foreach (InventoryFilterDisplayEntry entry in entries)
		{
			entry.NotifySelectionChanged(entry == selection);
		}
		return true;
	}
}
public class InventoryFilterDisplayEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	[SerializeField]
	private UnityEngine.UI.Image icon;

	[SerializeField]
	private TextMeshProUGUI nameDisplay;

	[SerializeField]
	private GameObject selectedIndicator;

	private Action<InventoryFilterDisplayEntry, PointerEventData> onPointerClick;

	public InventoryFilterProvider.FilterEntry Filter { get; private set; }

	public void OnPointerClick(PointerEventData eventData)
	{
		onPointerClick?.Invoke(this, eventData);
	}

	internal void Setup(Action<InventoryFilterDisplayEntry, PointerEventData> onPointerClick, InventoryFilterProvider.FilterEntry filter)
	{
		this.onPointerClick = onPointerClick;
		Filter = filter;
		if ((bool)icon)
		{
			icon.sprite = filter.icon;
		}
		if ((bool)nameDisplay)
		{
			nameDisplay.text = filter.DisplayName;
		}
	}

	internal void NotifySelectionChanged(bool isThisSelected)
	{
		selectedIndicator.SetActive(isThisSelected);
	}
}
public class InventoryFilterProvider : MonoBehaviour
{
	[Serializable]
	public struct FilterEntry
	{
		[LocalizationKey("Default")]
		public string name;

		public Sprite icon;

		public Tag[] requireTags;

		public string DisplayName => name.ToPlainText();

		private bool FilterFunction(Item item)
		{
			if (item == null)
			{
				return false;
			}
			if (requireTags.Length == 0)
			{
				return true;
			}
			Tag[] array = requireTags;
			foreach (Tag tag in array)
			{
				if (!(tag == null) && item.Tags.Contains(tag))
				{
					return true;
				}
			}
			return false;
		}

		public Func<Item, bool> GetFunction()
		{
			if (requireTags.Length == 0)
			{
				return null;
			}
			return FilterFunction;
		}
	}

	public FilterEntry[] entries;
}
public class BulletTypeDisplay : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI bulletDisplayName;

	[LocalizationKey("Default")]
	private string NotAssignedTextKey => "UI_Bullet_NotAssigned";

	internal void Setup(int targetBulletID)
	{
		if (targetBulletID < 0)
		{
			bulletDisplayName.text = NotAssignedTextKey.ToPlainText();
			return;
		}
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(targetBulletID);
		bulletDisplayName.text = metaData.DisplayName;
	}
}
public class ItemMetaDisplay : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IItemMetaDataProvider
{
	[SerializeField]
	private UnityEngine.UI.Image icon;

	[SerializeField]
	private TrueShadow displayQualityShadow;

	private ItemMetaData data;

	public static event Action<ItemMetaDisplay> OnMouseEnter;

	public static event Action<ItemMetaDisplay> OnMouseExit;

	public ItemMetaData GetMetaData()
	{
		return data;
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
		ItemMetaDisplay.OnMouseEnter?.Invoke(this);
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		ItemMetaDisplay.OnMouseExit?.Invoke(this);
	}

	public void Setup(int typeID)
	{
		ItemMetaData metaData = ItemAssetsCollection.GetMetaData(typeID);
		Setup(metaData);
	}

	public void Setup(ItemMetaData data)
	{
		this.data = data;
		icon.sprite = data.icon;
		GameplayDataSettings.UIStyle.ApplyDisplayQualityShadow(data.displayQuality, displayQualityShadow);
	}

	internal void Setup(object rootTypeID)
	{
		throw new NotImplementedException();
	}
}
public class MinimapButton : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class SplitDialogue : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	private enum Status
	{
		Idle,
		Normal,
		Busy,
		Complete,
		Canceled
	}

	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private UnityEngine.UI.Button confirmButton;

	[SerializeField]
	private TextMeshProUGUI countText;

	[SerializeField]
	private GameObject normalIndicator;

	[SerializeField]
	private GameObject busyIndicator;

	[SerializeField]
	private GameObject completeIndicator;

	[SerializeField]
	private UnityEngine.UI.Slider slider;

	private Item target;

	private Inventory destination;

	private int destinationIndex;

	private Inventory cachedInInventory;

	private Status status;

	public static SplitDialogue Instance
	{
		get
		{
			if (GameplayUIManager.Instance == null)
			{
				return null;
			}
			return GameplayUIManager.Instance.SplitDialogue;
		}
	}

	private void OnEnable()
	{
		View.OnActiveViewChanged += OnActiveViewChanged;
	}

	private void OnDisable()
	{
		View.OnActiveViewChanged -= OnActiveViewChanged;
	}

	private void OnActiveViewChanged()
	{
		Hide();
	}

	private void Awake()
	{
		confirmButton.onClick.AddListener(OnConfirmButtonClicked);
		slider.onValueChanged.AddListener(OnSliderValueChanged);
	}

	private void OnSliderValueChanged(float value)
	{
		RefreshCountText();
	}

	private void RefreshCountText()
	{
		countText.text = slider.value.ToString("0");
	}

	private void OnConfirmButtonClicked()
	{
		if (status == Status.Normal)
		{
			Confirm().Forget();
		}
	}

	private void Setup(Item target, Inventory destination = null, int destinationIndex = -1)
	{
		this.target = target;
		this.destination = destination;
		this.destinationIndex = destinationIndex;
		slider.minValue = 1f;
		slider.maxValue = target.StackCount;
		slider.value = (float)(target.StackCount - 1) / 2f;
		RefreshCountText();
		SwitchStatus(Status.Normal);
		cachedInInventory = target.InInventory;
	}

	public void Cancel()
	{
		if (status == Status.Normal)
		{
			SwitchStatus(Status.Canceled);
			Hide();
		}
	}

	private async UniTask Confirm()
	{
		if (status == Status.Normal)
		{
			if (cachedInInventory == target.InInventory)
			{
				SwitchStatus(Status.Busy);
				await DoSplit(Mathf.RoundToInt(slider.value));
			}
			SwitchStatus(Status.Complete);
			Hide();
		}
	}

	private void Hide()
	{
		fadeGroup.Hide();
	}

	private async UniTask DoSplit(int value)
	{
		if (value != 0)
		{
			if (value == target.StackCount)
			{
				Send(target);
				return;
			}
			Send(await target.Split(value));
			ItemUIUtilities.Select(null);
		}
		void Send(Item item)
		{
			item.Detach();
			if (destination != null && destination.Capacity > destinationIndex && destination.GetItemAt(destinationIndex) == null)
			{
				destination.AddAt(item, destinationIndex);
			}
			else
			{
				ItemUtilities.SendToPlayerCharacterInventory(item, dontMerge: true);
			}
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		if (eventData.pointerCurrentRaycast.gameObject == base.gameObject)
		{
			Cancel();
		}
	}

	private void SwitchStatus(Status status)
	{
		this.status = status;
		normalIndicator.SetActive(status == Status.Normal);
		busyIndicator.SetActive(status == Status.Busy);
		completeIndicator.SetActive(status == Status.Complete);
		switch (status)
		{
		}
	}

	public static void SetupAndShow(Item item)
	{
		if (!(Instance == null))
		{
			Instance.Setup(item);
			Instance.fadeGroup.Show();
		}
	}

	public static void SetupAndShow(Item item, Inventory destinationInventory, int destinationIndex)
	{
		if (!(Instance == null))
		{
			Instance.Setup(item, destinationInventory, destinationIndex);
			Instance.fadeGroup.Show();
		}
	}
}
public class DebugUISetup : MonoBehaviour
{
	[SerializeField]
	private ItemSlotCollectionDisplay slotCollectionDisplay;

	[SerializeField]
	private InventoryDisplay inventoryDisplay;

	private CharacterMainControl Character => LevelManager.Instance.MainCharacter;

	private Item CharacterItem => Character.CharacterItem;

	public void Setup()
	{
		slotCollectionDisplay.Setup(CharacterItem);
		inventoryDisplay.Setup(CharacterItem.Inventory);
	}
}
public class ExpDisplay : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI txtLevel;

	[SerializeField]
	private TextMeshProUGUI txtCurrentExp;

	[SerializeField]
	private TextMeshProUGUI txtMaxExp;

	[SerializeField]
	private UnityEngine.UI.Image expBarFill;

	[SerializeField]
	private bool snapToCurrentOnEnable;

	[SerializeField]
	private float animationDuration = 0.1f;

	[SerializeField]
	private AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	[SerializeField]
	private long displayExp;

	private int displayingLevel = -1;

	private Dictionary<int, (long from, long to)> cachedLevelExpRange = new Dictionary<int, (long, long)>();

	private int currentToken;

	private void Refresh()
	{
		EXPManager instance = EXPManager.Instance;
		if (!(instance == null))
		{
			int num = instance.LevelFromExp(displayExp);
			if (displayingLevel != num)
			{
				displayingLevel = num;
				OnDisplayingLevelChanged();
			}
			(long, long) levelExpRange = GetLevelExpRange(num);
			long num2 = levelExpRange.Item2 - levelExpRange.Item1;
			txtLevel.text = num.ToString();
			txtCurrentExp.text = displayExp.ToString();
			string text = ((levelExpRange.Item2 != long.MaxValue) ? levelExpRange.Item2.ToString() : "∞");
			txtMaxExp.text = text;
			float fillAmount = (float)((double)(displayExp - levelExpRange.Item1) / (double)num2);
			expBarFill.fillAmount = fillAmount;
		}
	}

	private void OnDisplayingLevelChanged()
	{
	}

	private (long from, long to) GetLevelExpRange(int level)
	{
		if (cachedLevelExpRange.TryGetValue(level, out (long, long) value))
		{
			return value;
		}
		EXPManager instance = EXPManager.Instance;
		if (instance == null)
		{
			return (from: 0L, to: 0L);
		}
		(long, long) levelExpRange = instance.GetLevelExpRange(level);
		cachedLevelExpRange[level] = levelExpRange;
		return levelExpRange;
	}

	private void SnapToCurrent()
	{
		displayExp = EXPManager.EXP;
		Refresh();
	}

	private async UniTask Animate(long targetExp, float duration, AnimationCurve curve)
	{
		int token = (currentToken = UnityEngine.Random.Range(int.MinValue, int.MaxValue));
		if (!(duration <= 0f))
		{
			float time = 0f;
			long from = displayExp;
			while (time < duration)
			{
				if (currentToken != token)
				{
					return;
				}
				float t = curve.Evaluate(time / duration);
				displayExp = LongLerp(from, targetExp, t);
				time += Time.deltaTime;
				Refresh();
				await UniTask.WaitForEndOfFrame(this);
			}
		}
		displayExp = targetExp;
		Refresh();
	}

	private long LongLerp(long a, long b, float t)
	{
		long num = b - a;
		return a + (long)(t * (float)num);
	}

	private void OnEnable()
	{
		if (snapToCurrentOnEnable)
		{
			SnapToCurrent();
		}
		RegisterEvents();
	}

	private void OnDisable()
	{
		UnregisterEvents();
	}

	private void RegisterEvents()
	{
		EXPManager.onExpChanged = (Action<long>)Delegate.Combine(EXPManager.onExpChanged, new Action<long>(OnExpChanged));
	}

	private void UnregisterEvents()
	{
		EXPManager.onExpChanged = (Action<long>)Delegate.Remove(EXPManager.onExpChanged, new Action<long>(OnExpChanged));
	}

	private void OnExpChanged(long exp)
	{
		Animate(exp, animationDuration, animationCurve).Forget();
	}
}
public class HealthBar_DamageBar : MonoBehaviour
{
	[SerializeField]
	internal RectTransform rectTransform;

	[SerializeField]
	internal UnityEngine.UI.Image image;

	[SerializeField]
	private float duration;

	[SerializeField]
	private float targetSizeDelta = 4f;

	[SerializeField]
	private AnimationCurve curve;

	[SerializeField]
	private Gradient colorOverTime;

	private void Awake()
	{
		if (rectTransform == null)
		{
			rectTransform = base.transform as RectTransform;
		}
		if (image == null)
		{
			image = GetComponent<UnityEngine.UI.Image>();
		}
	}

	public async UniTask Animate(float damageBarPostion, float damageBarWidth, Action onComplete)
	{
		base.gameObject.SetActive(value: true);
		rectTransform.anchoredPosition = new Vector2(damageBarPostion, 0f);
		rectTransform.sizeDelta = new Vector2(damageBarWidth, 0f);
		float time = 0f;
		while (time < duration)
		{
			if (rectTransform == null)
			{
				return;
			}
			time += Time.deltaTime;
			float time2 = time / duration;
			float y = curve.Evaluate(time2) * targetSizeDelta;
			rectTransform.sizeDelta = new Vector2(damageBarWidth, y);
			Color color = colorOverTime.Evaluate(time2);
			image.color = color;
			await UniTask.NextFrame();
		}
		onComplete?.Invoke();
	}
}
public class MultiInteraction : MonoBehaviour
{
	[SerializeField]
	private List<InteractableBase> interactables;

	public ReadOnlyCollection<InteractableBase> Interactables => interactables.AsReadOnly();

	private void OnTriggerEnter(Collider other)
	{
		if (CharacterMainControl.Main.gameObject == other.gameObject)
		{
			MultiInteractionMenu.Instance?.SetupAndShow(this).Forget();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CharacterMainControl.Main.gameObject == other.gameObject)
		{
			MultiInteractionMenu.Instance?.Hide().Forget();
		}
	}
}
public class MultiInteractionMenu : MonoBehaviour
{
	[SerializeField]
	private MultiInteractionMenuButton buttonTemplate;

	[SerializeField]
	private float delayEachButton = 0.25f;

	private PrefabPool<MultiInteractionMenuButton> _buttonPool;

	private MultiInteraction target;

	private int currentTaskToken;

	public static MultiInteractionMenu Instance { get; private set; }

	private PrefabPool<MultiInteractionMenuButton> ButtonPool
	{
		get
		{
			if (_buttonPool == null)
			{
				_buttonPool = new PrefabPool<MultiInteractionMenuButton>(buttonTemplate, buttonTemplate.transform.parent);
				buttonTemplate.gameObject.SetActive(value: false);
			}
			return _buttonPool;
		}
	}

	public MultiInteraction Target => target;

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		buttonTemplate.gameObject.SetActive(value: false);
		base.gameObject.SetActive(value: false);
	}

	private void Setup(MultiInteraction target)
	{
		this.target = target;
		ReadOnlyCollection<InteractableBase> interactables = target.Interactables;
		ButtonPool.ReleaseAll();
		foreach (InteractableBase item in interactables)
		{
			if (!(item == null))
			{
				MultiInteractionMenuButton multiInteractionMenuButton = ButtonPool.Get();
				multiInteractionMenuButton.Setup(item);
				multiInteractionMenuButton.transform.SetAsLastSibling();
			}
		}
	}

	private int CreateNewToken()
	{
		currentTaskToken = UnityEngine.Random.Range(int.MinValue, int.MaxValue);
		return currentTaskToken;
	}

	private bool TokenChanged(int token)
	{
		return token != currentTaskToken;
	}

	public async UniTask SetupAndShow(MultiInteraction target)
	{
		base.gameObject.SetActive(value: true);
		int token = CreateNewToken();
		Setup(target);
		ReadOnlyCollection<MultiInteractionMenuButton> activeEntries = ButtonPool.ActiveEntries;
		foreach (MultiInteractionMenuButton item in activeEntries)
		{
			item.Show();
			await UniTask.WaitForSeconds(delayEachButton, ignoreTimeScale: true);
			if (TokenChanged(token))
			{
				return;
			}
		}
	}

	public async UniTask Hide()
	{
		int token = CreateNewToken();
		ReadOnlyCollection<MultiInteractionMenuButton> activeEntries = ButtonPool.ActiveEntries;
		foreach (MultiInteractionMenuButton item in activeEntries)
		{
			item.Hide();
			await UniTask.WaitForSeconds(delayEachButton, ignoreTimeScale: true);
			if (TokenChanged(token))
			{
				return;
			}
		}
		base.gameObject.SetActive(value: false);
	}
}
public class MultiInteractionMenuButton : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Button button;

	[SerializeField]
	private TextMeshProUGUI text;

	[SerializeField]
	private FadeGroup fadeGroup;

	private InteractableBase target;

	private void Awake()
	{
		button.onClick.AddListener(OnButtonClicked);
	}

	private void OnButtonClicked()
	{
		if (!(target == null))
		{
			CharacterMainControl.Main?.Interact(target);
		}
	}

	internal void Setup(InteractableBase target)
	{
		base.gameObject.SetActive(value: true);
		this.target = target;
		text.text = target.InteractName;
		fadeGroup.SkipHide();
	}

	internal void Show()
	{
		fadeGroup.Show();
	}

	internal void Hide()
	{
		fadeGroup.Hide();
	}
}
public class HUDManager : MonoBehaviour
{
	[SerializeField]
	private FadeGroup fadeGroup;

	[SerializeField]
	private UnityEngine.CanvasGroup canvasGroup;

	private static List<UnityEngine.Object> hideTokens = new List<UnityEngine.Object>();

	private bool ShouldDisplay
	{
		get
		{
			bool num = hideTokens.Any((UnityEngine.Object e) => e != null);
			bool flag = View.ActiveView != null;
			bool active = DialogueUI.Active;
			bool flag2 = CustomFaceUI.ActiveView != null;
			bool active2 = CameraMode.Active;
			if (!num && !flag && !active && !flag2)
			{
				return !active2;
			}
			return false;
		}
	}

	private static event Action onHideTokensChanged;

	private void Awake()
	{
		View.OnActiveViewChanged += OnActiveViewChanged;
		DialogueUI.OnDialogueStatusChanged += OnDialogueStatusChanged;
		CustomFaceUI.OnCustomUIViewChanged += OnCustomFaceViewChange;
		CameraMode.OnCameraModeChanged = (Action<bool>)Delegate.Combine(CameraMode.OnCameraModeChanged, new Action<bool>(OnCameraModeChanged));
		onHideTokensChanged += OnHideTokensChanged;
	}

	private void OnDestroy()
	{
		View.OnActiveViewChanged -= OnActiveViewChanged;
		DialogueUI.OnDialogueStatusChanged -= OnDialogueStatusChanged;
		CustomFaceUI.OnCustomUIViewChanged -= OnCustomFaceViewChange;
		CameraMode.OnCameraModeChanged = (Action<bool>)Delegate.Remove(CameraMode.OnCameraModeChanged, new Action<bool>(OnCameraModeChanged));
		onHideTokensChanged -= OnHideTokensChanged;
	}

	private void OnHideTokensChanged()
	{
		Refresh();
	}

	private void OnCameraModeChanged(bool value)
	{
		Refresh();
	}

	private void OnDialogueStatusChanged()
	{
		Refresh();
	}

	private void OnActiveViewChanged()
	{
		Refresh();
	}

	private void OnCustomFaceViewChange()
	{
		Refresh();
	}

	private void Refresh()
	{
		if (ShouldDisplay)
		{
			canvasGroup.blocksRaycasts = true;
			if (!fadeGroup.IsShown)
			{
				fadeGroup.Show();
			}
		}
		else
		{
			canvasGroup.blocksRaycasts = false;
			if (!fadeGroup.IsHidden)
			{
				fadeGroup.Hide();
			}
		}
	}

	public static void RegisterHideToken(UnityEngine.Object obj)
	{
		hideTokens.Add(obj);
		HUDManager.onHideTokensChanged?.Invoke();
	}

	public static void UnregisterHideToken(UnityEngine.Object obj)
	{
		hideTokens.Remove(obj);
		HUDManager.onHideTokensChanged?.Invoke();
	}
}
public class UI_Bus_Slider : MonoBehaviour
{
	private AudioManager.Bus busRef;

	[SerializeField]
	private string busName;

	[SerializeField]
	private TextMeshProUGUI volumeNumberText;

	[SerializeField]
	private UnityEngine.UI.Slider slider;

	private bool initialized;

	private AudioManager.Bus BusRef
	{
		get
		{
			if (!AudioManager.Initialized)
			{
				return null;
			}
			if (busRef == null)
			{
				busRef = AudioManager.GetBus(busName);
				if (busRef == null)
				{
					UnityEngine.Debug.LogError("Bus not found:" + busName);
				}
			}
			return busRef;
		}
	}

	private void Initialize()
	{
		if (BusRef != null)
		{
			slider.SetValueWithoutNotify(BusRef.Volume);
			volumeNumberText.text = (BusRef.Volume * 100f).ToString("0");
			initialized = true;
		}
	}

	private void Awake()
	{
		slider.onValueChanged.AddListener(OnValueChanged);
	}

	private void Start()
	{
		if (!initialized)
		{
			Initialize();
		}
	}

	private void OnEnable()
	{
		Initialize();
	}

	private void OnValueChanged(float value)
	{
		if (BusRef != null)
		{
			BusRef.Volume = value;
			BusRef.Mute = value == 0f;
			volumeNumberText.text = (BusRef.Volume * 100f).ToString("0");
		}
	}
}
public class StorageDockCountTMP : MonoBehaviour
{
	[SerializeField]
	private TextMeshPro tmp;

	[SerializeField]
	private bool setActiveFalseWhenCountIsZero;

	private void Awake()
	{
		PlayerStorage.OnItemAddedToBuffer += OnItemAddedToBuffer;
		PlayerStorage.OnTakeBufferItem += OnTakeBufferItem;
		PlayerStorage.OnLoadingFinished += OnLoadingFinished;
	}

	private void OnDestroy()
	{
		PlayerStorage.OnItemAddedToBuffer -= OnItemAddedToBuffer;
		PlayerStorage.OnTakeBufferItem -= OnTakeBufferItem;
		PlayerStorage.OnLoadingFinished -= OnLoadingFinished;
	}

	private void OnLoadingFinished()
	{
		Refresh();
	}

	private void Start()
	{
		Refresh();
	}

	private void OnTakeBufferItem()
	{
		Refresh();
	}

	private void OnItemAddedToBuffer(Item item)
	{
		Refresh();
	}

	private void Refresh()
	{
		int count = PlayerStorage.IncomingItemBuffer.Count;
		tmp.text = $"{count}";
		if (setActiveFalseWhenCountIsZero)
		{
			base.gameObject.SetActive(count > 0);
		}
	}
}
public interface IMerchant
{
	int ConvertPrice(Item item, bool selling = false);
}
public class DecomposeSlider : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.UI.Slider slider;

	public TextMeshProUGUI minText;

	public TextMeshProUGUI maxText;

	public TextMeshProUGUI valueText;

	public int Value
	{
		get
		{
			return Mathf.RoundToInt(slider.value);
		}
		set
		{
			slider.value = value;
			valueText.text = value.ToString();
		}
	}

	public event Action<float> OnValueChangedEvent;

	private void Awake()
	{
		slider.onValueChanged.AddListener(OnValueChanged);
	}

	private void OnDestroy()
	{
		slider.onValueChanged.RemoveListener(OnValueChanged);
	}

	private void OnValueChanged(float value)
	{
		this.OnValueChangedEvent(value);
		valueText.text = value.ToString();
	}

	public void SetMinMax(int min, int max)
	{
		slider.minValue = min;
		slider.maxValue = max;
		minText.text = min.ToString();
		maxText.text = max.ToString();
	}
}
public class ItemRepair_RepairAllPanel : MonoBehaviour
{
	[SerializeField]
	private ItemRepairView master;

	[SerializeField]
	private TextMeshProUGUI priceDisplay;

	[SerializeField]
	private ItemDisplay itemDisplayTemplate;

	[SerializeField]
	private UnityEngine.UI.Button button;

	[SerializeField]
	private GameObject placeholder;

	private PrefabPool<ItemDisplay> _pool;

	private bool needsRefresh;

	private PrefabPool<ItemDisplay> Pool
	{
		get
		{
			if (_pool == null)
			{
				_pool = new PrefabPool<ItemDisplay>(itemDisplayTemplate, null, null, null, null, collectionCheck: true, 10, 10000, delegate(ItemDisplay e)
				{
					e.onPointerClick += OnPointerClickEntry;
				});
			}
			return _pool;
		}
	}

	private void OnPointerClickEntry(ItemDisplay display, PointerEventData data)
	{
		data.Use();
	}

	private void Awake()
	{
		itemDisplayTemplate.gameObject.SetActive(value: false);
		button.onClick.AddListener(OnButtonClicked);
	}

	private void OnButtonClicked()
	{
		if (!(master == null))
		{
			List<Item> allEquippedItems = master.GetAllEquippedItems();
			master.RepairItems(allEquippedItems);
			needsRefresh = true;
		}
	}

	private void OnEnable()
	{
		ItemUtilities.OnPlayerItemOperation += OnPlayerItemOperation;
		ItemRepairView.OnRepaireOptionDone += OnRepairOptionDone;
	}

	private void OnDisable()
	{
		ItemUtilities.OnPlayerItemOperation -= OnPlayerItemOperation;
		ItemRepairView.OnRepaireOptionDone -= OnRepairOptionDone;
	}

	public void Setup(ItemRepairView master)
	{
		this.master = master;
		Refresh();
	}

	private void OnPlayerItemOperation()
	{
		needsRefresh = true;
	}

	private void OnRepairOptionDone()
	{
		needsRefresh = true;
	}

	private void Refresh()
	{
		needsRefresh = false;
		Pool.ReleaseAll();
		List<Item> list = (from e in master.GetAllEquippedItems()
			where e.Durability < e.MaxDurabilityWithLoss
			select e).ToList();
		int num = 0;
		if (list != null && list.Count > 0)
		{
			foreach (Item item in list)
			{
				Pool.Get().Setup(item);
			}
			num = master.CalculateRepairPrice(list);
			placeholder.SetActive(value: false);
			bool enough = new Cost(num).Enough;
			button.interactable = enough;
		}
		else
		{
			placeholder.SetActive(value: true);
			button.interactable = false;
		}
		priceDisplay.text = num.ToString();
	}

	private void Update()
	{
		if (needsRefresh)
		{
			Refresh();
		}
	}
}
public class ViewTabs : MonoBehaviour
{
	[SerializeField]
	private FadeGroup fadeGroup;

	public void Show()
	{
		fadeGroup.Show();
	}

	public void Hide()
	{
		fadeGroup.Hide();
	}

	private void Update()
	{
		if (fadeGroup.IsShown && View.ActiveView == null)
		{
			Hide();
		}
	}
}
public class ViewTabDisplayEntry : MonoBehaviour
{
	[SerializeField]
	private string viewTypeName;

	[SerializeField]
	private GameObject indicator;

	[SerializeField]
	private PunchReceiver punch;

	private void Awake()
	{
		ManagedUIElement.onOpen += OnViewOpen;
		ManagedUIElement.onClose += OnViewClose;
		HideIndicator();
	}

	private void OnDestroy()
	{
		ManagedUIElement.onOpen -= OnViewOpen;
		ManagedUIElement.onClose -= OnViewClose;
	}

	private void Start()
	{
		if (View.ActiveView != null && View.ActiveView.GetType().Name == viewTypeName)
		{
			ShowIndicator();
		}
	}

	private void OnViewClose(ManagedUIElement element)
	{
		if (element.GetType().Name == viewTypeName)
		{
			HideIndicator();
		}
	}

	private void OnViewOpen(ManagedUIElement element)
	{
		if (element.GetType().Name == viewTypeName)
		{
			ShowIndicator();
		}
	}

	private void ShowIndicator()
	{
		indicator.SetActive(value: true);
		punch.Punch();
	}

	private void HideIndicator()
	{
		indicator.SetActive(value: false);
	}
}
public class ForceUnmaskable : MonoBehaviour
{
	private void OnEnable()
	{
		MaskableGraphic[] components = GetComponents<MaskableGraphic>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].maskable = false;
		}
	}
}
public class PointerDownUpEvents : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
{
	public UnityEvent<PointerEventData> onPointerDown;

	public UnityEvent<PointerEventData> onPointerUp;

	public void OnPointerDown(PointerEventData eventData)
	{
		onPointerDown?.Invoke(eventData);
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		onPointerUp?.Invoke(eventData);
	}
}
[ExecuteInEditMode]
public class ProceduralImageHashProvider : MonoBehaviour, ITrueShadowCustomHashProvider
{
	[SerializeField]
	private ProceduralImage proceduralImage;

	[SerializeField]
	private TrueShadow trueShadow;

	private void Awake()
	{
		if (trueShadow == null)
		{
			trueShadow = GetComponent<TrueShadow>();
		}
		if (proceduralImage == null)
		{
			proceduralImage = GetComponent<ProceduralImage>();
		}
	}

	private void Refresh()
	{
		trueShadow.CustomHash = Hash();
	}

	private void OnValidate()
	{
		if (trueShadow == null)
		{
			trueShadow = GetComponent<TrueShadow>();
		}
		if (proceduralImage == null)
		{
			proceduralImage = GetComponent<ProceduralImage>();
		}
		Refresh();
	}

	private void OnRectTransformDimensionsChange()
	{
		Refresh();
	}

	private int Hash()
	{
		return proceduralImage.InfoCache.GetHashCode() + proceduralImage.color.GetHashCode();
	}
}
public class ScrollViewEventReceiver : MonoBehaviour, IScrollHandler, IEventSystemHandler
{
	[SerializeField]
	private ScrollRect scrollRect;

	private void Awake()
	{
		if (scrollRect == null)
		{
			scrollRect = GetComponent<ScrollRect>();
		}
	}

	public void OnScroll(PointerEventData eventData)
	{
	}
}
public class UIToolkitTest : MonoBehaviour
{
	[SerializeField]
	private UIDocument doc;

	private void Awake()
	{
		VisualElement visualElement = doc.rootVisualElement.Q("Button");
		VisualElement visualElement2 = doc.rootVisualElement.Q("Button2");
		visualElement.RegisterCallback<ClickEvent>(OnButtonClicked);
		visualElement2.RegisterCallback<ClickEvent>(OnButton2Clicked);
	}

	private void OnButton2Clicked(ClickEvent evt)
	{
		UnityEngine.Debug.Log("Button 2 Clicked");
	}

	private void OnButtonClicked(ClickEvent evt)
	{
		UnityEngine.Debug.Log("Button Clicked");
	}
}
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[61636]
			{
				0, 0, 0, 1, 0, 0, 0, 48, 92, 65,
				115, 115, 101, 116, 115, 92, 65, 114, 116, 92,
				80, 111, 115, 116, 80, 114, 111, 99, 101, 115,
				115, 92, 83, 117, 110, 70, 111, 103, 84, 68,
				50, 48, 50, 51, 92, 83, 117, 110, 70, 111,
				103, 84, 68, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 61, 92, 65, 115, 115, 101, 116,
				115, 92, 65, 114, 116, 92, 83, 104, 97, 100,
				101, 114, 115, 92, 76, 105, 103, 104, 116, 105,
				110, 103, 92, 83, 111, 100, 97, 80, 111, 105,
				110, 116, 76, 105, 103, 104, 116, 92, 83, 111,
				100, 97, 80, 111, 105, 110, 116, 76, 105, 103,
				104, 116, 46, 99, 115, 0, 0, 0, 3, 0,
				0, 0, 36, 92, 65, 115, 115, 101, 116, 115,
				92, 67, 117, 115, 116, 111, 109, 70, 97, 99,
				101, 92, 67, 117, 115, 116, 111, 109, 70, 97,
				99, 101, 68, 97, 116, 97, 46, 99, 115, 0,
				0, 0, 4, 0, 0, 0, 40, 92, 65, 115,
				115, 101, 116, 115, 92, 67, 117, 115, 116, 111,
				109, 70, 97, 99, 101, 92, 67, 117, 115, 116,
				111, 109, 70, 97, 99, 101, 73, 110, 115, 116,
				97, 110, 99, 101, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 36, 92, 65, 115, 115, 101,
				116, 115, 92, 67, 117, 115, 116, 111, 109, 70,
				97, 99, 101, 92, 67, 117, 115, 116, 111, 109,
				70, 97, 99, 101, 80, 97, 114, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 38, 92,
				65, 115, 115, 101, 116, 115, 92, 67, 117, 115,
				116, 111, 109, 70, 97, 99, 101, 92, 67, 117,
				115, 116, 111, 109, 70, 97, 99, 101, 80, 114,
				101, 115, 101, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 37, 92, 65, 115, 115, 101,
				116, 115, 92, 67, 117, 115, 116, 111, 109, 70,
				97, 99, 101, 92, 84, 101, 115, 116, 65, 114,
				109, 82, 101, 110, 100, 101, 114, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 55,
				92, 65, 115, 115, 101, 116, 115, 92, 67, 117,
				115, 116, 111, 109, 70, 97, 99, 101, 92, 84,
				101, 115, 116, 83, 97, 118, 101, 92, 67, 117,
				115, 116, 111, 109, 70, 97, 99, 101, 76, 111,
				97, 100, 83, 97, 118, 101, 66, 117, 116, 116,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 49, 92, 65, 115, 115, 101, 116, 115,
				92, 67, 117, 115, 116, 111, 109, 70, 97, 99,
				101, 92, 84, 101, 115, 116, 83, 97, 118, 101,
				92, 67, 117, 115, 116, 111, 109, 70, 97, 99,
				101, 83, 97, 118, 101, 76, 111, 97, 100, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 49,
				92, 65, 115, 115, 101, 116, 115, 92, 67, 117,
				115, 116, 111, 109, 70, 97, 99, 101, 92, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				67, 117, 115, 116, 111, 109, 70, 97, 99, 101,
				83, 108, 105, 100, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 47, 92, 65, 115,
				115, 101, 116, 115, 92, 67, 117, 115, 116, 111,
				109, 70, 97, 99, 101, 92, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 117, 115,
				116, 111, 109, 70, 97, 99, 101, 84, 97, 98,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 45, 92, 65, 115, 115, 101, 116, 115, 92,
				67, 117, 115, 116, 111, 109, 70, 97, 99, 101,
				92, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 67, 117, 115, 116, 111, 109, 70, 97,
				99, 101, 85, 73, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 56, 92, 65, 115, 115, 101,
				116, 115, 92, 67, 117, 115, 116, 111, 109, 70,
				97, 99, 101, 92, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 117, 115, 116, 111,
				109, 70, 97, 99, 101, 85, 73, 67, 111, 108,
				111, 114, 80, 105, 99, 107, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 62, 92,
				65, 115, 115, 101, 116, 115, 92, 67, 117, 115,
				116, 111, 109, 70, 97, 99, 101, 92, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 67,
				117, 115, 116, 111, 109, 70, 97, 99, 101, 85,
				73, 67, 111, 108, 111, 114, 80, 105, 99, 107,
				101, 114, 66, 117, 116, 116, 111, 110, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 49, 92,
				65, 115, 115, 101, 116, 115, 92, 67, 117, 115,
				116, 111, 109, 70, 97, 99, 101, 92, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 67,
				117, 115, 116, 111, 109, 70, 97, 99, 101, 85,
				73, 80, 97, 114, 116, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 51, 92, 65, 115, 115,
				101, 116, 115, 92, 67, 117, 115, 116, 111, 109,
				70, 97, 99, 101, 92, 85, 73, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 67, 117, 115, 116,
				111, 109, 70, 97, 99, 101, 85, 73, 83, 119,
				105, 116, 99, 104, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 52, 92, 65, 115, 115, 101,
				116, 115, 92, 67, 117, 115, 116, 111, 109, 70,
				97, 99, 101, 92, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 73, 110, 116, 101, 114,
				97, 99, 116, 95, 67, 117, 115, 116, 111, 109,
				70, 97, 99, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 42, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 99, 99, 101, 115, 115, 111, 114, 121,
				92, 65, 99, 99, 101, 115, 115, 111, 114, 121,
				66, 97, 115, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 44, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 99, 99, 101, 115, 115, 111, 114, 121,
				92, 65, 99, 99, 101, 115, 115, 111, 114, 121,
				95, 76, 97, 122, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 59, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 99, 116, 105, 111, 110, 84,
				97, 115, 107, 115, 92, 65, 84, 95, 73, 110,
				116, 101, 114, 97, 99, 116, 87, 105, 116, 104,
				77, 97, 105, 110, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 41, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 73, 92, 65, 99, 116, 105, 111, 110, 115,
				92, 65, 105, 109, 84, 111, 80, 108, 97, 121,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 36, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 65,
				73, 92, 65, 99, 116, 105, 111, 110, 115, 92,
				65, 116, 116, 97, 99, 107, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 43, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 73, 92, 65, 99, 116, 105,
				111, 110, 115, 92, 67, 104, 101, 99, 107, 79,
				98, 115, 116, 105, 99, 108, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 34, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 65, 73, 92, 65, 99, 116,
				105, 111, 110, 115, 92, 68, 97, 115, 104, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 47,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 73, 92, 65,
				99, 116, 105, 111, 110, 115, 92, 70, 105, 110,
				100, 77, 97, 105, 110, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 48, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 73, 92, 65, 99, 116, 105, 111, 110,
				115, 92, 71, 101, 116, 67, 117, 114, 114, 101,
				110, 116, 80, 111, 115, 105, 116, 105, 111, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				45, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 73, 92,
				65, 99, 116, 105, 111, 110, 115, 92, 77, 111,
				118, 101, 84, 111, 82, 97, 110, 100, 111, 109,
				80, 111, 115, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 40, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 73, 92, 65, 99, 116, 105, 111, 110, 115,
				92, 80, 105, 99, 107, 117, 112, 73, 116, 101,
				109, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 37, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 73,
				92, 65, 99, 116, 105, 111, 110, 115, 92, 80,
				111, 112, 84, 101, 120, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 39, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 73, 92, 65, 99, 116, 105,
				111, 110, 115, 92, 80, 111, 115, 116, 83, 111,
				117, 110, 100, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 51, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 73, 92, 65, 99, 116, 105, 111, 110, 115,
				92, 82, 101, 108, 101, 97, 115, 101, 73, 116,
				101, 109, 83, 107, 105, 108, 108, 73, 102, 72,
				97, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 42, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 65,
				73, 92, 65, 99, 116, 105, 111, 110, 115, 92,
				82, 101, 108, 101, 97, 115, 101, 83, 107, 105,
				108, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 39, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 65,
				73, 92, 65, 99, 116, 105, 111, 110, 115, 92,
				82, 111, 116, 97, 116, 101, 65, 105, 109, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 47,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 73, 92, 65,
				99, 116, 105, 111, 110, 115, 92, 83, 101, 97,
				114, 99, 104, 69, 110, 101, 109, 121, 65, 114,
				111, 117, 110, 100, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 36, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 73, 92, 65, 99, 116, 105, 111, 110,
				115, 92, 83, 101, 116, 65, 105, 109, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 48, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 73, 92, 65, 99,
				116, 105, 111, 110, 115, 92, 83, 101, 116, 78,
				111, 116, 105, 99, 101, 100, 84, 111, 84, 97,
				114, 103, 101, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 36, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 73, 92, 65, 99, 116, 105, 111, 110,
				115, 92, 83, 101, 116, 82, 117, 110, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 35, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 73, 92, 65, 99,
				116, 105, 111, 110, 115, 92, 83, 104, 111, 111,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 42, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 73,
				92, 65, 99, 116, 105, 111, 110, 115, 92, 83,
				112, 97, 119, 110, 65, 108, 101, 114, 116, 70,
				120, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 40, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 73,
				92, 65, 99, 116, 105, 111, 110, 115, 92, 83,
				116, 111, 112, 77, 111, 118, 105, 110, 103, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 41,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 73, 92, 65,
				99, 116, 105, 111, 110, 115, 92, 84, 114, 97,
				99, 101, 84, 97, 114, 103, 101, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 48, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 73, 92, 65, 99,
				116, 105, 111, 110, 115, 92, 84, 114, 121, 84,
				111, 82, 101, 108, 111, 97, 100, 73, 102, 69,
				109, 112, 116, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 37, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 73, 92, 65, 99, 116, 105, 111, 110,
				115, 92, 85, 115, 101, 68, 114, 117, 103, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 43,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 73, 92, 65,
				73, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				67, 111, 110, 116, 114, 111, 108, 108, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				53, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 73, 92,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				92, 67, 104, 101, 99, 107, 67, 97, 110, 82,
				101, 108, 101, 97, 115, 101, 83, 107, 105, 108,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 51, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 73,
				92, 67, 111, 110, 100, 105, 116, 105, 111, 110,
				115, 92, 67, 104, 101, 99, 107, 72, 101, 97,
				116, 104, 76, 101, 115, 115, 84, 104, 97, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				45, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 73, 92,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				92, 67, 104, 101, 99, 107, 72, 111, 108, 100,
				71, 117, 110, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 42, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 73, 92, 67, 111, 110, 100, 105, 116, 105,
				111, 110, 115, 92, 67, 104, 101, 99, 107, 72,
				117, 114, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 45, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 73, 92, 67, 111, 110, 100, 105, 116, 105,
				111, 110, 115, 92, 67, 104, 101, 99, 107, 78,
				111, 116, 105, 99, 101, 100, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 47, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 73, 92, 67, 111, 110, 100,
				105, 116, 105, 111, 110, 115, 92, 67, 104, 101,
				99, 107, 82, 101, 108, 111, 97, 100, 105, 110,
				103, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 52, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 73,
				92, 67, 111, 110, 100, 105, 116, 105, 111, 110,
				115, 92, 67, 104, 101, 99, 107, 84, 97, 114,
				103, 101, 116, 68, 105, 115, 116, 97, 110, 99,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 52, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 73,
				92, 67, 111, 110, 100, 105, 116, 105, 111, 110,
				115, 92, 72, 97, 115, 79, 98, 115, 116, 105,
				99, 108, 101, 84, 111, 84, 97, 114, 103, 101,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 27, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 73,
				92, 80, 101, 116, 65, 73, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 40, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 117, 100, 105, 111, 92, 65,
				117, 100, 105, 111, 69, 118, 101, 110, 116, 80,
				114, 111, 120, 121, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 37, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 117, 100, 105, 111, 92, 65, 117, 100,
				105, 111, 77, 97, 110, 97, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 36,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 117, 100, 105,
				111, 92, 65, 117, 100, 105, 111, 79, 98, 106,
				101, 99, 116, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 40, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 117, 100, 105, 111, 92, 66, 97, 115, 101,
				66, 71, 77, 83, 101, 108, 101, 99, 116, 111,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 44, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 117,
				100, 105, 111, 92, 76, 111, 111, 112, 83, 111,
				117, 110, 100, 87, 105, 116, 104, 79, 98, 106,
				101, 99, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 41, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 117, 100, 105, 111, 92, 80, 108, 97, 121,
				69, 118, 101, 110, 116, 79, 110, 65, 119, 97,
				107, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 43, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 65,
				117, 100, 105, 111, 92, 80, 108, 97, 121, 72,
				117, 114, 116, 69, 118, 101, 110, 116, 80, 114,
				111, 120, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 35, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 117, 100, 105, 111, 92, 83, 102, 120, 79,
				110, 67, 108, 105, 99, 107, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 28, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 66, 117, 102, 102, 92, 66, 117,
				102, 102, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 44, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
				117, 102, 102, 92, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 66, 117, 102, 102, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 36, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 67, 97, 109, 101, 114, 97, 115, 92, 67,
				97, 109, 101, 114, 97, 65, 114, 109, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 37, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 97, 109, 101, 114,
				97, 115, 92, 71, 97, 109, 101, 67, 97, 109,
				101, 114, 97, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 45, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				67, 97, 109, 101, 114, 97, 115, 92, 72, 105,
				100, 101, 73, 102, 83, 105, 99, 107, 70, 114,
				105, 101, 110, 100, 108, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 50, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 92,
				65, 73, 95, 80, 97, 116, 104, 67, 111, 110,
				116, 114, 111, 108, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 45, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				67, 111, 110, 116, 114, 111, 108, 92, 66, 114,
				101, 97, 107, 97, 98, 108, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 61, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 67, 111, 110, 116, 114, 111, 108,
				92, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				65, 99, 116, 105, 111, 110, 92, 67, 65, 95,
				65, 116, 116, 97, 99, 107, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 60, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 92,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 65,
				99, 116, 105, 111, 110, 92, 67, 65, 95, 67,
				97, 114, 114, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 59, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				67, 111, 110, 116, 114, 111, 108, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 65, 99, 116,
				105, 111, 110, 92, 67, 65, 95, 68, 97, 115,
				104, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 63, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 67, 111, 110,
				116, 114, 111, 108, 92, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 65, 99, 116, 105, 111, 110,
				92, 67, 65, 95, 73, 110, 116, 101, 114, 97,
				99, 116, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 61, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 67, 111,
				110, 116, 114, 111, 108, 92, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 65, 99, 116, 105, 111,
				110, 92, 67, 65, 95, 82, 101, 108, 111, 97,
				100, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 60, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 67, 111, 110,
				116, 114, 111, 108, 92, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 65, 99, 116, 105, 111, 110,
				92, 67, 65, 95, 83, 107, 105, 108, 108, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 62,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 67, 111, 110, 116, 114,
				111, 108, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 65, 99, 116, 105, 111, 110, 92, 67,
				65, 95, 85, 115, 101, 73, 116, 101, 109, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 71,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 67, 111, 110, 116, 114,
				111, 108, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 65, 99, 116, 105, 111, 110, 92, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 65, 99,
				116, 105, 111, 110, 66, 97, 115, 101, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 71, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 67, 111, 110, 116, 114, 111,
				108, 92, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 65, 99, 116, 105, 111, 110, 92, 73, 110,
				116, 101, 114, 102, 97, 99, 101, 92, 73, 80,
				114, 111, 103, 114, 101, 115, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 61, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 67, 111, 110, 116, 114, 111, 108,
				92, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				65, 110, 105, 109, 97, 116, 105, 111, 110, 67,
				111, 110, 116, 114, 111, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 72, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 92,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 67, 111,
				110, 116, 114, 111, 108, 95, 77, 97, 103, 105,
				99, 66, 108, 101, 110, 100, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 64, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 92,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 69,
				113, 117, 105, 112, 109, 101, 110, 116, 67, 111,
				110, 116, 114, 111, 108, 108, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 56, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 67, 111, 110, 116, 114, 111,
				108, 92, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 73, 116, 101, 109, 67, 111, 110, 116, 114,
				111, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 56, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 67, 111,
				110, 116, 114, 111, 108, 92, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 77, 97, 105, 110, 67,
				111, 110, 116, 114, 111, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 64, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 92,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 77,
				97, 105, 110, 67, 111, 110, 116, 114, 111, 108,
				95, 112, 97, 114, 116, 105, 97, 108, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 50, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 67, 111, 110, 116, 114, 111,
				108, 92, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 77, 111, 100, 101, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 57, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 92,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 83,
				99, 101, 110, 101, 67, 111, 110, 116, 114, 111,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 55, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 67, 111, 110,
				116, 114, 111, 108, 92, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 83, 111, 117, 110, 100, 77,
				97, 107, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 55, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				67, 111, 110, 116, 114, 111, 108, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 83, 117, 98,
				86, 105, 115, 117, 97, 108, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 48, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 67, 111, 110, 116, 114, 111, 108,
				92, 72, 97, 108, 102, 79, 98, 115, 116, 105,
				99, 108, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 55, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 67,
				111, 110, 116, 114, 111, 108, 92, 72, 97, 108,
				102, 79, 98, 115, 116, 105, 99, 108, 101, 84,
				114, 105, 103, 103, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 48, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 92,
				72, 101, 97, 100, 67, 111, 108, 108, 105, 100,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 42, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 67, 111,
				110, 116, 114, 111, 108, 92, 72, 101, 97, 108,
				116, 104, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 52, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 67, 111,
				110, 116, 114, 111, 108, 92, 72, 101, 97, 108,
				116, 104, 83, 105, 109, 112, 108, 101, 66, 97,
				115, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 46, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 67, 111,
				110, 116, 114, 111, 108, 92, 72, 117, 114, 116,
				86, 105, 115, 117, 97, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 51, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 111, 110, 116, 114, 111, 108, 92,
				73, 116, 101, 109, 65, 103, 101, 110, 116, 72,
				111, 108, 100, 101, 114, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 48, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 67, 111, 110, 116, 114, 111, 108, 92, 73,
				116, 101, 109, 83, 104, 111, 114, 116, 99, 117,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 44, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 67, 111, 110,
				116, 114, 111, 108, 92, 77, 111, 118, 101, 109,
				101, 110, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 43, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				67, 104, 101, 97, 116, 105, 110, 103, 92, 67,
				104, 101, 97, 116, 105, 110, 103, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 36, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 67, 111, 109, 98, 97, 116, 92, 68, 97,
				109, 97, 103, 101, 73, 110, 102, 111, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 40, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 111, 109, 98, 97,
				116, 92, 68, 97, 109, 97, 103, 101, 82, 101,
				99, 101, 105, 118, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 33, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 111, 109, 98, 97, 116, 92,
				71, 114, 101, 110, 97, 100, 101, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 36, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 67, 111, 109, 98, 97, 116,
				92, 80, 114, 111, 106, 101, 99, 116, 105, 108,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 31, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 67, 111,
				109, 98, 97, 116, 92, 84, 101, 97, 109, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				50, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 111, 109,
				109, 111, 110, 86, 97, 114, 105, 97, 98, 108,
				101, 115, 92, 67, 111, 109, 109, 111, 110, 86,
				97, 114, 105, 97, 98, 108, 101, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 39, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 111, 110, 116, 114,
				111, 108, 92, 65, 68, 83, 65, 105, 109, 77,
				97, 114, 107, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 36, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 67, 111, 110, 116, 114, 111, 108, 92,
				65, 105, 109, 77, 97, 114, 107, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 42,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 67, 111, 110, 116,
				114, 111, 108, 92, 65, 105, 109, 84, 97, 114,
				103, 101, 116, 70, 105, 110, 100, 101, 114, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 48,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 67, 111, 110, 116,
				114, 111, 108, 92, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 73, 110, 112, 117, 116, 67, 111,
				110, 116, 114, 111, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 53, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 67, 111, 110, 116, 114, 111, 108, 92,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 84,
				111, 117, 99, 104, 73, 110, 112, 117, 116, 67,
				111, 110, 116, 114, 111, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 36, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 111, 110, 116, 114, 111, 108,
				92, 72, 105, 116, 77, 97, 114, 107, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				42, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 111, 110,
				116, 114, 111, 108, 92, 83, 105, 110, 103, 108,
				101, 67, 114, 111, 115, 115, 104, 97, 105, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				35, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 111, 110,
				116, 114, 111, 108, 92, 83, 107, 105, 108, 108,
				72, 85, 68, 46, 99, 115, 0, 0, 0, 3,
				0, 0, 0, 39, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				67, 117, 114, 115, 111, 114, 92, 67, 117, 114,
				115, 111, 114, 77, 97, 110, 97, 103, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				52, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 117, 115,
				116, 111, 109, 101, 114, 83, 101, 114, 118, 105,
				99, 101, 92, 81, 117, 101, 115, 116, 105, 111,
				110, 97, 105, 114, 66, 117, 116, 116, 111, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				52, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 117, 116,
				115, 99, 101, 110, 101, 92, 83, 101, 116, 69,
				110, 100, 105, 110, 103, 77, 105, 115, 115, 108,
				101, 80, 97, 114, 97, 109, 101, 116, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				44, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 68, 101, 98,
				117, 103, 92, 68, 121, 110, 97, 109, 105, 99,
				73, 116, 101, 109, 68, 101, 98, 117, 103, 103,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 42, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				101, 98, 117, 103, 92, 82, 101, 99, 116, 83,
				116, 114, 117, 99, 116, 82, 101, 102, 84, 101,
				115, 116, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 38, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				101, 98, 117, 103, 92, 83, 111, 100, 97, 73,
				109, 103, 117, 105, 84, 101, 115, 116, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 46, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 68, 105, 102, 102, 105,
				99, 117, 108, 116, 121, 92, 71, 97, 109, 101,
				82, 117, 108, 101, 115, 77, 97, 110, 97, 103,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 37, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				105, 102, 102, 105, 99, 117, 108, 116, 121, 92,
				82, 117, 108, 101, 115, 101, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 41, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 68, 105, 102, 102, 105, 99,
				117, 108, 116, 121, 92, 82, 117, 108, 101, 115,
				101, 116, 70, 105, 108, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 47, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 102, 102, 101, 99, 116, 115,
				92, 65, 99, 116, 105, 111, 110, 92, 65, 100,
				100, 66, 117, 102, 102, 65, 99, 116, 105, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 51, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 102,
				102, 101, 99, 116, 115, 92, 65, 99, 116, 105,
				111, 110, 92, 67, 111, 115, 116, 83, 116, 97,
				109, 105, 110, 97, 65, 99, 116, 105, 111, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				46, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 69, 102, 102,
				101, 99, 116, 115, 92, 65, 99, 116, 105, 111,
				110, 92, 68, 97, 109, 97, 103, 101, 65, 99,
				116, 105, 111, 110, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 42, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 69, 102, 102, 101, 99, 116, 115, 92, 65,
				99, 116, 105, 111, 110, 92, 70, 120, 65, 99,
				116, 105, 111, 110, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 44, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 69, 102, 102, 101, 99, 116, 115, 92, 65,
				99, 116, 105, 111, 110, 92, 72, 101, 97, 108,
				65, 99, 116, 105, 111, 110, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 48, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 102, 102, 101, 99, 116, 115,
				92, 65, 99, 116, 105, 111, 110, 92, 77, 111,
				100, 105, 102, 105, 101, 114, 65, 99, 116, 105,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 50, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 69,
				102, 102, 101, 99, 116, 115, 92, 65, 99, 116,
				105, 111, 110, 92, 82, 101, 109, 111, 118, 101,
				66, 117, 102, 102, 65, 99, 116, 105, 111, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				53, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 69, 102, 102,
				101, 99, 116, 115, 92, 65, 99, 116, 105, 111,
				110, 92, 83, 112, 97, 119, 110, 80, 97, 112,
				101, 114, 66, 111, 120, 65, 99, 116, 105, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 52, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 102,
				102, 101, 99, 116, 115, 92, 70, 105, 108, 116,
				101, 114, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 73, 115, 82, 117, 110, 110, 105, 110,
				103, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 53, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 102,
				102, 101, 99, 116, 115, 92, 70, 105, 108, 116,
				101, 114, 92, 69, 108, 101, 109, 101, 110, 116,
				70, 97, 99, 116, 111, 114, 70, 105, 108, 116,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 51, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 69,
				102, 102, 101, 99, 116, 115, 92, 70, 105, 108,
				116, 101, 114, 92, 78, 111, 116, 72, 117, 114,
				116, 70, 111, 114, 83, 101, 99, 111, 110, 100,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 55, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 102,
				102, 101, 99, 116, 115, 92, 84, 114, 105, 103,
				103, 101, 114, 92, 79, 110, 83, 104, 111, 111,
				116, 65, 116, 116, 97, 99, 107, 84, 114, 105,
				103, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 54, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 69, 102, 102, 101, 99, 116, 115, 92, 84,
				114, 105, 103, 103, 101, 114, 92, 79, 110, 84,
				97, 107, 101, 68, 97, 109, 97, 103, 101, 84,
				114, 105, 103, 103, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 74, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 110, 101, 109, 121, 67, 114,
				101, 97, 116, 101, 92, 65, 73, 83, 112, 101,
				99, 105, 97, 108, 65, 116, 116, 97, 99, 104,
				109, 101, 110, 116, 92, 65, 73, 83, 112, 101,
				99, 105, 97, 108, 65, 116, 116, 97, 99, 104,
				109, 101, 110, 116, 66, 97, 115, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 75, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 69, 110, 101, 109, 121,
				67, 114, 101, 97, 116, 101, 92, 65, 73, 83,
				112, 101, 99, 105, 97, 108, 65, 116, 116, 97,
				99, 104, 109, 101, 110, 116, 92, 65, 73, 83,
				112, 101, 99, 105, 97, 108, 65, 116, 116, 97,
				99, 104, 109, 101, 110, 116, 95, 83, 104, 111,
				112, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 90, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 110,
				101, 109, 121, 67, 114, 101, 97, 116, 101, 92,
				65, 73, 83, 112, 101, 99, 105, 97, 108, 65,
				116, 116, 97, 99, 104, 109, 101, 110, 116, 92,
				65, 73, 83, 112, 101, 99, 105, 97, 108, 65,
				116, 116, 97, 99, 104, 109, 101, 110, 116, 95,
				83, 112, 97, 119, 110, 73, 116, 101, 109, 79,
				110, 67, 114, 105, 116, 75, 105, 108, 108, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 52,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 69, 110, 101, 109,
				121, 67, 114, 101, 97, 116, 101, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 82, 97, 110,
				100, 111, 109, 80, 114, 101, 115, 101, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 69, 110, 101, 109,
				121, 67, 114, 101, 97, 116, 101, 92, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 83, 112, 97,
				119, 110, 101, 114, 66, 97, 115, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 60, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 69, 110, 101, 109, 121,
				67, 114, 101, 97, 116, 101, 92, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 83, 112, 97, 119,
				110, 101, 114, 67, 111, 109, 112, 111, 110, 101,
				110, 116, 66, 97, 115, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 52, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 110, 101, 109, 121, 67, 114,
				101, 97, 116, 101, 92, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 83, 112, 97, 119, 110, 101,
				114, 71, 114, 111, 117, 112, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 60, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 110, 101, 109, 121, 67, 114,
				101, 97, 116, 101, 92, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 83, 112, 97, 119, 110, 101,
				114, 71, 114, 111, 117, 112, 83, 101, 108, 101,
				99, 116, 111, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 51, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 69, 110, 101, 109, 121, 67, 114, 101, 97,
				116, 101, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 83, 112, 97, 119, 110, 101, 114, 82,
				111, 111, 116, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 53, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				69, 110, 101, 109, 121, 67, 114, 101, 97, 116,
				101, 92, 82, 97, 110, 100, 111, 109, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 83, 112, 97,
				119, 110, 101, 114, 46, 99, 115, 0, 0, 0,
				19, 0, 0, 0, 42, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 69, 118, 101, 110, 116, 82, 101, 112, 111,
				114, 116, 115, 92, 66, 68, 83, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 39, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 69, 118, 101, 110, 116, 82, 101, 112, 111,
				114, 116, 115, 92, 83, 116, 114, 74, 115, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 40, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 88,
				80, 77, 97, 110, 97, 103, 101, 114, 92, 69,
				88, 80, 77, 97, 110, 97, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 60,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 92, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 77, 97, 105, 110,
				67, 111, 110, 116, 114, 111, 108, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 45, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 69, 120, 116, 101, 110, 115,
				105, 111, 110, 115, 92, 67, 111, 108, 111, 114,
				69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				53, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 92, 82, 101,
				99, 116, 84, 114, 97, 110, 115, 102, 111, 114,
				109, 69, 120, 116, 101, 110, 115, 105, 111, 110,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 42, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 120,
				116, 101, 110, 115, 105, 111, 110, 115, 92, 84,
				97, 103, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 30, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 71, 97,
				109, 101, 77, 97, 110, 97, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 71, 97, 109, 101,
				77, 97, 110, 97, 103, 101, 114, 115, 92, 82,
				105, 99, 104, 80, 114, 101, 115, 101, 110, 99,
				101, 77, 97, 110, 97, 103, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 48, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 71, 97, 109, 101, 77,
				97, 110, 97, 103, 101, 114, 115, 92, 84, 105,
				109, 101, 83, 99, 97, 108, 101, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 43, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 92,
				67, 97, 114, 114, 121, 92, 67, 97, 114, 114,
				105, 97, 98, 108, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 31, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				92, 69, 103, 103, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 41, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 92,
				69, 110, 100, 105, 110, 103, 67, 111, 110, 116,
				114, 111, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 44, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 92, 70,
				105, 108, 108, 87, 97, 116, 101, 114, 65, 110,
				100, 70, 111, 111, 100, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 50, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				92, 70, 105, 115, 104, 105, 110, 103, 92, 65,
				99, 116, 105, 111, 110, 95, 70, 105, 115, 104,
				105, 110, 103, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 52, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 92, 70,
				105, 115, 104, 105, 110, 103, 92, 65, 99, 116,
				105, 111, 110, 95, 70, 105, 115, 104, 105, 110,
				103, 86, 50, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 48, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 92, 70,
				105, 115, 104, 105, 110, 103, 92, 70, 105, 115,
				104, 105, 110, 103, 80, 111, 105, 110, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 36,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 92, 70, 111, 119, 83, 109,
				111, 107, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 68, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 92, 73,
				110, 76, 101, 118, 101, 108, 68, 97, 116, 97,
				80, 114, 111, 120, 121, 92, 83, 101, 116, 73,
				110, 76, 101, 118, 101, 108, 68, 97, 116, 97,
				66, 111, 111, 108, 80, 114, 111, 120, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 67,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 92, 73, 110, 118, 105, 115,
				105, 98, 108, 101, 84, 101, 108, 101, 112, 111,
				114, 116, 101, 114, 92, 73, 110, 118, 105, 115,
				105, 98, 108, 101, 84, 101, 108, 101, 112, 111,
				114, 116, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 41, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 92,
				75, 117, 110, 92, 75, 117, 110, 69, 118, 101,
				110, 116, 115, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 36, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 92, 80,
				97, 112, 101, 114, 66, 111, 120, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 48, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 92, 82, 97, 110, 100, 111, 109, 65,
				99, 116, 105, 118, 101, 83, 101, 108, 101, 99,
				116, 111, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 45, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 92, 83,
				97, 118, 101, 68, 97, 116, 97, 66, 111, 111,
				108, 80, 114, 111, 120, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 45, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 92, 83, 101, 116, 65, 99, 116, 105, 118,
				101, 66, 121, 67, 104, 97, 110, 99, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 48,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 92, 83, 101, 116, 65, 99,
				116, 105, 118, 101, 66, 121, 67, 111, 110, 100,
				105, 116, 105, 111, 110, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 55, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				92, 83, 101, 116, 84, 105, 109, 101, 79, 110,
				69, 110, 116, 101, 114, 66, 97, 115, 101, 70,
				105, 114, 115, 116, 84, 105, 109, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 44, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 92, 83, 105, 109, 112, 108, 101,
				84, 101, 108, 101, 112, 111, 114, 116, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				51, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 71, 97, 109,
				101, 112, 108, 97, 121, 92, 83, 105, 109, 112,
				108, 101, 84, 101, 108, 101, 112, 111, 114, 116,
				101, 114, 83, 112, 97, 119, 110, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 55,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 92, 83, 111, 117, 108, 67,
				111, 108, 108, 101, 99, 116, 111, 114, 92, 83,
				111, 117, 108, 67, 111, 108, 108, 101, 99, 116,
				111, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 50, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 71,
				97, 109, 101, 112, 108, 97, 121, 92, 83, 111,
				117, 108, 67, 111, 108, 108, 101, 99, 116, 111,
				114, 92, 83, 111, 117, 108, 67, 117, 98, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				56, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 71, 97, 109,
				101, 112, 108, 97, 121, 92, 83, 112, 97, 99,
				101, 83, 104, 105, 112, 92, 83, 112, 97, 99,
				101, 83, 104, 105, 112, 73, 110, 115, 116, 97,
				108, 108, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 57, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 92,
				84, 101, 108, 101, 112, 111, 114, 116, 77, 97,
				114, 107, 101, 114, 92, 84, 101, 108, 101, 112,
				111, 114, 116, 66, 101, 97, 99, 111, 110, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 41,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 92, 87, 105, 115, 104, 76,
				105, 115, 116, 80, 114, 111, 120, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 32, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 92, 90, 111, 110, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 38, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 92, 90, 111, 110, 101, 68, 97,
				109, 97, 103, 101, 46, 99, 115, 0, 0, 0,
				17, 0, 0, 0, 60, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 68,
				97, 116, 97, 83, 101, 116, 116, 105, 110, 103,
				115, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				68, 97, 116, 97, 83, 101, 116, 116, 105, 110,
				103, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 58, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 71,
				97, 109, 101, 112, 108, 97, 121, 68, 97, 116,
				97, 83, 101, 116, 116, 105, 110, 103, 115, 92,
				85, 73, 80, 114, 101, 102, 97, 98, 115, 82,
				101, 102, 101, 114, 101, 110, 99, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 46, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 72, 85, 68, 92, 66,
				117, 102, 102, 92, 66, 117, 102, 102, 68, 101,
				116, 97, 105, 108, 115, 79, 118, 101, 114, 108,
				97, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 40, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 72,
				85, 68, 92, 66, 117, 102, 102, 92, 66, 117,
				102, 102, 115, 68, 105, 115, 112, 108, 97, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				45, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 72, 85, 68,
				92, 66, 117, 102, 102, 92, 66, 117, 102, 102,
				115, 68, 105, 115, 112, 108, 97, 121, 69, 110,
				116, 114, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 49, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				72, 85, 68, 92, 66, 117, 108, 108, 101, 116,
				67, 111, 117, 110, 116, 92, 66, 117, 108, 108,
				101, 116, 67, 111, 117, 110, 116, 72, 85, 68,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				48, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 72, 85, 68,
				92, 66, 117, 108, 108, 101, 116, 67, 111, 117,
				110, 116, 92, 66, 117, 108, 108, 101, 116, 84,
				121, 112, 101, 72, 85, 68, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 57, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 72, 85, 68, 92, 66, 117, 108,
				108, 101, 116, 67, 111, 117, 110, 116, 92, 66,
				117, 108, 108, 101, 116, 84, 121, 112, 101, 83,
				101, 108, 101, 99, 116, 66, 117, 116, 116, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 44, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 72, 85,
				68, 92, 66, 117, 108, 108, 101, 116, 67, 111,
				117, 110, 116, 92, 69, 110, 101, 114, 103, 121,
				72, 85, 68, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 44, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				72, 85, 68, 92, 66, 117, 108, 108, 101, 116,
				67, 111, 117, 110, 116, 92, 72, 101, 97, 108,
				116, 104, 72, 85, 68, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 47, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 72, 85, 68, 92, 66, 117, 108, 108,
				101, 116, 67, 111, 117, 110, 116, 92, 73, 110,
				100, 105, 99, 97, 116, 111, 114, 72, 85, 68,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				45, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 72, 85, 68,
				92, 66, 117, 108, 108, 101, 116, 67, 111, 117,
				110, 116, 92, 83, 116, 97, 109, 105, 110, 97,
				72, 85, 68, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 43, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				72, 85, 68, 92, 66, 117, 108, 108, 101, 116,
				67, 111, 117, 110, 116, 92, 87, 97, 116, 101,
				114, 72, 85, 68, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 32, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 72, 85, 68, 92, 68, 101, 98, 117, 103,
				86, 105, 101, 119, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 43, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 72, 85, 68, 92, 73, 110, 116, 101, 114,
				97, 99, 116, 92, 73, 110, 116, 101, 114, 97,
				99, 116, 72, 85, 68, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 52, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 72, 85, 68, 92, 73, 110, 116, 101,
				114, 97, 99, 116, 92, 73, 110, 116, 101, 114,
				97, 99, 116, 83, 101, 108, 101, 99, 116, 105,
				111, 110, 72, 85, 68, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 74, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 72, 85, 68, 92, 77, 101, 99, 104,
				97, 110, 105, 99, 115, 92, 69, 118, 97, 99,
				117, 97, 116, 105, 111, 110, 67, 111, 117, 110,
				116, 100, 111, 119, 110, 92, 69, 118, 97, 99,
				117, 97, 116, 105, 111, 110, 67, 111, 117, 110,
				116, 100, 111, 119, 110, 85, 73, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 57, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 72, 85, 68, 92, 78, 111,
				116, 105, 102, 105, 99, 97, 116, 105, 111, 110,
				84, 101, 120, 116, 92, 78, 111, 116, 105, 102,
				105, 99, 97, 116, 105, 111, 110, 80, 114, 111,
				120, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 56, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 72,
				85, 68, 92, 78, 111, 116, 105, 102, 105, 99,
				97, 116, 105, 111, 110, 84, 101, 120, 116, 92,
				78, 111, 116, 105, 102, 105, 99, 97, 116, 105,
				111, 110, 84, 101, 120, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 52, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 72, 85, 68, 92, 80, 114, 111,
				103, 114, 101, 115, 115, 66, 97, 114, 92, 65,
				99, 116, 105, 111, 110, 80, 114, 111, 103, 114,
				101, 115, 115, 72, 85, 68, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 53, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 72, 85, 68, 92, 80, 114, 111,
				103, 114, 101, 115, 115, 66, 97, 114, 92, 70,
				111, 108, 108, 111, 119, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 72, 85, 68, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 48, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 72, 85, 68, 92, 80, 114,
				111, 103, 114, 101, 115, 115, 66, 97, 114, 92,
				76, 105, 116, 116, 108, 101, 77, 111, 118, 101,
				72, 85, 68, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 39, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				72, 85, 68, 92, 82, 101, 108, 111, 97, 100,
				92, 82, 101, 108, 111, 97, 100, 72, 85, 68,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				44, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 72, 85, 68,
				92, 83, 107, 105, 108, 108, 92, 83, 104, 97,
				112, 101, 115, 83, 107, 105, 108, 108, 76, 105,
				110, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 39, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 72,
				85, 68, 92, 83, 107, 105, 108, 108, 92, 83,
				107, 105, 108, 108, 72, 117, 100, 51, 68, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 72, 85, 68, 92,
				83, 107, 105, 108, 108, 92, 83, 107, 105, 108,
				108, 80, 114, 111, 106, 101, 99, 116, 105, 108,
				101, 76, 105, 110, 101, 72, 85, 68, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 42, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 72, 85, 68, 92, 83,
				107, 105, 108, 108, 92, 83, 107, 105, 108, 108,
				82, 97, 110, 103, 101, 72, 85, 68, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 41, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 72, 85, 68, 92, 83,
				121, 110, 99, 68, 101, 98, 117, 103, 69, 100,
				103, 101, 76, 105, 103, 104, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 54, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 72, 85, 68, 92, 84, 105,
				109, 101, 79, 102, 68, 97, 121, 68, 105, 115,
				112, 108, 97, 121, 92, 84, 105, 109, 101, 79,
				102, 68, 97, 121, 65, 108, 101, 114, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 66,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 72, 85, 68, 92,
				84, 105, 109, 101, 79, 102, 68, 97, 121, 68,
				105, 115, 112, 108, 97, 121, 92, 84, 105, 109,
				101, 79, 102, 68, 97, 121, 65, 108, 101, 114,
				116, 84, 114, 105, 103, 103, 101, 114, 80, 114,
				111, 120, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 56, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				72, 85, 68, 92, 84, 105, 109, 101, 79, 102,
				68, 97, 121, 68, 105, 115, 112, 108, 97, 121,
				92, 84, 105, 109, 101, 79, 102, 68, 97, 121,
				68, 105, 115, 112, 108, 97, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 45, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 72, 85, 68, 92, 87, 101,
				105, 103, 104, 116, 66, 97, 114, 92, 87, 101,
				105, 103, 104, 116, 66, 97, 114, 72, 85, 68,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				61, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 73, 110, 116,
				101, 114, 97, 99, 116, 92, 67, 111, 110, 115,
				116, 114, 117, 99, 116, 105, 111, 110, 83, 105,
				116, 101, 92, 67, 111, 110, 115, 116, 114, 117,
				99, 116, 105, 111, 110, 83, 105, 116, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 47,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 73, 110, 116, 101,
				114, 97, 99, 116, 92, 67, 111, 115, 116, 84,
				97, 107, 101, 114, 92, 67, 111, 115, 116, 84,
				97, 107, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 50, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 73, 110, 116, 101, 114, 97, 99, 116, 92,
				67, 111, 115, 116, 84, 97, 107, 101, 114, 92,
				67, 111, 115, 116, 84, 97, 107, 101, 114, 72,
				85, 68, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 56, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 73,
				110, 116, 101, 114, 97, 99, 116, 92, 67, 111,
				115, 116, 84, 97, 107, 101, 114, 92, 67, 111,
				115, 116, 84, 97, 107, 101, 114, 72, 85, 68,
				95, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 32, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 110, 116, 101, 114, 97, 99,
				116, 92, 68, 111, 111, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 39, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 110, 116, 101, 114, 97, 99,
				116, 92, 68, 111, 111, 114, 84, 114, 105, 103,
				103, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 44, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 110, 116, 101, 114, 97, 99, 116, 92, 73,
				110, 116, 101, 114, 97, 99, 116, 97, 98, 108,
				101, 66, 97, 115, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 49, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 73, 110, 116, 101, 114, 97, 99, 116,
				92, 73, 110, 116, 101, 114, 97, 99, 116, 97,
				98, 108, 101, 67, 97, 114, 114, 105, 97, 98,
				108, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 47, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 73,
				110, 116, 101, 114, 97, 99, 116, 92, 73, 110,
				116, 101, 114, 97, 99, 116, 97, 98, 108, 101,
				76, 111, 111, 116, 98, 111, 120, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 46, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 73, 110, 116, 101, 114, 97,
				99, 116, 92, 73, 110, 116, 101, 114, 97, 99,
				116, 97, 98, 108, 101, 80, 105, 99, 107, 117,
				112, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 42, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 110,
				116, 101, 114, 97, 99, 116, 92, 73, 110, 116,
				101, 114, 97, 99, 116, 77, 97, 114, 107, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 42, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 110,
				116, 101, 114, 97, 99, 116, 92, 73, 116, 101,
				109, 83, 116, 97, 114, 116, 101, 114, 107, 105,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 47, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 110,
				116, 101, 114, 97, 99, 116, 92, 79, 110, 84,
				114, 105, 103, 103, 101, 114, 69, 110, 116, 101,
				114, 69, 118, 101, 110, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 49, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 110, 116, 101, 114, 97, 99,
				116, 92, 83, 101, 116, 68, 111, 111, 114, 79,
				112, 101, 110, 73, 102, 83, 97, 118, 101, 68,
				97, 116, 97, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 44, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 110, 116, 101, 114, 102, 97, 99, 101, 115,
				92, 73, 84, 97, 115, 107, 66, 101, 104, 97,
				118, 105, 111, 117, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 45, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 73, 116, 101, 109, 92, 65, 103, 101,
				110, 116, 92, 68, 117, 99, 107, 111, 118, 73,
				116, 101, 109, 65, 103, 101, 110, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 73, 116, 101, 109, 92,
				65, 103, 101, 110, 116, 92, 73, 110, 116, 101,
				114, 102, 97, 99, 101, 115, 92, 73, 65, 103,
				101, 110, 116, 85, 115, 97, 98, 108, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 50,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 73, 116, 101, 109,
				92, 65, 103, 101, 110, 116, 92, 73, 116, 101,
				109, 65, 103, 101, 110, 116, 95, 70, 105, 115,
				104, 105, 110, 103, 82, 111, 100, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 43, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 73, 116, 101, 109, 92, 65,
				103, 101, 110, 116, 92, 73, 116, 101, 109, 65,
				103, 101, 110, 116, 95, 71, 117, 110, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 51, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 73, 116, 101, 109, 92,
				65, 103, 101, 110, 116, 92, 73, 116, 101, 109,
				65, 103, 101, 110, 116, 95, 77, 101, 108, 101,
				101, 87, 101, 97, 112, 111, 110, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 48, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 73, 116, 101, 109, 92, 73,
				110, 118, 101, 110, 116, 111, 114, 121, 92, 83,
				97, 118, 101, 100, 73, 110, 118, 101, 110, 116,
				111, 114, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 43, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 116, 101, 109, 92, 73, 110, 118, 101, 110,
				116, 111, 114, 121, 69, 120, 116, 101, 110, 115,
				105, 111, 110, 115, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 38, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 73, 116, 101, 109, 92, 73, 116, 101, 109,
				69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				52, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 73, 116, 101,
				109, 92, 73, 116, 101, 109, 83, 101, 116, 116,
				105, 110, 103, 115, 92, 73, 116, 101, 109, 83,
				101, 116, 116, 105, 110, 103, 66, 97, 115, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				58, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 73, 116, 101,
				109, 92, 73, 116, 101, 109, 83, 101, 116, 116,
				105, 110, 103, 115, 92, 73, 116, 101, 109, 83,
				101, 116, 116, 105, 110, 103, 95, 65, 99, 99,
				101, 115, 115, 111, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 55, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 116, 101, 109, 92, 73, 116,
				101, 109, 83, 101, 116, 116, 105, 110, 103, 115,
				92, 73, 116, 101, 109, 83, 101, 116, 116, 105,
				110, 103, 95, 66, 117, 108, 108, 101, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 56,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 73, 116, 101, 109,
				92, 73, 116, 101, 109, 83, 101, 116, 116, 105,
				110, 103, 115, 92, 73, 116, 101, 109, 83, 101,
				116, 116, 105, 110, 103, 95, 70, 111, 114, 109,
				117, 108, 97, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 52, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 116, 101, 109, 92, 73, 116, 101, 109, 83,
				101, 116, 116, 105, 110, 103, 115, 92, 73, 116,
				101, 109, 83, 101, 116, 116, 105, 110, 103, 95,
				71, 80, 85, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 52, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 116, 101, 109, 92, 73, 116, 101, 109, 83,
				101, 116, 116, 105, 110, 103, 115, 92, 73, 116,
				101, 109, 83, 101, 116, 116, 105, 110, 103, 95,
				71, 117, 110, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 60, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 116, 101, 109, 92, 73, 116, 101, 109, 83,
				101, 116, 116, 105, 110, 103, 115, 92, 73, 116,
				101, 109, 83, 101, 116, 116, 105, 110, 103, 95,
				77, 101, 108, 101, 101, 87, 101, 97, 112, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 60, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 116,
				101, 109, 92, 73, 116, 101, 109, 83, 101, 116,
				116, 105, 110, 103, 115, 92, 73, 116, 101, 109,
				83, 101, 116, 116, 105, 110, 103, 95, 78, 105,
				103, 104, 116, 86, 105, 115, 105, 111, 110, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 54,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 73, 116, 101, 109,
				92, 73, 116, 101, 109, 83, 101, 116, 116, 105,
				110, 103, 115, 92, 73, 116, 101, 109, 83, 101,
				116, 116, 105, 110, 103, 95, 83, 107, 105, 108,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 37, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 116,
				101, 109, 92, 73, 116, 101, 109, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 51, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 116, 101, 109, 92, 80, 108,
				97, 121, 101, 114, 83, 116, 111, 114, 97, 103,
				101, 92, 80, 108, 97, 121, 101, 114, 83, 116,
				111, 114, 97, 103, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 57, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 73, 116, 101, 109, 92, 80, 108, 97,
				121, 101, 114, 83, 116, 111, 114, 97, 103, 101,
				92, 80, 108, 97, 121, 101, 114, 83, 116, 111,
				114, 97, 103, 101, 66, 117, 102, 102, 101, 114,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				53, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 73, 116, 101,
				109, 92, 82, 97, 110, 100, 111, 109, 73, 116,
				101, 109, 71, 101, 110, 101, 114, 97, 116, 101,
				68, 101, 115, 99, 114, 105, 112, 116, 105, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 37, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 116,
				101, 109, 92, 85, 115, 97, 103, 101, 92, 65,
				100, 100, 66, 117, 102, 102, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 42, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 116, 101, 109, 92, 85, 115,
				97, 103, 101, 92, 68, 101, 97, 100, 66, 121,
				67, 104, 97, 110, 99, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 34, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 116, 101, 109, 92, 85, 115,
				97, 103, 101, 92, 68, 114, 117, 103, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 39, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 73, 116, 101, 109, 92,
				85, 115, 97, 103, 101, 92, 70, 111, 111, 100,
				68, 114, 105, 110, 107, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 40, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 73, 116, 101, 109, 92, 85, 115, 97,
				103, 101, 92, 82, 101, 109, 111, 118, 101, 66,
				117, 102, 102, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 38, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 116, 101, 109, 92, 85, 115, 97, 103, 101,
				92, 83, 112, 97, 119, 110, 69, 103, 103, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 45,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 73, 116, 101, 109,
				92, 85, 115, 97, 103, 101, 92, 85, 115, 101,
				84, 111, 67, 114, 101, 97, 116, 101, 73, 116,
				101, 109, 46, 99, 115, 0, 0, 0, 4, 0,
				0, 0, 43, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 76,
				101, 118, 101, 108, 77, 97, 110, 97, 103, 101,
				114, 92, 65, 73, 77, 97, 105, 110, 66, 114,
				97, 105, 110, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 48, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				76, 101, 118, 101, 108, 77, 97, 110, 97, 103,
				101, 114, 92, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 67, 114, 101, 97, 116, 111, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 52,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 76, 101, 118, 101,
				108, 77, 97, 110, 97, 103, 101, 114, 92, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 80, 111,
				115, 73, 110, 83, 104, 97, 100, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 49,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 76, 101, 118, 101,
				108, 77, 97, 110, 97, 103, 101, 114, 92, 67,
				117, 115, 116, 111, 109, 70, 97, 99, 101, 77,
				97, 110, 97, 103, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 43, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 76, 101, 118, 101, 108, 77, 97,
				110, 97, 103, 101, 114, 92, 69, 120, 105, 116,
				67, 114, 101, 97, 116, 111, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 48, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 76, 101, 118, 101, 108, 77,
				97, 110, 97, 103, 101, 114, 92, 69, 120, 112,
				108, 111, 115, 105, 111, 110, 77, 97, 110, 97,
				103, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 44, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				76, 101, 118, 101, 108, 77, 97, 110, 97, 103,
				101, 114, 92, 73, 110, 112, 117, 116, 77, 97,
				110, 97, 103, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 67, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 76, 101, 118, 101, 108, 77, 97, 110,
				97, 103, 101, 114, 92, 73, 110, 116, 101, 114,
				102, 97, 99, 101, 115, 92, 73, 73, 110, 105,
				116, 105, 97, 108, 105, 122, 101, 100, 81, 117,
				101, 114, 121, 72, 97, 110, 100, 108, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				43, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 76, 101, 118,
				101, 108, 77, 97, 110, 97, 103, 101, 114, 92,
				76, 101, 118, 101, 108, 67, 111, 110, 102, 105,
				103, 46, 99, 115, 0, 0, 0, 3, 0, 0,
				0, 44, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 76, 101,
				118, 101, 108, 77, 97, 110, 97, 103, 101, 114,
				92, 76, 101, 118, 101, 108, 77, 97, 110, 97,
				103, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 43, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				76, 101, 118, 101, 108, 77, 97, 110, 97, 103,
				101, 114, 92, 76, 111, 111, 116, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 40, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 76, 101, 118, 101, 108, 77, 97, 110, 97,
				103, 101, 114, 92, 80, 101, 116, 80, 114, 111,
				120, 121, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 59, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 76,
				101, 118, 101, 108, 77, 97, 110, 97, 103, 101,
				114, 92, 80, 108, 97, 121, 101, 114, 80, 111,
				115, 105, 116, 105, 111, 110, 66, 97, 99, 107,
				117, 112, 77, 97, 110, 97, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 57,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 76, 101, 118, 101,
				108, 77, 97, 110, 97, 103, 101, 114, 92, 80,
				108, 97, 121, 101, 114, 80, 111, 115, 105, 116,
				105, 111, 110, 66, 97, 99, 107, 117, 112, 80,
				114, 111, 120, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 48, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 76, 101, 118, 101, 108, 77, 97, 110, 97,
				103, 101, 114, 92, 80, 111, 111, 108, 115, 92,
				66, 117, 108, 108, 101, 116, 80, 111, 111, 108,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				38, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 76, 111, 111,
				116, 105, 110, 103, 92, 70, 105, 115, 104, 83,
				112, 97, 119, 110, 101, 114, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 38, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 76, 111, 111, 116, 105, 110, 103,
				92, 76, 111, 111, 116, 83, 112, 97, 119, 110,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 42, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 77,
				101, 99, 104, 97, 110, 105, 99, 115, 92, 67,
				111, 117, 110, 116, 68, 111, 119, 110, 65, 114,
				101, 97, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 37, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 77,
				101, 99, 104, 97, 110, 105, 99, 115, 92, 80,
				101, 116, 72, 111, 117, 115, 101, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 40, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 77, 101, 116, 97, 68, 97,
				116, 97, 92, 71, 97, 109, 101, 77, 101, 116,
				97, 68, 97, 116, 97, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 43, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 77, 101, 116, 97, 68, 97, 116, 97,
				92, 71, 97, 109, 101, 86, 101, 114, 115, 105,
				111, 110, 68, 97, 116, 97, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 34, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 78, 97, 109, 101, 100, 70, 111,
				114, 109, 97, 116, 84, 101, 115, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 57, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 79, 112, 116, 105, 109,
				105, 122, 97, 116, 105, 111, 110, 92, 83, 101,
				116, 65, 99, 116, 105, 118, 101, 66, 121, 80,
				108, 97, 121, 101, 114, 68, 105, 115, 116, 97,
				110, 99, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 31, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				80, 108, 97, 116, 102, 111, 114, 109, 73, 110,
				102, 111, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 53, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 80,
				114, 111, 120, 105, 101, 115, 92, 69, 118, 97,
				99, 117, 97, 116, 105, 111, 110, 67, 111, 117,
				110, 116, 100, 111, 119, 110, 85, 73, 80, 114,
				111, 120, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 44, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				80, 114, 111, 120, 105, 101, 115, 92, 76, 101,
				118, 101, 108, 77, 97, 110, 97, 103, 101, 114,
				80, 114, 111, 120, 121, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 43, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 80, 114, 111, 120, 105, 101, 115, 92,
				83, 99, 101, 110, 101, 76, 111, 97, 100, 101,
				114, 80, 114, 111, 120, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 37, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 80, 114, 111, 120, 105, 101, 115,
				92, 86, 105, 101, 119, 115, 80, 114, 111, 120,
				121, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 34, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 67, 111, 110, 100, 105, 116,
				105, 111, 110, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 60, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				81, 117, 101, 115, 116, 92, 67, 111, 110, 100,
				105, 116, 105, 111, 110, 115, 92, 67, 111, 110,
				100, 105, 116, 105, 111, 110, 95, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 76, 101, 118, 101,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 60, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 67, 111, 110, 100, 105, 116,
				105, 111, 110, 115, 92, 67, 111, 110, 100, 105,
				116, 105, 111, 110, 95, 72, 97, 115, 66, 101,
				101, 110, 84, 111, 83, 99, 101, 110, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 54,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 81, 117, 101, 115,
				116, 92, 67, 111, 110, 100, 105, 116, 105, 111,
				110, 115, 92, 67, 111, 110, 100, 105, 116, 105,
				111, 110, 95, 82, 97, 105, 100, 68, 101, 97,
				100, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 55, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 67, 111, 110, 100, 105, 116,
				105, 111, 110, 115, 92, 67, 111, 110, 100, 105,
				116, 105, 111, 110, 95, 84, 105, 109, 101, 79,
				102, 68, 97, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 55, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 81, 117, 101, 115, 116, 92, 67, 111, 110,
				100, 105, 116, 105, 111, 110, 115, 92, 67, 111,
				110, 100, 105, 116, 105, 111, 110, 95, 88, 105,
				97, 111, 72, 101, 105, 90, 105, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 64, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 81, 117, 101, 115, 116, 92,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				92, 67, 111, 110, 100, 105, 116, 111, 110, 95,
				66, 117, 105, 108, 100, 105, 110, 103, 67, 111,
				110, 115, 116, 114, 117, 99, 116, 101, 100, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 57,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 81, 117, 101, 115,
				116, 92, 67, 111, 110, 100, 105, 116, 105, 111,
				110, 115, 92, 82, 101, 113, 117, 105, 114, 101,
				66, 101, 97, 99, 111, 110, 85, 110, 108, 111,
				99, 107, 101, 100, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 47, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 81, 117, 101, 115, 116, 92, 67, 111, 110,
				100, 105, 116, 105, 111, 110, 115, 92, 82, 101,
				113, 117, 105, 114, 101, 68, 101, 109, 111, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 54,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 81, 117, 101, 115,
				116, 92, 67, 111, 110, 100, 105, 116, 105, 111,
				110, 115, 92, 82, 101, 113, 117, 105, 114, 101,
				69, 110, 101, 109, 121, 75, 105, 108, 108, 101,
				100, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 59, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 67, 111, 110, 100, 105, 116,
				105, 111, 110, 115, 92, 82, 101, 113, 117, 105,
				114, 101, 70, 111, 114, 109, 117, 108, 97, 114,
				85, 110, 108, 111, 99, 107, 101, 100, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 61, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 81, 117, 101, 115, 116,
				92, 67, 111, 110, 100, 105, 116, 105, 111, 110,
				115, 92, 82, 101, 113, 117, 105, 114, 101, 71,
				97, 109, 101, 111, 98, 106, 101, 99, 116, 115,
				65, 99, 116, 105, 118, 101, 100, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 52, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 81, 117, 101, 115, 116, 92,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				92, 82, 101, 113, 117, 105, 114, 101, 72, 97,
				115, 70, 105, 115, 104, 101, 100, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 58, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 81, 117, 101, 115, 116, 92,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				92, 82, 101, 113, 117, 105, 114, 101, 73, 110,
				76, 101, 118, 101, 108, 68, 97, 116, 97, 66,
				111, 111, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 55, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				81, 117, 101, 115, 116, 92, 67, 111, 110, 100,
				105, 116, 105, 111, 110, 115, 92, 82, 101, 113,
				117, 105, 114, 101, 80, 101, 114, 107, 85, 110,
				108, 111, 99, 107, 101, 100, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 55, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 67,
				111, 110, 100, 105, 116, 105, 111, 110, 115, 92,
				82, 101, 113, 117, 105, 114, 101, 81, 117, 101,
				115, 116, 115, 65, 99, 116, 105, 118, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 57,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 81, 117, 101, 115,
				116, 92, 67, 111, 110, 100, 105, 116, 105, 111,
				110, 115, 92, 82, 101, 113, 117, 105, 114, 101,
				81, 117, 101, 115, 116, 115, 70, 105, 110, 105,
				115, 104, 101, 100, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 55, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 81, 117, 101, 115, 116, 92, 67, 111, 110,
				100, 105, 116, 105, 111, 110, 115, 92, 82, 101,
				113, 117, 105, 114, 101, 83, 97, 118, 101, 68,
				97, 116, 97, 66, 111, 111, 108, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 51, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 81, 117, 101, 115, 116, 92,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				92, 82, 101, 113, 117, 105, 114, 101, 87, 101,
				97, 116, 104, 101, 114, 115, 46, 99, 115, 0,
				0, 0, 3, 0, 0, 0, 30, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 81,
				117, 101, 115, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 40, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 81, 117, 101, 115, 116, 92, 81, 117, 101,
				115, 116, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 46, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 81,
				117, 101, 115, 116, 92, 81, 117, 101, 115, 116,
				71, 105, 118, 101, 114, 92, 81, 117, 101, 115,
				116, 71, 105, 118, 101, 114, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 37, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 81,
				117, 101, 115, 116, 77, 97, 110, 97, 103, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 63, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 81, 117, 101, 115, 116, 82,
				101, 108, 97, 116, 105, 111, 110, 115, 92, 81,
				117, 101, 115, 116, 82, 101, 108, 97, 116, 105,
				111, 110, 67, 111, 110, 110, 101, 99, 116, 105,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 58, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 81,
				117, 101, 115, 116, 92, 81, 117, 101, 115, 116,
				82, 101, 108, 97, 116, 105, 111, 110, 115, 92,
				81, 117, 101, 115, 116, 82, 101, 108, 97, 116,
				105, 111, 110, 71, 114, 97, 112, 104, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 57, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 81, 117, 101, 115, 116,
				92, 81, 117, 101, 115, 116, 82, 101, 108, 97,
				116, 105, 111, 110, 115, 92, 81, 117, 101, 115,
				116, 82, 101, 108, 97, 116, 105, 111, 110, 78,
				111, 100, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 62, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				81, 117, 101, 115, 116, 92, 81, 117, 101, 115,
				116, 82, 101, 108, 97, 116, 105, 111, 110, 115,
				92, 81, 117, 101, 115, 116, 82, 101, 108, 97,
				116, 105, 111, 110, 80, 114, 111, 120, 121, 78,
				111, 100, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 31, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				81, 117, 101, 115, 116, 92, 82, 101, 119, 97,
				114, 100, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 48, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 81,
				117, 101, 115, 116, 92, 82, 101, 119, 97, 114,
				100, 115, 92, 81, 117, 101, 115, 116, 82, 101,
				119, 97, 114, 100, 95, 69, 88, 80, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 50, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 81, 117, 101, 115, 116,
				92, 82, 101, 119, 97, 114, 100, 115, 92, 81,
				117, 101, 115, 116, 82, 101, 119, 97, 114, 100,
				95, 77, 111, 110, 101, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 60, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 82,
				101, 119, 97, 114, 100, 115, 92, 81, 117, 101,
				115, 116, 82, 101, 119, 97, 114, 100, 95, 85,
				110, 108, 111, 99, 107, 83, 116, 111, 99, 107,
				73, 116, 101, 109, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 43, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 81, 117, 101, 115, 116, 92, 82, 101, 119,
				97, 114, 100, 115, 92, 82, 101, 119, 97, 114,
				100, 73, 116, 101, 109, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 29, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 81, 117, 101, 115, 116, 92, 84, 97,
				115, 107, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 44, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 81,
				117, 101, 115, 116, 92, 84, 97, 115, 107, 69,
				118, 101, 110, 116, 92, 84, 97, 115, 107, 69,
				118, 101, 110, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 51, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 81, 117, 101, 115, 116, 92, 84, 97, 115,
				107, 69, 118, 101, 110, 116, 92, 84, 97, 115,
				107, 69, 118, 101, 110, 116, 69, 109, 105, 116,
				116, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 54, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				81, 117, 101, 115, 116, 92, 84, 97, 115, 107,
				115, 92, 81, 117, 101, 115, 116, 84, 97, 115,
				107, 95, 67, 104, 101, 99, 107, 83, 97, 118,
				101, 68, 97, 116, 97, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 58, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 81, 117, 101, 115, 116, 92, 84, 97,
				115, 107, 115, 92, 81, 117, 101, 115, 116, 84,
				97, 115, 107, 95, 67, 111, 110, 115, 116, 114,
				117, 99, 116, 66, 117, 105, 108, 100, 105, 110,
				103, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 49, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 84, 97, 115, 107, 115, 92,
				81, 117, 101, 115, 116, 84, 97, 115, 107, 95,
				69, 118, 97, 99, 117, 97, 116, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 50, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 81, 117, 101, 115, 116,
				92, 84, 97, 115, 107, 115, 92, 81, 117, 101,
				115, 116, 84, 97, 115, 107, 95, 75, 105, 108,
				108, 67, 111, 117, 110, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 54, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 84,
				97, 115, 107, 115, 92, 81, 117, 101, 115, 116,
				84, 97, 115, 107, 95, 82, 101, 97, 99, 104,
				76, 111, 99, 97, 116, 105, 111, 110, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 52, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 81, 117, 101, 115, 116,
				92, 84, 97, 115, 107, 115, 92, 81, 117, 101,
				115, 116, 84, 97, 115, 107, 95, 83, 117, 98,
				109, 105, 116, 77, 111, 110, 101, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 50, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 81, 117, 101, 115, 116,
				92, 84, 97, 115, 107, 115, 92, 81, 117, 101,
				115, 116, 84, 97, 115, 107, 95, 84, 97, 115,
				107, 69, 118, 101, 110, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 53, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 84,
				97, 115, 107, 115, 92, 81, 117, 101, 115, 116,
				84, 97, 115, 107, 95, 85, 110, 108, 111, 99,
				107, 66, 101, 97, 99, 111, 110, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 51, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 81, 117, 101, 115, 116, 92,
				84, 97, 115, 107, 115, 92, 81, 117, 101, 115,
				116, 84, 97, 115, 107, 95, 85, 110, 108, 111,
				99, 107, 80, 101, 114, 107, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 48, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 84,
				97, 115, 107, 115, 92, 81, 117, 101, 115, 116,
				84, 97, 115, 107, 95, 85, 115, 101, 73, 116,
				101, 109, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 42, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 81,
				117, 101, 115, 116, 92, 84, 97, 115, 107, 115,
				92, 83, 117, 98, 109, 105, 116, 73, 116, 101,
				109, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 65, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 81,
				117, 101, 115, 116, 92, 85, 73, 92, 81, 117,
				101, 115, 116, 67, 111, 109, 112, 108, 101, 116,
				101, 80, 97, 110, 101, 108, 92, 81, 117, 101,
				115, 116, 67, 111, 109, 112, 108, 101, 116, 101,
				80, 97, 110, 101, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 38, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 81, 117, 101, 115, 116, 92, 85, 73,
				92, 81, 117, 101, 115, 116, 69, 110, 116, 114,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 42, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 85, 73, 92, 81, 117, 101,
				115, 116, 71, 105, 118, 101, 114, 86, 105, 101,
				119, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 62, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 85, 73, 92, 81, 117, 101,
				115, 116, 71, 105, 118, 101, 114, 86, 105, 101,
				119, 92, 81, 117, 101, 115, 116, 71, 105, 118,
				101, 114, 84, 97, 98, 66, 117, 116, 116, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 57, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 85, 73, 92, 81, 117, 101,
				115, 116, 71, 105, 118, 101, 114, 86, 105, 101,
				119, 92, 81, 117, 101, 115, 116, 71, 105, 118,
				101, 114, 84, 97, 98, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 45, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 85,
				73, 92, 81, 117, 101, 115, 116, 82, 101, 113,
				117, 105, 114, 101, 100, 73, 116, 101, 109, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 37,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 81, 117, 101, 115,
				116, 92, 85, 73, 92, 81, 117, 101, 115, 116,
				86, 105, 101, 119, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 44, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 81, 117, 101, 115, 116, 92, 85, 73, 92,
				81, 117, 101, 115, 116, 86, 105, 101, 119, 68,
				101, 116, 97, 105, 108, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 47, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 85,
				73, 92, 81, 117, 101, 115, 116, 86, 105, 101,
				119, 70, 108, 97, 103, 66, 117, 116, 116, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 39, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 92, 85, 73, 92, 82, 101, 119,
				97, 114, 100, 69, 110, 116, 114, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 37, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 81, 117, 101, 115, 116,
				92, 85, 73, 92, 84, 97, 115, 107, 69, 110,
				116, 114, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 52, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				81, 117, 101, 115, 116, 92, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 92, 77, 97, 112, 69,
				108, 101, 109, 101, 110, 116, 70, 111, 114, 84,
				97, 115, 107, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 65, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				81, 117, 101, 115, 116, 92, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 92, 80, 108, 97, 121,
				68, 105, 97, 108, 111, 103, 117, 101, 71, 114,
				97, 112, 104, 79, 110, 81, 117, 101, 115, 116,
				65, 99, 116, 105, 118, 101, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 62, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 92, 83,
				104, 111, 119, 68, 105, 97, 108, 111, 103, 117,
				101, 79, 110, 81, 117, 101, 115, 116, 65, 99,
				116, 105, 118, 97, 116, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 51, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 92, 83,
				112, 97, 119, 110, 73, 116, 101, 109, 70, 111,
				114, 84, 97, 115, 107, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 53, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 81, 117, 101, 115, 116, 92, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 92, 83, 112,
				97, 119, 110, 80, 114, 101, 102, 97, 98, 70,
				111, 114, 84, 97, 115, 107, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 67, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 92, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 92, 85,
				110, 108, 111, 99, 107, 69, 110, 100, 111, 119,
				109, 101, 110, 116, 87, 104, 101, 110, 81, 117,
				101, 115, 116, 67, 111, 109, 112, 108, 101, 116,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 42, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 97,
				118, 101, 115, 92, 73, 83, 97, 118, 101, 68,
				97, 116, 97, 80, 114, 111, 118, 105, 100, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 43, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 97,
				118, 101, 115, 92, 73, 116, 101, 109, 83, 97,
				118, 101, 115, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 56, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				97, 118, 101, 115, 92, 82, 101, 115, 116, 111,
				114, 101, 70, 97, 105, 108, 117, 114, 101, 68,
				101, 116, 101, 99, 116, 101, 100, 73, 110, 100,
				105, 99, 97, 116, 111, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 37, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 83, 97, 118, 101, 115, 92, 83,
				97, 118, 101, 115, 67, 111, 117, 110, 116, 101,
				114, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 36, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 97,
				118, 101, 115, 92, 83, 97, 118, 101, 115, 83,
				121, 115, 116, 101, 109, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 56, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 83, 99, 101, 110, 101, 77, 97, 110,
				97, 103, 101, 109, 101, 110, 116, 92, 76, 111,
				97, 100, 85, 110, 105, 116, 121, 83, 99, 101,
				110, 101, 79, 110, 83, 116, 97, 114, 116, 46,
				99, 115, 0, 0, 0, 4, 0, 0, 0, 49,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 99, 101, 110,
				101, 77, 97, 110, 97, 103, 101, 109, 101, 110,
				116, 92, 77, 117, 108, 116, 105, 83, 99, 101,
				110, 101, 67, 111, 114, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 53, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 83, 99, 101, 110, 101, 77, 97,
				110, 97, 103, 101, 109, 101, 110, 116, 92, 77,
				117, 108, 116, 105, 83, 99, 101, 110, 101, 76,
				111, 99, 97, 116, 105, 111, 110, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 55, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 83, 99, 101, 110, 101, 77,
				97, 110, 97, 103, 101, 109, 101, 110, 116, 92,
				77, 117, 108, 116, 105, 83, 99, 101, 110, 101,
				84, 101, 108, 101, 112, 111, 114, 116, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				51, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 83, 99, 101,
				110, 101, 77, 97, 110, 97, 103, 101, 109, 101,
				110, 116, 92, 83, 99, 101, 110, 101, 73, 68,
				65, 116, 116, 114, 105, 98, 117, 116, 101, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 54,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 99, 101, 110,
				101, 77, 97, 110, 97, 103, 101, 109, 101, 110,
				116, 92, 83, 99, 101, 110, 101, 73, 110, 102,
				111, 67, 111, 108, 108, 101, 99, 116, 105, 111,
				110, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 46, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 99,
				101, 110, 101, 77, 97, 110, 97, 103, 101, 109,
				101, 110, 116, 92, 83, 99, 101, 110, 101, 76,
				111, 97, 100, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 61, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 83, 99, 101, 110, 101, 77, 97, 110,
				97, 103, 101, 109, 101, 110, 116, 92, 83, 99,
				101, 110, 101, 76, 111, 97, 100, 105, 110, 103,
				69, 118, 101, 110, 116, 115, 82, 101, 99, 101,
				105, 118, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 57, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 83, 99, 101, 110, 101, 77, 97, 110, 97,
				103, 101, 109, 101, 110, 116, 92, 83, 99, 101,
				110, 101, 76, 111, 99, 97, 116, 105, 111, 110,
				115, 80, 114, 111, 118, 105, 100, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 62,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 99, 101, 110,
				101, 77, 97, 110, 97, 103, 101, 109, 101, 110,
				116, 92, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 92, 83, 104, 111, 119, 76, 111, 99, 97,
				116, 105, 111, 110, 73, 110, 77, 97, 112, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 41,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 105, 109, 112,
				108, 101, 67, 97, 109, 101, 114, 97, 67, 111,
				110, 116, 114, 111, 108, 108, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 45, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 83, 107, 105, 108, 108,
				92, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				83, 107, 105, 108, 108, 75, 101, 101, 112, 101,
				114, 46, 99, 115, 0, 0, 0, 3, 0, 0,
				0, 34, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 107,
				105, 108, 108, 92, 83, 107, 105, 108, 108, 66,
				97, 115, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 38, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				83, 107, 105, 108, 108, 92, 83, 107, 105, 108,
				108, 95, 71, 114, 101, 110, 97, 100, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 45,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 112, 101, 99,
				105, 97, 108, 92, 66, 97, 115, 101, 83, 99,
				101, 110, 101, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 52, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				112, 101, 99, 105, 97, 108, 92, 79, 118, 101,
				114, 114, 105, 100, 101, 68, 101, 97, 116, 104,
				83, 99, 101, 110, 101, 82, 111, 117, 116, 105,
				110, 103, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 34, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				116, 97, 114, 116, 117, 112, 92, 83, 116, 97,
				114, 116, 117, 112, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 46, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 83, 116, 101, 97, 109, 119, 111, 114, 107,
				115, 46, 78, 69, 84, 92, 83, 116, 101, 97,
				109, 77, 97, 110, 97, 103, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 36, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 84, 101, 115, 116, 92,
				68, 97, 109, 97, 103, 101, 84, 111, 83, 101,
				108, 102, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 36, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
				101, 115, 116, 92, 69, 110, 101, 109, 121, 67,
				114, 101, 97, 116, 111, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 45, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 84, 101, 115, 116, 92, 76, 111,
				103, 79, 110, 69, 110, 97, 98, 108, 101, 65,
				110, 100, 68, 105, 115, 97, 98, 108, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 40,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 84, 101, 115, 116,
				92, 77, 97, 112, 73, 109, 97, 103, 101, 84,
				111, 83, 104, 97, 100, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 36, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 84, 101, 115, 116, 92, 79,
				110, 68, 105, 115, 97, 98, 108, 101, 76, 111,
				103, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 39, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 84, 101,
				115, 116, 92, 84, 101, 115, 116, 73, 116, 101,
				109, 71, 114, 97, 112, 104, 105, 99, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 50, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 84, 105, 109, 101, 108,
				105, 110, 101, 92, 80, 108, 97, 121, 97, 98,
				108, 101, 68, 105, 114, 101, 99, 116, 111, 114,
				69, 118, 101, 110, 116, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 40, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 84, 111, 111, 108, 115, 92, 66,
				108, 117, 101, 78, 111, 105, 115, 101, 83, 101,
				116, 116, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 58, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 111, 111, 108, 115, 92, 66, 111, 117,
				110, 100, 97, 114, 121, 71, 101, 110, 114, 97,
				116, 111, 114, 92, 66, 111, 117, 110, 100, 97,
				114, 121, 71, 101, 110, 114, 97, 116, 111, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				43, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 84, 111, 111,
				108, 115, 92, 68, 101, 99, 97, 108, 65, 116,
				108, 97, 115, 83, 101, 108, 101, 99, 116, 111,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 40, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 84, 111,
				111, 108, 115, 92, 68, 101, 115, 116, 114, 111,
				121, 79, 118, 101, 114, 116, 105, 109, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 45,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 84, 111, 111, 108,
				115, 92, 68, 117, 99, 107, 111, 118, 83, 99,
				114, 101, 101, 110, 67, 97, 112, 116, 117, 114,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 68, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
				111, 111, 108, 115, 92, 80, 105, 112, 101, 82,
				101, 110, 100, 101, 114, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 98, 115, 116,
				114, 97, 99, 116, 92, 83, 104, 97, 112, 101,
				80, 114, 111, 118, 105, 100, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 66, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 84, 111, 111, 108, 115,
				92, 80, 105, 112, 101, 82, 101, 110, 100, 101,
				114, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 69, 120, 116, 114, 97, 92, 80, 105,
				112, 101, 67, 111, 108, 108, 105, 100, 101, 114,
				50, 68, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 66, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
				111, 111, 108, 115, 92, 80, 105, 112, 101, 82,
				101, 110, 100, 101, 114, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 69, 120, 116, 114,
				97, 92, 80, 105, 112, 101, 68, 101, 99, 111,
				114, 97, 116, 105, 111, 110, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 80, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 84, 111, 111, 108, 115, 92, 80,
				105, 112, 101, 82, 101, 110, 100, 101, 114, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				69, 120, 116, 114, 117, 100, 101, 83, 104, 97,
				112, 101, 115, 92, 67, 105, 114, 99, 117, 108,
				97, 114, 69, 120, 116, 114, 117, 100, 101, 83,
				104, 97, 112, 101, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 82, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 111, 111, 108, 115, 92, 80, 105, 112,
				101, 82, 101, 110, 100, 101, 114, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 120,
				116, 114, 117, 100, 101, 83, 104, 97, 112, 101,
				115, 92, 77, 117, 108, 116, 105, 67, 105, 114,
				99, 101, 69, 120, 116, 114, 117, 100, 101, 83,
				104, 97, 112, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 87, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 111, 111, 108, 115, 92, 80, 105, 112,
				101, 82, 101, 110, 100, 101, 114, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 120,
				116, 114, 117, 100, 101, 83, 104, 97, 112, 101,
				115, 92, 82, 111, 117, 110, 100, 67, 111, 114,
				110, 101, 114, 82, 101, 99, 116, 69, 120, 116,
				114, 117, 100, 101, 83, 104, 97, 112, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 89,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 84, 111, 111, 108,
				115, 92, 80, 105, 112, 101, 82, 101, 110, 100,
				101, 114, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 120, 116, 114, 117, 100, 101,
				83, 104, 97, 112, 101, 115, 92, 82, 111, 117,
				110, 100, 67, 111, 114, 110, 101, 114, 83, 113,
				117, 97, 114, 101, 69, 120, 116, 114, 117, 100,
				101, 83, 104, 97, 112, 101, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 58, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 84, 111, 111, 108, 115, 92, 80,
				105, 112, 101, 82, 101, 110, 100, 101, 114, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				80, 105, 112, 101, 82, 101, 110, 100, 101, 114,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 63, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
				111, 111, 108, 115, 92, 80, 105, 112, 101, 82,
				101, 110, 100, 101, 114, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 112, 108, 105,
				110, 101, 83, 104, 97, 112, 101, 92, 66, 101,
				118, 101, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 74, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				84, 111, 111, 108, 115, 92, 80, 105, 112, 101,
				82, 101, 110, 100, 101, 114, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 83, 112, 108,
				105, 110, 101, 83, 104, 97, 112, 101, 92, 66,
				101, 118, 101, 108, 101, 100, 76, 105, 110, 101,
				83, 104, 97, 112, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 70, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 84, 111, 111, 108, 115, 92, 80, 105,
				112, 101, 82, 101, 110, 100, 101, 114, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				112, 108, 105, 110, 101, 83, 104, 97, 112, 101,
				92, 66, 101, 122, 105, 101, 114, 83, 112, 108,
				105, 110, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 77, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				84, 111, 111, 108, 115, 92, 80, 105, 112, 101,
				82, 101, 110, 100, 101, 114, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 83, 112, 108,
				105, 110, 101, 83, 104, 97, 112, 101, 92, 77,
				117, 108, 116, 105, 112, 108, 101, 66, 101, 122,
				105, 101, 114, 83, 104, 97, 112, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 75, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 84, 111, 111, 108, 115,
				92, 80, 105, 112, 101, 82, 101, 110, 100, 101,
				114, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 92, 80, 105, 112, 101, 72, 101, 108, 112,
				101, 114, 70, 117, 110, 99, 116, 105, 111, 110,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 56, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 84, 111,
				111, 108, 115, 92, 80, 105, 112, 101, 82, 101,
				110, 100, 101, 114, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 86, 67, 121, 108,
				105, 110, 100, 101, 114, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 31, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 84, 111, 111, 108, 115, 92, 80, 111,
				105, 110, 116, 115, 46, 99, 115, 0, 0, 0,
				3, 0, 0, 0, 62, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 111, 111, 108, 115, 92, 80, 114, 101,
				102, 97, 98, 76, 105, 110, 101, 71, 101, 110,
				114, 97, 116, 111, 114, 92, 80, 114, 101, 102,
				97, 98, 76, 105, 110, 101, 71, 101, 110, 114,
				97, 116, 111, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 50, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 111, 111, 108, 115, 92, 83, 99, 97,
				108, 97, 98, 108, 101, 77, 101, 115, 104, 92,
				83, 99, 97, 108, 97, 98, 108, 101, 77, 101,
				115, 104, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 41, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
				111, 111, 108, 115, 92, 83, 101, 116, 65, 99,
				116, 105, 118, 101, 79, 110, 65, 119, 97, 107,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 34, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 84, 111,
				111, 108, 115, 92, 84, 111, 103, 103, 108, 101,
				72, 85, 68, 46, 99, 115, 0, 0, 0, 4,
				0, 0, 0, 41, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				84, 114, 97, 100, 105, 110, 103, 92, 69, 99,
				111, 110, 111, 109, 121, 77, 97, 110, 97, 103,
				101, 114, 46, 99, 115, 0, 0, 0, 5, 0,
				0, 0, 36, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
				114, 97, 100, 105, 110, 103, 92, 83, 116, 111,
				99, 107, 83, 104, 111, 112, 46, 99, 115, 0,
				0, 0, 3, 0, 0, 0, 44, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 84, 114, 97, 100, 105, 110, 103,
				92, 83, 116, 111, 99, 107, 83, 104, 111, 112,
				68, 97, 116, 97, 98, 97, 115, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 33, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 66, 108,
				97, 99, 107, 83, 99, 114, 101, 101, 110, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 44,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 67,
				97, 110, 118, 97, 115, 83, 99, 97, 108, 101,
				114, 67, 111, 110, 116, 114, 111, 108, 108, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 44, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 67, 104, 97, 105, 110, 101, 100, 85, 73,
				80, 97, 110, 101, 108, 92, 85, 73, 80, 97,
				110, 101, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 65, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 67, 104, 97, 105, 110, 101, 100,
				85, 73, 80, 97, 110, 101, 108, 92, 85, 73,
				80, 97, 110, 101, 108, 66, 117, 116, 116, 111,
				110, 95, 79, 112, 101, 110, 67, 104, 105, 108,
				100, 80, 97, 110, 101, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 50, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 67, 111, 109, 109,
				111, 110, 92, 73, 116, 101, 109, 80, 114, 111,
				112, 101, 114, 116, 105, 101, 115, 68, 105, 115,
				112, 108, 97, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 42, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 67, 111, 109, 109, 111, 110,
				92, 76, 97, 98, 101, 108, 65, 110, 100, 86,
				97, 108, 117, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 44, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 67, 111, 109, 109, 111, 110,
				92, 76, 111, 110, 103, 80, 114, 101, 115, 115,
				66, 117, 116, 116, 111, 110, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 45, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 67, 111, 115, 116,
				68, 105, 115, 112, 108, 97, 121, 92, 67, 111,
				115, 116, 68, 105, 115, 112, 108, 97, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 67,
				111, 115, 116, 68, 105, 115, 112, 108, 97, 121,
				92, 73, 116, 101, 109, 65, 109, 111, 117, 110,
				116, 68, 105, 115, 112, 108, 97, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 47, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 68, 105,
				102, 102, 105, 99, 117, 108, 116, 121, 92, 82,
				101, 115, 101, 108, 101, 99, 116, 66, 117, 116,
				116, 111, 110, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 49, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 68, 105, 102, 102, 105, 99, 117,
				108, 116, 121, 92, 82, 117, 108, 101, 73, 110,
				100, 101, 120, 68, 105, 115, 112, 108, 97, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				33, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				68, 114, 97, 103, 72, 97, 110, 100, 108, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 53, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 73, 110, 116, 101, 114, 102, 97, 99, 101,
				115, 92, 73, 83, 105, 110, 103, 108, 101, 83,
				101, 108, 101, 99, 116, 105, 111, 110, 77, 101,
				110, 117, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 61, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 73, 116, 101, 109, 68, 114, 97, 103,
				103, 105, 110, 103, 92, 73, 110, 116, 101, 114,
				102, 97, 99, 101, 115, 92, 73, 73, 116, 101,
				109, 68, 114, 97, 103, 83, 111, 117, 114, 99,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 61, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 73, 116, 101, 109, 68, 114, 97, 103, 103,
				105, 110, 103, 92, 73, 116, 101, 109, 68, 114,
				97, 103, 103, 105, 110, 103, 80, 111, 105, 110,
				116, 101, 114, 68, 105, 115, 112, 108, 97, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				49, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				73, 116, 101, 109, 72, 111, 118, 101, 114, 105,
				110, 103, 92, 73, 116, 101, 109, 72, 111, 118,
				101, 114, 105, 110, 103, 85, 73, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 43, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 73, 116, 101,
				109, 80, 105, 99, 107, 101, 114, 92, 73, 116,
				101, 109, 80, 105, 99, 107, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 48, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 73, 116,
				101, 109, 80, 105, 99, 107, 101, 114, 92, 73,
				116, 101, 109, 80, 105, 99, 107, 101, 114, 68,
				101, 98, 117, 103, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 48, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 73, 116, 101, 109, 80, 105,
				99, 107, 101, 114, 92, 73, 116, 101, 109, 80,
				105, 99, 107, 101, 114, 69, 110, 116, 114, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				56, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				76, 111, 97, 100, 105, 110, 103, 92, 76, 101,
				118, 101, 108, 73, 110, 105, 116, 105, 97, 108,
				105, 122, 105, 110, 103, 73, 110, 100, 105, 99,
				97, 116, 111, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 50, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 77, 97, 105, 110, 77, 101,
				110, 117, 92, 65, 100, 100, 84, 111, 87, 105,
				115, 104, 76, 105, 115, 116, 66, 117, 116, 116,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 45, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 77, 97, 105, 110, 77, 101, 110, 117,
				92, 67, 111, 110, 116, 105, 110, 117, 101, 66,
				117, 116, 116, 111, 110, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 46, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 77, 97, 105, 110, 77,
				101, 110, 117, 92, 67, 111, 112, 121, 84, 101,
				120, 116, 79, 110, 67, 108, 105, 99, 107, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 77,
				97, 105, 110, 77, 101, 110, 117, 92, 68, 101,
				108, 101, 116, 101, 83, 97, 118, 101, 68, 97,
				116, 97, 66, 117, 116, 116, 111, 110, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 46, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 77, 97,
				105, 110, 77, 101, 110, 117, 92, 70, 97, 100,
				101, 71, 114, 111, 117, 112, 66, 117, 116, 116,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 39, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 77, 97, 105, 110, 77, 101, 110, 117,
				92, 77, 97, 105, 110, 77, 101, 110, 117, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 56,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 77,
				97, 105, 110, 77, 101, 110, 117, 92, 83, 97,
				118, 101, 115, 66, 97, 99, 107, 117, 112, 82,
				101, 115, 116, 111, 114, 101, 73, 110, 118, 111,
				107, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 54, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 77, 97, 105, 110, 77, 101, 110,
				117, 92, 83, 97, 118, 101, 115, 66, 97, 99,
				107, 117, 112, 82, 101, 115, 116, 111, 114, 101,
				80, 97, 110, 101, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 59, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 77, 97, 105, 110, 77,
				101, 110, 117, 92, 83, 97, 118, 101, 115, 66,
				97, 99, 107, 117, 112, 82, 101, 115, 116, 111,
				114, 101, 80, 97, 110, 101, 108, 69, 110, 116,
				114, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 42, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 77, 97, 105, 110, 77, 101, 110, 117,
				92, 83, 97, 118, 101, 115, 66, 117, 116, 116,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 54, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 77, 97, 105, 110, 77, 101, 110, 117,
				92, 83, 97, 118, 101, 83, 108, 111, 116, 83,
				101, 108, 101, 99, 116, 105, 111, 110, 66, 117,
				116, 116, 111, 110, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 52, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 77, 97, 105, 110, 77, 101,
				110, 117, 92, 83, 97, 118, 101, 83, 108, 111,
				116, 83, 101, 108, 101, 99, 116, 105, 111, 110,
				77, 101, 110, 117, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 36, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 77, 97, 105, 110, 77, 101,
				110, 117, 92, 84, 105, 116, 108, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 45, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 77, 101,
				116, 97, 92, 71, 97, 109, 101, 86, 101, 114,
				115, 105, 111, 110, 68, 105, 115, 112, 108, 97,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 47, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 77, 111, 110, 101, 121, 68, 105, 115, 112,
				108, 97, 121, 92, 77, 111, 110, 101, 121, 68,
				105, 115, 112, 108, 97, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 36, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 79, 110, 80, 111,
				105, 110, 116, 101, 114, 67, 108, 105, 99, 107,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				31, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				80, 97, 117, 115, 101, 77, 101, 110, 117, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 80,
				97, 117, 115, 101, 77, 101, 110, 117, 92, 66,
				117, 116, 116, 111, 110, 95, 76, 111, 97, 100,
				77, 97, 105, 110, 77, 101, 110, 117, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 47, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 80, 97,
				117, 115, 101, 77, 101, 110, 117, 92, 66, 117,
				116, 116, 111, 110, 95, 81, 117, 105, 116, 71,
				97, 109, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 47, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 80, 97, 117, 115, 101, 77, 101,
				110, 117, 92, 67, 111, 110, 102, 105, 114, 109,
				68, 105, 97, 108, 111, 103, 117, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 44, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 82, 101,
				100, 68, 111, 116, 92, 73, 78, 101, 101, 100,
				73, 110, 115, 112, 101, 99, 116, 105, 111, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				47, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				82, 101, 100, 68, 111, 116, 92, 81, 117, 101,
				115, 116, 115, 66, 117, 116, 116, 111, 110, 82,
				101, 100, 68, 111, 116, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 44, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 83, 101, 116, 65, 99,
				116, 105, 118, 101, 66, 121, 73, 110, 112, 117,
				116, 68, 101, 118, 105, 99, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 48, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 84, 111, 111,
				108, 116, 105, 112, 115, 92, 73, 84, 111, 111,
				108, 116, 105, 112, 115, 80, 114, 111, 118, 105,
				100, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 39, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 84, 111, 111, 108, 116, 105, 112,
				115, 92, 84, 111, 111, 108, 116, 105, 112, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				47, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				84, 111, 111, 108, 116, 105, 112, 115, 92, 84,
				111, 111, 108, 116, 105, 112, 115, 80, 114, 111,
				118, 105, 100, 101, 114, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 36, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 85, 73, 73, 110, 112,
				117, 116, 77, 97, 110, 97, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 42,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 92, 82, 97, 105, 100,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 38,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 86, 105, 115, 117,
				97, 108, 92, 66, 111, 119, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 33, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 86, 105, 115, 117, 97, 108, 92, 66,
				117, 102, 102, 86, 70, 88, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 42, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 86, 105, 115, 117, 97, 108, 92,
				66, 117, 110, 107, 101, 114, 68, 111, 111, 114,
				86, 105, 115, 117, 97, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 38, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 86, 105, 115, 117, 97, 108, 92,
				67, 97, 109, 101, 114, 97, 83, 104, 97, 107,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 38, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
				105, 115, 117, 97, 108, 92, 68, 97, 114, 107,
				82, 111, 111, 109, 70, 97, 100, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 38, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 86, 105, 115, 117, 97,
				108, 92, 68, 80, 83, 68, 105, 115, 112, 108,
				97, 121, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 37, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 86, 105, 115, 117, 97, 108, 92, 68, 117,
				99, 107, 111, 118, 72, 105, 100, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 41,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 86, 105, 115, 117,
				97, 108, 92, 70, 111, 103, 79, 102, 87, 97,
				114, 77, 97, 110, 97, 103, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 40, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 86, 105, 115, 117, 97,
				108, 92, 72, 97, 110, 100, 104, 101, 108, 100,
				83, 112, 114, 105, 116, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 41, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 86, 105, 115, 117, 97, 108, 92,
				76, 105, 103, 104, 116, 67, 111, 111, 107, 105,
				101, 77, 111, 118, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 43, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 86, 105, 115, 117, 97, 108, 92, 77,
				97, 105, 110, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 70, 97, 99, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 40, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 86, 105, 115, 117, 97, 108, 92,
				77, 97, 105, 110, 77, 101, 110, 117, 67, 97,
				109, 101, 114, 97, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 50, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 86, 105, 115, 117, 97, 108, 92, 77, 105,
				110, 105, 110, 103, 77, 97, 99, 104, 105, 110,
				101, 67, 97, 114, 100, 68, 105, 115, 112, 108,
				97, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 45, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
				105, 115, 117, 97, 108, 92, 77, 105, 110, 105,
				110, 103, 77, 97, 99, 104, 105, 110, 101, 86,
				105, 115, 117, 97, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 34, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 86, 105, 115, 117, 97, 108, 92, 77,
				111, 118, 101, 82, 105, 110, 103, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 36, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 86, 105, 115, 117, 97, 108,
				92, 77, 111, 118, 101, 86, 105, 115, 117, 97,
				108, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 43, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 86, 105,
				115, 117, 97, 108, 92, 78, 105, 103, 104, 116,
				86, 105, 115, 105, 111, 110, 86, 105, 115, 117,
				97, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 60, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
				105, 115, 117, 97, 108, 92, 79, 99, 99, 108,
				117, 115, 105, 111, 110, 70, 97, 100, 101, 92,
				79, 99, 99, 108, 117, 115, 105, 111, 110, 70,
				97, 100, 101, 67, 104, 101, 99, 107, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				60, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 86, 105, 115,
				117, 97, 108, 92, 79, 99, 99, 108, 117, 115,
				105, 111, 110, 70, 97, 100, 101, 92, 79, 99,
				99, 108, 117, 115, 105, 111, 110, 70, 97, 100,
				101, 77, 97, 110, 97, 103, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 59, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 86, 105, 115, 117, 97,
				108, 92, 79, 99, 99, 108, 117, 115, 105, 111,
				110, 70, 97, 100, 101, 92, 79, 99, 99, 108,
				117, 115, 105, 111, 110, 70, 97, 100, 101, 79,
				98, 106, 101, 99, 116, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 60, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 86, 105, 115, 117, 97, 108, 92, 79,
				99, 99, 108, 117, 115, 105, 111, 110, 70, 97,
				100, 101, 92, 79, 99, 99, 108, 117, 115, 105,
				111, 110, 70, 97, 100, 101, 84, 114, 105, 103,
				103, 101, 114, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 43, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				86, 105, 115, 117, 97, 108, 92, 83, 101, 116,
				65, 99, 116, 105, 118, 101, 66, 121, 69, 110,
				100, 105, 110, 103, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 40, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 86, 105, 115, 117, 97, 108, 92, 83, 104,
				111, 111, 116, 82, 97, 110, 103, 101, 82, 105,
				110, 103, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 38, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
				105, 115, 117, 97, 108, 92, 83, 116, 111, 114,
				109, 87, 101, 97, 116, 104, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 41, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 86, 105, 115, 117, 97,
				108, 92, 84, 105, 109, 101, 79, 102, 68, 97,
				121, 67, 111, 110, 102, 105, 103, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 45, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 86, 105, 115, 117, 97, 108,
				92, 84, 105, 109, 101, 79, 102, 68, 97, 121,
				67, 111, 110, 116, 114, 111, 108, 108, 101, 114,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				40, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 86, 105, 115,
				117, 97, 108, 92, 84, 105, 109, 101, 79, 102,
				68, 97, 121, 69, 110, 116, 114, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 48, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 86, 105, 115, 117, 97,
				108, 92, 84, 105, 109, 101, 79, 102, 68, 97,
				121, 86, 111, 108, 117, 109, 101, 67, 111, 110,
				116, 114, 111, 108, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 40, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 86, 105, 115, 117, 97, 108, 92, 86, 111,
				108, 117, 109, 101, 115, 67, 111, 110, 116, 114,
				111, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 42, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
				105, 115, 117, 97, 108, 92, 87, 101, 97, 116,
				104, 101, 114, 70, 120, 67, 111, 110, 116, 114,
				111, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 38, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 87,
				111, 114, 107, 98, 101, 110, 99, 104, 92, 87,
				111, 114, 107, 98, 101, 110, 99, 104, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 51, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 111, 100,
				97, 67, 114, 97, 102, 116, 92, 69, 100, 103,
				101, 76, 105, 103, 104, 116, 50, 48, 50, 51,
				92, 67, 97, 109, 101, 114, 97, 65, 114, 109,
				67, 111, 110, 116, 114, 111, 108, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 44, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 111, 100, 97,
				67, 114, 97, 102, 116, 92, 69, 100, 103, 101,
				76, 105, 103, 104, 116, 50, 48, 50, 51, 92,
				69, 100, 103, 101, 76, 105, 103, 104, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 47,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 111,
				100, 97, 67, 114, 97, 102, 116, 92, 69, 100,
				103, 101, 76, 105, 103, 104, 116, 50, 48, 50,
				51, 92, 76, 105, 103, 104, 116, 67, 111, 110,
				116, 114, 111, 108, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 48, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 111, 100, 97, 67, 114, 97,
				102, 116, 92, 69, 100, 103, 101, 76, 105, 103,
				104, 116, 50, 48, 50, 51, 92, 84, 105, 109,
				101, 79, 102, 68, 97, 121, 80, 111, 115, 116,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				69, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 65, 99, 104, 105, 101, 118, 101, 109, 101,
				110, 116, 77, 97, 110, 97, 103, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 99,
				104, 105, 101, 118, 101, 109, 101, 110, 116, 68,
				97, 116, 97, 98, 97, 115, 101, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 68, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 65, 99,
				104, 105, 101, 118, 101, 109, 101, 110, 116, 77,
				97, 110, 97, 103, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 99, 104, 105, 101,
				118, 101, 109, 101, 110, 116, 77, 97, 110, 97,
				103, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 63, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 65, 99, 104, 105, 101, 118,
				101, 109, 101, 110, 116, 77, 97, 110, 97, 103,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 83, 111, 99, 105, 97, 108, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 67, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 65, 99, 104, 105, 101,
				118, 101, 109, 101, 110, 116, 77, 97, 110, 97,
				103, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 83, 116, 97, 116, 105, 115, 116, 105,
				99, 115, 77, 97, 110, 97, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 3, 0, 0, 0, 48,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				65, 113, 117, 97, 114, 105, 117, 109, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 113, 117,
				97, 114, 105, 117, 109, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 49, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 65, 113, 117, 97,
				114, 105, 117, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 117, 109, 109, 121, 70, 105,
				115, 104, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 43, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 65, 84, 77, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 84, 77, 80, 97,
				110, 101, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 53, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 65, 84, 77, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 84, 77, 80,
				97, 110, 101, 108, 95, 68, 114, 97, 119, 80,
				97, 110, 101, 108, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 53, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 65, 84, 77, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 84, 77,
				80, 97, 110, 101, 108, 95, 83, 97, 118, 101,
				80, 97, 110, 101, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 42, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 65, 84, 77, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 84,
				77, 86, 105, 101, 119, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 50, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 65, 84, 77, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 68, 105,
				103, 105, 116, 73, 110, 112, 117, 116, 80, 97,
				110, 101, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 52, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 65, 117, 100, 105, 111, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 70, 109,
				111, 100, 69, 118, 101, 110, 116, 84, 101, 115,
				116, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 58, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 65, 117, 100, 105, 111, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 80, 111,
				115, 116, 65, 117, 100, 105, 111, 69, 118, 101,
				110, 116, 79, 110, 69, 110, 116, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 61,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				66, 97, 115, 101, 66, 117, 105, 108, 100, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				66, 117, 105, 108, 100, 101, 114, 86, 105, 101,
				119, 73, 110, 118, 111, 107, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 55, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 66,
				97, 115, 101, 66, 117, 105, 108, 100, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
				117, 105, 108, 100, 105, 110, 103, 65, 114, 101,
				97, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 57, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 66, 97, 115, 101, 66, 117, 105, 108,
				100, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 66, 117, 105, 108, 100,
				101, 114, 86, 105, 101, 119, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 62, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 66, 97, 115,
				101, 66, 117, 105, 108, 100, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				66, 117, 105, 108, 100, 105, 110, 103, 66, 116,
				110, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 65, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 66, 97, 115,
				101, 66, 117, 105, 108, 100, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				66, 117, 105, 108, 100, 105, 110, 103, 67, 111,
				110, 116, 101, 120, 116, 77, 101, 110, 117, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 70,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				66, 97, 115, 101, 66, 117, 105, 108, 100, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 66, 117, 105, 108, 100, 105, 110,
				103, 67, 111, 110, 116, 101, 120, 116, 77, 101,
				110, 117, 69, 110, 116, 114, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 68, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 66, 97,
				115, 101, 66, 117, 105, 108, 100, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 66, 117, 105, 108, 100, 105, 110, 103, 83,
				101, 108, 101, 99, 116, 105, 111, 110, 80, 97,
				110, 101, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 57, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 66, 97, 115, 101, 66, 117,
				105, 108, 100, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 71, 114, 105,
				100, 68, 105, 115, 112, 108, 97, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 48, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 66,
				97, 115, 107, 101, 116, 66, 97, 108, 108, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 66, 97,
				115, 107, 101, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 52, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 66, 97, 115, 107, 101,
				116, 66, 97, 108, 108, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 66, 97, 115, 107, 101, 116,
				66, 97, 108, 108, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 55, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 66, 97, 115, 107, 101,
				116, 66, 97, 108, 108, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 66, 97, 115, 107, 101, 116,
				84, 114, 105, 103, 103, 101, 114, 46, 99, 115,
				0, 0, 0, 3, 0, 0, 0, 52, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 66, 101,
				97, 99, 111, 110, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 66, 101, 97, 99, 111, 110,
				77, 97, 110, 97, 103, 101, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 51, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 66, 105,
				116, 99, 111, 105, 110, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 66, 105, 116, 99, 111, 105,
				110, 77, 105, 110, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 55, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 66, 105, 116,
				99, 111, 105, 110, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 66, 105, 116, 99, 111, 105, 110,
				77, 105, 110, 101, 114, 86, 105, 101, 119, 46,
				99, 115, 0, 0, 0, 5, 0, 0, 0, 54,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				66, 108, 97, 99, 107, 77, 97, 114, 107, 101,
				116, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				66, 108, 97, 99, 107, 77, 97, 114, 107, 101,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 61, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 66, 108, 97, 99, 107, 77, 97, 114,
				107, 101, 116, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 66, 108, 97, 99, 107,
				77, 97, 114, 107, 101, 116, 86, 105, 101, 119,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				57, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 66, 108, 97, 99, 107, 77, 97, 114, 107,
				101, 116, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 68, 101, 109, 97, 110, 100,
				80, 97, 110, 101, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 63, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 66, 108, 97, 99,
				107, 77, 97, 114, 107, 101, 116, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 68,
				101, 109, 97, 110, 100, 80, 97, 110, 101, 108,
				95, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 57, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 66, 108, 97,
				99, 107, 77, 97, 114, 107, 101, 116, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				83, 117, 112, 112, 108, 121, 80, 97, 110, 101,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 63, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 66, 108, 97, 99, 107, 77, 97, 114,
				107, 101, 116, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 83, 117, 112, 112, 108,
				121, 80, 97, 110, 101, 108, 95, 69, 110, 116,
				114, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 49, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 66, 117, 105, 108, 100, 105, 110,
				103, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 66, 117, 105, 108, 100, 105, 110, 103, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 63,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				66, 117, 105, 108, 100, 105, 110, 103, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 66, 117,
				105, 108, 100, 105, 110, 103, 68, 97, 116, 97,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				55, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 66, 117, 105, 108, 100, 105, 110, 103, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
				117, 105, 108, 100, 105, 110, 103, 69, 102, 102,
				101, 99, 116, 46, 99, 115, 0, 0, 0, 5,
				0, 0, 0, 56, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 66, 117, 105, 108, 100, 105,
				110, 103, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 66, 117, 105, 108, 100, 105, 110, 103,
				77, 97, 110, 97, 103, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 52, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 67, 97,
				109, 101, 114, 97, 77, 111, 100, 101, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 97, 109,
				101, 114, 97, 77, 111, 100, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 62, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 67, 97,
				109, 101, 114, 97, 77, 111, 100, 101, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 67, 97, 109,
				101, 114, 97, 77, 111, 100, 101, 67, 111, 110,
				116, 114, 111, 108, 108, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 49, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 67, 104,
				101, 97, 116, 105, 110, 103, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 104, 101, 97, 116,
				77, 111, 100, 101, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 55, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 67, 114, 97, 102, 116,
				105, 110, 103, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 67, 114, 97, 102, 116, 105, 110, 103,
				70, 111, 114, 109, 117, 108, 97, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 65, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 67, 114,
				97, 102, 116, 105, 110, 103, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 114, 97, 102, 116,
				105, 110, 103, 70, 111, 114, 109, 117, 108, 97,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				55, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 67, 114, 97, 102, 116, 105, 110, 103, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 67, 114,
				97, 102, 116, 105, 110, 103, 77, 97, 110, 97,
				103, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 57, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 67, 114, 97, 102, 116, 105,
				110, 103, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 68, 101, 99, 111, 109, 112, 111, 115, 101,
				68, 97, 116, 97, 98, 97, 115, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 56, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 67,
				114, 97, 102, 116, 105, 110, 103, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 101, 99, 111,
				109, 112, 111, 115, 101, 70, 111, 114, 109, 117,
				108, 97, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 55, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 67, 114, 97, 102, 116, 105, 110,
				103, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 110, 116, 101, 114, 97, 99, 116, 67, 114,
				97, 102, 116, 101, 114, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 52, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 67, 114, 97, 102,
				116, 105, 110, 103, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 67, 114, 97, 102,
				116, 86, 105, 101, 119, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 66, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 67, 114, 97, 102,
				116, 105, 110, 103, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 67, 114, 97, 102,
				116, 86, 105, 101, 119, 70, 105, 108, 116, 101,
				114, 66, 116, 110, 69, 110, 116, 114, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 62,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				67, 114, 97, 102, 116, 105, 110, 103, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				67, 114, 97, 102, 116, 86, 105, 101, 119, 95,
				76, 105, 115, 116, 69, 110, 116, 114, 121, 46,
				99, 115, 0, 0, 0, 4, 0, 0, 0, 56,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				68, 101, 97, 116, 104, 76, 111, 116, 116, 101,
				114, 121, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 68, 101, 97, 116, 104, 76, 111, 116, 116,
				101, 114, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 68, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 68, 101, 97, 116, 104, 76,
				111, 116, 116, 101, 114, 121, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 68, 101, 97, 116, 104,
				76, 111, 116, 116, 101, 114, 121, 73, 110, 116,
				101, 114, 97, 99, 116, 97, 98, 108, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 58,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				68, 101, 97, 116, 104, 76, 111, 116, 116, 101,
				114, 121, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 67, 97, 114, 100, 68, 105,
				115, 112, 108, 97, 121, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 63, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 68, 101, 97, 116,
				104, 76, 111, 116, 116, 101, 114, 121, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				68, 101, 97, 116, 104, 76, 111, 116, 116, 101,
				114, 121, 67, 97, 114, 100, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 63, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 68, 101, 97,
				116, 104, 76, 111, 116, 116, 101, 114, 121, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 68, 101, 97, 116, 104, 76, 111, 116, 116,
				101, 114, 121, 86, 73, 101, 119, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 61, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 68, 101,
				97, 116, 104, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 68, 101, 97, 100, 66, 111, 100, 121, 77,
				97, 110, 97, 103, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 41, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 68, 101, 98,
				117, 103, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 101, 109, 112, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 64, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 68, 101, 98, 117,
				103, 103, 105, 110, 103, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 68, 101, 98, 117, 103, 75,
				111, 110, 116, 101, 120, 116, 77, 101, 110, 117,
				73, 110, 118, 111, 107, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 58, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 68, 101,
				98, 117, 103, 103, 105, 110, 103, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 73, 110, 115, 116,
				97, 110, 116, 105, 97, 116, 101, 84, 105, 109,
				105, 110, 103, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 58, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 68, 101, 98, 117, 103, 103,
				105, 110, 103, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 73, 110, 118, 101, 110, 116, 111, 114,
				121, 83, 97, 118, 101, 76, 111, 97, 100, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 49,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				68, 101, 98, 117, 103, 103, 105, 110, 103, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 116,
				101, 109, 84, 101, 115, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 61, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 68, 105, 97,
				108, 111, 103, 117, 101, 66, 117, 98, 98, 108,
				101, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 68, 105, 97, 108, 111, 103, 117, 101, 66,
				117, 98, 98, 108, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 66, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 68, 105, 97, 108,
				111, 103, 117, 101, 66, 117, 98, 98, 108, 101,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				68, 105, 97, 108, 111, 103, 117, 101, 66, 117,
				98, 98, 108, 101, 80, 114, 111, 120, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 69,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				68, 105, 97, 108, 111, 103, 117, 101, 66, 117,
				98, 98, 108, 101, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 68, 105, 97, 108, 111, 103,
				117, 101, 66, 117, 98, 98, 108, 101, 115, 77,
				97, 110, 97, 103, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 54, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 68, 105, 97,
				108, 111, 103, 117, 101, 83, 121, 115, 116, 101,
				109, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				67, 117, 116, 83, 99, 101, 110, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 56, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 68,
				105, 97, 108, 111, 103, 117, 101, 83, 121, 115,
				116, 101, 109, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 68, 105, 97, 108, 111, 103, 117, 101,
				85, 73, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 62, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 68, 105, 97, 108, 111, 103, 117,
				101, 83, 121, 115, 116, 101, 109, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 105, 97, 108,
				111, 103, 117, 101, 85, 73, 67, 104, 111, 105,
				99, 101, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 65, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 68, 105, 97, 108, 111, 103, 117,
				101, 83, 121, 115, 116, 101, 109, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 68, 117, 99, 107,
				111, 118, 68, 105, 97, 108, 111, 103, 117, 101,
				65, 99, 116, 111, 114, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 76, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 68, 105, 97, 108,
				111, 103, 117, 101, 83, 121, 115, 116, 101, 109,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 78,
				111, 100, 101, 115, 92, 76, 111, 99, 97, 108,
				105, 122, 101, 100, 77, 117, 108, 116, 105, 67,
				104, 111, 105, 99, 101, 78, 111, 100, 101, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 74,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				68, 105, 97, 108, 111, 103, 117, 101, 83, 121,
				115, 116, 101, 109, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 78, 111, 100, 101, 115, 92, 76,
				111, 99, 97, 108, 105, 122, 101, 100, 83, 116,
				97, 116, 101, 109, 101, 110, 116, 78, 111, 100,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 78, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 68, 105, 97, 108, 111, 103, 117, 101,
				83, 121, 115, 116, 101, 109, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 78, 111, 100, 101, 115,
				92, 76, 111, 99, 97, 108, 105, 122, 101, 100,
				83, 116, 97, 116, 101, 109, 101, 110, 116, 83,
				101, 113, 117, 101, 110, 99, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 75, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 68, 105,
				97, 108, 111, 103, 117, 101, 83, 121, 115, 116,
				101, 109, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 97, 115, 107, 65, 99, 116, 105, 111,
				110, 115, 92, 65, 84, 95, 83, 101, 116, 66,
				108, 97, 99, 107, 83, 99, 114, 101, 101, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				77, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 68, 105, 97, 108, 111, 103, 117, 101, 83,
				121, 115, 116, 101, 109, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 84, 97, 115, 107, 65, 99,
				116, 105, 111, 110, 115, 92, 65, 84, 95, 83,
				101, 116, 86, 105, 114, 116, 117, 97, 108, 67,
				97, 109, 101, 114, 97, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 45, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 69, 110, 100, 105,
				110, 103, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 67, 114, 101, 100, 105, 116, 115, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 52, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 69,
				110, 100, 105, 110, 103, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 67, 114, 101, 100, 105, 116,
				115, 68, 105, 115, 112, 108, 97, 121, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 50, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 69,
				110, 100, 105, 110, 103, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 67, 114, 101, 100, 105, 116,
				115, 76, 101, 120, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 48, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 69, 110, 100,
				105, 110, 103, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 69, 109, 112, 116, 121, 69, 110, 116,
				114, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 48, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 69, 110, 100, 105, 110, 103, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 110,
				100, 105, 110, 103, 70, 108, 111, 119, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 69,
				110, 100, 105, 110, 103, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 72, 111, 114, 105, 122, 111,
				110, 116, 97, 108, 69, 110, 116, 114, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 48,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				69, 110, 100, 105, 110, 103, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 73, 109, 97, 103, 101,
				69, 110, 116, 114, 121, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 47, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 69, 110, 100, 105,
				110, 103, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 101, 120, 116, 69, 110, 116, 114, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				51, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 69, 110, 100, 105, 110, 103, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 86, 101, 114, 116,
				105, 99, 97, 108, 69, 110, 116, 114, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 57,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				69, 110, 100, 111, 119, 109, 101, 110, 116, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 69, 110,
				100, 111, 119, 109, 101, 110, 116, 68, 105, 115,
				112, 108, 97, 121, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 55, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 69, 110, 100, 111, 119,
				109, 101, 110, 116, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 110, 100, 111, 119, 109, 101,
				110, 116, 69, 110, 116, 114, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 57, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 69, 110,
				100, 111, 119, 109, 101, 110, 116, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 69, 110, 100, 111,
				119, 109, 101, 110, 116, 77, 97, 110, 97, 103,
				101, 114, 46, 99, 115, 0, 0, 0, 3, 0,
				0, 0, 50, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 70, 105, 115, 104, 105, 110, 103,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 70,
				105, 115, 104, 105, 110, 103, 80, 111, 111, 108,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				57, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 70, 105, 115, 104, 105, 110, 103, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				66, 97, 105, 116, 83, 101, 108, 101, 99, 116,
				80, 97, 110, 101, 108, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 62, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 70, 105, 115, 104,
				105, 110, 103, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 66, 97, 105, 116, 83,
				101, 108, 101, 99, 116, 80, 97, 110, 101, 108,
				69, 110, 116, 114, 121, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 54, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 70, 105, 115, 104,
				105, 110, 103, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 67, 111, 110, 102, 105,
				114, 109, 80, 97, 110, 101, 108, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 52, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 70, 105,
				115, 104, 105, 110, 103, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 70, 105, 115,
				104, 105, 110, 103, 72, 85, 68, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 51, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 70, 105,
				115, 104, 105, 110, 103, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 70, 105, 115,
				104, 105, 110, 103, 85, 73, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 74, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 70, 111, 114,
				109, 117, 108, 97, 115, 82, 101, 103, 105, 115,
				116, 101, 114, 86, 105, 101, 119, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 70, 111, 114, 109,
				117, 108, 97, 115, 68, 101, 116, 97, 105, 108,
				115, 68, 105, 115, 112, 108, 97, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 70, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 70,
				111, 114, 109, 117, 108, 97, 115, 82, 101, 103,
				105, 115, 116, 101, 114, 86, 105, 101, 119, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 70, 111,
				114, 109, 117, 108, 97, 115, 73, 110, 100, 101,
				120, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 69, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 70, 111, 114,
				109, 117, 108, 97, 115, 82, 101, 103, 105, 115,
				116, 101, 114, 86, 105, 101, 119, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 70, 111, 114, 109,
				117, 108, 97, 115, 73, 110, 100, 101, 120, 86,
				105, 101, 119, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 72, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 70, 111, 114, 109, 117, 108,
				97, 115, 82, 101, 103, 105, 115, 116, 101, 114,
				86, 105, 101, 119, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 70, 111, 114, 109, 117, 108, 97,
				115, 82, 101, 103, 105, 115, 116, 101, 114, 86,
				105, 101, 119, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 79, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 70, 111, 114, 109, 117, 108,
				97, 115, 82, 101, 103, 105, 115, 116, 101, 114,
				86, 105, 101, 119, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 70, 111, 114, 109, 117, 108, 97,
				115, 82, 101, 103, 105, 115, 116, 101, 114, 86,
				105, 101, 119, 73, 110, 118, 111, 107, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				65, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 70, 114, 101, 101, 67, 97, 109, 101, 114,
				97, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				67, 97, 109, 101, 114, 97, 80, 114, 111, 112,
				101, 114, 116, 105, 101, 115, 67, 111, 110, 116,
				114, 111, 108, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 48, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 70, 114, 101, 101, 67, 97,
				109, 101, 114, 97, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 118, 67, 97, 109, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 62,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				70, 114, 101, 101, 67, 97, 109, 101, 114, 97,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 70,
				114, 101, 101, 67, 97, 109, 101, 114, 97, 67,
				111, 110, 116, 114, 111, 108, 108, 101, 114, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 44,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				70, 88, 80, 111, 111, 108, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 70, 88, 80, 111, 111,
				108, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 50, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 71, 97, 109, 101, 67, 108, 111, 99,
				107, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				71, 97, 109, 101, 67, 108, 111, 99, 107, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 57,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 97, 109, 101, 67, 108, 111, 99, 107, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 71, 97,
				109, 101, 67, 108, 111, 99, 107, 68, 105, 115,
				112, 108, 97, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 50, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 97, 109, 101, 67,
				108, 111, 99, 107, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 83, 108, 101, 101, 112, 86, 105,
				101, 119, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 49, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 71, 97, 114, 100, 101, 110, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 67, 101,
				108, 108, 68, 105, 115, 112, 108, 97, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 42,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 97, 114, 100, 101, 110, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 114, 111, 112, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 50,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 97, 114, 100, 101, 110, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 67, 114, 111, 112, 65,
				110, 105, 109, 97, 116, 111, 114, 46, 99, 115,
				0, 0, 0, 4, 0, 0, 0, 50, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 97,
				114, 100, 101, 110, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 67, 114, 111, 112, 68, 97, 116,
				97, 98, 97, 115, 101, 46, 99, 115, 0, 0,
				0, 4, 0, 0, 0, 44, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 97, 114, 100,
				101, 110, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 71, 97, 114, 100, 101, 110, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 59, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 97,
				114, 100, 101, 110, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 67, 101, 108, 108,
				67, 111, 110, 116, 101, 120, 116, 68, 105, 115,
				112, 108, 97, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 51, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 97, 114, 100, 101,
				110, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 71, 97, 114, 100, 101, 110, 86,
				105, 101, 119, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 63, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 71, 97, 114, 100, 101, 110,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 71, 97, 114, 100, 101, 110, 86, 105,
				101, 119, 67, 114, 111, 112, 83, 101, 108, 101,
				99, 116, 111, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 61, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 97, 114, 100, 101,
				110, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 71, 97, 114, 100, 101, 110, 86,
				105, 101, 119, 84, 111, 111, 108, 66, 117, 116,
				116, 111, 110, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 50, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 73, 110, 112, 117, 116, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 110,
				112, 117, 116, 82, 101, 98, 105, 110, 100, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 59, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 73, 110, 112, 117, 116, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 73, 110, 112, 117,
				116, 82, 101, 98, 105, 110, 100, 101, 114, 73,
				110, 100, 105, 99, 97, 116, 111, 114, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 56, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 73,
				116, 101, 109, 87, 105, 115, 104, 108, 105, 115,
				116, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				73, 116, 101, 109, 87, 105, 115, 104, 108, 105,
				115, 116, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 58, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 76, 111, 111, 116, 66, 111, 120,
				76, 111, 97, 100, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 76, 111, 111, 116, 66,
				111, 120, 76, 111, 97, 100, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 82, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				97, 115, 116, 101, 114, 75, 101, 121, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 73, 110, 116,
				101, 114, 97, 99, 116, 97, 98, 108, 101, 92,
				77, 97, 115, 116, 101, 114, 75, 101, 121, 82,
				101, 103, 105, 115, 116, 101, 114, 86, 105, 101,
				119, 73, 110, 118, 111, 107, 101, 114, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 58, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				97, 115, 116, 101, 114, 75, 101, 121, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 77, 97, 115,
				116, 101, 114, 75, 101, 121, 115, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 64, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 97, 115, 116, 101,
				114, 75, 101, 121, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 77, 97, 115, 116,
				101, 114, 75, 101, 121, 115, 73, 110, 100, 101,
				120, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 68, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 97, 115,
				116, 101, 114, 75, 101, 121, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 77, 97,
				115, 116, 101, 114, 75, 101, 121, 115, 73, 110,
				100, 101, 120, 73, 110, 115, 112, 101, 99, 116,
				111, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 63, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 97, 115, 116, 101, 114, 75,
				101, 121, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 77, 97, 115, 116, 101, 114,
				75, 101, 121, 115, 73, 110, 100, 101, 120, 76,
				105, 115, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 66, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 97, 115, 116, 101, 114,
				75, 101, 121, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 77, 97, 115, 116, 101,
				114, 75, 101, 121, 115, 82, 101, 103, 105, 115,
				116, 101, 114, 86, 105, 101, 119, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 58, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 97,
				115, 116, 101, 114, 75, 101, 121, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 77,
				97, 115, 116, 101, 114, 75, 101, 121, 115, 86,
				105, 101, 119, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 40, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 101, 110, 117, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 77, 101, 110,
				117, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 44, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 101, 110, 117, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 77, 101, 110, 117, 73,
				116, 101, 109, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 77, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 66, 117, 98, 98, 108, 101, 80, 111, 112,
				112, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 66, 117, 98, 98, 108, 101, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 83, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 66, 117, 98, 98,
				108, 101, 80, 111, 112, 112, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 66, 117, 98,
				98, 108, 101, 80, 111, 112, 112, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 89,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 66, 117, 98,
				98, 108, 101, 80, 111, 112, 112, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 66, 117,
				98, 98, 108, 101, 80, 111, 112, 112, 101, 114,
				76, 97, 121, 111, 117, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 100, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 66, 117, 98, 98, 108, 101,
				80, 111, 112, 112, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 66, 117, 98, 98, 108,
				101, 80, 111, 112, 112, 101, 114, 76, 101, 118,
				101, 108, 68, 97, 116, 97, 80, 114, 111, 118,
				105, 100, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 71, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 70, 80, 83, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 67, 114, 111, 115, 115, 72,
				97, 105, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 85, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 70, 80, 83, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 101, 98, 117, 103, 92, 72,
				105, 100, 101, 65, 110, 100, 76, 111, 99, 107,
				67, 117, 114, 115, 111, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 89, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 70, 80, 83, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 69, 110, 101, 109,
				105, 101, 115, 92, 70, 80, 83, 95, 69, 110,
				101, 109, 121, 95, 72, 111, 109, 105, 110, 103,
				70, 108, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 74, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 70, 80, 83, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 70, 80, 83, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 79, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 70, 80, 83, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 70, 80, 83, 68, 97,
				109, 97, 103, 101, 82, 101, 99, 101, 105, 118,
				101, 114, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 68, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				70, 80, 83, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 70, 80, 83, 71, 117, 110, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 75, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 70, 80, 83, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 70, 80,
				83, 71, 117, 110, 67, 111, 110, 116, 114, 111,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 71, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 70,
				80, 83, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 70, 80, 83, 72, 101, 97, 108, 116, 104,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				73, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 70, 80,
				83, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				70, 80, 83, 77, 111, 118, 101, 109, 101, 110,
				116, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 85, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 114, 116,
				105, 102, 97, 99, 116, 115, 92, 71, 77, 65,
				95, 48, 48, 49, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 85, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 114, 116, 105, 102, 97, 99, 116, 115, 92,
				71, 77, 65, 95, 48, 48, 50, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 85, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 114, 116, 105, 102, 97, 99,
				116, 115, 92, 71, 77, 65, 95, 48, 48, 51,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				85, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 114, 116, 105,
				102, 97, 99, 116, 115, 92, 71, 77, 65, 95,
				48, 48, 52, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 85, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 65,
				114, 116, 105, 102, 97, 99, 116, 115, 92, 71,
				77, 65, 95, 48, 48, 53, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 85, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 65, 114, 116, 105, 102, 97, 99, 116,
				115, 92, 71, 77, 65, 95, 48, 48, 54, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 85,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 114, 116, 105, 102,
				97, 99, 116, 115, 92, 71, 77, 65, 95, 48,
				48, 55, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 85, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 114,
				116, 105, 102, 97, 99, 116, 115, 92, 71, 77,
				65, 95, 48, 48, 56, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 85, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 114, 116, 105, 102, 97, 99, 116, 115,
				92, 71, 77, 65, 95, 48, 48, 57, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 85, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 65, 114, 116, 105, 102, 97,
				99, 116, 115, 92, 71, 77, 65, 95, 48, 49,
				48, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 85, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 114, 116,
				105, 102, 97, 99, 116, 115, 92, 71, 77, 65,
				95, 48, 49, 49, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 85, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 114, 116, 105, 102, 97, 99, 116, 115, 92,
				71, 77, 65, 95, 48, 49, 50, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 85, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 114, 116, 105, 102, 97, 99,
				116, 115, 92, 71, 77, 65, 95, 48, 49, 51,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				85, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 114, 116, 105,
				102, 97, 99, 116, 115, 92, 71, 77, 65, 95,
				48, 49, 52, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 85, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 65,
				114, 116, 105, 102, 97, 99, 116, 115, 92, 71,
				77, 65, 95, 48, 49, 53, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 85, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 65, 114, 116, 105, 102, 97, 99, 116,
				115, 92, 71, 77, 65, 95, 48, 49, 54, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 85,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 114, 116, 105, 102,
				97, 99, 116, 115, 92, 71, 77, 65, 95, 48,
				49, 55, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 85, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 114,
				116, 105, 102, 97, 99, 116, 115, 92, 71, 77,
				65, 95, 48, 49, 56, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 85, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 114, 116, 105, 102, 97, 99, 116, 115,
				92, 71, 77, 65, 95, 48, 49, 57, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 85, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 65, 114, 116, 105, 102, 97,
				99, 116, 115, 92, 71, 77, 65, 95, 48, 50,
				48, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 85, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 114, 116,
				105, 102, 97, 99, 116, 115, 92, 71, 77, 65,
				95, 48, 50, 49, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 85, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 114, 116, 105, 102, 97, 99, 116, 115, 92,
				71, 77, 65, 95, 48, 50, 50, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 85, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 114, 116, 105, 102, 97, 99,
				116, 115, 92, 71, 77, 65, 95, 48, 50, 51,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				85, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 114, 116, 105,
				102, 97, 99, 116, 115, 92, 71, 77, 65, 95,
				48, 50, 52, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 85, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 65,
				114, 116, 105, 102, 97, 99, 116, 115, 92, 71,
				77, 65, 95, 48, 50, 53, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 85, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 65, 114, 116, 105, 102, 97, 99, 116,
				115, 92, 71, 77, 65, 95, 48, 50, 54, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 85,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 65, 114, 116, 105, 102,
				97, 99, 116, 115, 92, 71, 77, 65, 95, 48,
				50, 55, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 85, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 65, 114,
				116, 105, 102, 97, 99, 116, 115, 92, 71, 77,
				65, 95, 48, 50, 56, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 85, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 65, 114, 116, 105, 102, 97, 99, 116, 115,
				92, 71, 77, 65, 95, 48, 50, 57, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 85, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 65, 114, 116, 105, 102, 97,
				99, 116, 115, 92, 71, 77, 65, 95, 48, 51,
				48, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 85, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 65, 114, 116,
				105, 102, 97, 99, 116, 115, 92, 71, 77, 65,
				95, 48, 51, 49, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 85, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				65, 114, 116, 105, 102, 97, 99, 116, 115, 92,
				71, 77, 65, 95, 48, 51, 50, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 95, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 65, 114, 116, 105, 102, 97, 99,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 65, 114, 116, 105, 102, 97, 99, 116,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				104, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 65, 114, 116, 105,
				102, 97, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 65, 114, 116, 105, 102,
				97, 99, 116, 66, 101, 104, 97, 118, 105, 111,
				117, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 72, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 66, 111,
				109, 98, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 77, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 83, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 69, 110, 116, 105, 116, 121, 46, 99,
				115, 0, 0, 0, 2, 0, 0, 0, 81, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 83, 104, 111, 112, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 72, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 72, 111, 111, 107, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 76, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 72, 111, 111, 107, 72, 101, 97,
				100, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 96, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 83, 104, 111,
				112, 73, 116, 101, 109, 115, 92, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 95, 83, 104, 111,
				112, 73, 116, 101, 109, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 102, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 97, 114, 103, 101, 116, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 115, 92, 65, 100,
				100, 66, 111, 109, 98, 79, 110, 82, 101, 116,
				114, 105, 101, 118, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 112, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 97, 114, 103, 101, 116, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 115, 92, 65, 100,
				100, 69, 97, 103, 108, 101, 69, 121, 101, 80,
				111, 116, 105, 111, 110, 79, 110, 82, 101, 116,
				114, 105, 101, 118, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 112, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 97, 114, 103, 101, 116, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 115, 92, 65, 100,
				100, 83, 116, 114, 101, 110, 103, 116, 104, 80,
				111, 116, 105, 111, 110, 79, 110, 82, 101, 116,
				114, 105, 101, 118, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 100, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 84, 97, 114, 103, 101, 116, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 115, 92, 69, 120,
				112, 108, 111, 100, 101, 79, 110, 65, 116, 116,
				97, 99, 104, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 97, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 84,
				97, 114, 103, 101, 116, 66, 101, 104, 97, 118,
				105, 111, 117, 114, 115, 92, 80, 105, 103, 66,
				101, 104, 97, 118, 105, 111, 117, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 82, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 66, 111, 109,
				98, 68, 105, 115, 112, 108, 97, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 92, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 69, 97, 103,
				108, 101, 69, 121, 101, 80, 111, 116, 105, 111,
				110, 68, 105, 115, 112, 108, 97, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 92, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 77, 111, 110, 101,
				121, 68, 105, 115, 112, 108, 97, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 86, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 83, 104, 111, 112,
				85, 73, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 97, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				83, 104, 111, 112, 85, 73, 67, 111, 110, 116,
				105, 110, 117, 101, 66, 116, 110, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 91, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 83, 104, 111, 112, 85,
				73, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 96, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 83, 104, 111, 112, 85, 73,
				82, 101, 102, 114, 101, 115, 104, 66, 116, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				88, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 95, 80,
				111, 112, 84, 101, 120, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 93, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 95, 80, 111, 112, 84, 101,
				120, 116, 69, 110, 116, 114, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 88, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 76, 101, 118, 101,
				108, 83, 101, 116, 116, 108, 101, 109, 101, 110,
				116, 85, 73, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 79, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 78, 97, 118, 69, 110, 116, 114, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				79, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 78,
				97, 118, 71, 114, 111, 117, 112, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 95, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 78, 97, 118, 71,
				114, 111, 117, 112, 76, 105, 110, 101, 97, 114,
				67, 111, 110, 116, 114, 111, 108, 108, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				89, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 80,
				97, 115, 115, 105, 118, 101, 80, 114, 111, 112,
				68, 105, 115, 112, 108, 97, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 85, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 80, 97, 115, 115,
				105, 118, 101, 80, 114, 111, 112, 115, 85, 73,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				83, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 83,
				99, 111, 114, 101, 68, 105, 115, 112, 108, 97,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 85, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 85, 73, 92,
				83, 116, 97, 109, 105, 110, 97, 68, 105, 115,
				112, 108, 97, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 92, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 83, 116, 114, 101, 110, 103, 116,
				104, 80, 111, 116, 105, 111, 110, 68, 105, 115,
				112, 108, 97, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 84, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 86, 105, 114, 116, 117, 97, 108,
				67, 117, 114, 115, 111, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 90, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 85, 73, 92, 86, 105, 114, 116, 117,
				97, 108, 67, 117, 114, 115, 111, 114, 84, 97,
				114, 103, 101, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 78, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 72, 101, 108, 108, 111, 87, 111, 114,
				108, 100, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 70, 97, 107, 101, 77, 111, 117, 115, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				73, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 72, 101,
				108, 108, 111, 87, 111, 114, 108, 100, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 77, 111, 118,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 76, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 83,
				110, 97, 107, 101, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 83, 110, 97, 107, 101, 68, 105,
				115, 112, 108, 97, 121, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 74, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 83, 110, 97, 107, 101, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 83, 110, 97,
				107, 101, 70, 111, 114, 99, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 80, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 83, 110, 97, 107, 101,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				110, 97, 107, 101, 80, 97, 114, 116, 68, 105,
				115, 112, 108, 97, 121, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 59, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 67, 111, 110, 116, 114, 111,
				108, 108, 101, 114, 65, 110, 105, 109, 97, 116,
				111, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 66, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 67, 111, 110, 116, 114, 111, 108, 108, 101,
				114, 80, 105, 99, 107, 117, 112, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 54, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 71, 97, 109, 105, 110,
				103, 67, 111, 110, 115, 111, 108, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 62, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 71, 97, 109,
				105, 110, 103, 67, 111, 110, 115, 111, 108, 101,
				65, 110, 105, 109, 97, 116, 111, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 62, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 71, 97, 109,
				105, 110, 103, 67, 111, 110, 115, 111, 108, 101,
				71, 114, 97, 112, 104, 105, 99, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 57, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 71, 97, 109,
				105, 110, 103, 67, 111, 110, 115, 111, 108, 101,
				72, 85, 68, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 58, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 71, 97, 109, 105, 110, 103, 67, 111,
				110, 115, 111, 108, 101, 86, 105, 101, 119, 46,
				99, 115, 0, 0, 0, 3, 0, 0, 0, 49,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 77, 105,
				110, 105, 71, 97, 109, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 58, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 66, 101, 104, 97, 118, 105, 111,
				117, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 61, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 77, 105, 110, 105, 71, 97, 109, 101, 73,
				110, 112, 117, 116, 72, 97, 110, 100, 108, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 80, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				81, 117, 101, 115, 116, 84, 97, 115, 107, 115,
				92, 81, 117, 101, 115, 116, 84, 97, 115, 107,
				95, 66, 117, 98, 98, 108, 101, 80, 111, 112,
				112, 101, 114, 95, 76, 101, 118, 101, 108, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 77,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 81, 117,
				101, 115, 116, 84, 97, 115, 107, 115, 92, 81,
				117, 101, 115, 116, 84, 97, 115, 107, 95, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 95, 76,
				101, 118, 101, 108, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 73, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 81, 117, 101, 115, 116, 84, 97,
				115, 107, 115, 92, 81, 117, 101, 115, 116, 84,
				97, 115, 107, 95, 83, 110, 97, 107, 101, 95,
				83, 99, 111, 114, 101, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 60, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 77, 105, 110, 105,
				77, 97, 112, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 77, 105, 110, 105, 77, 97,
				112, 68, 97, 116, 97, 80, 114, 111, 118, 105,
				100, 101, 114, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 56, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 77, 97,
				112, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 77, 97, 112, 77, 97, 114, 107, 101, 114,
				77, 97, 110, 97, 103, 101, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 52, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 77, 97, 112, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 77, 97, 112, 77, 97,
				114, 107, 101, 114, 80, 79, 73, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 53, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 77, 97, 112, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 77, 105, 110, 105, 77,
				97, 112, 67, 101, 110, 116, 101, 114, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 55, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 77, 97, 112, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 77, 105, 110, 105,
				77, 97, 112, 83, 101, 116, 116, 105, 110, 103,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 54, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 77, 97, 112, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 77,
				105, 110, 105, 77, 97, 112, 83, 104, 111, 111,
				116, 101, 114, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 57, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 77, 97,
				112, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 80, 111, 105, 110, 116, 115, 79, 102, 73,
				110, 116, 101, 114, 101, 115, 116, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 61, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 77, 97, 112, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 105, 109, 112,
				108, 101, 80, 111, 105, 110, 116, 79, 102, 73,
				110, 116, 101, 114, 101, 115, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 63, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 77, 97, 112, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 77, 97,
				112, 77, 97, 114, 107, 101, 114, 80, 97, 110,
				101, 108, 66, 117, 116, 116, 111, 110, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 65, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				105, 110, 105, 77, 97, 112, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 77,
				97, 112, 77, 97, 114, 107, 101, 114, 83, 101,
				116, 116, 105, 110, 103, 115, 80, 97, 110, 101,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 57, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 77, 97, 112, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 77, 105, 110, 105, 77, 97, 112, 67,
				111, 109, 112, 97, 115, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 57, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 77, 105, 110,
				105, 77, 97, 112, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 77, 105, 110,
				105, 77, 97, 112, 68, 105, 115, 112, 108, 97,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 62, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 77, 97, 112, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 77, 105, 110, 105, 77, 97, 112, 68,
				105, 115, 112, 108, 97, 121, 69, 110, 116, 114,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 54, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 105, 110, 105, 77, 97, 112, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 77, 105, 110, 105, 77, 97, 112, 86,
				105, 101, 119, 46, 99, 115, 0, 0, 0, 2,
				0, 0, 0, 56, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 77, 105, 110, 105, 77, 97,
				112, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 80, 97, 99, 107, 101, 100,
				77, 97, 112, 68, 97, 116, 97, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 63, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 105,
				110, 105, 77, 97, 112, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 80, 111,
				105, 110, 116, 79, 102, 73, 110, 116, 101, 114,
				101, 115, 116, 69, 110, 116, 114, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 51, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 77,
				111, 100, 100, 105, 110, 103, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 77, 111, 100, 66, 101,
				104, 97, 118, 105, 111, 117, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 49, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 77, 111,
				100, 100, 105, 110, 103, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 77, 111, 100, 77, 97, 110,
				97, 103, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 59, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 77, 111, 100, 100, 105,
				110, 103, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 83, 116, 101, 97, 109, 87, 111, 114, 107,
				115, 104, 111, 112, 77, 97, 110, 97, 103, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 50, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 111, 100, 100, 105, 110, 103, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 77, 111, 100, 69, 110, 116, 114, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 54,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				77, 111, 100, 100, 105, 110, 103, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 77,
				111, 100, 77, 97, 110, 97, 103, 101, 114, 85,
				73, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 56, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 77, 111, 100, 100, 105, 110, 103, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 85, 73,
				92, 77, 111, 100, 85, 112, 108, 111, 97, 100,
				80, 97, 110, 101, 108, 46, 99, 115, 0, 0,
				0, 3, 0, 0, 0, 50, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 78, 111, 116, 101,
				73, 110, 100, 101, 120, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 78, 111, 116, 101, 73, 110,
				100, 101, 120, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 55, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 78, 111, 116, 101, 73, 110,
				100, 101, 120, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 78, 111, 116, 101, 73, 110, 100, 101,
				120, 80, 114, 111, 120, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 54, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 78, 111, 116,
				101, 73, 110, 100, 101, 120, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 78, 111, 116, 101, 73,
				110, 100, 101, 120, 86, 105, 101, 119, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 60, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 78,
				111, 116, 101, 73, 110, 100, 101, 120, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 78, 111, 116,
				101, 73, 110, 100, 101, 120, 86, 105, 101, 119,
				95, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 64, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 78, 111, 116,
				101, 73, 110, 100, 101, 120, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 78, 111, 116, 101, 73,
				110, 100, 101, 120, 86, 105, 101, 119, 95, 73,
				110, 115, 112, 101, 99, 116, 111, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 78,
				111, 116, 101, 73, 110, 100, 101, 120, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 78, 111, 116,
				101, 73, 110, 116, 101, 114, 97, 99, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 65,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				78, 111, 116, 101, 73, 110, 100, 101, 120, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 82, 101,
				113, 117, 105, 114, 101, 78, 111, 116, 101, 73,
				110, 100, 101, 120, 85, 110, 108, 111, 99, 107,
				101, 100, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 60, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 79, 112, 101, 110, 83, 97, 118,
				101, 70, 111, 108, 100, 101, 114, 83, 104, 111,
				114, 116, 67, 117, 116, 92, 79, 112, 101, 110,
				83, 97, 118, 101, 70, 111, 108, 100, 101, 114,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				78, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 79, 112, 116, 105, 111, 110, 115, 77, 97,
				110, 97, 103, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 73, 110, 112, 117, 116, 92,
				83, 99, 114, 111, 108, 108, 87, 104, 101, 101,
				108, 79, 112, 116, 105, 111, 110, 115, 80, 114,
				111, 118, 105, 100, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 86, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 79, 112, 116,
				105, 111, 110, 115, 77, 97, 110, 97, 103, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				76, 97, 110, 103, 117, 97, 103, 101, 83, 101,
				108, 101, 99, 116, 111, 114, 92, 76, 97, 110,
				103, 117, 97, 103, 101, 79, 112, 116, 105, 111,
				110, 115, 80, 114, 111, 118, 105, 100, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				60, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 79, 112, 116, 105, 111, 110, 115, 77, 97,
				110, 97, 103, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 79, 112, 116, 105, 111, 110,
				115, 77, 97, 110, 97, 103, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 65, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 79,
				112, 116, 105, 111, 110, 115, 77, 97, 110, 97,
				103, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 79, 112, 116, 105, 111, 110, 115, 80,
				114, 111, 118, 105, 100, 101, 114, 66, 97, 115,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 80, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 79, 112, 116, 105, 111, 110, 115, 77,
				97, 110, 97, 103, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 82, 101, 115, 111, 108,
				117, 116, 105, 111, 110, 83, 101, 116, 116, 101,
				114, 92, 70, 117, 108, 108, 83, 99, 114, 101,
				101, 110, 79, 112, 116, 105, 111, 110, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 80,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				79, 112, 116, 105, 111, 110, 115, 77, 97, 110,
				97, 103, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 82, 101, 115, 111, 108, 117, 116,
				105, 111, 110, 83, 101, 116, 116, 101, 114, 92,
				82, 101, 115, 111, 108, 117, 116, 105, 111, 110,
				79, 112, 116, 105, 111, 110, 115, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 79, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 79, 112,
				116, 105, 111, 110, 115, 77, 97, 110, 97, 103,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 82, 101, 115, 111, 108, 117, 116, 105, 111,
				110, 83, 101, 116, 116, 101, 114, 92, 82, 101,
				115, 111, 108, 117, 116, 105, 111, 110, 83, 101,
				116, 116, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 74, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 79, 112, 116, 105, 111,
				110, 115, 77, 97, 110, 97, 103, 101, 114, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 101,
				116, 116, 105, 110, 103, 115, 92, 68, 105, 115,
				97, 98, 108, 101, 67, 97, 109, 101, 114, 97,
				79, 102, 102, 115, 101, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 69, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 79, 112, 116,
				105, 111, 110, 115, 77, 97, 110, 97, 103, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				83, 101, 116, 116, 105, 110, 103, 115, 92, 69,
				100, 103, 101, 76, 105, 103, 104, 116, 69, 110,
				116, 114, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 72, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 79, 112, 116, 105, 111, 110,
				115, 77, 97, 110, 97, 103, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 83, 101, 116,
				116, 105, 110, 103, 115, 92, 69, 100, 103, 101,
				76, 105, 103, 104, 116, 83, 101, 116, 116, 105,
				110, 103, 115, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 71, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 79, 112, 116, 105, 111, 110,
				115, 77, 97, 110, 97, 103, 101, 114, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 83, 101, 116,
				116, 105, 110, 103, 115, 92, 70, 114, 97, 109,
				101, 82, 97, 116, 101, 83, 101, 116, 116, 105,
				110, 103, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 65, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 79, 112, 116, 105, 111, 110, 115,
				77, 97, 110, 97, 103, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 101, 116, 116,
				105, 110, 103, 115, 92, 70, 115, 114, 83, 101,
				116, 116, 105, 110, 103, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 67, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 79, 112, 116, 105,
				111, 110, 115, 77, 97, 110, 97, 103, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				101, 116, 116, 105, 110, 103, 115, 92, 71, 114,
				97, 115, 115, 79, 112, 116, 105, 111, 110, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				67, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 79, 112, 116, 105, 111, 110, 115, 77, 97,
				110, 97, 103, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 83, 101, 116, 116, 105, 110,
				103, 115, 92, 72, 66, 65, 79, 83, 101, 116,
				116, 105, 110, 103, 115, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 75, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 79, 112, 116, 105,
				111, 110, 115, 77, 97, 110, 97, 103, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				101, 116, 116, 105, 110, 103, 115, 92, 77, 111,
				118, 101, 68, 105, 114, 101, 99, 116, 105, 111,
				110, 79, 112, 116, 105, 111, 110, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 74, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 79,
				112, 116, 105, 111, 110, 115, 77, 97, 110, 97,
				103, 101, 114, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 83, 101, 116, 116, 105, 110, 103, 115,
				92, 82, 117, 110, 73, 110, 112, 117, 116, 77,
				111, 100, 101, 79, 112, 116, 105, 111, 110, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				68, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 79, 112, 116, 105, 111, 110, 115, 77, 97,
				110, 97, 103, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 83, 101, 116, 116, 105, 110,
				103, 115, 92, 83, 104, 97, 100, 111, 119, 83,
				101, 116, 116, 105, 110, 103, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 72, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 79, 112, 116,
				105, 111, 110, 115, 77, 97, 110, 97, 103, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				83, 101, 116, 116, 105, 110, 103, 115, 92, 83,
				111, 102, 116, 83, 104, 97, 100, 111, 119, 79,
				112, 116, 105, 111, 110, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 66, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 79, 112, 116,
				105, 111, 110, 115, 77, 97, 110, 97, 103, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				83, 101, 116, 116, 105, 110, 103, 115, 92, 83,
				117, 110, 70, 111, 103, 69, 110, 116, 114, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				69, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 79, 112, 116, 105, 111, 110, 115, 77, 97,
				110, 97, 103, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 83, 101, 116, 116, 105, 110,
				103, 115, 92, 83, 117, 110, 70, 111, 103, 83,
				101, 116, 116, 105, 110, 103, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 70, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 79, 112,
				116, 105, 111, 110, 115, 77, 97, 110, 97, 103,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 83, 101, 116, 116, 105, 110, 103, 115, 92,
				85, 73, 83, 104, 97, 100, 111, 119, 79, 112,
				116, 105, 111, 110, 115, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 67, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 79, 112, 116, 105,
				111, 110, 115, 77, 97, 110, 97, 103, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				101, 116, 116, 105, 110, 103, 115, 92, 118, 83,
				121, 110, 99, 83, 101, 116, 116, 105, 110, 103,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				79, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 79, 112, 116, 105, 111, 110, 115, 77, 97,
				110, 97, 103, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 67, 111, 109,
				112, 111, 110, 101, 110, 116, 115, 92, 83, 108,
				105, 100, 101, 114, 87, 105, 116, 104, 84, 101,
				120, 116, 70, 105, 101, 108, 100, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 81, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 79, 112,
				116, 105, 111, 110, 115, 77, 97, 110, 97, 103,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 75, 101, 121, 98, 105, 110,
				100, 105, 110, 103, 92, 85, 73, 66, 117, 116,
				116, 111, 110, 82, 101, 118, 101, 114, 116, 66,
				105, 110, 100, 105, 110, 103, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 77, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 79, 112, 116,
				105, 111, 110, 115, 77, 97, 110, 97, 103, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 92, 75, 101, 121, 98, 105, 110, 100,
				105, 110, 103, 92, 85, 73, 75, 101, 121, 98,
				105, 110, 100, 105, 110, 103, 69, 110, 116, 114,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 61, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 79, 112, 116, 105, 111, 110, 115, 77,
				97, 110, 97, 103, 101, 114, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 85, 73, 92, 79, 112,
				116, 105, 111, 110, 115, 80, 97, 110, 101, 108,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				71, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 79, 112, 116, 105, 111, 110, 115, 77, 97,
				110, 97, 103, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 79, 112, 116,
				105, 111, 110, 115, 80, 97, 110, 101, 108, 95,
				84, 97, 98, 66, 117, 116, 116, 111, 110, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 72,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				79, 112, 116, 105, 111, 110, 115, 77, 97, 110,
				97, 103, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 79, 112, 116, 105,
				111, 110, 115, 85, 73, 69, 110, 116, 114, 121,
				95, 68, 114, 111, 112, 100, 111, 119, 110, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 70,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				79, 112, 116, 105, 111, 110, 115, 77, 97, 110,
				97, 103, 101, 114, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 85, 73, 92, 79, 112, 116, 105,
				111, 110, 115, 85, 73, 69, 110, 116, 114, 121,
				95, 83, 108, 105, 100, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 70, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 79, 112,
				116, 105, 111, 110, 115, 77, 97, 110, 97, 103,
				101, 114, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 85, 73, 92, 79, 112, 116, 105, 111, 110,
				115, 85, 73, 69, 110, 116, 114, 121, 95, 84,
				111, 103, 103, 108, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 69, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 79, 112, 116, 105,
				111, 110, 115, 77, 97, 110, 97, 103, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 85,
				73, 92, 82, 117, 108, 101, 115, 92, 82, 117,
				108, 101, 69, 110, 116, 114, 121, 95, 66, 111,
				111, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 70, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 79, 112, 116, 105, 111, 110, 115,
				77, 97, 110, 97, 103, 101, 114, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 85, 73, 92, 82,
				117, 108, 101, 115, 92, 82, 117, 108, 101, 69,
				110, 116, 114, 121, 95, 70, 108, 111, 97, 116,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				68, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 79, 112, 116, 105, 111, 110, 115, 77, 97,
				110, 97, 103, 101, 114, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 85, 73, 92, 82, 117, 108,
				101, 115, 92, 82, 117, 108, 101, 69, 110, 116,
				114, 121, 95, 73, 110, 116, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 75, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 79, 112, 116,
				105, 111, 110, 115, 77, 97, 110, 97, 103, 101,
				114, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				85, 73, 83, 104, 97, 100, 111, 119, 83, 101,
				116, 116, 101, 114, 92, 85, 73, 83, 104, 97,
				100, 111, 119, 83, 101, 116, 116, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 71,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				80, 101, 114, 107, 84, 114, 101, 101, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 110,
				116, 101, 114, 97, 99, 116, 97, 98, 108, 101,
				92, 80, 101, 114, 107, 84, 114, 101, 101, 85,
				73, 73, 110, 118, 111, 107, 101, 114, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 45, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 80,
				101, 114, 107, 84, 114, 101, 101, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 80, 101, 114,
				107, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 54, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 80, 101, 114, 107, 84, 114, 101, 101,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				80, 101, 114, 107, 66, 101, 104, 97, 118, 105,
				111, 117, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 83, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 80, 101, 114, 107, 84, 114,
				101, 101, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 80, 101, 114, 107, 66, 101, 104, 97,
				118, 105, 111, 117, 114, 115, 92, 65, 100, 100,
				66, 108, 97, 99, 107, 77, 97, 114, 107, 101,
				116, 82, 101, 102, 114, 101, 115, 104, 67, 104,
				97, 110, 99, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 69, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 80, 101, 114, 107, 84,
				114, 101, 101, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 80, 101, 114, 107, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 115, 92, 65, 100,
				100, 71, 97, 114, 100, 101, 110, 83, 105, 122,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 72, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 80, 101, 114, 107, 84, 114, 101, 101,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				80, 101, 114, 107, 66, 101, 104, 97, 118, 105,
				111, 117, 114, 115, 92, 65, 100, 100, 80, 108,
				97, 121, 101, 114, 83, 116, 111, 114, 97, 103,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 90, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 80, 101, 114, 107, 84, 114, 101, 101,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				80, 101, 114, 107, 66, 101, 104, 97, 118, 105,
				111, 117, 114, 115, 92, 67, 104, 97, 110, 103,
				101, 66, 108, 97, 99, 107, 77, 97, 114, 107,
				101, 116, 82, 101, 102, 114, 101, 115, 104, 84,
				105, 109, 101, 70, 97, 99, 116, 111, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 71,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				80, 101, 114, 107, 84, 114, 101, 101, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 80, 101,
				114, 107, 66, 101, 104, 97, 118, 105, 111, 117,
				114, 115, 92, 71, 97, 114, 100, 101, 110, 65,
				117, 116, 111, 87, 97, 116, 101, 114, 46, 99,
				115, 0, 0, 0, 3, 0, 0, 0, 80, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 80,
				101, 114, 107, 84, 114, 101, 101, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 80, 101, 114,
				107, 66, 101, 104, 97, 118, 105, 111, 117, 114,
				115, 92, 77, 111, 100, 105, 102, 121, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 83, 116, 97,
				116, 115, 66, 97, 115, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 73, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 80, 101, 114,
				107, 84, 114, 101, 101, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 80, 101, 114, 107, 66,
				101, 104, 97, 118, 105, 111, 117, 114, 115, 92,
				85, 110, 108, 111, 99, 107, 65, 99, 104, 105,
				101, 118, 101, 109, 101, 110, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 69, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 80, 101,
				114, 107, 84, 114, 101, 101, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 80, 101, 114, 107,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 115,
				92, 85, 110, 108, 111, 99, 107, 70, 111, 114,
				109, 117, 108, 97, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 75, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 80, 101, 114, 107, 84,
				114, 101, 101, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 80, 101, 114, 107, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 115, 92, 85, 110,
				108, 111, 99, 107, 83, 116, 111, 99, 107, 83,
				104, 111, 112, 73, 116, 101, 109, 46, 99, 115,
				0, 0, 0, 3, 0, 0, 0, 49, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 80, 101,
				114, 107, 84, 114, 101, 101, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 80, 101, 114, 107,
				84, 114, 101, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 56, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 80, 101, 114, 107, 84,
				114, 101, 101, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 80, 101, 114, 107, 84, 114, 101,
				101, 77, 97, 110, 97, 103, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 80, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 80,
				101, 114, 107, 84, 114, 101, 101, 115, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 80, 101, 114,
				107, 84, 114, 101, 101, 82, 101, 108, 97, 116,
				105, 111, 110, 71, 114, 97, 112, 104, 92, 80,
				101, 114, 107, 76, 101, 118, 101, 108, 76, 105,
				110, 101, 78, 111, 100, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 85, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 80, 101, 114,
				107, 84, 114, 101, 101, 115, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 80, 101, 114, 107, 84,
				114, 101, 101, 82, 101, 108, 97, 116, 105, 111,
				110, 71, 114, 97, 112, 104, 92, 80, 101, 114,
				107, 82, 101, 108, 97, 116, 105, 111, 110, 67,
				111, 110, 110, 101, 99, 116, 105, 111, 110, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 80,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				80, 101, 114, 107, 84, 114, 101, 101, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 80, 101,
				114, 107, 84, 114, 101, 101, 82, 101, 108, 97,
				116, 105, 111, 110, 71, 114, 97, 112, 104, 92,
				80, 101, 114, 107, 82, 101, 108, 97, 116, 105,
				111, 110, 71, 114, 97, 112, 104, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 79, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 80, 101,
				114, 107, 84, 114, 101, 101, 115, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 80, 101, 114, 107,
				84, 114, 101, 101, 82, 101, 108, 97, 116, 105,
				111, 110, 71, 114, 97, 112, 104, 92, 80, 101,
				114, 107, 82, 101, 108, 97, 116, 105, 111, 110,
				78, 111, 100, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 83, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 80, 101, 114, 107, 84,
				114, 101, 101, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 80, 101, 114, 107, 84, 114, 101,
				101, 82, 101, 108, 97, 116, 105, 111, 110, 71,
				114, 97, 112, 104, 92, 80, 101, 114, 107, 82,
				101, 108, 97, 116, 105, 111, 110, 78, 111, 100,
				101, 66, 97, 115, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 89, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 80, 101, 114, 107,
				84, 114, 101, 101, 115, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 80, 101, 114, 107, 84, 114,
				101, 101, 82, 101, 108, 97, 116, 105, 111, 110,
				71, 114, 97, 112, 104, 92, 80, 101, 114, 107,
				84, 114, 101, 101, 82, 101, 108, 97, 116, 105,
				111, 110, 71, 114, 97, 112, 104, 79, 119, 110,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 58, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 80, 101, 114, 107, 84, 114, 101,
				101, 115, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 80, 114, 101, 85, 110, 108, 111, 99, 107,
				80, 101, 114, 107, 84, 114, 101, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 38, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 80,
				111, 112, 84, 101, 120, 116, 92, 80, 111, 112,
				84, 101, 120, 116, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 44, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 80, 111, 112, 84, 101,
				120, 116, 92, 80, 111, 112, 84, 101, 120, 116,
				69, 110, 116, 105, 116, 121, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 78, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 80, 114, 101,
				112, 97, 114, 101, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 68, 105, 102, 102, 105, 99, 117,
				108, 116, 121, 83, 101, 108, 101, 99, 116, 105,
				111, 110, 92, 68, 105, 102, 102, 105, 99, 117,
				108, 116, 121, 83, 101, 108, 101, 99, 116, 105,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 84, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 80, 114, 101, 112, 97, 114, 101,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 68,
				105, 102, 102, 105, 99, 117, 108, 116, 121, 83,
				101, 108, 101, 99, 116, 105, 111, 110, 92, 68,
				105, 102, 102, 105, 99, 117, 108, 116, 121, 83,
				101, 108, 101, 99, 116, 105, 111, 110, 95, 69,
				110, 116, 114, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 81, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 80, 114, 101, 112, 97,
				114, 101, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 69, 110, 100, 111, 119, 109, 101, 110, 116,
				83, 101, 108, 101, 99, 116, 105, 111, 110, 92,
				69, 110, 100, 111, 119, 109, 101, 110, 116, 83,
				101, 108, 101, 99, 116, 105, 111, 110, 69, 110,
				116, 114, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 81, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 80, 114, 101, 112, 97, 114,
				101, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				69, 110, 100, 111, 119, 109, 101, 110, 116, 83,
				101, 108, 101, 99, 116, 105, 111, 110, 92, 69,
				110, 100, 111, 119, 109, 101, 110, 116, 83, 101,
				108, 101, 99, 116, 105, 111, 110, 80, 97, 110,
				101, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 57, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 80, 114, 101, 112, 97, 114, 101,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 71,
				97, 109, 101, 80, 114, 101, 112, 97, 114, 101,
				80, 114, 111, 99, 101, 115, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 50, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 83, 111,
				100, 97, 74, 111, 121, 115, 116, 105, 99, 107,
				92, 83, 111, 100, 97, 95, 74, 111, 121, 115,
				116, 105, 99, 107, 115, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 62, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 83, 111, 117, 110,
				100, 86, 105, 115, 117, 97, 108, 105, 122, 97,
				116, 105, 111, 110, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 83, 111, 117, 110, 100, 68, 105,
				115, 112, 108, 97, 121, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 68, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 83, 111, 117, 110,
				100, 86, 105, 115, 117, 97, 108, 105, 122, 97,
				116, 105, 111, 110, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 83, 111, 117, 110, 100, 86, 105,
				115, 117, 97, 108, 105, 122, 97, 116, 105, 111,
				110, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 56, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 83, 112, 108, 105, 110, 101, 115, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 112,
				108, 105, 110, 101, 70, 108, 97, 116, 69, 120,
				116, 114, 117, 100, 101, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 59, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 83, 112, 108, 105,
				110, 101, 115, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 83, 112, 108, 105, 110, 101, 80, 114,
				111, 102, 105, 108, 101, 69, 120, 116, 114, 117,
				100, 101, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 60, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 83, 112, 108, 105, 110, 101, 115,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				112, 108, 105, 110, 101, 83, 105, 100, 101, 119,
				97, 108, 107, 69, 120, 116, 114, 117, 100, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				59, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 83, 116, 97, 116, 105, 115, 116, 105, 99,
				115, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				83, 116, 101, 97, 109, 83, 116, 97, 116, 115,
				65, 80, 73, 84, 101, 115, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 54, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 83, 116,
				101, 97, 109, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 69, 118, 101, 110, 116, 73, 102, 83,
				116, 101, 97, 109, 67, 104, 105, 110, 97, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 51,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				83, 116, 101, 97, 109, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 83, 116, 101, 97, 109, 76,
				111, 103, 111, 73, 109, 97, 103, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 48, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 84,
				97, 115, 107, 76, 105, 115, 116, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 76, 105, 115, 116,
				84, 97, 115, 107, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 52, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 84, 97, 115, 107, 76,
				105, 115, 116, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 80, 97, 114, 97, 108, 108, 101, 108,
				84, 97, 115, 107, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 56, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 84, 97, 115, 107, 76,
				105, 115, 116, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 80, 108, 97, 121, 84, 105, 109, 101,
				108, 105, 110, 101, 84, 97, 115, 107, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 84,
				97, 115, 107, 76, 105, 115, 116, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 84, 97, 115, 107,
				83, 107, 105, 112, 112, 101, 114, 85, 73, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 57,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				84, 105, 109, 101, 83, 112, 97, 110, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 68, 97, 116,
				101, 84, 105, 109, 101, 65, 116, 116, 114, 105,
				98, 117, 116, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 57, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 84, 105, 109, 101, 83,
				112, 97, 110, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 84, 105, 109, 101, 83, 112, 97, 110,
				65, 116, 116, 114, 105, 98, 117, 116, 101, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 47,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				84, 105, 112, 115, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 84, 105, 112, 115, 68, 105, 115,
				112, 108, 97, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 47, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 65, 110,
				105, 109, 97, 116, 105, 111, 110, 115, 92, 67,
				111, 108, 111, 114, 80, 117, 110, 99, 104, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 88,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 65, 110, 105, 109, 97, 116, 105,
				111, 110, 115, 92, 70, 97, 100, 105, 110, 103,
				92, 70, 97, 100, 101, 32, 69, 108, 101, 109,
				101, 110, 116, 32, 73, 109, 112, 108, 105, 109,
				101, 110, 116, 97, 116, 105, 111, 110, 115, 92,
				67, 97, 110, 118, 97, 115, 71, 114, 111, 117,
				112, 70, 97, 100, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 93, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 115, 92,
				70, 97, 100, 105, 110, 103, 92, 70, 97, 100,
				101, 32, 69, 108, 101, 109, 101, 110, 116, 32,
				73, 109, 112, 108, 105, 109, 101, 110, 116, 97,
				116, 105, 111, 110, 115, 92, 77, 97, 116, 101,
				114, 105, 97, 108, 80, 114, 111, 112, 101, 114,
				116, 121, 70, 97, 100, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 90, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				65, 110, 105, 109, 97, 116, 105, 111, 110, 115,
				92, 70, 97, 100, 105, 110, 103, 92, 70, 97,
				100, 101, 32, 69, 108, 101, 109, 101, 110, 116,
				32, 73, 109, 112, 108, 105, 109, 101, 110, 116,
				97, 116, 105, 111, 110, 115, 92, 82, 101, 99,
				116, 84, 114, 97, 110, 115, 102, 111, 114, 109,
				70, 97, 100, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 82, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 65, 110,
				105, 109, 97, 116, 105, 111, 110, 115, 92, 70,
				97, 100, 105, 110, 103, 92, 70, 97, 100, 101,
				32, 69, 108, 101, 109, 101, 110, 116, 32, 73,
				109, 112, 108, 105, 109, 101, 110, 116, 97, 116,
				105, 111, 110, 115, 92, 83, 99, 97, 108, 101,
				70, 97, 100, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 55, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 65, 110,
				105, 109, 97, 116, 105, 111, 110, 115, 92, 70,
				97, 100, 105, 110, 103, 92, 70, 97, 100, 101,
				69, 108, 101, 109, 101, 110, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 53, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				115, 92, 70, 97, 100, 105, 110, 103, 92, 70,
				97, 100, 101, 71, 114, 111, 117, 112, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 66, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 65, 110, 105, 109, 97, 116, 105, 111,
				110, 115, 92, 76, 111, 111, 112, 101, 114, 92,
				65, 110, 99, 104, 111, 114, 101, 100, 80, 111,
				115, 105, 116, 105, 111, 110, 76, 111, 111, 112,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 60, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 115, 92, 76, 111, 111,
				112, 101, 114, 92, 73, 109, 97, 103, 101, 67,
				111, 108, 111, 114, 76, 111, 111, 112, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				63, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 65, 110, 105, 109, 97, 116,
				105, 111, 110, 115, 92, 76, 111, 111, 112, 101,
				114, 92, 76, 111, 99, 97, 108, 80, 111, 115,
				105, 116, 105, 111, 110, 76, 111, 111, 112, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 55, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 115, 92, 76, 111, 111, 112,
				101, 114, 92, 76, 111, 111, 112, 101, 114, 67,
				108, 111, 99, 107, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 57, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 65, 110,
				105, 109, 97, 116, 105, 111, 110, 115, 92, 76,
				111, 111, 112, 101, 114, 92, 76, 111, 111, 112,
				101, 114, 69, 108, 101, 109, 101, 110, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 58,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 65, 110, 105, 109, 97, 116, 105,
				111, 110, 115, 92, 76, 111, 111, 112, 101, 114,
				92, 82, 111, 116, 97, 116, 105, 111, 110, 76,
				111, 111, 112, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 55, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 115, 92,
				76, 111, 111, 112, 101, 114, 92, 83, 99, 97,
				108, 101, 76, 111, 111, 112, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 50, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 65, 110, 105, 109, 97, 116, 105, 111,
				110, 115, 92, 80, 117, 110, 99, 104, 82, 101,
				99, 101, 105, 118, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 45, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				65, 110, 105, 109, 97, 116, 105, 111, 110, 115,
				92, 82, 101, 118, 111, 108, 118, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 59,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 65, 110, 105, 109, 97, 116, 105,
				111, 110, 115, 92, 84, 111, 103, 103, 108, 101,
				92, 66, 117, 116, 116, 111, 110, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 69, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				65, 110, 105, 109, 97, 116, 105, 111, 110, 115,
				92, 84, 111, 103, 103, 108, 101, 92, 67, 104,
				97, 110, 103, 101, 71, 114, 97, 112, 104, 105,
				99, 115, 67, 111, 108, 111, 114, 84, 111, 103,
				103, 108, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 55, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 85, 73, 92, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 115, 92, 84, 111,
				103, 103, 108, 101, 92, 83, 99, 97, 108, 101,
				84, 111, 103, 103, 108, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 59, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				65, 110, 105, 109, 97, 116, 105, 111, 110, 115,
				92, 84, 111, 103, 103, 108, 101, 92, 83, 105,
				122, 101, 68, 101, 108, 116, 97, 84, 111, 103,
				103, 108, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 59, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 85, 73, 92, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 115, 92, 84, 111,
				103, 103, 108, 101, 92, 84, 111, 103, 103, 108,
				101, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				59, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 65, 110, 105, 109, 97, 116,
				105, 111, 110, 115, 92, 84, 111, 103, 103, 108,
				101, 92, 84, 111, 103, 103, 108, 101, 67, 111,
				109, 112, 111, 110, 101, 110, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 77, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				66, 97, 114, 68, 105, 115, 112, 108, 97, 121,
				115, 92, 66, 97, 114, 68, 105, 115, 112, 108,
				97, 121, 67, 111, 110, 116, 114, 111, 108, 108,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 80, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 66, 97, 114, 68, 105,
				115, 112, 108, 97, 121, 115, 92, 66, 97, 114,
				68, 105, 115, 112, 108, 97, 121, 67, 111, 110,
				116, 114, 111, 108, 108, 101, 114, 95, 72, 80,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				84, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 66, 97, 114, 68, 105, 115, 112,
				108, 97, 121, 115, 92, 66, 97, 114, 68, 105,
				115, 112, 108, 97, 121, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 95, 72, 117, 110, 103,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 85, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 66, 97, 114, 68, 105,
				115, 112, 108, 97, 121, 115, 92, 66, 97, 114,
				68, 105, 115, 112, 108, 97, 121, 67, 111, 110,
				116, 114, 111, 108, 108, 101, 114, 95, 83, 116,
				101, 109, 105, 110, 97, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 84, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 71,
				97, 109, 101, 112, 108, 97, 121, 85, 73, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 66, 97,
				114, 68, 105, 115, 112, 108, 97, 121, 115, 92,
				66, 97, 114, 68, 105, 115, 112, 108, 97, 121,
				67, 111, 110, 116, 114, 111, 108, 108, 101, 114,
				95, 84, 104, 117, 114, 115, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 69, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				66, 97, 115, 105, 99, 69, 108, 101, 109, 101,
				110, 116, 115, 92, 66, 97, 114, 68, 105, 115,
				112, 108, 97, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 72, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 66, 97, 115,
				105, 99, 69, 108, 101, 109, 101, 110, 116, 115,
				92, 71, 101, 110, 101, 114, 105, 99, 66, 117,
				116, 116, 111, 110, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 91, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 66, 97, 115,
				105, 99, 69, 108, 101, 109, 101, 110, 116, 115,
				92, 73, 110, 116, 101, 114, 102, 97, 99, 101,
				115, 92, 73, 73, 116, 101, 109, 77, 101, 116,
				97, 68, 97, 116, 97, 80, 114, 111, 118, 105,
				100, 101, 114, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 91, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 85, 73, 92, 71, 97, 109,
				101, 112, 108, 97, 121, 85, 73, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 66, 97, 115, 105,
				99, 69, 108, 101, 109, 101, 110, 116, 115, 92,
				73, 110, 118, 101, 110, 116, 111, 114, 121, 92,
				73, 110, 118, 101, 110, 116, 111, 114, 121, 70,
				105, 108, 116, 101, 114, 68, 105, 115, 112, 108,
				97, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 96, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 66, 97, 115, 105, 99,
				69, 108, 101, 109, 101, 110, 116, 115, 92, 73,
				110, 118, 101, 110, 116, 111, 114, 121, 92, 73,
				110, 118, 101, 110, 116, 111, 114, 121, 70, 105,
				108, 116, 101, 114, 68, 105, 115, 112, 108, 97,
				121, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 92, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
				97, 115, 105, 99, 69, 108, 101, 109, 101, 110,
				116, 115, 92, 73, 110, 118, 101, 110, 116, 111,
				114, 121, 92, 73, 110, 118, 101, 110, 116, 111,
				114, 121, 70, 105, 108, 116, 101, 114, 80, 114,
				111, 118, 105, 100, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 75, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
				97, 115, 105, 99, 69, 108, 101, 109, 101, 110,
				116, 115, 92, 73, 110, 118, 101, 110, 116, 111,
				114, 121, 68, 105, 115, 112, 108, 97, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 73,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 66, 97, 115, 105, 99, 69, 108, 101,
				109, 101, 110, 116, 115, 92, 73, 110, 118, 101,
				110, 116, 111, 114, 121, 69, 110, 116, 114, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				88, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 66, 97, 115, 105, 99, 69, 108,
				101, 109, 101, 110, 116, 115, 92, 73, 116, 101,
				109, 68, 101, 116, 97, 105, 108, 115, 92, 66,
				117, 108, 108, 101, 116, 84, 121, 112, 101, 68,
				105, 115, 112, 108, 97, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 89, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
				97, 115, 105, 99, 69, 108, 101, 109, 101, 110,
				116, 115, 92, 73, 116, 101, 109, 68, 101, 116,
				97, 105, 108, 115, 92, 73, 116, 101, 109, 68,
				101, 116, 97, 105, 108, 115, 68, 105, 115, 112,
				108, 97, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 87, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 85, 73, 92, 71, 97, 109,
				101, 112, 108, 97, 121, 85, 73, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 66, 97, 115, 105,
				99, 69, 108, 101, 109, 101, 110, 116, 115, 92,
				73, 116, 101, 109, 68, 101, 116, 97, 105, 108,
				115, 92, 73, 116, 101, 109, 68, 101, 116, 97,
				105, 108, 115, 80, 97, 110, 101, 108, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 86, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				85, 73, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 66, 97, 115, 105, 99, 69, 108, 101, 109,
				101, 110, 116, 115, 92, 73, 116, 101, 109, 68,
				101, 116, 97, 105, 108, 115, 92, 73, 116, 101,
				109, 69, 102, 102, 101, 99, 116, 69, 110, 116,
				114, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 88, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 66, 97, 115, 105, 99,
				69, 108, 101, 109, 101, 110, 116, 115, 92, 73,
				116, 101, 109, 68, 101, 116, 97, 105, 108, 115,
				92, 73, 116, 101, 109, 77, 111, 100, 105, 102,
				105, 101, 114, 69, 110, 116, 114, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 84, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				85, 73, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 66, 97, 115, 105, 99, 69, 108, 101, 109,
				101, 110, 116, 115, 92, 73, 116, 101, 109, 68,
				101, 116, 97, 105, 108, 115, 92, 73, 116, 101,
				109, 83, 116, 97, 116, 69, 110, 116, 114, 121,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				88, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 66, 97, 115, 105, 99, 69, 108,
				101, 109, 101, 110, 116, 115, 92, 73, 116, 101,
				109, 68, 101, 116, 97, 105, 108, 115, 92, 73,
				116, 101, 109, 86, 97, 114, 105, 97, 98, 108,
				101, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 2, 0, 0, 0, 87, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
				97, 115, 105, 99, 69, 108, 101, 109, 101, 110,
				116, 115, 92, 73, 116, 101, 109, 68, 101, 116,
				97, 105, 108, 115, 92, 83, 116, 97, 116, 73,
				110, 102, 111, 68, 97, 116, 97, 98, 97, 115,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 92, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 66, 97, 115, 105, 99, 69,
				108, 101, 109, 101, 110, 116, 115, 92, 73, 116,
				101, 109, 68, 101, 116, 97, 105, 108, 115, 92,
				85, 115, 97, 103, 101, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 68, 105, 115, 112, 108, 97,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 98, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 66, 97, 115, 105, 99, 69,
				108, 101, 109, 101, 110, 116, 115, 92, 73, 116,
				101, 109, 68, 101, 116, 97, 105, 108, 115, 92,
				85, 115, 97, 103, 101, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 68, 105, 115, 112, 108, 97,
				121, 95, 69, 110, 116, 114, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 70, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				66, 97, 115, 105, 99, 69, 108, 101, 109, 101,
				110, 116, 115, 92, 73, 116, 101, 109, 68, 105,
				115, 112, 108, 97, 121, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 74, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 71,
				97, 109, 101, 112, 108, 97, 121, 85, 73, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 66, 97,
				115, 105, 99, 69, 108, 101, 109, 101, 110, 116,
				115, 92, 73, 116, 101, 109, 77, 101, 116, 97,
				68, 105, 115, 112, 108, 97, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 94, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				66, 97, 115, 105, 99, 69, 108, 101, 109, 101,
				110, 116, 115, 92, 73, 116, 101, 109, 79, 112,
				101, 114, 97, 116, 105, 111, 110, 77, 101, 110,
				117, 92, 73, 116, 101, 109, 79, 112, 101, 114,
				97, 116, 105, 111, 110, 77, 101, 110, 117, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 84,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 66, 97, 115, 105, 99, 69, 108, 101,
				109, 101, 110, 116, 115, 92, 73, 116, 101, 109,
				83, 108, 111, 116, 67, 111, 108, 108, 101, 99,
				116, 105, 111, 110, 68, 105, 115, 112, 108, 97,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 72, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 66, 97, 115, 105, 99, 69,
				108, 101, 109, 101, 110, 116, 115, 92, 77, 105,
				110, 105, 109, 97, 112, 66, 117, 116, 116, 111,
				110, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 70, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 66, 97, 115, 105, 99, 69,
				108, 101, 109, 101, 110, 116, 115, 92, 83, 108,
				111, 116, 68, 105, 115, 112, 108, 97, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 72,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 66, 97, 115, 105, 99, 69, 108, 101,
				109, 101, 110, 116, 115, 92, 83, 108, 111, 116,
				73, 110, 100, 105, 99, 97, 116, 111, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 86,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 66, 97, 115, 105, 99, 69, 108, 101,
				109, 101, 110, 116, 115, 92, 83, 112, 108, 105,
				116, 68, 105, 97, 108, 111, 103, 117, 101, 92,
				83, 112, 108, 105, 116, 68, 105, 97, 108, 111,
				103, 117, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 82, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 85, 73, 92, 71, 97, 109,
				101, 112, 108, 97, 121, 85, 73, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 66, 97, 115, 105,
				99, 69, 108, 101, 109, 101, 110, 116, 115, 92,
				84, 97, 103, 115, 68, 105, 115, 112, 108, 97,
				121, 92, 84, 97, 103, 115, 68, 105, 115, 112,
				108, 97, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 87, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 85, 73, 92, 71, 97, 109,
				101, 112, 108, 97, 121, 85, 73, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 66, 97, 115, 105,
				99, 69, 108, 101, 109, 101, 110, 116, 115, 92,
				84, 97, 103, 115, 68, 105, 115, 112, 108, 97,
				121, 92, 84, 97, 103, 115, 68, 105, 115, 112,
				108, 97, 121, 69, 110, 116, 114, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 100, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				85, 73, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 66, 97, 115, 105, 99, 69, 108, 101, 109,
				101, 110, 116, 115, 92, 84, 114, 97, 100, 105,
				110, 103, 92, 73, 110, 118, 101, 110, 116, 111,
				114, 121, 69, 110, 116, 114, 121, 84, 114, 97,
				100, 105, 110, 103, 80, 114, 105, 99, 101, 68,
				105, 115, 112, 108, 97, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 71, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 66,
				97, 115, 105, 99, 69, 108, 101, 109, 101, 110,
				116, 115, 92, 87, 101, 97, 112, 111, 110, 66,
				117, 116, 116, 111, 110, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 57, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 71,
				97, 109, 101, 112, 108, 97, 121, 85, 73, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 68, 101,
				98, 117, 103, 85, 73, 83, 101, 116, 117, 112,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				59, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 69, 120, 112, 92, 69, 120, 112,
				68, 105, 115, 112, 108, 97, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 64, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				72, 101, 97, 108, 116, 104, 66, 97, 114, 92,
				72, 101, 97, 108, 116, 104, 66, 97, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 71,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 72, 101, 97, 108, 116, 104, 66, 97,
				114, 92, 72, 101, 97, 108, 116, 104, 66, 97,
				114, 77, 97, 110, 97, 103, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 74, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				85, 73, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 72, 101, 97, 108, 116, 104, 66, 97, 114,
				92, 72, 101, 97, 108, 116, 104, 66, 97, 114,
				95, 68, 97, 109, 97, 103, 101, 66, 97, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				77, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 73, 110, 116, 101, 114, 97, 99,
				116, 105, 111, 110, 77, 101, 110, 117, 92, 77,
				117, 108, 116, 105, 73, 110, 116, 101, 114, 97,
				99, 116, 105, 111, 110, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 81, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 71,
				97, 109, 101, 112, 108, 97, 121, 85, 73, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 73, 110,
				116, 101, 114, 97, 99, 116, 105, 111, 110, 77,
				101, 110, 117, 92, 77, 117, 108, 116, 105, 73,
				110, 116, 101, 114, 97, 99, 116, 105, 111, 110,
				77, 101, 110, 117, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 87, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 73, 110, 116,
				101, 114, 97, 99, 116, 105, 111, 110, 77, 101,
				110, 117, 92, 77, 117, 108, 116, 105, 73, 110,
				116, 101, 114, 97, 99, 116, 105, 111, 110, 77,
				101, 110, 117, 66, 117, 116, 116, 111, 110, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 60,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 73, 116, 101, 109, 85, 73, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 79, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				77, 97, 110, 97, 103, 101, 100, 85, 73, 77,
				111, 100, 117, 108, 101, 115, 92, 77, 97, 110,
				97, 103, 101, 100, 85, 73, 66, 101, 104, 97,
				118, 105, 111, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 68, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 77, 97, 110,
				97, 103, 101, 114, 115, 92, 68, 105, 97, 108,
				111, 103, 117, 101, 67, 97, 110, 118, 97, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				71, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 77, 97, 110, 97, 103, 101, 114,
				115, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				85, 73, 77, 97, 110, 97, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 64,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 77, 97, 110, 97, 103, 101, 114, 115,
				92, 72, 85, 68, 77, 97, 110, 97, 103, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 66, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 79, 112, 116, 105, 111, 110,
				115, 92, 85, 73, 95, 66, 117, 115, 95, 83,
				108, 105, 100, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 79, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 71,
				97, 109, 101, 112, 108, 97, 121, 85, 73, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 83, 104,
				111, 114, 116, 67, 117, 116, 66, 117, 116, 116,
				111, 110, 115, 92, 73, 116, 101, 109, 83, 104,
				111, 114, 116, 99, 117, 116, 66, 117, 116, 116,
				111, 110, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 84, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 83, 104, 111, 114, 116,
				67, 117, 116, 66, 117, 116, 116, 111, 110, 115,
				92, 73, 116, 101, 109, 83, 104, 111, 114, 116,
				99, 117, 116, 69, 100, 105, 116, 111, 114, 69,
				110, 116, 114, 121, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 84, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 83, 104, 111,
				114, 116, 67, 117, 116, 66, 117, 116, 116, 111,
				110, 115, 92, 73, 116, 101, 109, 83, 104, 111,
				114, 116, 99, 117, 116, 69, 100, 105, 116, 111,
				114, 80, 97, 110, 101, 108, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 78, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 83,
				104, 111, 114, 116, 67, 117, 116, 66, 117, 116,
				116, 111, 110, 115, 92, 73, 116, 101, 109, 83,
				104, 111, 114, 116, 99, 117, 116, 80, 97, 110,
				101, 108, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 92, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 83, 116, 97, 116, 115,
				65, 110, 100, 86, 97, 114, 105, 97, 98, 108,
				101, 115, 92, 77, 97, 105, 110, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 83, 116, 97, 116,
				86, 97, 108, 117, 101, 68, 105, 115, 112, 108,
				97, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 68, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 83, 116, 111, 114, 97,
				103, 101, 68, 111, 99, 107, 92, 83, 116, 111,
				114, 97, 103, 101, 68, 111, 99, 107, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 76, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				85, 73, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 83, 116, 111, 114, 97, 103, 101, 68, 111,
				99, 107, 92, 83, 116, 111, 114, 97, 103, 101,
				68, 111, 99, 107, 67, 111, 117, 110, 116, 84,
				77, 80, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 73, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 83, 116, 111, 114, 97,
				103, 101, 68, 111, 99, 107, 92, 83, 116, 111,
				114, 97, 103, 101, 68, 111, 99, 107, 69, 110,
				116, 114, 121, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 86, 92, 65, 115, 115, 101, 116,
				115, 92, 83, 117, 98, 80, 114, 111, 106, 101,
				99, 116, 115, 92, 85, 73, 92, 71, 97, 109,
				101, 112, 108, 97, 121, 85, 73, 92, 83, 99,
				114, 105, 112, 116, 115, 92, 83, 116, 114, 111,
				110, 103, 78, 111, 116, 105, 102, 105, 99, 97,
				116, 105, 111, 110, 92, 73, 116, 101, 109, 85,
				110, 108, 111, 99, 107, 78, 111, 116, 105, 102,
				105, 99, 97, 116, 105, 111, 110, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 82, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				83, 116, 114, 111, 110, 103, 78, 111, 116, 105,
				102, 105, 99, 97, 116, 105, 111, 110, 92, 83,
				116, 114, 111, 110, 103, 78, 111, 116, 105, 102,
				105, 99, 97, 116, 105, 111, 110, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 62, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				84, 114, 97, 100, 105, 110, 103, 92, 73, 77,
				101, 114, 99, 104, 97, 110, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 71, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				84, 114, 97, 100, 105, 110, 103, 92, 84, 114,
				97, 100, 105, 110, 103, 85, 73, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 70, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
				105, 101, 119, 115, 92, 67, 108, 111, 115, 117,
				114, 101, 92, 67, 108, 111, 115, 117, 114, 101,
				86, 105, 101, 119, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 66, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 86, 105, 101,
				119, 115, 92, 68, 101, 67, 111, 109, 112, 111,
				115, 101, 83, 108, 105, 100, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 64, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				85, 73, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 86, 105, 101, 119, 115, 92, 73, 110, 118,
				101, 110, 116, 111, 114, 121, 86, 105, 101, 119,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				77, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 86, 105, 101, 119, 115, 92, 73,
				116, 101, 109, 67, 117, 115, 116, 111, 109, 105,
				122, 101, 83, 101, 108, 101, 99, 116, 105, 111,
				110, 86, 105, 101, 119, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 68, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 71,
				97, 109, 101, 112, 108, 97, 121, 85, 73, 92,
				83, 99, 114, 105, 112, 116, 115, 92, 86, 105,
				101, 119, 115, 92, 73, 116, 101, 109, 67, 117,
				115, 116, 111, 109, 105, 122, 101, 86, 105, 101,
				119, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 68, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 86, 105, 101, 119, 115, 92,
				73, 116, 101, 109, 68, 101, 99, 111, 109, 112,
				111, 115, 101, 86, 105, 101, 119, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 65, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				86, 105, 101, 119, 115, 92, 73, 116, 101, 109,
				82, 101, 112, 97, 105, 114, 86, 105, 101, 119,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				76, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 86, 105, 101, 119, 115, 92, 73,
				116, 101, 109, 82, 101, 112, 97, 105, 114, 95,
				82, 101, 112, 97, 105, 114, 65, 108, 108, 80,
				97, 110, 101, 108, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 59, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 86, 105, 101,
				119, 115, 92, 76, 111, 111, 116, 86, 105, 101,
				119, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 72, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 86, 105, 101, 119, 115, 92,
				76, 111, 111, 116, 86, 105, 101, 119, 92, 80,
				97, 103, 101, 115, 67, 111, 110, 116, 114, 111,
				108, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 78, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 86, 105, 101, 119, 115, 92,
				76, 111, 111, 116, 86, 105, 101, 119, 92, 80,
				97, 103, 101, 115, 67, 111, 110, 116, 114, 111,
				108, 95, 69, 110, 116, 114, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 81, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				86, 105, 101, 119, 115, 92, 77, 97, 112, 83,
				101, 108, 101, 99, 116, 105, 111, 110, 92, 77,
				97, 112, 83, 101, 108, 101, 99, 116, 105, 111,
				110, 69, 110, 116, 114, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 80, 92, 65, 115,
				115, 101, 116, 115, 92, 83, 117, 98, 80, 114,
				111, 106, 101, 99, 116, 115, 92, 85, 73, 92,
				71, 97, 109, 101, 112, 108, 97, 121, 85, 73,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 86,
				105, 101, 119, 115, 92, 77, 97, 112, 83, 101,
				108, 101, 99, 116, 105, 111, 110, 92, 77, 97,
				112, 83, 101, 108, 101, 99, 116, 105, 111, 110,
				86, 105, 101, 119, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 67, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 86, 105, 101,
				119, 115, 92, 80, 101, 114, 107, 92, 80, 101,
				114, 107, 68, 101, 116, 97, 105, 108, 115, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 65,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 86, 105, 101, 119, 115, 92, 80, 101,
				114, 107, 92, 80, 101, 114, 107, 69, 110, 116,
				114, 121, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 69, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 85, 73, 92, 71, 97, 109, 101,
				112, 108, 97, 121, 85, 73, 92, 83, 99, 114,
				105, 112, 116, 115, 92, 86, 105, 101, 119, 115,
				92, 80, 101, 114, 107, 92, 80, 101, 114, 107,
				76, 105, 110, 101, 69, 110, 116, 114, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 72,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 86, 105, 101, 119, 115, 92, 80, 101,
				114, 107, 92, 82, 101, 113, 117, 105, 114, 101,
				73, 116, 101, 109, 69, 110, 116, 114, 121, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 63,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 86, 105, 101, 119, 115, 92, 80, 101,
				114, 107, 84, 114, 101, 101, 86, 105, 101, 119,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				82, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 86, 105, 101, 119, 115, 92, 80,
				108, 97, 121, 101, 114, 83, 116, 97, 116, 115,
				86, 105, 101, 119, 92, 80, 108, 97, 121, 101,
				114, 83, 116, 97, 116, 115, 86, 105, 101, 119,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				79, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 71, 97, 109, 101, 112, 108,
				97, 121, 85, 73, 92, 83, 99, 114, 105, 112,
				116, 115, 92, 86, 105, 101, 119, 115, 92, 83,
				116, 111, 99, 107, 83, 104, 111, 112, 92, 83,
				116, 111, 99, 107, 83, 104, 111, 112, 73, 116,
				101, 109, 69, 110, 116, 114, 121, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 74, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 92, 83, 99, 114, 105, 112, 116, 115, 92,
				86, 105, 101, 119, 115, 92, 83, 116, 111, 99,
				107, 83, 104, 111, 112, 92, 83, 116, 111, 99,
				107, 83, 104, 111, 112, 86, 105, 101, 119, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 84,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 97, 109, 101, 112, 108, 97,
				121, 85, 73, 92, 83, 99, 114, 105, 112, 116,
				115, 92, 86, 105, 101, 119, 115, 92, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 92, 67, 108,
				111, 115, 101, 86, 105, 101, 119, 79, 110, 80,
				111, 105, 110, 116, 101, 114, 67, 108, 105, 99,
				107, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 55, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 86, 105, 101, 119, 115, 92,
				86, 105, 101, 119, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 59, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 97,
				109, 101, 112, 108, 97, 121, 85, 73, 92, 83,
				99, 114, 105, 112, 116, 115, 92, 86, 105, 101,
				119, 115, 92, 86, 105, 101, 119, 84, 97, 98,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 79, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 97, 109, 101, 112,
				108, 97, 121, 85, 73, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 86, 105, 101, 119, 115, 92,
				86, 105, 101, 119, 84, 97, 98, 115, 92, 86,
				105, 101, 119, 84, 97, 98, 68, 105, 115, 112,
				108, 97, 121, 69, 110, 116, 114, 121, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 71, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 97, 109, 101, 112, 108, 97, 121,
				85, 73, 92, 83, 99, 114, 105, 112, 116, 115,
				92, 87, 101, 105, 103, 104, 116, 66, 97, 114,
				92, 87, 101, 105, 103, 104, 116, 66, 97, 114,
				67, 111, 109, 112, 108, 101, 120, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 46, 92, 65,
				115, 115, 101, 116, 115, 92, 83, 117, 98, 80,
				114, 111, 106, 101, 99, 116, 115, 92, 85, 73,
				92, 71, 101, 110, 101, 114, 97, 108, 92, 70,
				111, 108, 108, 111, 119, 67, 117, 114, 115, 111,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 49, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 101, 110, 101, 114,
				97, 108, 92, 70, 111, 114, 99, 101, 85, 110,
				109, 97, 115, 107, 97, 98, 108, 101, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 53, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 101, 110, 101, 114, 97, 108, 92,
				80, 111, 105, 110, 116, 101, 114, 68, 111, 119,
				110, 85, 112, 69, 118, 101, 110, 116, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 61,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 101, 110, 101, 114, 97, 108,
				92, 80, 114, 111, 99, 101, 100, 117, 114, 97,
				108, 73, 109, 97, 103, 101, 72, 97, 115, 104,
				80, 114, 111, 118, 105, 100, 101, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 65, 92,
				65, 115, 115, 101, 116, 115, 92, 83, 117, 98,
				80, 114, 111, 106, 101, 99, 116, 115, 92, 85,
				73, 92, 71, 101, 110, 101, 114, 97, 108, 92,
				82, 101, 99, 116, 84, 114, 97, 110, 115, 102,
				111, 114, 109, 67, 104, 97, 110, 103, 101, 69,
				118, 101, 110, 116, 69, 109, 105, 116, 116, 101,
				114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 55, 92, 65, 115, 115, 101, 116, 115, 92,
				83, 117, 98, 80, 114, 111, 106, 101, 99, 116,
				115, 92, 85, 73, 92, 71, 101, 110, 101, 114,
				97, 108, 92, 83, 99, 114, 111, 108, 108, 86,
				105, 101, 119, 66, 111, 114, 100, 101, 114, 70,
				114, 97, 109, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 57, 92, 65, 115, 115, 101,
				116, 115, 92, 83, 117, 98, 80, 114, 111, 106,
				101, 99, 116, 115, 92, 85, 73, 92, 71, 101,
				110, 101, 114, 97, 108, 92, 83, 99, 114, 111,
				108, 108, 86, 105, 101, 119, 69, 118, 101, 110,
				116, 82, 101, 99, 101, 105, 118, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 53,
				92, 65, 115, 115, 101, 116, 115, 92, 83, 117,
				98, 80, 114, 111, 106, 101, 99, 116, 115, 92,
				85, 73, 92, 71, 101, 110, 101, 114, 97, 108,
				92, 83, 99, 114, 111, 108, 108, 86, 105, 101,
				119, 77, 97, 120, 72, 101, 105, 103, 104, 116,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				57, 92, 65, 115, 115, 101, 116, 115, 92, 83,
				117, 98, 80, 114, 111, 106, 101, 99, 116, 115,
				92, 85, 73, 92, 75, 111, 110, 116, 101, 120,
				116, 77, 101, 110, 117, 92, 83, 99, 114, 105,
				112, 116, 115, 92, 75, 111, 110, 116, 101, 120,
				116, 77, 101, 110, 117, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 62, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 92, 75,
				111, 110, 116, 101, 120, 116, 77, 101, 110, 117,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 75,
				111, 110, 116, 101, 120, 116, 77, 101, 110, 117,
				69, 110, 116, 114, 121, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 49, 92, 65, 115, 115,
				101, 116, 115, 92, 83, 117, 98, 80, 114, 111,
				106, 101, 99, 116, 115, 92, 85, 73, 84, 111,
				111, 107, 105, 116, 84, 101, 115, 116, 92, 85,
				73, 84, 111, 111, 108, 107, 105, 116, 84, 101,
				115, 116, 46, 99, 115, 0, 0, 0, 4, 0,
				0, 0, 53, 92, 65, 115, 115, 101, 116, 115,
				92, 83, 117, 98, 80, 114, 111, 106, 101, 99,
				116, 115, 92, 87, 101, 97, 116, 104, 101, 114,
				92, 83, 99, 114, 105, 112, 116, 115, 92, 87,
				101, 97, 116, 104, 101, 114, 77, 97, 110, 97,
				103, 101, 114, 46, 99, 115
			},
			TypesData = new byte[36401]
			{
				0, 0, 0, 0, 18, 83, 111, 100, 97, 67,
				114, 97, 102, 116, 124, 83, 117, 110, 70, 111,
				103, 84, 68, 0, 0, 0, 0, 15, 124, 83,
				111, 100, 97, 80, 111, 105, 110, 116, 76, 105,
				103, 104, 116, 0, 0, 0, 0, 15, 124, 67,
				117, 115, 116, 111, 109, 70, 97, 99, 101, 68,
				97, 116, 97, 0, 0, 0, 0, 25, 124, 67,
				117, 115, 116, 111, 109, 70, 97, 99, 101, 80,
				97, 114, 116, 67, 111, 108, 108, 101, 99, 116,
				105, 111, 110, 0, 0, 0, 0, 19, 124, 67,
				117, 115, 116, 111, 109, 70, 97, 99, 101, 80,
				97, 114, 116, 77, 101, 116, 97, 0, 0, 0,
				0, 19, 124, 67, 117, 115, 116, 111, 109, 70,
				97, 99, 101, 73, 110, 115, 116, 97, 110, 99,
				101, 0, 0, 0, 0, 22, 124, 67, 117, 115,
				116, 111, 109, 70, 97, 99, 101, 80, 97, 114,
				116, 85, 116, 105, 108, 105, 116, 121, 0, 0,
				0, 0, 22, 124, 67, 117, 115, 116, 111, 109,
				70, 97, 99, 101, 72, 101, 97, 100, 83, 101,
				116, 116, 105, 110, 103, 0, 0, 0, 0, 22,
				124, 67, 117, 115, 116, 111, 109, 70, 97, 99,
				101, 83, 101, 116, 116, 105, 110, 103, 68, 97,
				116, 97, 0, 0, 0, 0, 15, 124, 67, 117,
				115, 116, 111, 109, 70, 97, 99, 101, 80, 97,
				114, 116, 0, 0, 0, 0, 19, 124, 67, 117,
				115, 116, 111, 109, 70, 97, 99, 101, 80, 97,
				114, 116, 73, 110, 102, 111, 0, 0, 0, 0,
				17, 124, 67, 117, 115, 116, 111, 109, 70, 97,
				99, 101, 80, 114, 101, 115, 101, 116, 0, 0,
				0, 0, 16, 124, 84, 101, 115, 116, 65, 114,
				109, 82, 101, 110, 100, 101, 114, 101, 114, 0,
				0, 0, 0, 25, 124, 67, 117, 115, 116, 111,
				109, 70, 97, 99, 101, 76, 111, 97, 100, 83,
				97, 118, 101, 66, 117, 116, 116, 111, 110, 0,
				0, 0, 0, 19, 124, 67, 117, 115, 116, 111,
				109, 70, 97, 99, 101, 83, 97, 118, 101, 76,
				111, 97, 100, 0, 0, 0, 0, 17, 124, 67,
				117, 115, 116, 111, 109, 70, 97, 99, 101, 83,
				108, 105, 100, 101, 114, 0, 0, 0, 0, 15,
				124, 67, 117, 115, 116, 111, 109, 70, 97, 99,
				101, 84, 97, 98, 115, 0, 0, 0, 0, 13,
				124, 67, 117, 115, 116, 111, 109, 70, 97, 99,
				101, 85, 73, 0, 0, 0, 0, 24, 124, 67,
				117, 115, 116, 111, 109, 70, 97, 99, 101, 85,
				73, 67, 111, 108, 111, 114, 80, 105, 99, 107,
				101, 114, 0, 0, 0, 0, 30, 124, 67, 117,
				115, 116, 111, 109, 70, 97, 99, 101, 85, 73,
				67, 111, 108, 111, 114, 80, 105, 99, 107, 101,
				114, 66, 117, 116, 116, 111, 110, 0, 0, 0,
				0, 17, 124, 67, 117, 115, 116, 111, 109, 70,
				97, 99, 101, 85, 73, 80, 97, 114, 116, 0,
				0, 0, 0, 19, 124, 67, 117, 115, 116, 111,
				109, 70, 97, 99, 101, 85, 73, 83, 119, 105,
				116, 99, 104, 0, 0, 0, 0, 20, 124, 73,
				110, 116, 101, 114, 97, 99, 116, 95, 67, 117,
				115, 116, 111, 109, 70, 97, 99, 101, 0, 0,
				0, 0, 14, 124, 65, 99, 99, 101, 115, 115,
				111, 114, 121, 66, 97, 115, 101, 0, 0, 0,
				0, 16, 124, 65, 99, 99, 101, 115, 115, 111,
				114, 121, 95, 76, 97, 122, 101, 114, 0, 0,
				0, 0, 29, 124, 65, 84, 95, 73, 110, 116,
				101, 114, 97, 99, 116, 87, 105, 116, 104, 77,
				97, 105, 110, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 0, 0, 0, 0, 36, 78, 111, 100,
				101, 67, 97, 110, 118, 97, 115, 46, 84, 97,
				115, 107, 115, 46, 65, 99, 116, 105, 111, 110,
				115, 124, 65, 105, 109, 84, 111, 80, 108, 97,
				121, 101, 114, 0, 0, 0, 0, 31, 78, 111,
				100, 101, 67, 97, 110, 118, 97, 115, 46, 84,
				97, 115, 107, 115, 46, 65, 99, 116, 105, 111,
				110, 115, 124, 65, 116, 116, 97, 99, 107, 0,
				0, 0, 0, 38, 78, 111, 100, 101, 67, 97,
				110, 118, 97, 115, 46, 84, 97, 115, 107, 115,
				46, 65, 99, 116, 105, 111, 110, 115, 124, 67,
				104, 101, 99, 107, 79, 98, 115, 116, 105, 99,
				108, 101, 0, 0, 0, 0, 29, 78, 111, 100,
				101, 67, 97, 110, 118, 97, 115, 46, 84, 97,
				115, 107, 115, 46, 65, 99, 116, 105, 111, 110,
				115, 124, 68, 97, 115, 104, 0, 0, 0, 0,
				42, 78, 111, 100, 101, 67, 97, 110, 118, 97,
				115, 46, 84, 97, 115, 107, 115, 46, 65, 99,
				116, 105, 111, 110, 115, 124, 70, 105, 110, 100,
				77, 97, 105, 110, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 0, 0, 0, 0, 19, 124, 71,
				101, 116, 67, 117, 114, 114, 101, 110, 116, 80,
				111, 115, 105, 116, 105, 111, 110, 0, 0, 0,
				0, 40, 78, 111, 100, 101, 67, 97, 110, 118,
				97, 115, 46, 84, 97, 115, 107, 115, 46, 65,
				99, 116, 105, 111, 110, 115, 124, 77, 111, 118,
				101, 84, 111, 82, 97, 110, 100, 111, 109, 80,
				111, 115, 0, 0, 0, 0, 43, 78, 111, 100,
				101, 67, 97, 110, 118, 97, 115, 46, 84, 97,
				115, 107, 115, 46, 65, 99, 116, 105, 111, 110,
				115, 124, 80, 105, 99, 107, 117, 112, 83, 101,
				97, 114, 99, 104, 101, 100, 73, 116, 101, 109,
				0, 0, 0, 0, 32, 78, 111, 100, 101, 67,
				97, 110, 118, 97, 115, 46, 84, 97, 115, 107,
				115, 46, 65, 99, 116, 105, 111, 110, 115, 124,
				80, 111, 112, 84, 101, 120, 116, 0, 0, 0,
				0, 34, 78, 111, 100, 101, 67, 97, 110, 118,
				97, 115, 46, 84, 97, 115, 107, 115, 46, 65,
				99, 116, 105, 111, 110, 115, 124, 80, 111, 115,
				116, 83, 111, 117, 110, 100, 0, 0, 0, 0,
				46, 78, 111, 100, 101, 67, 97, 110, 118, 97,
				115, 46, 84, 97, 115, 107, 115, 46, 65, 99,
				116, 105, 111, 110, 115, 124, 82, 101, 108, 101,
				97, 115, 101, 73, 116, 101, 109, 83, 107, 105,
				108, 108, 73, 102, 72, 97, 115, 0, 0, 0,
				0, 37, 78, 111, 100, 101, 67, 97, 110, 118,
				97, 115, 46, 84, 97, 115, 107, 115, 46, 65,
				99, 116, 105, 111, 110, 115, 124, 82, 101, 108,
				101, 97, 115, 101, 83, 107, 105, 108, 108, 0,
				0, 0, 0, 34, 78, 111, 100, 101, 67, 97,
				110, 118, 97, 115, 46, 84, 97, 115, 107, 115,
				46, 65, 99, 116, 105, 111, 110, 115, 124, 82,
				111, 116, 97, 116, 101, 65, 105, 109, 0, 0,
				0, 0, 42, 78, 111, 100, 101, 67, 97, 110,
				118, 97, 115, 46, 84, 97, 115, 107, 115, 46,
				65, 99, 116, 105, 111, 110, 115, 124, 83, 101,
				97, 114, 99, 104, 69, 110, 101, 109, 121, 65,
				114, 111, 117, 110, 100, 0, 0, 0, 0, 31,
				78, 111, 100, 101, 67, 97, 110, 118, 97, 115,
				46, 84, 97, 115, 107, 115, 46, 65, 99, 116,
				105, 111, 110, 115, 124, 83, 101, 116, 65, 105,
				109, 0, 0, 0, 0, 43, 78, 111, 100, 101,
				67, 97, 110, 118, 97, 115, 46, 84, 97, 115,
				107, 115, 46, 65, 99, 116, 105, 111, 110, 115,
				124, 83, 101, 116, 78, 111, 116, 105, 99, 101,
				100, 84, 111, 84, 97, 114, 103, 101, 116, 0,
				0, 0, 0, 31, 78, 111, 100, 101, 67, 97,
				110, 118, 97, 115, 46, 84, 97, 115, 107, 115,
				46, 65, 99, 116, 105, 111, 110, 115, 124, 83,
				101, 116, 82, 117, 110, 0, 0, 0, 0, 30,
				78, 111, 100, 101, 67, 97, 110, 118, 97, 115,
				46, 84, 97, 115, 107, 115, 46, 65, 99, 116,
				105, 111, 110, 115, 124, 83, 104, 111, 111, 116,
				0, 0, 0, 0, 37, 78, 111, 100, 101, 67,
				97, 110, 118, 97, 115, 46, 84, 97, 115, 107,
				115, 46, 65, 99, 116, 105, 111, 110, 115, 124,
				83, 112, 97, 119, 110, 65, 108, 101, 114, 116,
				70, 120, 0, 0, 0, 0, 35, 78, 111, 100,
				101, 67, 97, 110, 118, 97, 115, 46, 84, 97,
				115, 107, 115, 46, 65, 99, 116, 105, 111, 110,
				115, 124, 83, 116, 111, 112, 77, 111, 118, 105,
				110, 103, 0, 0, 0, 0, 36, 78, 111, 100,
				101, 67, 97, 110, 118, 97, 115, 46, 84, 97,
				115, 107, 115, 46, 65, 99, 116, 105, 111, 110,
				115, 124, 84, 114, 97, 99, 101, 84, 97, 114,
				103, 101, 116, 0, 0, 0, 0, 43, 78, 111,
				100, 101, 67, 97, 110, 118, 97, 115, 46, 84,
				97, 115, 107, 115, 46, 65, 99, 116, 105, 111,
				110, 115, 124, 84, 114, 121, 84, 111, 82, 101,
				108, 111, 97, 100, 73, 102, 69, 109, 112, 116,
				121, 0, 0, 0, 0, 32, 78, 111, 100, 101,
				67, 97, 110, 118, 97, 115, 46, 84, 97, 115,
				107, 115, 46, 65, 99, 116, 105, 111, 110, 115,
				124, 85, 115, 101, 68, 114, 117, 103, 0, 0,
				0, 0, 22, 124, 65, 73, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 0, 0, 0, 0, 48,
				78, 111, 100, 101, 67, 97, 110, 118, 97, 115,
				46, 84, 97, 115, 107, 115, 46, 67, 111, 110,
				100, 105, 116, 105, 111, 110, 115, 124, 67, 104,
				101, 99, 107, 67, 97, 110, 82, 101, 108, 101,
				97, 115, 101, 83, 107, 105, 108, 108, 0, 0,
				0, 0, 46, 78, 111, 100, 101, 67, 97, 110,
				118, 97, 115, 46, 84, 97, 115, 107, 115, 46,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				124, 67, 104, 101, 99, 107, 72, 101, 97, 116,
				104, 76, 101, 115, 115, 84, 104, 97, 110, 0,
				0, 0, 0, 40, 78, 111, 100, 101, 67, 97,
				110, 118, 97, 115, 46, 84, 97, 115, 107, 115,
				46, 67, 111, 110, 100, 105, 116, 105, 111, 110,
				115, 124, 67, 104, 101, 99, 107, 72, 111, 108,
				100, 71, 117, 110, 0, 0, 0, 0, 37, 78,
				111, 100, 101, 67, 97, 110, 118, 97, 115, 46,
				84, 97, 115, 107, 115, 46, 67, 111, 110, 100,
				105, 116, 105, 111, 110, 115, 124, 67, 104, 101,
				99, 107, 72, 117, 114, 116, 0, 0, 0, 0,
				40, 78, 111, 100, 101, 67, 97, 110, 118, 97,
				115, 46, 84, 97, 115, 107, 115, 46, 67, 111,
				110, 100, 105, 116, 105, 111, 110, 115, 124, 67,
				104, 101, 99, 107, 78, 111, 116, 105, 99, 101,
				100, 0, 0, 0, 0, 42, 78, 111, 100, 101,
				67, 97, 110, 118, 97, 115, 46, 84, 97, 115,
				107, 115, 46, 67, 111, 110, 100, 105, 116, 105,
				111, 110, 115, 124, 67, 104, 101, 99, 107, 82,
				101, 108, 111, 97, 100, 105, 110, 103, 0, 0,
				0, 0, 47, 78, 111, 100, 101, 67, 97, 110,
				118, 97, 115, 46, 84, 97, 115, 107, 115, 46,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				124, 67, 104, 101, 99, 107, 84, 97, 114, 103,
				101, 116, 68, 105, 115, 116, 97, 110, 99, 101,
				0, 0, 0, 0, 47, 78, 111, 100, 101, 67,
				97, 110, 118, 97, 115, 46, 84, 97, 115, 107,
				115, 46, 67, 111, 110, 100, 105, 116, 105, 111,
				110, 115, 124, 72, 97, 115, 79, 98, 115, 116,
				105, 99, 108, 101, 84, 111, 84, 97, 114, 103,
				101, 116, 0, 0, 0, 0, 6, 124, 80, 101,
				116, 65, 73, 0, 0, 0, 0, 16, 124, 65,
				117, 100, 105, 111, 69, 118, 101, 110, 116, 80,
				114, 111, 120, 121, 0, 0, 0, 0, 19, 68,
				117, 99, 107, 111, 118, 124, 65, 117, 100, 105,
				111, 77, 97, 110, 97, 103, 101, 114, 0, 0,
				0, 0, 23, 68, 117, 99, 107, 111, 118, 46,
				65, 117, 100, 105, 111, 77, 97, 110, 97, 103,
				101, 114, 124, 66, 117, 115, 0, 0, 0, 0,
				18, 68, 117, 99, 107, 111, 118, 124, 65, 117,
				100, 105, 111, 79, 98, 106, 101, 99, 116, 0,
				0, 0, 0, 16, 124, 66, 97, 115, 101, 66,
				71, 77, 83, 101, 108, 101, 99, 116, 111, 114,
				0, 0, 0, 0, 21, 66, 97, 115, 101, 66,
				71, 77, 83, 101, 108, 101, 99, 116, 111, 114,
				124, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				20, 124, 76, 111, 111, 112, 83, 111, 117, 110,
				100, 87, 105, 116, 104, 79, 98, 106, 101, 99,
				116, 0, 0, 0, 0, 17, 124, 80, 108, 97,
				121, 69, 118, 101, 110, 116, 79, 110, 65, 119,
				97, 107, 101, 0, 0, 0, 0, 19, 124, 80,
				108, 97, 121, 72, 117, 114, 116, 69, 118, 101,
				110, 116, 80, 114, 111, 120, 121, 0, 0, 0,
				0, 11, 124, 83, 102, 120, 79, 110, 67, 108,
				105, 99, 107, 0, 0, 0, 0, 17, 68, 117,
				99, 107, 111, 118, 46, 66, 117, 102, 102, 115,
				124, 66, 117, 102, 102, 0, 0, 0, 0, 33,
				68, 117, 99, 107, 111, 118, 46, 66, 117, 102,
				102, 115, 124, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 66, 117, 102, 102, 77, 97, 110, 97,
				103, 101, 114, 0, 0, 0, 0, 10, 124, 67,
				97, 109, 101, 114, 97, 65, 114, 109, 0, 0,
				0, 0, 11, 124, 71, 97, 109, 101, 67, 97,
				109, 101, 114, 97, 0, 0, 0, 0, 19, 124,
				72, 105, 100, 101, 73, 102, 83, 105, 99, 107,
				70, 114, 105, 101, 110, 100, 108, 121, 0, 0,
				0, 0, 15, 124, 65, 73, 95, 80, 97, 116,
				104, 67, 111, 110, 116, 114, 111, 108, 0, 0,
				0, 0, 10, 124, 66, 114, 101, 97, 107, 97,
				98, 108, 101, 0, 0, 0, 0, 10, 124, 67,
				65, 95, 65, 116, 116, 97, 99, 107, 0, 0,
				0, 0, 9, 124, 67, 65, 95, 67, 97, 114,
				114, 121, 0, 0, 0, 0, 8, 124, 67, 65,
				95, 68, 97, 115, 104, 0, 0, 0, 0, 12,
				124, 67, 65, 95, 73, 110, 116, 101, 114, 97,
				99, 116, 0, 0, 0, 0, 10, 124, 67, 65,
				95, 82, 101, 108, 111, 97, 100, 0, 0, 0,
				0, 9, 124, 67, 65, 95, 83, 107, 105, 108,
				108, 0, 0, 0, 0, 11, 124, 67, 65, 95,
				85, 115, 101, 73, 116, 101, 109, 0, 0, 0,
				0, 20, 124, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 65, 99, 116, 105, 111, 110, 66, 97,
				115, 101, 0, 0, 0, 0, 16, 68, 117, 99,
				107, 111, 118, 124, 73, 80, 114, 111, 103, 114,
				101, 115, 115, 0, 0, 0, 0, 15, 68, 117,
				99, 107, 111, 118, 124, 80, 114, 111, 103, 114,
				101, 115, 115, 0, 0, 0, 0, 26, 124, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 65, 110,
				105, 109, 97, 116, 105, 111, 110, 67, 111, 110,
				116, 114, 111, 108, 0, 0, 0, 0, 37, 124,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 67, 111,
				110, 116, 114, 111, 108, 95, 77, 97, 103, 105,
				99, 66, 108, 101, 110, 100, 0, 0, 0, 0,
				29, 124, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 69, 113, 117, 105, 112, 109, 101, 110, 116,
				67, 111, 110, 116, 114, 111, 108, 108, 101, 114,
				0, 0, 0, 0, 21, 124, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 73, 116, 101, 109, 67,
				111, 110, 116, 114, 111, 108, 1, 0, 0, 0,
				21, 124, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 77, 97, 105, 110, 67, 111, 110, 116, 114,
				111, 108, 1, 0, 0, 0, 21, 124, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 77, 97, 105,
				110, 67, 111, 110, 116, 114, 111, 108, 0, 0,
				0, 0, 15, 124, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 77, 111, 100, 101, 108, 0, 0,
				0, 0, 22, 124, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 83, 99, 101, 110, 101, 67, 111,
				110, 116, 114, 111, 108, 0, 0, 0, 0, 20,
				124, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				83, 111, 117, 110, 100, 77, 97, 107, 101, 114,
				0, 0, 0, 0, 20, 124, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 83, 117, 98, 86, 105,
				115, 117, 97, 108, 115, 0, 0, 0, 0, 13,
				124, 72, 97, 108, 102, 79, 98, 115, 116, 105,
				99, 108, 101, 0, 0, 0, 0, 20, 124, 72,
				97, 108, 102, 79, 98, 115, 116, 105, 99, 108,
				101, 84, 114, 105, 103, 103, 101, 114, 0, 0,
				0, 0, 13, 124, 72, 101, 97, 100, 67, 111,
				108, 108, 105, 100, 101, 114, 0, 0, 0, 0,
				7, 124, 72, 101, 97, 108, 116, 104, 0, 0,
				0, 0, 17, 124, 72, 101, 97, 108, 116, 104,
				83, 105, 109, 112, 108, 101, 66, 97, 115, 101,
				0, 0, 0, 0, 11, 124, 72, 117, 114, 116,
				86, 105, 115, 117, 97, 108, 0, 0, 0, 0,
				16, 124, 73, 116, 101, 109, 65, 103, 101, 110,
				116, 72, 111, 108, 100, 101, 114, 0, 0, 0,
				0, 19, 68, 117, 99, 107, 111, 118, 124, 73,
				116, 101, 109, 83, 104, 111, 114, 116, 99, 117,
				116, 0, 0, 0, 0, 28, 68, 117, 99, 107,
				111, 118, 46, 73, 116, 101, 109, 83, 104, 111,
				114, 116, 99, 117, 116, 124, 83, 97, 118, 101,
				68, 97, 116, 97, 0, 0, 0, 0, 9, 124,
				77, 111, 118, 101, 109, 101, 110, 116, 0, 0,
				0, 0, 16, 124, 67, 104, 101, 97, 116, 105,
				110, 103, 77, 97, 110, 97, 103, 101, 114, 0,
				0, 0, 0, 11, 124, 68, 97, 109, 97, 103,
				101, 73, 110, 102, 111, 0, 0, 0, 0, 14,
				124, 69, 108, 101, 109, 101, 110, 116, 70, 97,
				99, 116, 111, 114, 0, 0, 0, 0, 15, 124,
				68, 97, 109, 97, 103, 101, 82, 101, 99, 101,
				105, 118, 101, 114, 0, 0, 0, 0, 8, 124,
				71, 114, 101, 110, 97, 100, 101, 0, 0, 0,
				0, 11, 124, 80, 114, 111, 106, 101, 99, 116,
				105, 108, 101, 0, 0, 0, 0, 18, 124, 80,
				114, 111, 106, 101, 99, 116, 105, 108, 101, 67,
				111, 110, 116, 101, 120, 116, 0, 0, 0, 0,
				5, 124, 84, 101, 97, 109, 0, 0, 0, 0,
				32, 68, 117, 99, 107, 111, 118, 46, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 124, 67, 111,
				109, 109, 111, 110, 86, 97, 114, 105, 97, 98,
				108, 101, 115, 0, 0, 0, 0, 13, 124, 65,
				68, 83, 65, 105, 109, 77, 97, 114, 107, 101,
				114, 0, 0, 0, 0, 10, 124, 65, 105, 109,
				77, 97, 114, 107, 101, 114, 0, 0, 0, 0,
				16, 124, 65, 105, 109, 84, 97, 114, 103, 101,
				116, 70, 105, 110, 100, 101, 114, 0, 0, 0,
				0, 22, 124, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 73, 110, 112, 117, 116, 67, 111, 110,
				116, 114, 111, 108, 0, 0, 0, 0, 43, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 73, 110,
				112, 117, 116, 67, 111, 110, 116, 114, 111, 108,
				124, 73, 110, 112, 117, 116, 65, 99, 116, 105,
				111, 110, 82, 101, 102, 101, 114, 101, 110, 99,
				101, 115, 0, 0, 0, 0, 27, 124, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 84, 111, 117,
				99, 104, 73, 110, 112, 117, 116, 67, 111, 110,
				116, 114, 111, 108, 0, 0, 0, 0, 10, 124,
				72, 105, 116, 77, 97, 114, 107, 101, 114, 0,
				0, 0, 0, 16, 124, 83, 105, 110, 103, 108,
				101, 67, 114, 111, 115, 115, 104, 97, 105, 114,
				0, 0, 0, 0, 9, 124, 83, 107, 105, 108,
				108, 72, 85, 68, 0, 0, 0, 0, 20, 68,
				117, 99, 107, 111, 118, 124, 67, 117, 114, 115,
				111, 114, 77, 97, 110, 97, 103, 101, 114, 0,
				0, 0, 0, 17, 68, 117, 99, 107, 111, 118,
				124, 67, 117, 114, 115, 111, 114, 68, 97, 116,
				97, 0, 0, 0, 0, 26, 68, 117, 99, 107,
				111, 118, 124, 73, 67, 117, 114, 115, 111, 114,
				68, 97, 116, 97, 80, 114, 111, 118, 105, 100,
				101, 114, 0, 0, 0, 0, 40, 68, 117, 99,
				107, 111, 118, 46, 67, 117, 115, 116, 111, 109,
				101, 114, 83, 101, 114, 118, 105, 99, 101, 124,
				81, 117, 101, 115, 116, 105, 111, 110, 97, 105,
				114, 66, 117, 116, 116, 111, 110, 0, 0, 0,
				0, 25, 124, 83, 101, 116, 69, 110, 100, 105,
				110, 103, 77, 105, 115, 115, 108, 101, 80, 97,
				114, 97, 109, 101, 116, 101, 114, 0, 0, 0,
				0, 20, 124, 68, 121, 110, 97, 109, 105, 99,
				73, 116, 101, 109, 68, 101, 98, 117, 103, 103,
				101, 114, 0, 0, 0, 0, 18, 124, 82, 101,
				99, 116, 83, 116, 114, 117, 99, 116, 82, 101,
				102, 84, 101, 115, 116, 0, 0, 0, 0, 14,
				124, 83, 111, 100, 97, 73, 109, 103, 117, 105,
				84, 101, 115, 116, 0, 0, 0, 0, 29, 68,
				117, 99, 107, 111, 118, 46, 82, 117, 108, 101,
				115, 124, 71, 97, 109, 101, 82, 117, 108, 101,
				115, 77, 97, 110, 97, 103, 101, 114, 0, 0,
				0, 0, 48, 68, 117, 99, 107, 111, 118, 46,
				82, 117, 108, 101, 115, 46, 71, 97, 109, 101,
				82, 117, 108, 101, 115, 77, 97, 110, 97, 103,
				101, 114, 124, 82, 117, 108, 101, 73, 110, 100,
				101, 120, 70, 105, 108, 101, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 20, 68, 117, 99, 107,
				111, 118, 46, 82, 117, 108, 101, 115, 124, 82,
				117, 108, 101, 115, 101, 116, 0, 0, 0, 0,
				24, 68, 117, 99, 107, 111, 118, 46, 82, 117,
				108, 101, 115, 124, 82, 117, 108, 101, 115, 101,
				116, 70, 105, 108, 101, 0, 0, 0, 0, 14,
				124, 65, 100, 100, 66, 117, 102, 102, 65, 99,
				116, 105, 111, 110, 0, 0, 0, 0, 18, 124,
				67, 111, 115, 116, 83, 116, 97, 109, 105, 110,
				97, 65, 99, 116, 105, 111, 110, 0, 0, 0,
				0, 27, 68, 117, 99, 107, 111, 118, 46, 69,
				102, 102, 101, 99, 116, 115, 124, 68, 97, 109,
				97, 103, 101, 65, 99, 116, 105, 111, 110, 0,
				0, 0, 0, 9, 124, 70, 120, 65, 99, 116,
				105, 111, 110, 0, 0, 0, 0, 11, 124, 72,
				101, 97, 108, 65, 99, 116, 105, 111, 110, 0,
				0, 0, 0, 15, 124, 77, 111, 100, 105, 102,
				105, 101, 114, 65, 99, 116, 105, 111, 110, 0,
				0, 0, 0, 17, 124, 82, 101, 109, 111, 118,
				101, 66, 117, 102, 102, 65, 99, 116, 105, 111,
				110, 0, 0, 0, 0, 20, 124, 83, 112, 97,
				119, 110, 80, 97, 112, 101, 114, 66, 111, 120,
				65, 99, 116, 105, 111, 110, 0, 0, 0, 0,
				19, 124, 67, 104, 97, 114, 97, 99, 116, 101,
				114, 73, 115, 82, 117, 110, 110, 105, 110, 103,
				0, 0, 0, 0, 20, 124, 69, 108, 101, 109,
				101, 110, 116, 70, 97, 99, 116, 111, 114, 70,
				105, 108, 116, 101, 114, 0, 0, 0, 0, 18,
				124, 78, 111, 116, 72, 117, 114, 116, 70, 111,
				114, 83, 101, 99, 111, 110, 100, 115, 0, 0,
				0, 0, 36, 73, 116, 101, 109, 83, 116, 97,
				116, 115, 83, 121, 115, 116, 101, 109, 124, 79,
				110, 83, 104, 111, 111, 116, 65, 116, 116, 97,
				99, 107, 84, 114, 105, 103, 103, 101, 114, 0,
				0, 0, 0, 35, 73, 116, 101, 109, 83, 116,
				97, 116, 115, 83, 121, 115, 116, 101, 109, 124,
				79, 110, 84, 97, 107, 101, 68, 97, 109, 97,
				103, 101, 84, 114, 105, 103, 103, 101, 114, 0,
				0, 0, 0, 24, 124, 65, 73, 83, 112, 101,
				99, 105, 97, 108, 65, 116, 116, 97, 99, 104,
				109, 101, 110, 116, 66, 97, 115, 101, 0, 0,
				0, 0, 25, 124, 65, 73, 83, 112, 101, 99,
				105, 97, 108, 65, 116, 116, 97, 99, 104, 109,
				101, 110, 116, 95, 83, 104, 111, 112, 0, 0,
				0, 0, 40, 124, 65, 73, 83, 112, 101, 99,
				105, 97, 108, 65, 116, 116, 97, 99, 104, 109,
				101, 110, 116, 95, 83, 112, 97, 119, 110, 73,
				116, 101, 109, 79, 110, 67, 114, 105, 116, 75,
				105, 108, 108, 0, 0, 0, 0, 22, 124, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 82, 97,
				110, 100, 111, 109, 80, 114, 101, 115, 101, 116,
				0, 0, 0, 0, 42, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 82, 97, 110, 100, 111, 109,
				80, 114, 101, 115, 101, 116, 124, 83, 101, 116,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 83,
				116, 97, 116, 73, 110, 102, 111, 0, 0, 0,
				0, 21, 124, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 83, 112, 97, 119, 110, 101, 114, 66,
				97, 115, 101, 0, 0, 0, 0, 30, 124, 67,
				104, 97, 114, 97, 99, 116, 101, 114, 83, 112,
				97, 119, 110, 101, 114, 67, 111, 109, 112, 111,
				110, 101, 110, 116, 66, 97, 115, 101, 0, 0,
				0, 0, 22, 124, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 83, 112, 97, 119, 110, 101, 114,
				71, 114, 111, 117, 112, 0, 0, 0, 0, 30,
				124, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				83, 112, 97, 119, 110, 101, 114, 71, 114, 111,
				117, 112, 83, 101, 108, 101, 99, 116, 111, 114,
				0, 0, 0, 0, 21, 124, 67, 104, 97, 114,
				97, 99, 116, 101, 114, 83, 112, 97, 119, 110,
				101, 114, 82, 111, 111, 116, 0, 0, 0, 0,
				23, 124, 82, 97, 110, 100, 111, 109, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 83, 112, 97,
				119, 110, 101, 114, 0, 0, 0, 0, 26, 124,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 82,
				97, 110, 100, 111, 109, 80, 114, 101, 115, 101,
				116, 73, 110, 102, 111, 0, 0, 0, 0, 23,
				69, 118, 101, 110, 116, 82, 101, 112, 111, 114,
				116, 115, 124, 66, 68, 83, 77, 97, 110, 97,
				103, 101, 114, 0, 0, 0, 0, 52, 69, 118,
				101, 110, 116, 82, 101, 112, 111, 114, 116, 115,
				46, 66, 68, 83, 77, 97, 110, 97, 103, 101,
				114, 124, 67, 104, 101, 97, 116, 77, 111, 100,
				101, 83, 116, 97, 116, 117, 115, 67, 104, 97,
				110, 103, 101, 67, 111, 110, 116, 101, 120, 116,
				0, 0, 0, 0, 44, 69, 118, 101, 110, 116,
				82, 101, 112, 111, 114, 116, 115, 46, 66, 68,
				83, 77, 97, 110, 97, 103, 101, 114, 124, 73,
				110, 116, 101, 114, 97, 99, 116, 69, 118, 101,
				110, 116, 67, 111, 110, 116, 101, 120, 116, 0,
				0, 0, 0, 43, 69, 118, 101, 110, 116, 82,
				101, 112, 111, 114, 116, 115, 46, 66, 68, 83,
				77, 97, 110, 97, 103, 101, 114, 124, 73, 116,
				101, 109, 85, 115, 101, 69, 118, 101, 110, 116,
				67, 111, 110, 116, 101, 120, 116, 0, 0, 0,
				0, 47, 69, 118, 101, 110, 116, 82, 101, 112,
				111, 114, 116, 115, 46, 66, 68, 83, 77, 97,
				110, 97, 103, 101, 114, 124, 82, 101, 119, 97,
				114, 100, 67, 108, 97, 105, 109, 69, 118, 101,
				110, 116, 67, 111, 110, 116, 101, 120, 116, 0,
				0, 0, 0, 44, 69, 118, 101, 110, 116, 82,
				101, 112, 111, 114, 116, 115, 46, 66, 68, 83,
				77, 97, 110, 97, 103, 101, 114, 124, 73, 116,
				101, 109, 83, 111, 108, 100, 69, 118, 101, 110,
				116, 67, 111, 110, 116, 101, 120, 116, 0, 0,
				0, 0, 41, 69, 118, 101, 110, 116, 82, 101,
				112, 111, 114, 116, 115, 46, 66, 68, 83, 77,
				97, 110, 97, 103, 101, 114, 124, 69, 113, 117,
				105, 112, 69, 118, 101, 110, 116, 67, 111, 110,
				116, 101, 120, 116, 0, 0, 0, 0, 46, 69,
				118, 101, 110, 116, 82, 101, 112, 111, 114, 116,
				115, 46, 66, 68, 83, 77, 97, 110, 97, 103,
				101, 114, 124, 77, 97, 115, 116, 101, 114, 75,
				101, 121, 85, 110, 108, 111, 99, 107, 67, 111,
				110, 116, 101, 120, 116, 0, 0, 0, 0, 32,
				69, 118, 101, 110, 116, 82, 101, 112, 111, 114,
				116, 115, 46, 66, 68, 83, 77, 97, 110, 97,
				103, 101, 114, 124, 80, 101, 114, 107, 73, 110,
				102, 111, 0, 0, 0, 0, 44, 69, 118, 101,
				110, 116, 82, 101, 112, 111, 114, 116, 115, 46,
				66, 68, 83, 77, 97, 110, 97, 103, 101, 114,
				124, 66, 117, 105, 108, 100, 105, 110, 103, 69,
				118, 101, 110, 116, 67, 111, 110, 116, 101, 120,
				116, 0, 0, 0, 0, 48, 69, 118, 101, 110,
				116, 82, 101, 112, 111, 114, 116, 115, 46, 66,
				68, 83, 77, 97, 110, 97, 103, 101, 114, 124,
				76, 101, 118, 101, 108, 67, 104, 97, 110, 103,
				101, 100, 69, 118, 101, 110, 116, 67, 111, 110,
				116, 101, 120, 116, 0, 0, 0, 0, 37, 69,
				118, 101, 110, 116, 82, 101, 112, 111, 114, 116,
				115, 46, 66, 68, 83, 77, 97, 110, 97, 103,
				101, 114, 124, 69, 110, 101, 109, 121, 75, 105,
				108, 108, 73, 110, 102, 111, 0, 0, 0, 0,
				36, 69, 118, 101, 110, 116, 82, 101, 112, 111,
				114, 116, 115, 46, 66, 68, 83, 77, 97, 110,
				97, 103, 101, 114, 124, 80, 117, 114, 99, 104,
				97, 115, 101, 73, 110, 102, 111, 0, 0, 0,
				0, 32, 69, 118, 101, 110, 116, 82, 101, 112,
				111, 114, 116, 115, 46, 66, 68, 83, 77, 97,
				110, 97, 103, 101, 114, 124, 73, 116, 101, 109,
				73, 110, 102, 111, 0, 0, 0, 0, 45, 69,
				118, 101, 110, 116, 82, 101, 112, 111, 114, 116,
				115, 46, 66, 68, 83, 77, 97, 110, 97, 103,
				101, 114, 124, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 68, 101, 97, 116, 104, 67, 111, 110,
				116, 101, 120, 116, 0, 0, 0, 0, 36, 69,
				118, 101, 110, 116, 82, 101, 112, 111, 114, 116,
				115, 46, 66, 68, 83, 77, 97, 110, 97, 103,
				101, 114, 124, 80, 108, 97, 121, 101, 114, 83,
				116, 97, 116, 117, 115, 0, 0, 0, 0, 43,
				69, 118, 101, 110, 116, 82, 101, 112, 111, 114,
				116, 115, 46, 66, 68, 83, 77, 97, 110, 97,
				103, 101, 114, 124, 69, 118, 97, 99, 117, 97,
				116, 105, 111, 110, 69, 118, 101, 110, 116, 68,
				97, 116, 97, 0, 0, 0, 0, 35, 69, 118,
				101, 110, 116, 82, 101, 112, 111, 114, 116, 115,
				46, 66, 68, 83, 77, 97, 110, 97, 103, 101,
				114, 124, 83, 101, 115, 115, 105, 111, 110, 73,
				110, 102, 111, 0, 0, 0, 0, 34, 69, 118,
				101, 110, 116, 82, 101, 112, 111, 114, 116, 115,
				46, 66, 68, 83, 77, 97, 110, 97, 103, 101,
				114, 124, 80, 108, 97, 121, 101, 114, 73, 110,
				102, 111, 0, 0, 0, 0, 8, 124, 83, 116,
				114, 74, 115, 111, 110, 0, 0, 0, 0, 13,
				83, 116, 114, 74, 115, 111, 110, 124, 69, 110,
				116, 114, 121, 0, 0, 0, 0, 17, 68, 117,
				99, 107, 111, 118, 124, 69, 88, 80, 77, 97,
				110, 97, 103, 101, 114, 0, 0, 0, 0, 31,
				124, 67, 104, 97, 114, 97, 99, 116, 101, 114,
				77, 97, 105, 110, 67, 111, 110, 116, 114, 111,
				108, 69, 120, 116, 101, 110, 115, 105, 111, 110,
				115, 0, 0, 0, 0, 16, 124, 67, 111, 108,
				111, 114, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 0, 0, 0, 0, 24, 124, 82, 101,
				99, 116, 84, 114, 97, 110, 115, 102, 111, 114,
				109, 69, 120, 116, 101, 110, 115, 105, 111, 110,
				115, 0, 0, 0, 0, 13, 124, 84, 97, 103,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 0,
				0, 0, 0, 12, 124, 71, 97, 109, 101, 77,
				97, 110, 97, 103, 101, 114, 0, 0, 0, 0,
				26, 68, 117, 99, 107, 111, 118, 124, 82, 105,
				99, 104, 80, 114, 101, 115, 101, 110, 99, 101,
				77, 97, 110, 97, 103, 101, 114, 0, 0, 0,
				0, 17, 124, 84, 105, 109, 101, 83, 99, 97,
				108, 101, 77, 97, 110, 97, 103, 101, 114, 0,
				0, 0, 0, 10, 124, 67, 97, 114, 114, 105,
				97, 98, 108, 101, 0, 0, 0, 0, 4, 124,
				69, 103, 103, 0, 0, 0, 0, 14, 124, 69,
				110, 100, 105, 110, 103, 67, 111, 110, 116, 114,
				111, 108, 0, 0, 0, 0, 17, 124, 70, 105,
				108, 108, 87, 97, 116, 101, 114, 65, 110, 100,
				70, 111, 111, 100, 0, 0, 0, 0, 15, 124,
				65, 99, 116, 105, 111, 110, 95, 70, 105, 115,
				104, 105, 110, 103, 0, 0, 0, 0, 17, 124,
				65, 99, 116, 105, 111, 110, 95, 70, 105, 115,
				104, 105, 110, 103, 86, 50, 0, 0, 0, 0,
				13, 124, 70, 105, 115, 104, 105, 110, 103, 80,
				111, 105, 110, 116, 0, 0, 0, 0, 9, 124,
				70, 111, 119, 83, 109, 111, 107, 101, 0, 0,
				0, 0, 24, 124, 83, 101, 116, 73, 110, 76,
				101, 118, 101, 108, 68, 97, 116, 97, 66, 111,
				111, 108, 80, 114, 111, 120, 121, 0, 0, 0,
				0, 20, 124, 73, 110, 118, 105, 115, 105, 98,
				108, 101, 84, 101, 108, 101, 112, 111, 114, 116,
				101, 114, 0, 0, 0, 0, 10, 124, 75, 117,
				110, 69, 118, 101, 110, 116, 115, 0, 0, 0,
				0, 9, 124, 80, 97, 112, 101, 114, 66, 111,
				120, 0, 0, 0, 0, 21, 124, 82, 97, 110,
				100, 111, 109, 65, 99, 116, 105, 118, 101, 83,
				101, 108, 101, 99, 116, 111, 114, 0, 0, 0,
				0, 18, 124, 83, 97, 118, 101, 68, 97, 116,
				97, 66, 111, 111, 108, 80, 114, 111, 120, 121,
				0, 0, 0, 0, 18, 124, 83, 101, 116, 65,
				99, 116, 105, 118, 101, 66, 121, 67, 104, 97,
				110, 99, 101, 0, 0, 0, 0, 21, 124, 83,
				101, 116, 65, 99, 116, 105, 118, 101, 66, 121,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 0,
				0, 0, 0, 28, 124, 83, 101, 116, 84, 105,
				109, 101, 79, 110, 69, 110, 116, 101, 114, 66,
				97, 115, 101, 70, 105, 114, 115, 116, 84, 105,
				109, 101, 0, 0, 0, 0, 17, 124, 83, 105,
				109, 112, 108, 101, 84, 101, 108, 101, 112, 111,
				114, 116, 101, 114, 0, 0, 0, 0, 24, 124,
				83, 105, 109, 112, 108, 101, 84, 101, 108, 101,
				112, 111, 114, 116, 101, 114, 83, 112, 97, 119,
				110, 101, 114, 0, 0, 0, 0, 14, 124, 83,
				111, 117, 108, 67, 111, 108, 108, 101, 99, 116,
				111, 114, 0, 0, 0, 0, 9, 124, 83, 111,
				117, 108, 67, 117, 98, 101, 0, 0, 0, 0,
				19, 124, 83, 112, 97, 99, 101, 83, 104, 105,
				112, 73, 110, 115, 116, 97, 108, 108, 101, 114,
				0, 0, 0, 0, 15, 124, 84, 101, 108, 101,
				112, 111, 114, 116, 66, 101, 97, 99, 111, 110,
				0, 0, 0, 0, 14, 124, 87, 105, 115, 104,
				76, 105, 115, 116, 80, 114, 111, 120, 121, 0,
				0, 0, 0, 5, 124, 90, 111, 110, 101, 0,
				0, 0, 0, 11, 124, 90, 111, 110, 101, 68,
				97, 109, 97, 103, 101, 0, 0, 0, 0, 37,
				68, 117, 99, 107, 111, 118, 46, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 124, 71, 97, 109,
				101, 112, 108, 97, 121, 68, 97, 116, 97, 83,
				101, 116, 116, 105, 110, 103, 115, 0, 0, 0,
				0, 49, 68, 117, 99, 107, 111, 118, 46, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 46, 71,
				97, 109, 101, 112, 108, 97, 121, 68, 97, 116,
				97, 83, 101, 116, 116, 105, 110, 103, 115, 124,
				76, 111, 111, 116, 105, 110, 103, 68, 97, 116,
				97, 0, 0, 0, 0, 46, 68, 117, 99, 107,
				111, 118, 46, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 46, 71, 97, 109, 101, 112, 108, 97,
				121, 68, 97, 116, 97, 83, 101, 116, 116, 105,
				110, 103, 115, 124, 84, 97, 103, 115, 68, 97,
				116, 97, 0, 0, 0, 0, 49, 68, 117, 99,
				107, 111, 118, 46, 85, 116, 105, 108, 105, 116,
				105, 101, 115, 46, 71, 97, 109, 101, 112, 108,
				97, 121, 68, 97, 116, 97, 83, 101, 116, 116,
				105, 110, 103, 115, 124, 80, 114, 101, 102, 97,
				98, 115, 68, 97, 116, 97, 0, 0, 0, 0,
				47, 68, 117, 99, 107, 111, 118, 46, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 46, 71, 97,
				109, 101, 112, 108, 97, 121, 68, 97, 116, 97,
				83, 101, 116, 116, 105, 110, 103, 115, 124, 66,
				117, 102, 102, 115, 68, 97, 116, 97, 0, 0,
				0, 0, 52, 68, 117, 99, 107, 111, 118, 46,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 46,
				71, 97, 109, 101, 112, 108, 97, 121, 68, 97,
				116, 97, 83, 101, 116, 116, 105, 110, 103, 115,
				124, 73, 116, 101, 109, 65, 115, 115, 101, 116,
				115, 68, 97, 116, 97, 0, 0, 0, 0, 53,
				68, 117, 99, 107, 111, 118, 46, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 46, 71, 97, 109,
				101, 112, 108, 97, 121, 68, 97, 116, 97, 83,
				101, 116, 116, 105, 110, 103, 115, 124, 83, 116,
				114, 105, 110, 103, 76, 105, 115, 116, 115, 68,
				97, 116, 97, 0, 0, 0, 0, 48, 68, 117,
				99, 107, 111, 118, 46, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 46, 71, 97, 109, 101, 112,
				108, 97, 121, 68, 97, 116, 97, 83, 101, 116,
				116, 105, 110, 103, 115, 124, 76, 97, 121, 101,
				114, 115, 68, 97, 116, 97, 0, 0, 0, 0,
				57, 68, 117, 99, 107, 111, 118, 46, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 46, 71, 97,
				109, 101, 112, 108, 97, 121, 68, 97, 116, 97,
				83, 101, 116, 116, 105, 110, 103, 115, 124, 83,
				99, 101, 110, 101, 77, 97, 110, 97, 103, 101,
				109, 101, 110, 116, 68, 97, 116, 97, 0, 0,
				0, 0, 48, 68, 117, 99, 107, 111, 118, 46,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 46,
				71, 97, 109, 101, 112, 108, 97, 121, 68, 97,
				116, 97, 83, 101, 116, 116, 105, 110, 103, 115,
				124, 81, 117, 101, 115, 116, 115, 68, 97, 116,
				97, 0, 0, 0, 0, 63, 68, 117, 99, 107,
				111, 118, 46, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 46, 71, 97, 109, 101, 112, 108, 97,
				121, 68, 97, 116, 97, 83, 101, 116, 116, 105,
				110, 103, 115, 43, 81, 117, 101, 115, 116, 115,
				68, 97, 116, 97, 124, 81, 117, 101, 115, 116,
				71, 105, 118, 101, 114, 73, 110, 102, 111, 0,
				0, 0, 0, 49, 68, 117, 99, 107, 111, 118,
				46, 85, 116, 105, 108, 105, 116, 105, 101, 115,
				46, 71, 97, 109, 101, 112, 108, 97, 121, 68,
				97, 116, 97, 83, 101, 116, 116, 105, 110, 103,
				115, 124, 69, 99, 111, 110, 111, 109, 121, 68,
				97, 116, 97, 0, 0, 0, 0, 49, 68, 117,
				99, 107, 111, 118, 46, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 46, 71, 97, 109, 101, 112,
				108, 97, 121, 68, 97, 116, 97, 83, 101, 116,
				116, 105, 110, 103, 115, 124, 85, 73, 83, 116,
				121, 108, 101, 68, 97, 116, 97, 0, 0, 0,
				0, 68, 68, 117, 99, 107, 111, 118, 46, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 46, 71,
				97, 109, 101, 112, 108, 97, 121, 68, 97, 116,
				97, 83, 101, 116, 116, 105, 110, 103, 115, 43,
				85, 73, 83, 116, 121, 108, 101, 68, 97, 116,
				97, 124, 68, 105, 115, 112, 108, 97, 121, 81,
				117, 97, 108, 105, 116, 121, 76, 111, 111, 107,
				0, 0, 0, 0, 81, 68, 117, 99, 107, 111,
				118, 46, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 46, 71, 97, 109, 101, 112, 108, 97, 121,
				68, 97, 116, 97, 83, 101, 116, 116, 105, 110,
				103, 115, 43, 85, 73, 83, 116, 121, 108, 101,
				68, 97, 116, 97, 124, 68, 105, 115, 112, 108,
				97, 121, 69, 108, 101, 109, 101, 110, 116, 68,
				97, 109, 97, 103, 101, 80, 111, 112, 84, 101,
				120, 116, 76, 111, 111, 107, 0, 0, 0, 0,
				49, 68, 117, 99, 107, 111, 118, 46, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 46, 71, 97,
				109, 101, 112, 108, 97, 121, 68, 97, 116, 97,
				83, 101, 116, 116, 105, 110, 103, 115, 124, 83,
				112, 114, 105, 116, 101, 115, 68, 97, 116, 97,
				0, 0, 0, 0, 55, 68, 117, 99, 107, 111,
				118, 46, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 46, 71, 97, 109, 101, 112, 108, 97, 121,
				68, 97, 116, 97, 83, 101, 116, 116, 105, 110,
				103, 115, 43, 83, 112, 114, 105, 116, 101, 115,
				68, 97, 116, 97, 124, 69, 110, 116, 114, 121,
				0, 0, 0, 0, 28, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 124, 85, 73, 80, 114, 101,
				102, 97, 98, 115, 82, 101, 102, 101, 114, 101,
				110, 99, 101, 0, 0, 0, 0, 28, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 124, 66, 117,
				102, 102, 68, 101, 116, 97, 105, 108, 115, 79,
				118, 101, 114, 108, 97, 121, 0, 0, 0, 0,
				22, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 66, 117, 102, 102, 115, 68, 105, 115, 112,
				108, 97, 121, 0, 0, 0, 0, 27, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 124, 66, 117,
				102, 102, 115, 68, 105, 115, 112, 108, 97, 121,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 15,
				124, 66, 117, 108, 108, 101, 116, 67, 111, 117,
				110, 116, 72, 85, 68, 0, 0, 0, 0, 14,
				124, 66, 117, 108, 108, 101, 116, 84, 121, 112,
				101, 72, 85, 68, 0, 0, 0, 0, 23, 124,
				66, 117, 108, 108, 101, 116, 84, 121, 112, 101,
				83, 101, 108, 101, 99, 116, 66, 117, 116, 116,
				111, 110, 0, 0, 0, 0, 10, 124, 69, 110,
				101, 114, 103, 121, 72, 85, 68, 0, 0, 0,
				0, 10, 124, 72, 101, 97, 108, 116, 104, 72,
				85, 68, 0, 0, 0, 0, 13, 124, 73, 110,
				100, 105, 99, 97, 116, 111, 114, 72, 85, 68,
				0, 0, 0, 0, 11, 124, 83, 116, 97, 109,
				105, 110, 97, 72, 85, 68, 0, 0, 0, 0,
				9, 124, 87, 97, 116, 101, 114, 72, 85, 68,
				0, 0, 0, 0, 14, 83, 111, 100, 97, 124,
				68, 101, 98, 117, 103, 86, 105, 101, 119, 0,
				0, 0, 0, 12, 124, 73, 110, 116, 101, 114,
				97, 99, 116, 72, 85, 68, 0, 0, 0, 0,
				21, 124, 73, 110, 116, 101, 114, 97, 99, 116,
				83, 101, 108, 101, 99, 116, 105, 111, 110, 72,
				85, 68, 0, 0, 0, 0, 22, 124, 69, 118,
				97, 99, 117, 97, 116, 105, 111, 110, 67, 111,
				117, 110, 116, 100, 111, 119, 110, 85, 73, 0,
				0, 0, 0, 18, 124, 78, 111, 116, 105, 102,
				105, 99, 97, 116, 105, 111, 110, 80, 114, 111,
				120, 121, 0, 0, 0, 0, 26, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 124, 78, 111, 116,
				105, 102, 105, 99, 97, 116, 105, 111, 110, 84,
				101, 120, 116, 0, 0, 0, 0, 18, 124, 65,
				99, 116, 105, 111, 110, 80, 114, 111, 103, 114,
				101, 115, 115, 72, 85, 68, 0, 0, 0, 0,
				19, 124, 70, 111, 108, 108, 111, 119, 67, 104,
				97, 114, 97, 99, 116, 101, 114, 72, 85, 68,
				0, 0, 0, 0, 14, 124, 76, 105, 116, 116,
				108, 101, 77, 111, 118, 101, 72, 85, 68, 0,
				0, 0, 0, 10, 124, 82, 101, 108, 111, 97,
				100, 72, 85, 68, 0, 0, 0, 0, 16, 124,
				83, 104, 97, 112, 101, 115, 83, 107, 105, 108,
				108, 76, 105, 110, 101, 0, 0, 0, 0, 11,
				124, 83, 107, 105, 108, 108, 72, 117, 100, 51,
				68, 0, 0, 0, 0, 23, 124, 83, 107, 105,
				108, 108, 80, 114, 111, 106, 101, 99, 116, 105,
				108, 101, 76, 105, 110, 101, 72, 85, 68, 0,
				0, 0, 0, 14, 124, 83, 107, 105, 108, 108,
				82, 97, 110, 103, 101, 72, 85, 68, 0, 0,
				0, 0, 19, 124, 83, 121, 110, 99, 68, 101,
				98, 117, 103, 69, 100, 103, 101, 76, 105, 103,
				104, 116, 0, 0, 0, 0, 15, 124, 84, 105,
				109, 101, 79, 102, 68, 97, 121, 65, 108, 101,
				114, 116, 0, 0, 0, 0, 27, 124, 84, 105,
				109, 101, 79, 102, 68, 97, 121, 65, 108, 101,
				114, 116, 84, 114, 105, 103, 103, 101, 114, 80,
				114, 111, 120, 121, 0, 0, 0, 0, 17, 124,
				84, 105, 109, 101, 79, 102, 68, 97, 121, 68,
				105, 115, 112, 108, 97, 121, 0, 0, 0, 0,
				13, 124, 87, 101, 105, 103, 104, 116, 66, 97,
				114, 72, 85, 68, 0, 0, 0, 0, 17, 124,
				67, 111, 110, 115, 116, 114, 117, 99, 116, 105,
				111, 110, 83, 105, 116, 101, 0, 0, 0, 0,
				10, 124, 67, 111, 115, 116, 84, 97, 107, 101,
				114, 0, 0, 0, 0, 13, 124, 67, 111, 115,
				116, 84, 97, 107, 101, 114, 72, 85, 68, 0,
				0, 0, 0, 19, 124, 67, 111, 115, 116, 84,
				97, 107, 101, 114, 72, 85, 68, 95, 69, 110,
				116, 114, 121, 0, 0, 0, 0, 5, 124, 68,
				111, 111, 114, 0, 0, 0, 0, 22, 68, 111,
				111, 114, 124, 68, 111, 111, 114, 84, 114, 97,
				110, 115, 102, 111, 114, 109, 73, 110, 102, 111,
				0, 0, 0, 0, 12, 124, 68, 111, 111, 114,
				84, 114, 105, 103, 103, 101, 114, 0, 0, 0,
				0, 17, 124, 73, 110, 116, 101, 114, 97, 99,
				116, 97, 98, 108, 101, 66, 97, 115, 101, 0,
				0, 0, 0, 22, 124, 73, 110, 116, 101, 114,
				97, 99, 116, 97, 98, 108, 101, 67, 97, 114,
				114, 105, 97, 98, 108, 101, 0, 0, 0, 0,
				20, 124, 73, 110, 116, 101, 114, 97, 99, 116,
				97, 98, 108, 101, 76, 111, 111, 116, 98, 111,
				120, 0, 0, 0, 0, 19, 124, 73, 110, 116,
				101, 114, 97, 99, 116, 97, 98, 108, 101, 80,
				105, 99, 107, 117, 112, 0, 0, 0, 0, 15,
				124, 73, 110, 116, 101, 114, 97, 99, 116, 77,
				97, 114, 107, 101, 114, 0, 0, 0, 0, 15,
				124, 73, 116, 101, 109, 83, 116, 97, 114, 116,
				101, 114, 107, 105, 116, 0, 0, 0, 0, 20,
				124, 79, 110, 84, 114, 105, 103, 103, 101, 114,
				69, 110, 116, 101, 114, 69, 118, 101, 110, 116,
				0, 0, 0, 0, 22, 124, 83, 101, 116, 68,
				111, 111, 114, 79, 112, 101, 110, 73, 102, 83,
				97, 118, 101, 68, 97, 116, 97, 0, 0, 0,
				0, 27, 68, 117, 99, 107, 111, 118, 46, 84,
				97, 115, 107, 115, 124, 73, 84, 97, 115, 107,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 0,
				0, 0, 0, 16, 124, 68, 117, 99, 107, 111,
				118, 73, 116, 101, 109, 65, 103, 101, 110, 116,
				0, 0, 0, 0, 13, 124, 73, 65, 103, 101,
				110, 116, 85, 115, 97, 98, 108, 101, 0, 0,
				0, 0, 11, 124, 70, 105, 115, 104, 105, 110,
				103, 82, 111, 100, 0, 0, 0, 0, 14, 124,
				73, 116, 101, 109, 65, 103, 101, 110, 116, 95,
				71, 117, 110, 0, 0, 0, 0, 22, 124, 73,
				116, 101, 109, 65, 103, 101, 110, 116, 95, 77,
				101, 108, 101, 101, 87, 101, 97, 112, 111, 110,
				0, 0, 0, 0, 15, 124, 83, 97, 118, 101,
				100, 73, 110, 118, 101, 110, 116, 111, 114, 121,
				0, 0, 0, 0, 20, 124, 73, 110, 118, 101,
				110, 116, 111, 114, 121, 69, 120, 116, 101, 110,
				115, 105, 111, 110, 115, 0, 0, 0, 0, 15,
				124, 73, 116, 101, 109, 69, 120, 116, 101, 110,
				115, 105, 111, 110, 115, 0, 0, 0, 0, 16,
				124, 73, 116, 101, 109, 83, 101, 116, 116, 105,
				110, 103, 66, 97, 115, 101, 0, 0, 0, 0,
				22, 124, 73, 116, 101, 109, 83, 101, 116, 116,
				105, 110, 103, 95, 65, 99, 99, 101, 115, 115,
				111, 114, 121, 0, 0, 0, 0, 19, 124, 73,
				116, 101, 109, 83, 101, 116, 116, 105, 110, 103,
				95, 66, 117, 108, 108, 101, 116, 0, 0, 0,
				0, 20, 124, 73, 116, 101, 109, 83, 101, 116,
				116, 105, 110, 103, 95, 70, 111, 114, 109, 117,
				108, 97, 0, 0, 0, 0, 16, 124, 73, 116,
				101, 109, 83, 101, 116, 116, 105, 110, 103, 95,
				71, 80, 85, 0, 0, 0, 0, 16, 124, 73,
				116, 101, 109, 83, 101, 116, 116, 105, 110, 103,
				95, 71, 117, 110, 0, 0, 0, 0, 15, 124,
				66, 117, 108, 108, 101, 116, 84, 121, 112, 101,
				73, 110, 102, 111, 0, 0, 0, 0, 24, 124,
				73, 116, 101, 109, 83, 101, 116, 116, 105, 110,
				103, 95, 77, 101, 108, 101, 101, 87, 101, 97,
				112, 111, 110, 0, 0, 0, 0, 24, 124, 73,
				116, 101, 109, 83, 101, 116, 116, 105, 110, 103,
				95, 78, 105, 103, 104, 116, 86, 105, 115, 105,
				111, 110, 0, 0, 0, 0, 18, 124, 73, 116,
				101, 109, 83, 101, 116, 116, 105, 110, 103, 95,
				83, 107, 105, 108, 108, 0, 0, 0, 0, 14,
				124, 73, 116, 101, 109, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 0, 0, 0, 0, 14, 124,
				80, 108, 97, 121, 101, 114, 83, 116, 111, 114,
				97, 103, 101, 0, 0, 0, 0, 46, 80, 108,
				97, 121, 101, 114, 83, 116, 111, 114, 97, 103,
				101, 124, 83, 116, 111, 114, 97, 103, 101, 67,
				97, 112, 97, 99, 105, 116, 121, 67, 97, 108,
				99, 117, 108, 97, 116, 105, 111, 110, 72, 111,
				108, 100, 101, 114, 0, 0, 0, 0, 20, 124,
				80, 108, 97, 121, 101, 114, 83, 116, 111, 114,
				97, 103, 101, 66, 117, 102, 102, 101, 114, 0,
				0, 0, 0, 30, 124, 82, 97, 110, 100, 111,
				109, 73, 116, 101, 109, 71, 101, 110, 101, 114,
				97, 116, 101, 68, 101, 115, 99, 114, 105, 112,
				116, 105, 111, 110, 0, 0, 0, 0, 6, 124,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 24,
				68, 117, 99, 107, 111, 118, 46, 73, 116, 101,
				109, 85, 115, 97, 103, 101, 124, 65, 100, 100,
				66, 117, 102, 102, 0, 0, 0, 0, 29, 68,
				117, 99, 107, 111, 118, 46, 73, 116, 101, 109,
				85, 115, 97, 103, 101, 124, 68, 101, 97, 100,
				66, 121, 67, 104, 97, 110, 99, 101, 0, 0,
				0, 0, 21, 68, 117, 99, 107, 111, 118, 46,
				73, 116, 101, 109, 85, 115, 97, 103, 101, 124,
				68, 114, 117, 103, 0, 0, 0, 0, 26, 68,
				117, 99, 107, 111, 118, 46, 73, 116, 101, 109,
				85, 115, 97, 103, 101, 124, 70, 111, 111, 100,
				68, 114, 105, 110, 107, 0, 0, 0, 0, 27,
				68, 117, 99, 107, 111, 118, 46, 73, 116, 101,
				109, 85, 115, 97, 103, 101, 124, 82, 101, 109,
				111, 118, 101, 66, 117, 102, 102, 0, 0, 0,
				0, 25, 68, 117, 99, 107, 111, 118, 46, 73,
				116, 101, 109, 85, 115, 97, 103, 101, 124, 83,
				112, 97, 119, 110, 69, 103, 103, 0, 0, 0,
				0, 16, 124, 85, 115, 101, 84, 111, 67, 114,
				101, 97, 116, 101, 73, 116, 101, 109, 0, 0,
				0, 0, 21, 85, 115, 101, 84, 111, 67, 114,
				101, 97, 116, 101, 73, 116, 101, 109, 124, 69,
				110, 116, 114, 121, 0, 0, 0, 0, 12, 124,
				65, 73, 77, 97, 105, 110, 66, 114, 97, 105,
				110, 0, 0, 0, 0, 29, 65, 73, 77, 97,
				105, 110, 66, 114, 97, 105, 110, 124, 83, 101,
				97, 114, 99, 104, 84, 97, 115, 107, 67, 111,
				110, 116, 101, 120, 116, 0, 0, 0, 0, 36,
				65, 73, 77, 97, 105, 110, 66, 114, 97, 105,
				110, 124, 67, 104, 101, 99, 107, 79, 98, 115,
				116, 105, 99, 108, 101, 84, 97, 115, 107, 67,
				111, 110, 116, 101, 120, 116, 0, 0, 0, 0,
				8, 124, 65, 73, 83, 111, 117, 110, 100, 0,
				0, 0, 0, 17, 124, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 67, 114, 101, 97, 116, 111,
				114, 0, 0, 0, 0, 21, 124, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 80, 111, 115, 73,
				110, 83, 104, 97, 100, 101, 114, 0, 0, 0,
				0, 18, 124, 67, 117, 115, 116, 111, 109, 70,
				97, 99, 101, 77, 97, 110, 97, 103, 101, 114,
				0, 0, 0, 0, 12, 124, 69, 120, 105, 116,
				67, 114, 101, 97, 116, 111, 114, 0, 0, 0,
				0, 17, 124, 69, 120, 112, 108, 111, 115, 105,
				111, 110, 77, 97, 110, 97, 103, 101, 114, 0,
				0, 0, 0, 13, 124, 73, 110, 112, 117, 116,
				77, 97, 110, 97, 103, 101, 114, 0, 0, 0,
				0, 25, 124, 73, 73, 110, 105, 116, 105, 97,
				108, 105, 122, 101, 100, 81, 117, 101, 114, 121,
				72, 97, 110, 100, 108, 101, 114, 0, 0, 0,
				0, 12, 124, 76, 101, 118, 101, 108, 67, 111,
				110, 102, 105, 103, 0, 0, 0, 0, 13, 124,
				76, 101, 118, 101, 108, 77, 97, 110, 97, 103,
				101, 114, 0, 0, 0, 0, 22, 76, 101, 118,
				101, 108, 77, 97, 110, 97, 103, 101, 114, 124,
				76, 101, 118, 101, 108, 73, 110, 102, 111, 0,
				0, 0, 0, 15, 124, 69, 118, 97, 99, 117,
				97, 116, 105, 111, 110, 73, 110, 102, 111, 0,
				0, 0, 0, 12, 124, 76, 111, 111, 116, 77,
				97, 110, 97, 103, 101, 114, 0, 0, 0, 0,
				9, 124, 80, 101, 116, 80, 114, 111, 120, 121,
				0, 0, 0, 0, 28, 124, 80, 108, 97, 121,
				101, 114, 80, 111, 115, 105, 116, 105, 111, 110,
				66, 97, 99, 107, 117, 112, 77, 97, 110, 97,
				103, 101, 114, 0, 0, 0, 0, 53, 80, 108,
				97, 121, 101, 114, 80, 111, 115, 105, 116, 105,
				111, 110, 66, 97, 99, 107, 117, 112, 77, 97,
				110, 97, 103, 101, 114, 124, 80, 108, 97, 121,
				101, 114, 80, 111, 115, 105, 116, 105, 111, 110,
				66, 97, 99, 107, 117, 112, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 26, 124, 80, 108, 97,
				121, 101, 114, 80, 111, 115, 105, 116, 105, 111,
				110, 66, 97, 99, 107, 117, 112, 80, 114, 111,
				120, 121, 0, 0, 0, 0, 11, 124, 66, 117,
				108, 108, 101, 116, 80, 111, 111, 108, 0, 0,
				0, 0, 28, 68, 117, 99, 107, 111, 118, 46,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 124,
				70, 105, 115, 104, 83, 112, 97, 119, 110, 101,
				114, 0, 0, 0, 0, 40, 68, 117, 99, 107,
				111, 118, 46, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 46, 70, 105, 115, 104, 83, 112, 97,
				119, 110, 101, 114, 124, 83, 112, 101, 99, 105,
				97, 108, 80, 97, 105, 114, 0, 0, 0, 0,
				28, 68, 117, 99, 107, 111, 118, 46, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 124, 76, 111,
				111, 116, 83, 112, 97, 119, 110, 101, 114, 0,
				0, 0, 0, 34, 68, 117, 99, 107, 111, 118,
				46, 85, 116, 105, 108, 105, 116, 105, 101, 115,
				46, 76, 111, 111, 116, 83, 112, 97, 119, 110,
				101, 114, 124, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 14, 124, 67, 111, 117, 110, 116, 68,
				111, 119, 110, 65, 114, 101, 97, 0, 0, 0,
				0, 9, 124, 80, 101, 116, 72, 111, 117, 115,
				101, 0, 0, 0, 0, 19, 68, 117, 99, 107,
				111, 118, 124, 71, 97, 109, 101, 77, 101, 116,
				97, 68, 97, 116, 97, 0, 0, 0, 0, 18,
				68, 117, 99, 107, 111, 118, 124, 86, 101, 114,
				115, 105, 111, 110, 68, 97, 116, 97, 0, 0,
				0, 0, 22, 68, 117, 99, 107, 111, 118, 124,
				71, 97, 109, 101, 86, 101, 114, 115, 105, 111,
				110, 68, 97, 116, 97, 0, 0, 0, 0, 16,
				124, 78, 97, 109, 101, 100, 70, 111, 114, 109,
				97, 116, 84, 101, 115, 116, 0, 0, 0, 0,
				23, 78, 97, 109, 101, 100, 70, 111, 114, 109,
				97, 116, 84, 101, 115, 116, 124, 67, 111, 110,
				116, 101, 110, 116, 0, 0, 0, 0, 42, 68,
				117, 99, 107, 111, 118, 46, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 124, 83, 101, 116, 65,
				99, 116, 105, 118, 101, 66, 121, 80, 108, 97,
				121, 101, 114, 68, 105, 115, 116, 97, 110, 99,
				101, 0, 0, 0, 0, 19, 68, 117, 99, 107,
				111, 118, 124, 80, 108, 97, 116, 102, 111, 114,
				109, 73, 110, 102, 111, 0, 0, 0, 0, 27,
				124, 69, 118, 97, 99, 117, 97, 116, 105, 111,
				110, 67, 111, 117, 110, 116, 100, 111, 119, 110,
				85, 73, 80, 114, 111, 120, 121, 0, 0, 0,
				0, 18, 124, 76, 101, 118, 101, 108, 77, 97,
				110, 97, 103, 101, 114, 80, 114, 111, 120, 121,
				0, 0, 0, 0, 17, 124, 83, 99, 101, 110,
				101, 76, 111, 97, 100, 101, 114, 80, 114, 111,
				120, 121, 0, 0, 0, 0, 11, 124, 86, 105,
				101, 119, 115, 80, 114, 111, 120, 121, 0, 0,
				0, 0, 23, 68, 117, 99, 107, 111, 118, 46,
				81, 117, 101, 115, 116, 115, 124, 67, 111, 110,
				100, 105, 116, 105, 111, 110, 0, 0, 0, 0,
				33, 68, 117, 99, 107, 111, 118, 46, 81, 117,
				101, 115, 116, 115, 124, 67, 111, 110, 100, 105,
				116, 105, 111, 110, 69, 120, 116, 101, 110, 115,
				105, 111, 110, 115, 0, 0, 0, 0, 25, 124,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 95,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 76,
				101, 118, 101, 108, 0, 0, 0, 0, 25, 124,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 95,
				72, 97, 115, 66, 101, 101, 110, 84, 111, 83,
				99, 101, 110, 101, 0, 0, 0, 0, 19, 124,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 95,
				82, 97, 105, 100, 68, 101, 97, 100, 0, 0,
				0, 0, 20, 124, 67, 111, 110, 100, 105, 116,
				105, 111, 110, 95, 84, 105, 109, 101, 79, 102,
				68, 97, 121, 0, 0, 0, 0, 20, 124, 67,
				111, 110, 100, 105, 116, 105, 111, 110, 95, 88,
				105, 97, 111, 72, 101, 105, 90, 105, 0, 0,
				0, 0, 29, 124, 67, 111, 110, 100, 105, 116,
				111, 110, 95, 66, 117, 105, 108, 100, 105, 110,
				103, 67, 111, 110, 115, 116, 114, 117, 99, 116,
				101, 100, 0, 0, 0, 0, 22, 124, 82, 101,
				113, 117, 105, 114, 101, 66, 101, 97, 99, 111,
				110, 85, 110, 108, 111, 99, 107, 101, 100, 0,
				0, 0, 0, 36, 68, 117, 99, 107, 111, 118,
				46, 81, 117, 101, 115, 116, 115, 46, 67, 111,
				110, 100, 105, 116, 105, 111, 110, 115, 124, 82,
				101, 113, 117, 105, 114, 101, 68, 101, 109, 111,
				0, 0, 0, 0, 19, 124, 82, 101, 113, 117,
				105, 114, 101, 69, 110, 101, 109, 121, 75, 105,
				108, 108, 101, 100, 0, 0, 0, 0, 47, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 46, 67, 111, 110, 100, 105, 116, 105,
				111, 110, 115, 124, 82, 101, 113, 117, 105, 114,
				101, 70, 111, 114, 109, 117, 108, 97, 85, 110,
				108, 111, 99, 107, 101, 100, 0, 0, 0, 0,
				50, 68, 117, 99, 107, 111, 118, 46, 81, 117,
				101, 115, 116, 115, 46, 67, 111, 110, 100, 105,
				116, 105, 111, 110, 115, 124, 82, 101, 113, 117,
				105, 114, 101, 71, 97, 109, 101, 111, 98, 106,
				101, 99, 116, 115, 65, 99, 116, 105, 118, 101,
				100, 0, 0, 0, 0, 41, 68, 117, 99, 107,
				111, 118, 46, 81, 117, 101, 115, 116, 115, 46,
				67, 111, 110, 100, 105, 116, 105, 111, 110, 115,
				124, 82, 101, 113, 117, 105, 114, 101, 72, 97,
				115, 70, 105, 115, 104, 101, 100, 0, 0, 0,
				0, 23, 124, 82, 101, 113, 117, 105, 114, 101,
				73, 110, 76, 101, 118, 101, 108, 68, 97, 116,
				97, 66, 111, 111, 108, 0, 0, 0, 0, 44,
				68, 117, 99, 107, 111, 118, 46, 81, 117, 101,
				115, 116, 115, 46, 67, 111, 110, 100, 105, 116,
				105, 111, 110, 115, 124, 82, 101, 113, 117, 105,
				114, 101, 80, 101, 114, 107, 85, 110, 108, 111,
				99, 107, 101, 100, 0, 0, 0, 0, 44, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 46, 67, 111, 110, 100, 105, 116, 105,
				111, 110, 115, 124, 82, 101, 113, 117, 105, 114,
				101, 81, 117, 101, 115, 116, 115, 65, 99, 116,
				105, 118, 101, 0, 0, 0, 0, 46, 68, 117,
				99, 107, 111, 118, 46, 81, 117, 101, 115, 116,
				115, 46, 67, 111, 110, 100, 105, 116, 105, 111,
				110, 115, 124, 82, 101, 113, 117, 105, 114, 101,
				81, 117, 101, 115, 116, 115, 70, 105, 110, 105,
				115, 104, 101, 100, 0, 0, 0, 0, 20, 124,
				82, 101, 113, 117, 105, 114, 101, 83, 97, 118,
				101, 68, 97, 116, 97, 66, 111, 111, 108, 0,
				0, 0, 0, 16, 124, 82, 101, 113, 117, 105,
				114, 101, 87, 101, 97, 116, 104, 101, 114, 115,
				0, 0, 0, 0, 19, 68, 117, 99, 107, 111,
				118, 46, 81, 117, 101, 115, 116, 115, 124, 81,
				117, 101, 115, 116, 0, 0, 0, 0, 28, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 46, 81, 117, 101, 115, 116, 124, 83,
				97, 118, 101, 68, 97, 116, 97, 0, 0, 0,
				0, 29, 68, 117, 99, 107, 111, 118, 46, 81,
				117, 101, 115, 116, 115, 46, 81, 117, 101, 115,
				116, 124, 81, 117, 101, 115, 116, 73, 110, 102,
				111, 0, 0, 0, 0, 29, 68, 117, 99, 107,
				111, 118, 46, 81, 117, 101, 115, 116, 115, 124,
				81, 117, 101, 115, 116, 67, 111, 108, 108, 101,
				99, 116, 105, 111, 110, 0, 0, 0, 0, 24,
				68, 117, 99, 107, 111, 118, 46, 81, 117, 101,
				115, 116, 115, 124, 81, 117, 101, 115, 116, 71,
				105, 118, 101, 114, 0, 0, 0, 0, 26, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 124, 81, 117, 101, 115, 116, 77, 97,
				110, 97, 103, 101, 114, 0, 0, 0, 0, 35,
				68, 117, 99, 107, 111, 118, 46, 81, 117, 101,
				115, 116, 115, 46, 81, 117, 101, 115, 116, 77,
				97, 110, 97, 103, 101, 114, 124, 83, 97, 118,
				101, 68, 97, 116, 97, 0, 0, 0, 0, 47,
				68, 117, 99, 107, 111, 118, 46, 81, 117, 101,
				115, 116, 115, 46, 82, 101, 108, 97, 116, 105,
				111, 110, 115, 124, 81, 117, 101, 115, 116, 82,
				101, 108, 97, 116, 105, 111, 110, 67, 111, 110,
				110, 101, 99, 116, 105, 111, 110, 0, 0, 0,
				0, 42, 68, 117, 99, 107, 111, 118, 46, 81,
				117, 101, 115, 116, 115, 46, 82, 101, 108, 97,
				116, 105, 111, 110, 115, 124, 81, 117, 101, 115,
				116, 82, 101, 108, 97, 116, 105, 111, 110, 71,
				114, 97, 112, 104, 0, 0, 0, 0, 45, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 46, 82, 101, 108, 97, 116, 105, 111,
				110, 115, 124, 81, 117, 101, 115, 116, 82, 101,
				108, 97, 116, 105, 111, 110, 78, 111, 100, 101,
				66, 97, 115, 101, 0, 0, 0, 0, 41, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 46, 82, 101, 108, 97, 116, 105, 111,
				110, 115, 124, 81, 117, 101, 115, 116, 82, 101,
				108, 97, 116, 105, 111, 110, 78, 111, 100, 101,
				0, 0, 0, 0, 46, 68, 117, 99, 107, 111,
				118, 46, 81, 117, 101, 115, 116, 115, 46, 82,
				101, 108, 97, 116, 105, 111, 110, 115, 124, 81,
				117, 101, 115, 116, 82, 101, 108, 97, 116, 105,
				111, 110, 80, 114, 111, 120, 121, 78, 111, 100,
				101, 0, 0, 0, 0, 20, 68, 117, 99, 107,
				111, 118, 46, 81, 117, 101, 115, 116, 115, 124,
				82, 101, 119, 97, 114, 100, 0, 0, 0, 0,
				37, 68, 117, 99, 107, 111, 118, 46, 81, 117,
				101, 115, 116, 115, 46, 82, 101, 119, 97, 114,
				100, 115, 124, 81, 117, 101, 115, 116, 82, 101,
				119, 97, 114, 100, 95, 69, 88, 80, 0, 0,
				0, 0, 39, 68, 117, 99, 107, 111, 118, 46,
				81, 117, 101, 115, 116, 115, 46, 82, 101, 119,
				97, 114, 100, 115, 124, 81, 117, 101, 115, 116,
				82, 101, 119, 97, 114, 100, 95, 77, 111, 110,
				101, 121, 0, 0, 0, 0, 49, 68, 117, 99,
				107, 111, 118, 46, 81, 117, 101, 115, 116, 115,
				46, 82, 101, 119, 97, 114, 100, 115, 124, 81,
				117, 101, 115, 116, 82, 101, 119, 97, 114, 100,
				95, 85, 110, 108, 111, 99, 107, 83, 116, 111,
				99, 107, 73, 116, 101, 109, 0, 0, 0, 0,
				24, 68, 117, 99, 107, 111, 118, 46, 81, 117,
				101, 115, 116, 115, 124, 82, 101, 119, 97, 114,
				100, 73, 116, 101, 109, 0, 0, 0, 0, 18,
				68, 117, 99, 107, 111, 118, 46, 81, 117, 101,
				115, 116, 115, 124, 84, 97, 115, 107, 0, 0,
				0, 0, 10, 124, 84, 97, 115, 107, 69, 118,
				101, 110, 116, 0, 0, 0, 0, 17, 124, 84,
				97, 115, 107, 69, 118, 101, 110, 116, 69, 109,
				105, 116, 116, 101, 114, 0, 0, 0, 0, 43,
				68, 117, 99, 107, 111, 118, 46, 81, 117, 101,
				115, 116, 115, 46, 84, 97, 115, 107, 115, 124,
				81, 117, 101, 115, 116, 84, 97, 115, 107, 95,
				67, 104, 101, 99, 107, 83, 97, 118, 101, 68,
				97, 116, 97, 0, 0, 0, 0, 47, 68, 117,
				99, 107, 111, 118, 46, 81, 117, 101, 115, 116,
				115, 46, 84, 97, 115, 107, 115, 124, 81, 117,
				101, 115, 116, 84, 97, 115, 107, 95, 67, 111,
				110, 115, 116, 114, 117, 99, 116, 66, 117, 105,
				108, 100, 105, 110, 103, 0, 0, 0, 0, 38,
				68, 117, 99, 107, 111, 118, 46, 81, 117, 101,
				115, 116, 115, 46, 84, 97, 115, 107, 115, 124,
				81, 117, 101, 115, 116, 84, 97, 115, 107, 95,
				69, 118, 97, 99, 117, 97, 116, 101, 0, 0,
				0, 0, 39, 68, 117, 99, 107, 111, 118, 46,
				81, 117, 101, 115, 116, 115, 46, 84, 97, 115,
				107, 115, 124, 81, 117, 101, 115, 116, 84, 97,
				115, 107, 95, 75, 105, 108, 108, 67, 111, 117,
				110, 116, 0, 0, 0, 0, 43, 68, 117, 99,
				107, 111, 118, 46, 81, 117, 101, 115, 116, 115,
				46, 84, 97, 115, 107, 115, 124, 81, 117, 101,
				115, 116, 84, 97, 115, 107, 95, 82, 101, 97,
				99, 104, 76, 111, 99, 97, 116, 105, 111, 110,
				0, 0, 0, 0, 41, 68, 117, 99, 107, 111,
				118, 46, 81, 117, 101, 115, 116, 115, 46, 84,
				97, 115, 107, 115, 124, 81, 117, 101, 115, 116,
				84, 97, 115, 107, 95, 83, 117, 98, 109, 105,
				116, 77, 111, 110, 101, 121, 0, 0, 0, 0,
				39, 68, 117, 99, 107, 111, 118, 46, 81, 117,
				101, 115, 116, 115, 46, 84, 97, 115, 107, 115,
				124, 81, 117, 101, 115, 116, 84, 97, 115, 107,
				95, 84, 97, 115, 107, 69, 118, 101, 110, 116,
				0, 0, 0, 0, 36, 68, 117, 99, 107, 111,
				118, 46, 81, 117, 101, 115, 116, 115, 124, 81,
				117, 101, 115, 116, 84, 97, 115, 107, 95, 85,
				110, 108, 111, 99, 107, 66, 101, 97, 99, 111,
				110, 0, 0, 0, 0, 40, 68, 117, 99, 107,
				111, 118, 46, 81, 117, 101, 115, 116, 115, 46,
				84, 97, 115, 107, 115, 124, 81, 117, 101, 115,
				116, 84, 97, 115, 107, 95, 85, 110, 108, 111,
				99, 107, 80, 101, 114, 107, 0, 0, 0, 0,
				37, 68, 117, 99, 107, 111, 118, 46, 81, 117,
				101, 115, 116, 115, 46, 84, 97, 115, 107, 115,
				124, 81, 117, 101, 115, 116, 84, 97, 115, 107,
				95, 85, 115, 101, 73, 116, 101, 109, 0, 0,
				0, 0, 31, 68, 117, 99, 107, 111, 118, 46,
				81, 117, 101, 115, 116, 115, 46, 84, 97, 115,
				107, 115, 124, 83, 117, 98, 109, 105, 116, 73,
				116, 101, 109, 115, 0, 0, 0, 0, 35, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 46, 85, 73, 124, 81, 117, 101, 115,
				116, 67, 111, 109, 112, 108, 101, 116, 101, 80,
				97, 110, 101, 108, 0, 0, 0, 0, 27, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 46, 85, 73, 124, 81, 117, 101, 115,
				116, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				31, 68, 117, 99, 107, 111, 118, 46, 81, 117,
				101, 115, 116, 115, 46, 85, 73, 124, 81, 117,
				101, 115, 116, 71, 105, 118, 101, 114, 86, 105,
				101, 119, 0, 0, 0, 0, 36, 68, 117, 99,
				107, 111, 118, 46, 81, 117, 101, 115, 116, 115,
				46, 85, 73, 124, 81, 117, 101, 115, 116, 71,
				105, 118, 101, 114, 84, 97, 98, 66, 117, 116,
				116, 111, 110, 0, 0, 0, 0, 31, 68, 117,
				99, 107, 111, 118, 46, 81, 117, 101, 115, 116,
				115, 46, 85, 73, 124, 81, 117, 101, 115, 116,
				71, 105, 118, 101, 114, 84, 97, 98, 115, 0,
				0, 0, 0, 18, 124, 81, 117, 101, 115, 116,
				82, 101, 113, 117, 105, 114, 101, 100, 73, 116,
				101, 109, 0, 0, 0, 0, 26, 68, 117, 99,
				107, 111, 118, 46, 81, 117, 101, 115, 116, 115,
				46, 85, 73, 124, 81, 117, 101, 115, 116, 86,
				105, 101, 119, 0, 0, 0, 0, 33, 68, 117,
				99, 107, 111, 118, 46, 81, 117, 101, 115, 116,
				115, 46, 85, 73, 124, 81, 117, 101, 115, 116,
				86, 105, 101, 119, 68, 101, 116, 97, 105, 108,
				115, 0, 0, 0, 0, 36, 68, 117, 99, 107,
				111, 118, 46, 81, 117, 101, 115, 116, 115, 46,
				85, 73, 124, 81, 117, 101, 115, 116, 86, 105,
				101, 119, 70, 108, 97, 103, 66, 117, 116, 116,
				111, 110, 0, 0, 0, 0, 28, 68, 117, 99,
				107, 111, 118, 46, 81, 117, 101, 115, 116, 115,
				46, 85, 73, 124, 82, 101, 119, 97, 114, 100,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 26,
				68, 117, 99, 107, 111, 118, 46, 81, 117, 101,
				115, 116, 115, 46, 85, 73, 124, 84, 97, 115,
				107, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				31, 68, 117, 99, 107, 111, 118, 46, 81, 117,
				101, 115, 116, 115, 124, 77, 97, 112, 69, 108,
				101, 109, 101, 110, 116, 70, 111, 114, 84, 97,
				115, 107, 0, 0, 0, 0, 44, 68, 117, 99,
				107, 111, 118, 46, 81, 117, 101, 115, 116, 115,
				124, 80, 108, 97, 121, 68, 105, 97, 108, 111,
				103, 117, 101, 71, 114, 97, 112, 104, 79, 110,
				81, 117, 101, 115, 116, 65, 99, 116, 105, 118,
				101, 0, 0, 0, 0, 41, 68, 117, 99, 107,
				111, 118, 46, 81, 117, 101, 115, 116, 115, 124,
				83, 104, 111, 119, 68, 105, 97, 108, 111, 103,
				117, 101, 79, 110, 81, 117, 101, 115, 116, 65,
				99, 116, 105, 118, 97, 116, 101, 0, 0, 0,
				0, 55, 68, 117, 99, 107, 111, 118, 46, 81,
				117, 101, 115, 116, 115, 46, 83, 104, 111, 119,
				68, 105, 97, 108, 111, 103, 117, 101, 79, 110,
				81, 117, 101, 115, 116, 65, 99, 116, 105, 118,
				97, 116, 101, 124, 68, 105, 97, 108, 111, 103,
				117, 101, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 30, 68, 117, 99, 107, 111, 118, 46, 81,
				117, 101, 115, 116, 115, 124, 83, 112, 97, 119,
				110, 73, 116, 101, 109, 70, 111, 114, 84, 97,
				115, 107, 0, 0, 0, 0, 32, 68, 117, 99,
				107, 111, 118, 46, 81, 117, 101, 115, 116, 115,
				124, 83, 112, 97, 119, 110, 80, 114, 101, 102,
				97, 98, 70, 111, 114, 84, 97, 115, 107, 0,
				0, 0, 0, 33, 124, 85, 110, 108, 111, 99,
				107, 69, 110, 100, 111, 119, 109, 101, 110, 116,
				87, 104, 101, 110, 81, 117, 101, 115, 116, 67,
				111, 109, 112, 108, 101, 116, 101, 0, 0, 0,
				0, 23, 83, 97, 118, 101, 115, 124, 73, 83,
				97, 118, 101, 68, 97, 116, 97, 80, 114, 111,
				118, 105, 100, 101, 114, 0, 0, 0, 0, 24,
				83, 97, 118, 101, 115, 124, 73, 116, 101, 109,
				83, 97, 118, 101, 115, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 0, 0, 0, 0, 32, 124,
				82, 101, 115, 116, 111, 114, 101, 70, 97, 105,
				108, 117, 114, 101, 68, 101, 116, 101, 99, 116,
				101, 100, 73, 110, 100, 105, 99, 97, 116, 111,
				114, 0, 0, 0, 0, 13, 124, 83, 97, 118,
				101, 115, 67, 111, 117, 110, 116, 101, 114, 0,
				0, 0, 0, 17, 83, 97, 118, 101, 115, 124,
				83, 97, 118, 101, 115, 83, 121, 115, 116, 101,
				109, 0, 0, 0, 0, 28, 83, 97, 118, 101,
				115, 46, 83, 97, 118, 101, 115, 83, 121, 115,
				116, 101, 109, 124, 66, 97, 99, 107, 117, 112,
				73, 110, 102, 111, 0, 0, 0, 0, 22, 124,
				76, 111, 97, 100, 85, 110, 105, 116, 121, 83,
				99, 101, 110, 101, 79, 110, 83, 116, 97, 114,
				116, 0, 0, 0, 0, 28, 68, 117, 99, 107,
				111, 118, 46, 83, 99, 101, 110, 101, 115, 124,
				77, 117, 108, 116, 105, 83, 99, 101, 110, 101,
				67, 111, 114, 101, 0, 0, 0, 0, 27, 68,
				117, 99, 107, 111, 118, 46, 83, 99, 101, 110,
				101, 115, 124, 83, 117, 98, 83, 99, 101, 110,
				101, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				36, 68, 117, 99, 107, 111, 118, 46, 83, 99,
				101, 110, 101, 115, 46, 83, 117, 98, 83, 99,
				101, 110, 101, 69, 110, 116, 114, 121, 124, 76,
				111, 99, 97, 116, 105, 111, 110, 0, 0, 0,
				0, 42, 68, 117, 99, 107, 111, 118, 46, 83,
				99, 101, 110, 101, 115, 46, 83, 117, 98, 83,
				99, 101, 110, 101, 69, 110, 116, 114, 121, 124,
				84, 101, 108, 101, 112, 111, 114, 116, 101, 114,
				73, 110, 102, 111, 0, 0, 0, 0, 32, 68,
				117, 99, 107, 111, 118, 46, 83, 99, 101, 110,
				101, 115, 124, 77, 117, 108, 116, 105, 83, 99,
				101, 110, 101, 76, 111, 99, 97, 116, 105, 111,
				110, 0, 0, 0, 0, 34, 68, 117, 99, 107,
				111, 118, 46, 83, 99, 101, 110, 101, 115, 124,
				77, 117, 108, 116, 105, 83, 99, 101, 110, 101,
				84, 101, 108, 101, 112, 111, 114, 116, 101, 114,
				0, 0, 0, 0, 30, 68, 117, 99, 107, 111,
				118, 46, 83, 99, 101, 110, 101, 115, 124, 83,
				99, 101, 110, 101, 73, 68, 65, 116, 116, 114,
				105, 98, 117, 116, 101, 0, 0, 0, 0, 20,
				124, 83, 99, 101, 110, 101, 73, 110, 102, 111,
				67, 111, 108, 108, 101, 99, 116, 105, 111, 110,
				0, 0, 0, 0, 15, 124, 83, 99, 101, 110,
				101, 73, 110, 102, 111, 69, 110, 116, 114, 121,
				0, 0, 0, 0, 20, 124, 83, 99, 101, 110,
				101, 76, 111, 97, 100, 105, 110, 103, 67, 111,
				110, 116, 101, 120, 116, 0, 0, 0, 0, 12,
				124, 83, 99, 101, 110, 101, 76, 111, 97, 100,
				101, 114, 0, 0, 0, 0, 27, 124, 83, 99,
				101, 110, 101, 76, 111, 97, 100, 105, 110, 103,
				69, 118, 101, 110, 116, 115, 82, 101, 99, 101,
				105, 118, 101, 114, 0, 0, 0, 0, 36, 68,
				117, 99, 107, 111, 118, 46, 83, 99, 101, 110,
				101, 115, 124, 83, 99, 101, 110, 101, 76, 111,
				99, 97, 116, 105, 111, 110, 115, 80, 114, 111,
				118, 105, 100, 101, 114, 0, 0, 0, 0, 18,
				124, 83, 104, 111, 119, 76, 111, 99, 97, 116,
				105, 111, 110, 73, 110, 77, 97, 112, 0, 0,
				0, 0, 44, 85, 110, 105, 116, 121, 84, 101,
				109, 112, 108, 97, 116, 101, 80, 114, 111, 106,
				101, 99, 116, 115, 124, 83, 105, 109, 112, 108,
				101, 67, 97, 109, 101, 114, 97, 67, 111, 110,
				116, 114, 111, 108, 108, 101, 114, 0, 0, 0,
				0, 56, 85, 110, 105, 116, 121, 84, 101, 109,
				112, 108, 97, 116, 101, 80, 114, 111, 106, 101,
				99, 116, 115, 46, 83, 105, 109, 112, 108, 101,
				67, 97, 109, 101, 114, 97, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 124, 67, 97, 109,
				101, 114, 97, 83, 116, 97, 116, 101, 0, 0,
				0, 0, 21, 124, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 83, 107, 105, 108, 108, 75, 101,
				101, 112, 101, 114, 0, 0, 0, 0, 13, 124,
				83, 107, 105, 108, 108, 67, 111, 110, 116, 101,
				120, 116, 0, 0, 0, 0, 20, 124, 83, 107,
				105, 108, 108, 82, 101, 108, 101, 97, 115, 101,
				67, 111, 110, 116, 101, 120, 116, 0, 0, 0,
				0, 10, 124, 83, 107, 105, 108, 108, 66, 97,
				115, 101, 0, 0, 0, 0, 14, 124, 83, 107,
				105, 108, 108, 95, 71, 114, 101, 110, 97, 100,
				101, 0, 0, 0, 0, 19, 124, 66, 97, 115,
				101, 83, 99, 101, 110, 101, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 0, 0, 0, 0, 26,
				124, 79, 118, 101, 114, 114, 105, 100, 101, 68,
				101, 97, 116, 104, 83, 99, 101, 110, 101, 82,
				111, 117, 116, 105, 110, 103, 0, 0, 0, 0,
				20, 68, 117, 99, 107, 111, 118, 46, 84, 97,
				115, 107, 115, 124, 83, 116, 97, 114, 116, 117,
				112, 0, 0, 0, 0, 13, 124, 83, 116, 101,
				97, 109, 77, 97, 110, 97, 103, 101, 114, 0,
				0, 0, 0, 13, 124, 68, 97, 109, 97, 103,
				101, 84, 111, 83, 101, 108, 102, 0, 0, 0,
				0, 13, 124, 69, 110, 101, 109, 121, 67, 114,
				101, 97, 116, 111, 114, 0, 0, 0, 0, 22,
				124, 76, 111, 103, 79, 110, 69, 110, 97, 98,
				108, 101, 65, 110, 100, 68, 105, 115, 97, 98,
				108, 101, 0, 0, 0, 0, 17, 124, 77, 97,
				112, 73, 109, 97, 103, 101, 84, 111, 83, 104,
				97, 100, 101, 114, 0, 0, 0, 0, 13, 124,
				79, 110, 68, 105, 115, 97, 98, 108, 101, 76,
				111, 103, 0, 0, 0, 0, 31, 73, 116, 101,
				109, 83, 116, 97, 116, 115, 83, 121, 115, 116,
				101, 109, 124, 84, 101, 115, 116, 105, 116, 101,
				109, 71, 114, 97, 112, 104, 105, 99, 0, 0,
				0, 0, 23, 124, 80, 108, 97, 121, 97, 98,
				108, 101, 68, 105, 114, 101, 99, 116, 111, 114,
				69, 118, 101, 110, 116, 115, 0, 0, 0, 0,
				16, 124, 66, 108, 117, 101, 78, 111, 105, 115,
				101, 83, 101, 116, 116, 101, 114, 0, 0, 0,
				0, 18, 124, 66, 111, 117, 110, 100, 97, 114,
				121, 71, 101, 110, 101, 114, 97, 116, 111, 114,
				0, 0, 0, 0, 19, 124, 68, 101, 99, 97,
				108, 65, 116, 108, 97, 115, 83, 101, 108, 101,
				99, 116, 111, 114, 0, 0, 0, 0, 16, 124,
				68, 101, 115, 116, 114, 111, 121, 79, 118, 101,
				114, 116, 105, 109, 101, 0, 0, 0, 0, 21,
				124, 68, 117, 99, 107, 111, 118, 83, 99, 114,
				101, 101, 110, 67, 97, 112, 116, 117, 114, 101,
				114, 0, 0, 0, 0, 14, 124, 83, 104, 97,
				112, 101, 80, 114, 111, 118, 105, 100, 101, 114,
				0, 0, 0, 0, 15, 124, 80, 105, 112, 101,
				67, 111, 108, 108, 105, 100, 101, 114, 50, 68,
				0, 0, 0, 0, 15, 124, 80, 105, 112, 101,
				68, 101, 99, 111, 114, 97, 116, 105, 111, 110,
				0, 0, 0, 0, 31, 80, 105, 112, 101, 68,
				101, 99, 111, 114, 97, 116, 105, 111, 110, 124,
				71, 97, 109, 101, 79, 98, 106, 101, 99, 116,
				79, 102, 102, 115, 101, 116, 0, 0, 0, 0,
				21, 124, 67, 105, 114, 99, 117, 108, 97, 114,
				69, 120, 116, 114, 117, 100, 101, 83, 104, 97,
				112, 101, 0, 0, 0, 0, 23, 124, 77, 117,
				108, 116, 105, 67, 105, 114, 99, 101, 69, 120,
				116, 114, 117, 100, 101, 83, 104, 97, 112, 101,
				0, 0, 0, 0, 29, 77, 117, 108, 116, 105,
				67, 105, 114, 99, 101, 69, 120, 116, 114, 117,
				100, 101, 83, 104, 97, 112, 101, 124, 67, 105,
				114, 99, 108, 101, 0, 0, 0, 0, 28, 124,
				82, 111, 117, 110, 100, 67, 111, 114, 110, 101,
				114, 82, 101, 99, 116, 69, 120, 116, 114, 117,
				100, 101, 83, 104, 97, 112, 101, 0, 0, 0,
				0, 30, 124, 82, 111, 117, 110, 100, 67, 111,
				114, 110, 101, 114, 83, 113, 117, 97, 114, 101,
				69, 120, 116, 114, 117, 100, 101, 83, 104, 97,
				112, 101, 0, 0, 0, 0, 13, 124, 80, 105,
				112, 101, 82, 101, 110, 100, 101, 114, 101, 114,
				0, 0, 0, 0, 26, 80, 105, 112, 101, 82,
				101, 110, 100, 101, 114, 101, 114, 124, 79, 114,
				105, 101, 110, 116, 101, 100, 80, 111, 105, 110,
				116, 0, 0, 0, 0, 20, 68, 117, 99, 107,
				111, 118, 46, 83, 112, 108, 105, 110, 101, 115,
				124, 66, 101, 118, 101, 108, 0, 0, 0, 0,
				31, 68, 117, 99, 107, 111, 118, 46, 83, 112,
				108, 105, 110, 101, 115, 124, 66, 101, 118, 101,
				108, 101, 100, 76, 105, 110, 101, 83, 104, 97,
				112, 101, 0, 0, 0, 0, 13, 124, 66, 101,
				122, 105, 101, 114, 83, 112, 108, 105, 110, 101,
				0, 0, 0, 0, 20, 124, 77, 117, 108, 116,
				105, 112, 108, 101, 66, 101, 122, 105, 101, 114,
				83, 104, 97, 112, 101, 0, 0, 0, 0, 20,
				124, 80, 105, 112, 101, 72, 101, 108, 112, 101,
				114, 70, 117, 110, 99, 116, 105, 111, 110, 115,
				0, 0, 0, 0, 11, 124, 85, 86, 67, 121,
				108, 105, 110, 100, 101, 114, 0, 0, 0, 0,
				7, 124, 80, 111, 105, 110, 116, 115, 0, 0,
				0, 0, 17, 124, 73, 79, 110, 80, 111, 105,
				110, 116, 115, 67, 104, 97, 110, 103, 101, 100,
				0, 0, 0, 0, 19, 124, 80, 114, 101, 102,
				97, 98, 76, 105, 110, 101, 71, 101, 110, 114,
				97, 116, 111, 114, 0, 0, 0, 0, 28, 80,
				114, 101, 102, 97, 98, 76, 105, 110, 101, 71,
				101, 110, 114, 97, 116, 111, 114, 124, 83, 97,
				112, 119, 110, 73, 110, 102, 111, 0, 0, 0,
				0, 29, 80, 114, 101, 102, 97, 98, 76, 105,
				110, 101, 71, 101, 110, 114, 97, 116, 111, 114,
				124, 80, 114, 101, 102, 97, 98, 80, 97, 105,
				114, 0, 0, 0, 0, 13, 124, 83, 99, 97,
				108, 97, 98, 108, 101, 77, 101, 115, 104, 0,
				0, 0, 0, 17, 124, 83, 101, 116, 65, 99,
				116, 105, 118, 101, 79, 110, 65, 119, 97, 107,
				101, 0, 0, 0, 0, 10, 124, 84, 111, 103,
				103, 108, 101, 72, 85, 68, 0, 0, 0, 0,
				29, 68, 117, 99, 107, 111, 118, 46, 69, 99,
				111, 110, 111, 109, 121, 124, 69, 99, 111, 110,
				111, 109, 121, 77, 97, 110, 97, 103, 101, 114,
				0, 0, 0, 0, 38, 68, 117, 99, 107, 111,
				118, 46, 69, 99, 111, 110, 111, 109, 121, 46,
				69, 99, 111, 110, 111, 109, 121, 77, 97, 110,
				97, 103, 101, 114, 124, 83, 97, 118, 101, 68,
				97, 116, 97, 0, 0, 0, 0, 19, 68, 117,
				99, 107, 111, 118, 46, 69, 99, 111, 110, 111,
				109, 121, 124, 67, 111, 115, 116, 0, 0, 0,
				0, 25, 68, 117, 99, 107, 111, 118, 46, 69,
				99, 111, 110, 111, 109, 121, 46, 124, 73, 116,
				101, 109, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 24, 68, 117, 99, 107, 111, 118, 46, 69,
				99, 111, 110, 111, 109, 121, 124, 83, 116, 111,
				99, 107, 83, 104, 111, 112, 0, 0, 0, 0,
				30, 68, 117, 99, 107, 111, 118, 46, 69, 99,
				111, 110, 111, 109, 121, 46, 83, 116, 111, 99,
				107, 83, 104, 111, 112, 124, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 50, 68, 117, 99, 107,
				111, 118, 46, 69, 99, 111, 110, 111, 109, 121,
				46, 83, 116, 111, 99, 107, 83, 104, 111, 112,
				124, 79, 118, 101, 114, 114, 105, 100, 101, 83,
				101, 108, 108, 105, 110, 103, 80, 114, 105, 99,
				101, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				33, 68, 117, 99, 107, 111, 118, 46, 69, 99,
				111, 110, 111, 109, 121, 46, 83, 116, 111, 99,
				107, 83, 104, 111, 112, 124, 83, 97, 118, 101,
				68, 97, 116, 97, 0, 0, 0, 0, 49, 68,
				117, 99, 107, 111, 118, 46, 69, 99, 111, 110,
				111, 109, 121, 46, 83, 116, 111, 99, 107, 83,
				104, 111, 112, 43, 83, 97, 118, 101, 68, 97,
				116, 97, 124, 83, 116, 111, 99, 107, 67, 111,
				117, 110, 116, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 18, 124, 83, 116, 111, 99, 107, 83,
				104, 111, 112, 68, 97, 116, 97, 98, 97, 115,
				101, 0, 0, 0, 0, 33, 83, 116, 111, 99,
				107, 83, 104, 111, 112, 68, 97, 116, 97, 98,
				97, 115, 101, 124, 77, 101, 114, 99, 104, 97,
				110, 116, 80, 114, 111, 102, 105, 108, 101, 0,
				0, 0, 0, 27, 83, 116, 111, 99, 107, 83,
				104, 111, 112, 68, 97, 116, 97, 98, 97, 115,
				101, 124, 73, 116, 101, 109, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 21, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 66, 108, 97, 99,
				107, 83, 99, 114, 101, 101, 110, 0, 0, 0,
				0, 23, 124, 67, 97, 110, 118, 97, 115, 83,
				99, 97, 108, 101, 114, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 0, 0, 0, 0, 8,
				124, 85, 73, 80, 97, 110, 101, 108, 0, 0,
				0, 0, 29, 124, 85, 73, 80, 97, 110, 101,
				108, 66, 117, 116, 116, 111, 110, 95, 79, 112,
				101, 110, 67, 104, 105, 108, 100, 80, 97, 110,
				101, 108, 0, 0, 0, 0, 22, 124, 73, 116,
				101, 109, 80, 114, 111, 112, 101, 114, 116, 105,
				101, 115, 68, 105, 115, 112, 108, 97, 121, 0,
				0, 0, 0, 14, 124, 76, 97, 98, 101, 108,
				65, 110, 100, 86, 97, 108, 117, 101, 0, 0,
				0, 0, 16, 124, 76, 111, 110, 103, 80, 114,
				101, 115, 115, 66, 117, 116, 116, 111, 110, 0,
				0, 0, 0, 12, 124, 67, 111, 115, 116, 68,
				105, 115, 112, 108, 97, 121, 0, 0, 0, 0,
				18, 124, 73, 116, 101, 109, 65, 109, 111, 117,
				110, 116, 68, 105, 115, 112, 108, 97, 121, 0,
				0, 0, 0, 15, 124, 82, 101, 115, 101, 108,
				101, 99, 116, 66, 117, 116, 116, 111, 110, 0,
				0, 0, 0, 17, 124, 82, 117, 108, 101, 73,
				110, 100, 101, 120, 68, 105, 115, 112, 108, 97,
				121, 0, 0, 0, 0, 12, 124, 68, 114, 97,
				103, 72, 97, 110, 100, 108, 101, 114, 0, 0,
				0, 0, 21, 124, 73, 83, 105, 110, 103, 108,
				101, 83, 101, 108, 101, 99, 116, 105, 111, 110,
				77, 101, 110, 117, 0, 0, 0, 0, 16, 124,
				73, 73, 116, 101, 109, 68, 114, 97, 103, 83,
				111, 117, 114, 99, 101, 0, 0, 0, 0, 27,
				124, 73, 116, 101, 109, 68, 114, 97, 103, 103,
				105, 110, 103, 80, 111, 105, 110, 116, 101, 114,
				68, 105, 115, 112, 108, 97, 121, 0, 0, 0,
				0, 24, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 73, 116, 101, 109, 72, 111, 118, 101,
				114, 105, 110, 103, 85, 73, 0, 0, 0, 0,
				20, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 73, 116, 101, 109, 80, 105, 99, 107, 101,
				114, 0, 0, 0, 0, 16, 124, 73, 116, 101,
				109, 80, 105, 99, 107, 101, 114, 68, 101, 98,
				117, 103, 0, 0, 0, 0, 25, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 124, 73, 116, 101,
				109, 80, 105, 99, 107, 101, 114, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 27, 124, 76, 101,
				118, 101, 108, 73, 110, 105, 116, 105, 97, 108,
				105, 122, 105, 110, 103, 73, 110, 100, 105, 99,
				97, 116, 111, 114, 0, 0, 0, 0, 20, 124,
				65, 100, 100, 84, 111, 87, 105, 115, 104, 76,
				105, 115, 116, 66, 117, 116, 116, 111, 110, 0,
				0, 0, 0, 33, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 46, 77, 97, 105, 110, 77, 101,
				110, 117, 124, 67, 111, 110, 116, 105, 110, 117,
				101, 66, 117, 116, 116, 111, 110, 0, 0, 0,
				0, 16, 124, 67, 111, 112, 121, 84, 101, 120,
				116, 79, 110, 67, 108, 105, 99, 107, 0, 0,
				0, 0, 21, 124, 68, 101, 108, 101, 116, 101,
				83, 97, 118, 101, 68, 97, 116, 97, 66, 117,
				116, 116, 111, 110, 0, 0, 0, 0, 16, 124,
				70, 97, 100, 101, 71, 114, 111, 117, 112, 66,
				117, 116, 116, 111, 110, 0, 0, 0, 0, 9,
				124, 77, 97, 105, 110, 77, 101, 110, 117, 0,
				0, 0, 0, 26, 124, 83, 97, 118, 101, 115,
				66, 97, 99, 107, 117, 112, 82, 101, 115, 116,
				111, 114, 101, 73, 110, 118, 111, 107, 101, 114,
				0, 0, 0, 0, 46, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 46, 83, 97, 118, 101, 115,
				82, 101, 115, 116, 111, 114, 101, 124, 83, 97,
				118, 101, 115, 66, 97, 99, 107, 117, 112, 82,
				101, 115, 116, 111, 114, 101, 80, 97, 110, 101,
				108, 0, 0, 0, 0, 51, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 46, 83, 97, 118, 101,
				115, 82, 101, 115, 116, 111, 114, 101, 124, 83,
				97, 118, 101, 115, 66, 97, 99, 107, 117, 112,
				82, 101, 115, 116, 111, 114, 101, 80, 97, 110,
				101, 108, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 30, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 46, 77, 97, 105, 110, 77, 101, 110, 117,
				124, 83, 97, 118, 101, 115, 66, 117, 116, 116,
				111, 110, 0, 0, 0, 0, 42, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 46, 77, 97, 105,
				110, 77, 101, 110, 117, 124, 83, 97, 118, 101,
				83, 108, 111, 116, 83, 101, 108, 101, 99, 116,
				105, 111, 110, 66, 117, 116, 116, 111, 110, 0,
				0, 0, 0, 40, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 46, 77, 97, 105, 110, 77, 101,
				110, 117, 124, 83, 97, 118, 101, 83, 108, 111,
				116, 83, 101, 108, 101, 99, 116, 105, 111, 110,
				77, 101, 110, 117, 0, 0, 0, 0, 6, 124,
				84, 105, 116, 108, 101, 0, 0, 0, 0, 25,
				68, 117, 99, 107, 111, 118, 124, 71, 97, 109,
				101, 86, 101, 114, 115, 105, 111, 110, 68, 105,
				115, 112, 108, 97, 121, 0, 0, 0, 0, 22,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 124,
				77, 111, 110, 101, 121, 68, 105, 115, 112, 108,
				97, 121, 0, 0, 0, 0, 15, 124, 79, 110,
				80, 111, 105, 110, 116, 101, 114, 67, 108, 105,
				99, 107, 0, 0, 0, 0, 10, 124, 80, 97,
				117, 115, 101, 77, 101, 110, 117, 0, 0, 0,
				0, 20, 124, 66, 117, 116, 116, 111, 110, 95,
				76, 111, 97, 100, 77, 97, 105, 110, 77, 101,
				110, 117, 0, 0, 0, 0, 16, 124, 66, 117,
				116, 116, 111, 110, 95, 81, 117, 105, 116, 71,
				97, 109, 101, 0, 0, 0, 0, 16, 124, 67,
				111, 110, 102, 105, 114, 109, 68, 105, 97, 108,
				111, 103, 117, 101, 0, 0, 0, 0, 16, 124,
				73, 78, 101, 101, 100, 73, 110, 115, 112, 101,
				99, 116, 105, 111, 110, 0, 0, 0, 0, 36,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 46,
				82, 101, 100, 68, 111, 116, 115, 124, 81, 117,
				101, 115, 116, 115, 66, 117, 116, 116, 111, 110,
				82, 101, 100, 68, 111, 116, 0, 0, 0, 0,
				23, 124, 83, 101, 116, 65, 99, 116, 105, 118,
				101, 66, 121, 73, 110, 112, 117, 116, 68, 101,
				118, 105, 99, 101, 0, 0, 0, 0, 27, 68,
				117, 99, 107, 111, 118, 46, 85, 73, 124, 73,
				84, 111, 111, 108, 116, 105, 112, 115, 80, 114,
				111, 118, 105, 100, 101, 114, 0, 0, 0, 0,
				18, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 84, 111, 111, 108, 116, 105, 112, 115, 0,
				0, 0, 0, 26, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 84, 111, 111, 108, 116, 105,
				112, 115, 80, 114, 111, 118, 105, 100, 101, 114,
				0, 0, 0, 0, 15, 124, 85, 73, 73, 110,
				112, 117, 116, 77, 97, 110, 97, 103, 101, 114,
				0, 0, 0, 0, 17, 124, 85, 73, 73, 110,
				112, 117, 116, 69, 118, 101, 110, 116, 68, 97,
				116, 97, 0, 0, 0, 0, 14, 124, 82, 97,
				105, 100, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 0, 0, 0, 0, 22, 82, 97, 105, 100,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 124,
				82, 97, 105, 100, 73, 110, 102, 111, 0, 0,
				0, 0, 13, 124, 66, 111, 119, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 0, 0, 0, 0,
				8, 124, 66, 117, 102, 102, 86, 70, 88, 0,
				0, 0, 0, 17, 124, 66, 117, 110, 107, 101,
				114, 68, 111, 111, 114, 86, 105, 115, 117, 97,
				108, 0, 0, 0, 0, 13, 124, 67, 97, 109,
				101, 114, 97, 83, 104, 97, 107, 101, 114, 0,
				0, 0, 0, 13, 124, 68, 97, 114, 107, 82,
				111, 111, 109, 70, 97, 100, 101, 0, 0, 0,
				0, 13, 124, 68, 80, 83, 68, 105, 115, 112,
				108, 97, 121, 101, 114, 0, 0, 0, 0, 12,
				124, 68, 117, 99, 107, 111, 118, 72, 105, 100,
				101, 114, 0, 0, 0, 0, 16, 124, 70, 111,
				103, 79, 102, 87, 97, 114, 77, 97, 110, 97,
				103, 101, 114, 0, 0, 0, 0, 15, 124, 72,
				97, 110, 100, 104, 101, 108, 100, 83, 112, 114,
				105, 116, 101, 0, 0, 0, 0, 16, 124, 76,
				105, 103, 104, 116, 67, 111, 111, 107, 105, 101,
				77, 111, 118, 101, 0, 0, 0, 0, 18, 124,
				77, 97, 105, 110, 67, 104, 97, 114, 97, 99,
				116, 101, 114, 70, 97, 99, 101, 0, 0, 0,
				0, 15, 124, 77, 97, 105, 110, 77, 101, 110,
				117, 67, 97, 109, 101, 114, 97, 0, 0, 0,
				0, 25, 124, 77, 105, 110, 105, 110, 103, 77,
				97, 99, 104, 105, 110, 101, 67, 97, 114, 100,
				68, 105, 115, 112, 108, 97, 121, 0, 0, 0,
				0, 20, 124, 77, 105, 110, 105, 110, 103, 77,
				97, 99, 104, 105, 110, 101, 86, 105, 115, 117,
				97, 108, 0, 0, 0, 0, 9, 124, 77, 111,
				118, 101, 82, 105, 110, 103, 0, 0, 0, 0,
				11, 124, 77, 111, 118, 101, 86, 105, 115, 117,
				97, 108, 0, 0, 0, 0, 18, 124, 78, 105,
				103, 104, 116, 86, 105, 115, 105, 111, 110, 86,
				105, 115, 117, 97, 108, 0, 0, 0, 0, 33,
				78, 105, 103, 104, 116, 86, 105, 115, 105, 111,
				110, 86, 105, 115, 117, 97, 108, 124, 78, 105,
				103, 104, 116, 86, 105, 115, 105, 111, 110, 84,
				121, 112, 101, 0, 0, 0, 0, 21, 124, 79,
				99, 99, 108, 117, 115, 105, 111, 110, 70, 97,
				100, 101, 67, 104, 101, 99, 107, 101, 114, 0,
				0, 0, 0, 21, 124, 79, 99, 99, 108, 117,
				115, 105, 111, 110, 70, 97, 100, 101, 77, 97,
				110, 97, 103, 101, 114, 0, 0, 0, 0, 20,
				124, 79, 99, 99, 108, 117, 115, 105, 111, 110,
				70, 97, 100, 101, 79, 98, 106, 101, 99, 116,
				0, 0, 0, 0, 21, 124, 79, 99, 99, 108,
				117, 115, 105, 111, 110, 70, 97, 100, 101, 84,
				114, 105, 103, 103, 101, 114, 0, 0, 0, 0,
				7, 124, 69, 110, 100, 105, 110, 103, 0, 0,
				0, 0, 18, 124, 83, 101, 116, 65, 99, 116,
				105, 118, 101, 66, 121, 69, 110, 100, 105, 110,
				103, 0, 0, 0, 0, 15, 124, 83, 104, 111,
				111, 116, 82, 97, 110, 103, 101, 82, 105, 110,
				103, 0, 0, 0, 0, 13, 124, 83, 116, 111,
				114, 109, 87, 101, 97, 116, 104, 101, 114, 0,
				0, 0, 0, 16, 124, 84, 105, 109, 101, 79,
				102, 68, 97, 121, 67, 111, 110, 102, 105, 103,
				0, 0, 0, 0, 20, 124, 84, 105, 109, 101,
				79, 102, 68, 97, 121, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 0, 0, 0, 0, 15,
				124, 84, 105, 109, 101, 79, 102, 68, 97, 121,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 15,
				124, 84, 105, 109, 101, 79, 102, 68, 97, 121,
				80, 104, 97, 115, 101, 0, 0, 0, 0, 23,
				124, 84, 105, 109, 101, 79, 102, 68, 97, 121,
				86, 111, 108, 117, 109, 101, 67, 111, 110, 116,
				114, 111, 108, 0, 0, 0, 0, 15, 124, 86,
				111, 108, 117, 109, 101, 115, 67, 111, 110, 116,
				114, 111, 108, 0, 0, 0, 0, 17, 124, 87,
				101, 97, 116, 104, 101, 114, 70, 120, 67, 111,
				110, 116, 114, 111, 108, 0, 0, 0, 0, 10,
				124, 87, 111, 114, 107, 98, 101, 110, 99, 104,
				0, 0, 0, 0, 26, 83, 111, 100, 97, 67,
				114, 97, 102, 116, 124, 67, 97, 109, 101, 114,
				97, 65, 114, 109, 67, 111, 110, 116, 114, 111,
				108, 0, 0, 0, 0, 19, 83, 111, 100, 97,
				67, 114, 97, 102, 116, 124, 69, 100, 103, 101,
				76, 105, 103, 104, 116, 0, 0, 0, 0, 22,
				83, 111, 100, 97, 67, 114, 97, 102, 116, 124,
				76, 105, 103, 104, 116, 67, 111, 110, 116, 114,
				111, 108, 0, 0, 0, 0, 23, 83, 111, 100,
				97, 67, 114, 97, 102, 116, 124, 84, 105, 109,
				101, 79, 102, 68, 97, 121, 80, 111, 115, 116,
				0, 0, 0, 0, 39, 68, 117, 99, 107, 111,
				118, 46, 65, 99, 104, 105, 101, 118, 101, 109,
				101, 110, 116, 115, 124, 65, 99, 104, 105, 101,
				118, 101, 109, 101, 110, 116, 68, 97, 116, 97,
				98, 97, 115, 101, 0, 0, 0, 0, 51, 68,
				117, 99, 107, 111, 118, 46, 65, 99, 104, 105,
				101, 118, 101, 109, 101, 110, 116, 115, 46, 65,
				99, 104, 105, 101, 118, 101, 109, 101, 110, 116,
				68, 97, 116, 97, 98, 97, 115, 101, 124, 65,
				99, 104, 105, 101, 118, 101, 109, 101, 110, 116,
				0, 0, 0, 0, 38, 68, 117, 99, 107, 111,
				118, 46, 65, 99, 104, 105, 101, 118, 101, 109,
				101, 110, 116, 115, 124, 65, 99, 104, 105, 101,
				118, 101, 109, 101, 110, 116, 77, 97, 110, 97,
				103, 101, 114, 0, 0, 0, 0, 59, 68, 117,
				99, 107, 111, 118, 46, 65, 99, 104, 105, 101,
				118, 101, 109, 101, 110, 116, 115, 46, 65, 99,
				104, 105, 101, 118, 101, 109, 101, 110, 116, 77,
				97, 110, 97, 103, 101, 114, 124, 75, 105, 108,
				108, 67, 111, 117, 110, 116, 65, 99, 104, 105,
				101, 118, 101, 109, 101, 110, 116, 0, 0, 0,
				0, 20, 68, 117, 99, 107, 111, 118, 124, 83,
				111, 99, 105, 97, 108, 77, 97, 110, 97, 103,
				101, 114, 0, 0, 0, 0, 37, 68, 117, 99,
				107, 111, 118, 46, 65, 99, 104, 105, 101, 118,
				101, 109, 101, 110, 116, 115, 124, 83, 116, 97,
				116, 105, 115, 116, 105, 99, 115, 77, 97, 110,
				97, 103, 101, 114, 0, 0, 0, 0, 25, 68,
				117, 99, 107, 111, 118, 46, 65, 113, 117, 97,
				114, 105, 117, 109, 115, 124, 65, 113, 117, 97,
				114, 105, 117, 109, 0, 0, 0, 0, 41, 68,
				117, 99, 107, 111, 118, 46, 65, 113, 117, 97,
				114, 105, 117, 109, 115, 46, 65, 113, 117, 97,
				114, 105, 117, 109, 124, 73, 116, 101, 109, 71,
				114, 97, 112, 104, 105, 99, 80, 97, 105, 114,
				0, 0, 0, 0, 33, 68, 117, 99, 107, 111,
				118, 46, 65, 113, 117, 97, 114, 105, 117, 109,
				115, 124, 73, 65, 113, 117, 97, 114, 105, 117,
				109, 67, 111, 110, 116, 101, 110, 116, 0, 0,
				0, 0, 10, 124, 68, 117, 109, 109, 121, 70,
				105, 115, 104, 0, 0, 0, 0, 9, 124, 65,
				84, 77, 80, 97, 110, 101, 108, 0, 0, 0,
				0, 19, 124, 65, 84, 77, 80, 97, 110, 101,
				108, 95, 68, 114, 97, 119, 80, 97, 110, 101,
				108, 0, 0, 0, 0, 19, 124, 65, 84, 77,
				80, 97, 110, 101, 108, 95, 83, 97, 118, 101,
				80, 97, 110, 101, 108, 0, 0, 0, 0, 8,
				124, 65, 84, 77, 86, 105, 101, 119, 0, 0,
				0, 0, 16, 124, 68, 105, 103, 105, 116, 73,
				110, 112, 117, 116, 80, 97, 110, 101, 108, 0,
				0, 0, 0, 16, 124, 70, 109, 111, 100, 69,
				118, 101, 110, 116, 84, 101, 115, 116, 101, 114,
				0, 0, 0, 0, 22, 124, 80, 111, 115, 116,
				65, 117, 100, 105, 111, 69, 118, 101, 110, 116,
				79, 110, 69, 110, 116, 101, 114, 0, 0, 0,
				0, 19, 124, 66, 117, 105, 108, 100, 101, 114,
				86, 105, 101, 119, 73, 110, 118, 111, 107, 101,
				114, 0, 0, 0, 0, 29, 68, 117, 99, 107,
				111, 118, 46, 66, 117, 105, 108, 100, 105, 110,
				103, 115, 124, 66, 117, 105, 108, 100, 105, 110,
				103, 65, 114, 101, 97, 0, 0, 0, 0, 31,
				68, 117, 99, 107, 111, 118, 46, 66, 117, 105,
				108, 100, 105, 110, 103, 115, 46, 85, 73, 124,
				66, 117, 105, 108, 100, 101, 114, 86, 105, 101,
				119, 0, 0, 0, 0, 36, 68, 117, 99, 107,
				111, 118, 46, 66, 117, 105, 108, 100, 105, 110,
				103, 115, 46, 85, 73, 124, 66, 117, 105, 108,
				100, 105, 110, 103, 66, 116, 110, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 39, 68, 117, 99,
				107, 111, 118, 46, 66, 117, 105, 108, 100, 105,
				110, 103, 115, 46, 85, 73, 124, 66, 117, 105,
				108, 100, 105, 110, 103, 67, 111, 110, 116, 101,
				120, 116, 77, 101, 110, 117, 0, 0, 0, 0,
				44, 68, 117, 99, 107, 111, 118, 46, 66, 117,
				105, 108, 100, 105, 110, 103, 115, 46, 85, 73,
				124, 66, 117, 105, 108, 100, 105, 110, 103, 67,
				111, 110, 116, 101, 120, 116, 77, 101, 110, 117,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 42,
				68, 117, 99, 107, 111, 118, 46, 66, 117, 105,
				108, 100, 105, 110, 103, 115, 46, 85, 73, 124,
				66, 117, 105, 108, 100, 105, 110, 103, 83, 101,
				108, 101, 99, 116, 105, 111, 110, 80, 97, 110,
				101, 108, 0, 0, 0, 0, 31, 68, 117, 99,
				107, 111, 118, 46, 66, 117, 105, 108, 100, 105,
				110, 103, 115, 46, 85, 73, 124, 71, 114, 105,
				100, 68, 105, 115, 112, 108, 97, 121, 0, 0,
				0, 0, 25, 68, 117, 99, 107, 111, 118, 46,
				66, 97, 115, 107, 101, 116, 66, 97, 108, 108,
				115, 124, 66, 97, 115, 107, 101, 116, 0, 0,
				0, 0, 29, 68, 117, 99, 107, 111, 118, 46,
				66, 97, 115, 107, 101, 116, 66, 97, 108, 108,
				115, 124, 66, 97, 115, 107, 101, 116, 66, 97,
				108, 108, 0, 0, 0, 0, 32, 68, 117, 99,
				107, 111, 118, 46, 66, 97, 115, 107, 101, 116,
				66, 97, 108, 108, 115, 124, 66, 97, 115, 107,
				101, 116, 84, 114, 105, 103, 103, 101, 114, 0,
				0, 0, 0, 28, 68, 117, 99, 107, 118, 111,
				46, 66, 101, 97, 99, 111, 110, 115, 124, 66,
				101, 97, 99, 111, 110, 77, 97, 110, 97, 103,
				101, 114, 0, 0, 0, 0, 41, 68, 117, 99,
				107, 118, 111, 46, 66, 101, 97, 99, 111, 110,
				115, 46, 66, 101, 97, 99, 111, 110, 77, 97,
				110, 97, 103, 101, 114, 124, 66, 101, 97, 99,
				111, 110, 83, 116, 97, 116, 117, 115, 0, 0,
				0, 0, 33, 68, 117, 99, 107, 118, 111, 46,
				66, 101, 97, 99, 111, 110, 115, 46, 66, 101,
				97, 99, 111, 110, 77, 97, 110, 97, 103, 101,
				114, 124, 68, 97, 116, 97, 0, 0, 0, 0,
				28, 68, 117, 99, 107, 111, 118, 46, 66, 105,
				116, 99, 111, 105, 110, 115, 124, 66, 105, 116,
				99, 111, 105, 110, 77, 105, 110, 101, 114, 0,
				0, 0, 0, 37, 68, 117, 99, 107, 111, 118,
				46, 66, 105, 116, 99, 111, 105, 110, 115, 46,
				66, 105, 116, 99, 111, 105, 110, 77, 105, 110,
				101, 114, 124, 83, 97, 118, 101, 68, 97, 116,
				97, 0, 0, 0, 0, 17, 124, 66, 105, 116,
				99, 111, 105, 110, 77, 105, 110, 101, 114, 86,
				105, 101, 119, 0, 0, 0, 0, 31, 68, 117,
				99, 107, 111, 118, 46, 66, 108, 97, 99, 107,
				77, 97, 114, 107, 101, 116, 115, 124, 66, 108,
				97, 99, 107, 77, 97, 114, 107, 101, 116, 0,
				0, 0, 0, 69, 68, 117, 99, 107, 111, 118,
				46, 66, 108, 97, 99, 107, 77, 97, 114, 107,
				101, 116, 115, 46, 66, 108, 97, 99, 107, 77,
				97, 114, 107, 101, 116, 124, 79, 110, 82, 101,
				113, 117, 101, 115, 116, 77, 97, 120, 82, 101,
				102, 114, 101, 115, 104, 67, 104, 97, 110, 99,
				101, 69, 118, 101, 110, 116, 67, 111, 110, 116,
				101, 120, 116, 0, 0, 0, 0, 70, 68, 117,
				99, 107, 111, 118, 46, 66, 108, 97, 99, 107,
				77, 97, 114, 107, 101, 116, 115, 46, 66, 108,
				97, 99, 107, 77, 97, 114, 107, 101, 116, 124,
				79, 110, 82, 101, 113, 117, 101, 115, 116, 82,
				101, 102, 114, 101, 115, 104, 84, 105, 109, 101,
				70, 97, 99, 116, 111, 114, 69, 118, 101, 110,
				116, 67, 111, 110, 116, 101, 120, 116, 0, 0,
				0, 0, 49, 68, 117, 99, 107, 111, 118, 46,
				66, 108, 97, 99, 107, 77, 97, 114, 107, 101,
				116, 115, 46, 66, 108, 97, 99, 107, 77, 97,
				114, 107, 101, 116, 124, 68, 101, 109, 97, 110,
				100, 83, 117, 112, 112, 108, 121, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 40, 68, 117, 99,
				107, 111, 118, 46, 66, 108, 97, 99, 107, 77,
				97, 114, 107, 101, 116, 115, 46, 66, 108, 97,
				99, 107, 77, 97, 114, 107, 101, 116, 124, 83,
				97, 118, 101, 68, 97, 116, 97, 0, 0, 0,
				0, 38, 68, 117, 99, 107, 111, 118, 46, 66,
				108, 97, 99, 107, 77, 97, 114, 107, 101, 116,
				115, 46, 85, 73, 124, 66, 108, 97, 99, 107,
				77, 97, 114, 107, 101, 116, 86, 105, 101, 119,
				0, 0, 0, 0, 34, 68, 117, 99, 107, 111,
				118, 46, 66, 108, 97, 99, 107, 77, 97, 114,
				107, 101, 116, 115, 46, 85, 73, 124, 68, 101,
				109, 97, 110, 100, 80, 97, 110, 101, 108, 0,
				0, 0, 0, 40, 68, 117, 99, 107, 111, 118,
				46, 66, 108, 97, 99, 107, 77, 97, 114, 107,
				101, 116, 115, 46, 85, 73, 124, 68, 101, 109,
				97, 110, 100, 80, 97, 110, 101, 108, 95, 69,
				110, 116, 114, 121, 0, 0, 0, 0, 34, 68,
				117, 99, 107, 111, 118, 46, 66, 108, 97, 99,
				107, 77, 97, 114, 107, 101, 116, 115, 46, 85,
				73, 124, 83, 117, 112, 112, 108, 121, 80, 97,
				110, 101, 108, 0, 0, 0, 0, 40, 68, 117,
				99, 107, 111, 118, 46, 66, 108, 97, 99, 107,
				77, 97, 114, 107, 101, 116, 115, 46, 85, 73,
				124, 83, 117, 112, 112, 108, 121, 80, 97, 110,
				101, 108, 95, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 25, 68, 117, 99, 107, 111, 118, 46,
				66, 117, 105, 108, 100, 105, 110, 103, 115, 124,
				66, 117, 105, 108, 100, 105, 110, 103, 0, 0,
				0, 0, 39, 68, 117, 99, 107, 111, 118, 46,
				66, 117, 105, 108, 100, 105, 110, 103, 115, 124,
				66, 117, 105, 108, 100, 105, 110, 103, 68, 97,
				116, 97, 67, 111, 108, 108, 101, 99, 116, 105,
				111, 110, 0, 0, 0, 0, 29, 68, 117, 99,
				107, 111, 118, 46, 66, 117, 105, 108, 100, 105,
				110, 103, 115, 124, 66, 117, 105, 108, 100, 105,
				110, 103, 73, 110, 102, 111, 0, 0, 0, 0,
				31, 68, 117, 99, 107, 111, 118, 46, 66, 117,
				105, 108, 100, 105, 110, 103, 115, 124, 66, 117,
				105, 108, 100, 105, 110, 103, 69, 102, 102, 101,
				99, 116, 0, 0, 0, 0, 51, 68, 117, 99,
				107, 111, 118, 46, 66, 117, 105, 108, 100, 105,
				110, 103, 115, 46, 66, 117, 105, 108, 100, 105,
				110, 103, 69, 102, 102, 101, 99, 116, 124, 77,
				111, 100, 105, 102, 105, 101, 114, 68, 101, 115,
				99, 114, 105, 112, 116, 105, 111, 110, 0, 0,
				0, 0, 32, 68, 117, 99, 107, 111, 118, 46,
				66, 117, 105, 108, 100, 105, 110, 103, 115, 124,
				66, 117, 105, 108, 100, 105, 110, 103, 77, 97,
				110, 97, 103, 101, 114, 0, 0, 0, 0, 57,
				68, 117, 99, 107, 111, 118, 46, 66, 117, 105,
				108, 100, 105, 110, 103, 115, 46, 66, 117, 105,
				108, 100, 105, 110, 103, 77, 97, 110, 97, 103,
				101, 114, 124, 66, 117, 105, 108, 100, 105, 110,
				103, 84, 111, 107, 101, 110, 65, 109, 111, 117,
				110, 116, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 49, 68, 117, 99, 107, 111, 118, 46, 66,
				117, 105, 108, 100, 105, 110, 103, 115, 46, 66,
				117, 105, 108, 100, 105, 110, 103, 77, 97, 110,
				97, 103, 101, 114, 124, 66, 117, 105, 108, 100,
				105, 110, 103, 65, 114, 101, 97, 68, 97, 116,
				97, 0, 0, 0, 0, 45, 68, 117, 99, 107,
				111, 118, 46, 66, 117, 105, 108, 100, 105, 110,
				103, 115, 46, 66, 117, 105, 108, 100, 105, 110,
				103, 77, 97, 110, 97, 103, 101, 114, 124, 66,
				117, 105, 108, 100, 105, 110, 103, 68, 97, 116,
				97, 0, 0, 0, 0, 41, 68, 117, 99, 107,
				111, 118, 46, 66, 117, 105, 108, 100, 105, 110,
				103, 115, 46, 66, 117, 105, 108, 100, 105, 110,
				103, 77, 97, 110, 97, 103, 101, 114, 124, 83,
				97, 118, 101, 68, 97, 116, 97, 0, 0, 0,
				0, 11, 124, 67, 97, 109, 101, 114, 97, 77,
				111, 100, 101, 0, 0, 0, 0, 21, 124, 67,
				97, 109, 101, 114, 97, 77, 111, 100, 101, 67,
				111, 110, 116, 114, 111, 108, 108, 101, 114, 0,
				0, 0, 0, 16, 68, 117, 99, 107, 111, 118,
				124, 67, 104, 101, 97, 116, 77, 111, 100, 101,
				0, 0, 0, 0, 16, 124, 67, 114, 97, 102,
				116, 105, 110, 103, 70, 111, 114, 109, 117, 108,
				97, 0, 0, 0, 0, 10, 124, 73, 116, 101,
				109, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				26, 124, 67, 114, 97, 102, 116, 105, 110, 103,
				70, 111, 114, 109, 117, 108, 97, 67, 111, 108,
				108, 101, 99, 116, 105, 111, 110, 0, 0, 0,
				0, 16, 124, 67, 114, 97, 102, 116, 105, 110,
				103, 77, 97, 110, 97, 103, 101, 114, 0, 0,
				0, 0, 18, 124, 68, 101, 99, 111, 109, 112,
				111, 115, 101, 68, 97, 116, 97, 98, 97, 115,
				101, 0, 0, 0, 0, 17, 124, 68, 101, 99,
				111, 109, 112, 111, 115, 101, 70, 111, 114, 109,
				117, 108, 97, 0, 0, 0, 0, 16, 124, 73,
				110, 116, 101, 114, 97, 99, 116, 67, 114, 97,
				102, 116, 101, 114, 0, 0, 0, 0, 10, 124,
				67, 114, 97, 102, 116, 86, 105, 101, 119, 0,
				0, 0, 0, 20, 67, 114, 97, 102, 116, 86,
				105, 101, 119, 124, 70, 105, 108, 116, 101, 114,
				73, 110, 102, 111, 0, 0, 0, 0, 24, 124,
				67, 114, 97, 102, 116, 86, 105, 101, 119, 70,
				105, 108, 116, 101, 114, 66, 116, 110, 69, 110,
				116, 114, 121, 0, 0, 0, 0, 20, 124, 67,
				114, 97, 102, 116, 86, 105, 101, 119, 95, 76,
				105, 115, 116, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 34, 68, 117, 99, 107, 111, 118, 46,
				68, 101, 97, 116, 104, 76, 111, 116, 116, 101,
				114, 105, 101, 115, 124, 68, 101, 97, 116, 104,
				76, 111, 116, 116, 101, 114, 121, 0, 0, 0,
				0, 49, 68, 117, 99, 107, 111, 118, 46, 68,
				101, 97, 116, 104, 76, 111, 116, 116, 101, 114,
				105, 101, 115, 46, 68, 101, 97, 116, 104, 76,
				111, 116, 116, 101, 114, 121, 124, 100, 117, 109,
				109, 121, 73, 116, 101, 109, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 48, 68, 117, 99, 107,
				111, 118, 46, 68, 101, 97, 116, 104, 76, 111,
				116, 116, 101, 114, 105, 101, 115, 46, 68, 101,
				97, 116, 104, 76, 111, 116, 116, 101, 114, 121,
				124, 79, 112, 116, 105, 111, 110, 97, 108, 67,
				111, 115, 116, 115, 0, 0, 0, 0, 41, 68,
				117, 99, 107, 111, 118, 46, 68, 101, 97, 116,
				104, 76, 111, 116, 116, 101, 114, 105, 101, 115,
				46, 68, 101, 97, 116, 104, 76, 111, 116, 116,
				101, 114, 121, 124, 83, 116, 97, 116, 117, 115,
				0, 0, 0, 0, 46, 68, 117, 99, 107, 111,
				118, 46, 68, 101, 97, 116, 104, 76, 111, 116,
				116, 101, 114, 105, 101, 115, 124, 68, 101, 97,
				116, 104, 76, 111, 116, 116, 101, 114, 121, 73,
				110, 116, 101, 114, 97, 99, 116, 97, 98, 108,
				101, 0, 0, 0, 0, 33, 68, 117, 99, 107,
				111, 118, 46, 68, 101, 97, 116, 104, 76, 111,
				116, 116, 101, 114, 105, 101, 115, 124, 67, 97,
				114, 100, 68, 105, 115, 112, 108, 97, 121, 0,
				0, 0, 0, 38, 68, 117, 99, 107, 111, 118,
				46, 68, 101, 97, 116, 104, 76, 111, 116, 116,
				101, 114, 105, 101, 115, 124, 68, 101, 97, 116,
				104, 76, 111, 116, 116, 101, 114, 121, 67, 97,
				114, 100, 0, 0, 0, 0, 38, 68, 117, 99,
				107, 111, 118, 46, 68, 101, 97, 116, 104, 76,
				111, 116, 116, 101, 114, 105, 101, 115, 124, 68,
				101, 97, 116, 104, 76, 111, 116, 116, 101, 114,
				121, 86, 73, 101, 119, 0, 0, 0, 0, 22,
				68, 117, 99, 107, 111, 118, 124, 68, 101, 97,
				100, 66, 111, 100, 121, 77, 97, 110, 97, 103,
				101, 114, 0, 0, 0, 0, 32, 68, 117, 99,
				107, 111, 118, 46, 68, 101, 97, 100, 66, 111,
				100, 121, 77, 97, 110, 97, 103, 101, 114, 124,
				68, 101, 97, 116, 104, 73, 110, 102, 111, 0,
				0, 0, 0, 5, 124, 84, 101, 109, 112, 0,
				0, 0, 0, 33, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 68, 101, 98, 117, 103, 75,
				111, 110, 116, 101, 120, 116, 77, 101, 110, 117,
				73, 110, 118, 111, 107, 101, 114, 0, 0, 0,
				0, 27, 68, 101, 98, 117, 103, 103, 105, 110,
				103, 124, 73, 110, 115, 116, 97, 110, 116, 105,
				97, 116, 101, 84, 105, 109, 105, 110, 103, 0,
				0, 0, 0, 27, 68, 101, 98, 117, 103, 103,
				105, 110, 103, 124, 73, 110, 118, 101, 110, 116,
				111, 114, 121, 83, 97, 118, 101, 76, 111, 97,
				100, 0, 0, 0, 0, 9, 124, 73, 116, 101,
				109, 84, 101, 115, 116, 0, 0, 0, 0, 40,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 46,
				68, 105, 97, 108, 111, 103, 117, 101, 66, 117,
				98, 98, 108, 101, 115, 124, 68, 105, 97, 108,
				111, 103, 117, 101, 66, 117, 98, 98, 108, 101,
				0, 0, 0, 0, 20, 124, 68, 105, 97, 108,
				111, 103, 117, 101, 66, 117, 98, 98, 108, 101,
				80, 114, 111, 120, 121, 0, 0, 0, 0, 48,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 46,
				68, 105, 97, 108, 111, 103, 117, 101, 66, 117,
				98, 98, 108, 101, 115, 124, 68, 105, 97, 108,
				111, 103, 117, 101, 66, 117, 98, 98, 108, 101,
				115, 77, 97, 110, 97, 103, 101, 114, 0, 0,
				0, 0, 9, 124, 67, 117, 116, 83, 99, 101,
				110, 101, 0, 0, 0, 0, 20, 68, 105, 97,
				108, 111, 103, 117, 101, 115, 124, 68, 105, 97,
				108, 111, 103, 117, 101, 85, 73, 0, 0, 0,
				0, 26, 68, 105, 97, 108, 111, 103, 117, 101,
				115, 124, 68, 105, 97, 108, 111, 103, 117, 101,
				85, 73, 67, 104, 111, 105, 99, 101, 0, 0,
				0, 0, 20, 124, 68, 117, 99, 107, 111, 118,
				68, 105, 97, 108, 111, 103, 117, 101, 65, 99,
				116, 111, 114, 0, 0, 0, 0, 52, 78, 111,
				100, 101, 67, 97, 110, 118, 97, 115, 46, 68,
				105, 97, 108, 111, 103, 117, 101, 84, 114, 101,
				101, 115, 124, 76, 111, 99, 97, 108, 105, 122,
				101, 100, 77, 117, 108, 116, 105, 112, 108, 101,
				67, 104, 111, 105, 99, 101, 78, 111, 100, 101,
				0, 0, 0, 0, 59, 78, 111, 100, 101, 67,
				97, 110, 118, 97, 115, 46, 68, 105, 97, 108,
				111, 103, 117, 101, 84, 114, 101, 101, 115, 46,
				76, 111, 99, 97, 108, 105, 122, 101, 100, 77,
				117, 108, 116, 105, 112, 108, 101, 67, 104, 111,
				105, 99, 101, 78, 111, 100, 101, 124, 67, 104,
				111, 105, 99, 101, 0, 0, 0, 0, 28, 68,
				105, 97, 108, 111, 103, 117, 101, 115, 124, 76,
				111, 99, 97, 108, 105, 122, 101, 100, 83, 116,
				97, 116, 101, 109, 101, 110, 116, 0, 0, 0,
				0, 32, 68, 105, 97, 108, 111, 103, 117, 101,
				115, 124, 76, 111, 99, 97, 108, 105, 122, 101,
				100, 83, 116, 97, 116, 101, 109, 101, 110, 116,
				78, 111, 100, 101, 0, 0, 0, 0, 36, 68,
				105, 97, 108, 111, 103, 117, 101, 115, 124, 76,
				111, 99, 97, 108, 105, 122, 101, 100, 83, 116,
				97, 116, 101, 109, 101, 110, 116, 83, 101, 113,
				117, 101, 110, 99, 101, 0, 0, 0, 0, 18,
				124, 65, 84, 95, 83, 101, 116, 66, 108, 97,
				99, 107, 83, 99, 114, 101, 101, 110, 0, 0,
				0, 0, 20, 124, 65, 84, 95, 83, 101, 116,
				86, 105, 114, 116, 117, 97, 108, 67, 97, 109,
				101, 114, 97, 0, 0, 0, 0, 20, 68, 117,
				99, 107, 111, 118, 46, 84, 97, 115, 107, 115,
				124, 67, 114, 101, 100, 105, 116, 115, 0, 0,
				0, 0, 36, 68, 117, 99, 107, 111, 118, 46,
				67, 114, 101, 100, 105, 116, 115, 85, 116, 105,
				108, 105, 116, 121, 124, 67, 114, 101, 100, 105,
				116, 115, 68, 105, 115, 112, 108, 97, 121, 0,
				0, 0, 0, 53, 68, 117, 99, 107, 111, 118,
				46, 67, 114, 101, 100, 105, 116, 115, 85, 116,
				105, 108, 105, 116, 121, 46, 67, 114, 101, 100,
				105, 116, 115, 68, 105, 115, 112, 108, 97, 121,
				124, 71, 101, 110, 101, 114, 97, 116, 105, 111,
				110, 83, 116, 97, 116, 117, 115, 0, 0, 0,
				0, 27, 68, 117, 99, 107, 111, 118, 46, 67,
				114, 101, 100, 105, 116, 115, 85, 116, 105, 108,
				105, 116, 121, 124, 84, 111, 107, 101, 110, 0,
				0, 0, 0, 34, 68, 117, 99, 107, 111, 118,
				46, 67, 114, 101, 100, 105, 116, 115, 85, 116,
				105, 108, 105, 116, 121, 124, 67, 114, 101, 100,
				105, 116, 115, 76, 101, 120, 101, 114, 0, 0,
				0, 0, 32, 68, 117, 99, 107, 111, 118, 46,
				67, 114, 101, 100, 105, 116, 115, 85, 116, 105,
				108, 105, 116, 121, 124, 69, 109, 112, 116, 121,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 23,
				68, 117, 99, 107, 111, 118, 46, 84, 97, 115,
				107, 115, 124, 69, 110, 100, 105, 110, 103, 70,
				108, 111, 119, 0, 0, 0, 0, 37, 68, 117,
				99, 107, 111, 118, 46, 67, 114, 101, 100, 105,
				116, 115, 85, 116, 105, 108, 105, 116, 121, 124,
				72, 111, 114, 105, 122, 111, 110, 116, 97, 108,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 32,
				68, 117, 99, 107, 111, 118, 46, 67, 114, 101,
				100, 105, 116, 115, 85, 116, 105, 108, 105, 116,
				121, 124, 73, 109, 97, 103, 101, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 31, 68, 117, 99,
				107, 111, 118, 46, 67, 114, 101, 100, 105, 116,
				115, 85, 116, 105, 108, 105, 116, 121, 124, 84,
				101, 120, 116, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 35, 68, 117, 99, 107, 111, 118, 46,
				67, 114, 101, 100, 105, 116, 115, 85, 116, 105,
				108, 105, 116, 121, 124, 86, 101, 114, 116, 105,
				99, 97, 108, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 36, 68, 117, 99, 107, 111, 118, 46,
				69, 110, 100, 111, 119, 109, 101, 110, 116, 46,
				85, 73, 124, 69, 110, 100, 111, 119, 109, 101,
				110, 116, 68, 105, 115, 112, 108, 97, 121, 0,
				0, 0, 0, 31, 68, 117, 99, 107, 111, 118,
				46, 69, 110, 100, 111, 119, 109, 101, 110, 116,
				124, 69, 110, 100, 111, 119, 109, 101, 110, 116,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 51,
				68, 117, 99, 107, 111, 118, 46, 69, 110, 100,
				111, 119, 109, 101, 110, 116, 46, 69, 110, 100,
				111, 119, 109, 101, 110, 116, 69, 110, 116, 114,
				121, 124, 77, 111, 100, 105, 102, 105, 101, 114,
				68, 101, 115, 99, 114, 105, 112, 116, 105, 111,
				110, 0, 0, 0, 0, 33, 68, 117, 99, 107,
				111, 118, 46, 69, 110, 100, 111, 119, 109, 101,
				110, 116, 124, 69, 110, 100, 111, 119, 109, 101,
				110, 116, 77, 97, 110, 97, 103, 101, 114, 0,
				0, 0, 0, 19, 70, 105, 115, 104, 105, 110,
				103, 124, 70, 105, 115, 104, 105, 110, 103, 80,
				111, 111, 108, 0, 0, 0, 0, 27, 70, 105,
				115, 104, 105, 110, 103, 124, 87, 101, 105, 103,
				104, 116, 77, 111, 100, 105, 102, 105, 99, 97,
				116, 105, 111, 110, 115, 0, 0, 0, 0, 24,
				70, 105, 115, 104, 105, 110, 103, 124, 70, 105,
				115, 104, 105, 110, 103, 80, 111, 111, 108, 69,
				110, 116, 114, 121, 0, 0, 0, 0, 26, 70,
				105, 115, 104, 105, 110, 103, 46, 85, 73, 124,
				66, 97, 105, 116, 83, 101, 108, 101, 99, 116,
				80, 97, 110, 101, 108, 0, 0, 0, 0, 31,
				70, 105, 115, 104, 105, 110, 103, 46, 85, 73,
				124, 66, 97, 105, 116, 83, 101, 108, 101, 99,
				116, 80, 97, 110, 101, 108, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 23, 70, 105, 115, 104,
				105, 110, 103, 46, 85, 73, 124, 67, 111, 110,
				102, 105, 114, 109, 80, 97, 110, 101, 108, 0,
				0, 0, 0, 18, 70, 105, 115, 104, 105, 110,
				103, 124, 70, 105, 115, 104, 105, 110, 103, 72,
				85, 68, 0, 0, 0, 0, 20, 70, 105, 115,
				104, 105, 110, 103, 46, 85, 73, 124, 70, 105,
				115, 104, 105, 110, 103, 85, 73, 0, 0, 0,
				0, 23, 124, 70, 111, 114, 109, 117, 108, 97,
				115, 68, 101, 116, 97, 105, 108, 115, 68, 105,
				115, 112, 108, 97, 121, 0, 0, 0, 0, 28,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 124,
				70, 111, 114, 109, 117, 108, 97, 115, 73, 110,
				100, 101, 120, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 27, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 124, 70, 111, 114, 109, 117, 108, 97,
				115, 73, 110, 100, 101, 120, 86, 105, 101, 119,
				0, 0, 0, 0, 30, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 124, 70, 111, 114, 109, 117,
				108, 97, 115, 82, 101, 103, 105, 115, 116, 101,
				114, 86, 105, 101, 119, 0, 0, 0, 0, 28,
				124, 70, 111, 114, 109, 117, 108, 97, 115, 82,
				101, 103, 105, 115, 116, 101, 114, 86, 105, 101,
				119, 73, 110, 118, 111, 107, 101, 114, 0, 0,
				0, 0, 37, 67, 97, 109, 101, 114, 97, 83,
				121, 115, 116, 101, 109, 115, 124, 67, 97, 109,
				101, 114, 97, 80, 114, 111, 112, 101, 114, 116,
				105, 101, 115, 67, 111, 110, 116, 114, 111, 108,
				0, 0, 0, 0, 7, 124, 68, 101, 118, 67,
				97, 109, 0, 0, 0, 0, 21, 124, 70, 114,
				101, 101, 67, 97, 109, 101, 114, 97, 67, 111,
				110, 116, 114, 111, 108, 108, 101, 114, 0, 0,
				0, 0, 7, 124, 70, 88, 80, 111, 111, 108,
				0, 0, 0, 0, 11, 70, 88, 80, 111, 111,
				108, 124, 80, 111, 111, 108, 0, 0, 0, 0,
				10, 124, 71, 97, 109, 101, 67, 108, 111, 99,
				107, 0, 0, 0, 0, 18, 71, 97, 109, 101,
				67, 108, 111, 99, 107, 124, 83, 97, 118, 101,
				68, 97, 116, 97, 0, 0, 0, 0, 17, 124,
				71, 97, 109, 101, 67, 108, 111, 99, 107, 68,
				105, 115, 112, 108, 97, 121, 0, 0, 0, 0,
				19, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 83, 108, 101, 101, 112, 86, 105, 101, 119,
				0, 0, 0, 0, 24, 68, 117, 99, 107, 111,
				118, 46, 67, 114, 111, 112, 115, 124, 67, 101,
				108, 108, 68, 105, 115, 112, 108, 97, 121, 0,
				0, 0, 0, 38, 68, 117, 99, 107, 111, 118,
				46, 67, 114, 111, 112, 115, 46, 67, 101, 108,
				108, 68, 105, 115, 112, 108, 97, 121, 124, 71,
				114, 97, 112, 104, 105, 99, 115, 83, 116, 121,
				108, 101, 0, 0, 0, 0, 17, 68, 117, 99,
				107, 111, 118, 46, 67, 114, 111, 112, 115, 124,
				67, 114, 111, 112, 0, 0, 0, 0, 25, 68,
				117, 99, 107, 111, 118, 46, 67, 114, 111, 112,
				115, 124, 67, 114, 111, 112, 65, 110, 105, 109,
				97, 116, 111, 114, 0, 0, 0, 0, 31, 68,
				117, 99, 107, 111, 118, 46, 67, 114, 111, 112,
				115, 46, 67, 114, 111, 112, 65, 110, 105, 109,
				97, 116, 111, 114, 124, 83, 116, 97, 103, 101,
				0, 0, 0, 0, 25, 68, 117, 99, 107, 111,
				118, 46, 67, 114, 111, 112, 115, 124, 67, 114,
				111, 112, 68, 97, 116, 97, 98, 97, 115, 101,
				0, 0, 0, 0, 21, 68, 117, 99, 107, 111,
				118, 46, 67, 114, 111, 112, 115, 124, 83, 101,
				101, 100, 73, 110, 102, 111, 0, 0, 0, 0,
				21, 68, 117, 99, 107, 111, 118, 46, 67, 114,
				111, 112, 115, 124, 67, 114, 111, 112, 73, 110,
				102, 111, 0, 0, 0, 0, 21, 68, 117, 99,
				107, 111, 118, 46, 67, 114, 111, 112, 115, 124,
				67, 114, 111, 112, 68, 97, 116, 97, 0, 0,
				0, 0, 19, 68, 117, 99, 107, 111, 118, 46,
				67, 114, 111, 112, 115, 124, 71, 97, 114, 100,
				101, 110, 0, 0, 0, 0, 28, 68, 117, 99,
				107, 111, 118, 46, 67, 114, 111, 112, 115, 46,
				71, 97, 114, 100, 101, 110, 124, 83, 97, 118,
				101, 68, 97, 116, 97, 0, 0, 0, 0, 29,
				68, 117, 99, 107, 111, 118, 46, 67, 114, 111,
				112, 115, 124, 73, 71, 97, 114, 100, 101, 110,
				83, 105, 122, 101, 65, 100, 100, 101, 114, 0,
				0, 0, 0, 37, 68, 117, 99, 107, 111, 118,
				46, 67, 114, 111, 112, 115, 124, 73, 71, 97,
				114, 100, 101, 110, 65, 117, 116, 111, 87, 97,
				116, 101, 114, 80, 114, 111, 118, 105, 100, 101,
				114, 0, 0, 0, 0, 34, 68, 117, 99, 107,
				111, 118, 46, 67, 114, 111, 112, 115, 46, 85,
				73, 124, 67, 101, 108, 108, 67, 111, 110, 116,
				101, 120, 116, 68, 105, 115, 112, 108, 97, 121,
				0, 0, 0, 0, 26, 68, 117, 99, 107, 111,
				118, 46, 67, 114, 111, 112, 115, 46, 85, 73,
				124, 71, 97, 114, 100, 101, 110, 86, 105, 101,
				119, 0, 0, 0, 0, 38, 68, 117, 99, 107,
				111, 118, 46, 67, 114, 111, 112, 115, 46, 85,
				73, 124, 71, 97, 114, 100, 101, 110, 86, 105,
				101, 119, 67, 114, 111, 112, 83, 101, 108, 101,
				99, 116, 111, 114, 0, 0, 0, 0, 36, 68,
				117, 99, 107, 111, 118, 46, 67, 114, 111, 112,
				115, 46, 85, 73, 124, 71, 97, 114, 100, 101,
				110, 86, 105, 101, 119, 84, 111, 111, 108, 66,
				117, 116, 116, 111, 110, 0, 0, 0, 0, 14,
				124, 73, 110, 112, 117, 116, 82, 101, 98, 105,
				110, 100, 101, 114, 0, 0, 0, 0, 23, 124,
				73, 110, 112, 117, 116, 82, 101, 98, 105, 110,
				100, 101, 114, 73, 110, 100, 105, 99, 97, 116,
				111, 114, 0, 0, 0, 0, 13, 124, 73, 116,
				101, 109, 87, 105, 115, 104, 108, 105, 115, 116,
				0, 0, 0, 0, 25, 73, 116, 101, 109, 87,
				105, 115, 104, 108, 105, 115, 116, 124, 87, 105,
				115, 104, 108, 105, 115, 116, 73, 110, 102, 111,
				0, 0, 0, 0, 30, 68, 117, 99, 107, 111,
				118, 46, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 124, 76, 111, 111, 116, 66, 111, 120, 76,
				111, 97, 100, 101, 114, 0, 0, 0, 0, 36,
				68, 117, 99, 107, 111, 118, 46, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 46, 76, 111, 111,
				116, 66, 111, 120, 76, 111, 97, 100, 101, 114,
				124, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				46, 68, 117, 99, 107, 111, 118, 46, 77, 97,
				115, 116, 101, 114, 75, 101, 121, 115, 124, 77,
				97, 115, 116, 101, 114, 75, 101, 121, 82, 101,
				103, 105, 115, 116, 101, 114, 86, 105, 101, 119,
				73, 110, 118, 111, 107, 101, 114, 0, 0, 0,
				0, 35, 68, 117, 99, 107, 111, 118, 46, 77,
				97, 115, 116, 101, 114, 75, 101, 121, 115, 124,
				77, 97, 115, 116, 101, 114, 75, 101, 121, 115,
				77, 97, 110, 97, 103, 101, 114, 0, 0, 0,
				0, 42, 68, 117, 99, 107, 111, 118, 46, 77,
				97, 115, 116, 101, 114, 75, 101, 121, 115, 46,
				77, 97, 115, 116, 101, 114, 75, 101, 121, 115,
				77, 97, 110, 97, 103, 101, 114, 124, 83, 116,
				97, 116, 117, 115, 0, 0, 0, 0, 41, 68,
				117, 99, 107, 111, 118, 46, 77, 97, 115, 116,
				101, 114, 75, 101, 121, 115, 46, 85, 73, 124,
				77, 97, 115, 116, 101, 114, 75, 101, 121, 115,
				73, 110, 100, 101, 120, 69, 110, 116, 114, 121,
				0, 0, 0, 0, 46, 68, 117, 99, 107, 111,
				118, 46, 77, 97, 115, 116, 101, 114, 75, 101,
				121, 115, 46, 85, 73, 46, 77, 97, 115, 116,
				101, 114, 75, 101, 121, 115, 73, 110, 100, 101,
				120, 69, 110, 116, 114, 121, 124, 76, 111, 111,
				107, 0, 0, 0, 0, 45, 68, 117, 99, 107,
				111, 118, 46, 77, 97, 115, 116, 101, 114, 75,
				101, 121, 115, 46, 85, 73, 124, 77, 97, 115,
				116, 101, 114, 75, 101, 121, 115, 73, 110, 100,
				101, 120, 73, 110, 115, 112, 101, 99, 116, 111,
				114, 0, 0, 0, 0, 40, 68, 117, 99, 107,
				111, 118, 46, 77, 97, 115, 116, 101, 114, 75,
				101, 121, 115, 46, 85, 73, 124, 77, 97, 115,
				116, 101, 114, 75, 101, 121, 115, 73, 110, 100,
				101, 120, 76, 105, 115, 116, 0, 0, 0, 0,
				43, 68, 117, 99, 107, 111, 118, 46, 77, 97,
				115, 116, 101, 114, 75, 101, 121, 115, 46, 85,
				73, 124, 77, 97, 115, 116, 101, 114, 75, 101,
				121, 115, 82, 101, 103, 105, 115, 116, 101, 114,
				86, 105, 101, 119, 0, 0, 0, 0, 35, 68,
				117, 99, 107, 111, 118, 46, 77, 97, 115, 116,
				101, 114, 75, 101, 121, 115, 46, 85, 73, 124,
				77, 97, 115, 116, 101, 114, 75, 101, 121, 115,
				86, 105, 101, 119, 0, 0, 0, 0, 7, 85,
				73, 124, 77, 101, 110, 117, 0, 0, 0, 0,
				11, 85, 73, 124, 77, 101, 110, 117, 73, 116,
				101, 109, 0, 0, 0, 0, 37, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 46, 66, 117, 98, 98, 108, 101,
				80, 111, 112, 112, 101, 114, 115, 124, 66, 117,
				98, 98, 108, 101, 0, 0, 0, 0, 43, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 46, 66, 117, 98, 98,
				108, 101, 80, 111, 112, 112, 101, 114, 115, 124,
				66, 117, 98, 98, 108, 101, 80, 111, 112, 112,
				101, 114, 0, 0, 0, 0, 54, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 46, 66, 117, 98, 98, 108, 101,
				80, 111, 112, 112, 101, 114, 115, 46, 66, 117,
				98, 98, 108, 101, 80, 111, 112, 112, 101, 114,
				124, 67, 97, 115, 116, 82, 101, 115, 117, 108,
				116, 0, 0, 0, 0, 49, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 66, 117, 98, 98, 108, 101, 80,
				111, 112, 112, 101, 114, 115, 124, 66, 117, 98,
				98, 108, 101, 80, 111, 112, 112, 101, 114, 76,
				97, 121, 111, 117, 116, 0, 0, 0, 0, 60,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 66, 117, 98,
				98, 108, 101, 80, 111, 112, 112, 101, 114, 115,
				124, 66, 117, 98, 98, 108, 101, 80, 111, 112,
				112, 101, 114, 76, 101, 118, 101, 108, 68, 97,
				116, 97, 80, 114, 111, 118, 105, 100, 101, 114,
				0, 0, 0, 0, 41, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 46, 69, 120, 97, 109, 112, 108, 101, 115,
				46, 70, 80, 83, 124, 85, 73, 67, 114, 111,
				115, 115, 72, 97, 105, 114, 0, 0, 0, 0,
				44, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 46, 68, 101,
				98, 117, 103, 103, 105, 110, 103, 124, 72, 105,
				100, 101, 65, 110, 100, 76, 111, 99, 107, 67,
				117, 114, 115, 111, 114, 0, 0, 0, 0, 49,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 69, 120, 97,
				109, 112, 108, 101, 115, 46, 70, 80, 83, 124,
				70, 80, 83, 95, 69, 110, 101, 109, 121, 95,
				72, 111, 109, 105, 110, 103, 70, 108, 121, 0,
				0, 0, 0, 42, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 69, 120, 97, 109, 112, 108, 101, 115, 46,
				70, 80, 83, 124, 70, 80, 83, 67, 104, 97,
				114, 97, 99, 116, 101, 114, 0, 0, 0, 0,
				47, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 46, 69, 120,
				97, 109, 112, 108, 101, 115, 46, 70, 80, 83,
				124, 70, 80, 83, 68, 97, 109, 97, 103, 101,
				82, 101, 99, 101, 105, 118, 101, 114, 0, 0,
				0, 0, 43, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				69, 120, 97, 109, 112, 108, 101, 115, 46, 70,
				80, 83, 124, 70, 80, 83, 68, 97, 109, 97,
				103, 101, 73, 110, 102, 111, 0, 0, 0, 0,
				36, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 46, 69, 120,
				97, 109, 112, 108, 101, 115, 46, 70, 80, 83,
				124, 70, 80, 83, 71, 117, 110, 0, 0, 0,
				0, 41, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 46, 69,
				120, 97, 109, 112, 108, 101, 115, 46, 70, 80,
				83, 46, 70, 80, 83, 71, 117, 110, 124, 80,
				111, 115, 101, 0, 0, 0, 0, 43, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 69, 120, 97, 109, 112,
				108, 101, 115, 46, 70, 80, 83, 124, 70, 80,
				83, 71, 117, 110, 67, 111, 110, 116, 114, 111,
				108, 0, 0, 0, 0, 39, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 69, 120, 97, 109, 112, 108, 101,
				115, 46, 70, 80, 83, 124, 70, 80, 83, 72,
				101, 97, 108, 116, 104, 0, 0, 0, 0, 41,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 69, 120, 97,
				109, 112, 108, 101, 115, 46, 70, 80, 83, 124,
				70, 80, 83, 77, 111, 118, 101, 109, 101, 110,
				116, 0, 0, 0, 0, 44, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 46, 65, 114, 116, 105, 102, 97, 99,
				116, 115, 124, 71, 77, 65, 95, 48, 48, 49,
				0, 0, 0, 0, 44, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 46, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 46, 65, 114, 116, 105, 102, 97, 99, 116,
				115, 124, 71, 77, 65, 95, 48, 48, 50, 0,
				0, 0, 0, 44, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				46, 65, 114, 116, 105, 102, 97, 99, 116, 115,
				124, 71, 77, 65, 95, 48, 48, 51, 0, 0,
				0, 0, 44, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 46,
				65, 114, 116, 105, 102, 97, 99, 116, 115, 124,
				71, 77, 65, 95, 48, 48, 52, 0, 0, 0,
				0, 44, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 46, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 46, 65,
				114, 116, 105, 102, 97, 99, 116, 115, 124, 71,
				77, 65, 95, 48, 48, 53, 0, 0, 0, 0,
				44, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 46, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 46, 65, 114,
				116, 105, 102, 97, 99, 116, 115, 124, 71, 77,
				65, 95, 48, 48, 54, 0, 0, 0, 0, 44,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 46, 65, 114, 116,
				105, 102, 97, 99, 116, 115, 124, 71, 77, 65,
				95, 48, 48, 55, 0, 0, 0, 0, 44, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 46, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 46, 65, 114, 116, 105,
				102, 97, 99, 116, 115, 124, 71, 77, 65, 95,
				48, 48, 56, 0, 0, 0, 0, 44, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 46, 65, 114, 116, 105, 102,
				97, 99, 116, 115, 124, 71, 77, 65, 95, 48,
				48, 57, 0, 0, 0, 0, 44, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 46, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 46, 65, 114, 116, 105, 102, 97,
				99, 116, 115, 124, 71, 77, 65, 95, 48, 49,
				48, 0, 0, 0, 0, 44, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 46, 65, 114, 116, 105, 102, 97, 99,
				116, 115, 124, 71, 77, 65, 95, 48, 49, 49,
				0, 0, 0, 0, 44, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 46, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 46, 65, 114, 116, 105, 102, 97, 99, 116,
				115, 124, 71, 77, 65, 95, 48, 49, 50, 0,
				0, 0, 0, 44, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				46, 65, 114, 116, 105, 102, 97, 99, 116, 115,
				124, 71, 77, 65, 95, 48, 49, 51, 0, 0,
				0, 0, 44, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 46,
				65, 114, 116, 105, 102, 97, 99, 116, 115, 124,
				71, 77, 65, 95, 48, 49, 52, 0, 0, 0,
				0, 44, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 46, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 46, 65,
				114, 116, 105, 102, 97, 99, 116, 115, 124, 71,
				77, 65, 95, 48, 49, 53, 0, 0, 0, 0,
				44, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 46, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 46, 65, 114,
				116, 105, 102, 97, 99, 116, 115, 124, 71, 77,
				65, 95, 48, 49, 54, 0, 0, 0, 0, 44,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 46, 65, 114, 116,
				105, 102, 97, 99, 116, 115, 124, 71, 77, 65,
				95, 48, 49, 55, 0, 0, 0, 0, 44, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 46, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 46, 65, 114, 116, 105,
				102, 97, 99, 116, 115, 124, 71, 77, 65, 95,
				48, 49, 56, 0, 0, 0, 0, 44, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 46, 65, 114, 116, 105, 102,
				97, 99, 116, 115, 124, 71, 77, 65, 95, 48,
				49, 57, 0, 0, 0, 0, 44, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 46, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 46, 65, 114, 116, 105, 102, 97,
				99, 116, 115, 124, 71, 77, 65, 95, 48, 50,
				48, 0, 0, 0, 0, 44, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 46, 65, 114, 116, 105, 102, 97, 99,
				116, 115, 124, 71, 77, 65, 95, 48, 50, 49,
				0, 0, 0, 0, 44, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 46, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 46, 65, 114, 116, 105, 102, 97, 99, 116,
				115, 124, 71, 77, 65, 95, 48, 50, 50, 0,
				0, 0, 0, 44, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				46, 65, 114, 116, 105, 102, 97, 99, 116, 115,
				124, 71, 77, 65, 95, 48, 50, 51, 0, 0,
				0, 0, 44, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 46,
				65, 114, 116, 105, 102, 97, 99, 116, 115, 124,
				71, 77, 65, 95, 48, 50, 52, 0, 0, 0,
				0, 44, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 46, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 46, 65,
				114, 116, 105, 102, 97, 99, 116, 115, 124, 71,
				77, 65, 95, 48, 50, 53, 0, 0, 0, 0,
				44, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 46, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 46, 65, 114,
				116, 105, 102, 97, 99, 116, 115, 124, 71, 77,
				65, 95, 48, 50, 54, 0, 0, 0, 0, 44,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 46, 65, 114, 116,
				105, 102, 97, 99, 116, 115, 124, 71, 77, 65,
				95, 48, 50, 55, 0, 0, 0, 0, 44, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 46, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 46, 65, 114, 116, 105,
				102, 97, 99, 116, 115, 124, 71, 77, 65, 95,
				48, 50, 56, 0, 0, 0, 0, 44, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 46, 65, 114, 116, 105, 102,
				97, 99, 116, 115, 124, 71, 77, 65, 95, 48,
				50, 57, 0, 0, 0, 0, 44, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 46, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 46, 65, 114, 116, 105, 102, 97,
				99, 116, 115, 124, 71, 77, 65, 95, 48, 51,
				48, 0, 0, 0, 0, 44, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 46, 65, 114, 116, 105, 102, 97, 99,
				116, 115, 124, 71, 77, 65, 95, 48, 51, 49,
				0, 0, 0, 0, 44, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 46, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 46, 65, 114, 116, 105, 102, 97, 99, 116,
				115, 124, 71, 77, 65, 95, 48, 51, 50, 0,
				0, 0, 0, 44, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				124, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				65, 114, 116, 105, 102, 97, 99, 116, 0, 0,
				0, 0, 53, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 124,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 65,
				114, 116, 105, 102, 97, 99, 116, 66, 101, 104,
				97, 118, 105, 111, 117, 114, 0, 0, 0, 0,
				31, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 46, 71, 111,
				108, 100, 77, 105, 110, 101, 114, 124, 66, 111,
				109, 98, 0, 0, 0, 0, 43, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 46, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 124, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 82, 117, 110, 68, 97, 116, 97,
				0, 0, 0, 0, 36, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 46, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 124, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 0, 0, 0, 0, 42, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 124, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 69, 110, 116, 105, 116, 121, 0, 0,
				0, 0, 40, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 124,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 83,
				104, 111, 112, 0, 0, 0, 0, 37, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 124, 83, 104, 111, 112, 69,
				110, 116, 105, 116, 121, 0, 0, 0, 0, 31,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 124, 72, 111, 111,
				107, 0, 0, 0, 0, 35, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 124, 72, 111, 111, 107, 72, 101, 97,
				100, 0, 0, 0, 0, 45, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 124, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 95, 83, 104, 111, 112, 73, 116, 101,
				109, 0, 0, 0, 0, 44, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 124, 65, 100, 100, 66, 111, 109, 98,
				79, 110, 82, 101, 116, 114, 105, 101, 118, 101,
				0, 0, 0, 0, 54, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 46, 71, 111, 108, 100, 77, 105, 110, 101,
				114, 124, 65, 100, 100, 69, 97, 103, 108, 101,
				69, 121, 101, 80, 111, 116, 105, 111, 110, 79,
				110, 82, 101, 116, 114, 105, 101, 118, 101, 0,
				0, 0, 0, 54, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				124, 65, 100, 100, 83, 116, 114, 101, 110, 103,
				116, 104, 80, 111, 116, 105, 111, 110, 79, 110,
				82, 101, 116, 114, 105, 101, 118, 101, 0, 0,
				0, 0, 42, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 124,
				69, 120, 112, 108, 111, 100, 101, 79, 110, 65,
				116, 116, 97, 99, 104, 0, 0, 0, 0, 39,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 124, 80, 105, 103,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 0,
				0, 0, 0, 38, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				124, 66, 111, 109, 98, 68, 105, 115, 112, 108,
				97, 121, 0, 0, 0, 0, 48, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 46, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 124, 69, 97, 103, 108, 101, 69,
				121, 101, 80, 111, 116, 105, 111, 110, 68, 105,
				115, 112, 108, 97, 121, 0, 0, 0, 0, 48,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 124, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 77, 111, 110, 101,
				121, 68, 105, 115, 112, 108, 97, 121, 0, 0,
				0, 0, 42, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 124,
				71, 111, 108, 100, 77, 105, 110, 101, 114, 83,
				104, 111, 112, 85, 73, 0, 0, 0, 0, 53,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 124, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 83, 104, 111, 112,
				85, 73, 67, 111, 110, 116, 105, 110, 117, 101,
				66, 116, 110, 0, 0, 0, 0, 47, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 124, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 83, 104, 111, 112, 85, 73,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 52,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 124, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 83, 104, 111, 112,
				85, 73, 82, 101, 102, 114, 101, 115, 104, 66,
				116, 110, 0, 0, 0, 0, 44, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 46, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 124, 71, 111, 108, 100, 77, 105,
				110, 101, 114, 95, 80, 111, 112, 84, 101, 120,
				116, 0, 0, 0, 0, 49, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 124, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 95, 80, 111, 112, 84, 101, 120, 116,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 44,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 71, 111, 108,
				100, 77, 105, 110, 101, 114, 124, 76, 101, 118,
				101, 108, 83, 101, 116, 116, 108, 101, 109, 101,
				110, 116, 85, 73, 0, 0, 0, 0, 38, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 46, 71, 111, 108, 100,
				77, 105, 110, 101, 114, 46, 85, 73, 124, 78,
				97, 118, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 35, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 46, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 124, 78,
				97, 118, 71, 114, 111, 117, 112, 0, 0, 0,
				0, 51, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 46, 71,
				111, 108, 100, 77, 105, 110, 101, 114, 124, 78,
				97, 118, 71, 114, 111, 117, 112, 76, 105, 110,
				101, 97, 114, 67, 111, 110, 116, 114, 111, 108,
				108, 101, 114, 0, 0, 0, 0, 45, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 124, 80, 97, 115, 115, 105,
				118, 101, 80, 114, 111, 112, 68, 105, 115, 112,
				108, 97, 121, 0, 0, 0, 0, 41, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 124, 80, 97, 115, 115, 105,
				118, 101, 80, 114, 111, 112, 115, 85, 73, 0,
				0, 0, 0, 39, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				124, 83, 99, 111, 114, 101, 68, 105, 115, 112,
				108, 97, 121, 0, 0, 0, 0, 41, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 71, 111, 108, 100, 77,
				105, 110, 101, 114, 124, 83, 116, 97, 109, 105,
				110, 97, 68, 105, 115, 112, 108, 97, 121, 0,
				0, 0, 0, 48, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 71, 111, 108, 100, 77, 105, 110, 101, 114,
				124, 83, 116, 114, 101, 110, 103, 116, 104, 80,
				111, 116, 105, 111, 110, 68, 105, 115, 112, 108,
				97, 121, 0, 0, 0, 0, 30, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 71, 97,
				109, 101, 115, 124, 86, 105, 114, 116, 117, 97,
				108, 67, 117, 114, 115, 111, 114, 0, 0, 0,
				0, 36, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 124, 86,
				105, 114, 116, 117, 97, 108, 67, 117, 114, 115,
				111, 114, 84, 97, 114, 103, 101, 116, 0, 0,
				0, 0, 46, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 71, 97, 109, 101, 115, 46,
				69, 120, 97, 109, 112, 108, 101, 115, 46, 72,
				101, 108, 108, 111, 87, 111, 114, 108, 100, 124,
				70, 97, 107, 101, 77, 111, 117, 115, 101, 0,
				0, 0, 0, 41, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 71, 97, 109, 101, 115,
				46, 69, 120, 97, 109, 112, 108, 101, 115, 46,
				72, 101, 108, 108, 111, 87, 111, 114, 108, 100,
				124, 77, 111, 118, 101, 0, 0, 0, 0, 41,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 83, 110, 97,
				107, 101, 70, 111, 114, 99, 101, 115, 124, 83,
				110, 97, 107, 101, 68, 105, 115, 112, 108, 97,
				121, 0, 0, 0, 0, 39, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 46, 83, 110, 97, 107, 101, 70, 111,
				114, 99, 101, 115, 124, 83, 110, 97, 107, 101,
				70, 111, 114, 99, 101, 0, 0, 0, 0, 44,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 46, 83, 110, 97,
				107, 101, 70, 111, 114, 99, 101, 115, 46, 83,
				110, 97, 107, 101, 70, 111, 114, 99, 101, 124,
				80, 97, 114, 116, 0, 0, 0, 0, 45, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 46, 83, 110, 97, 107,
				101, 70, 111, 114, 99, 101, 115, 124, 83, 110,
				97, 107, 101, 80, 97, 114, 116, 68, 105, 115,
				112, 108, 97, 121, 0, 0, 0, 0, 45, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 46, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 124, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 65, 110, 105, 109,
				97, 116, 111, 114, 0, 0, 0, 0, 52, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				71, 97, 109, 101, 115, 46, 85, 116, 105, 108,
				105, 116, 105, 101, 115, 124, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 80, 105, 99, 107,
				117, 112, 65, 110, 105, 109, 97, 116, 105, 111,
				110, 0, 0, 0, 0, 30, 68, 117, 99, 107,
				111, 118, 46, 77, 105, 110, 105, 71, 97, 109,
				101, 115, 124, 71, 97, 109, 105, 110, 103, 67,
				111, 110, 115, 111, 108, 101, 0, 0, 0, 0,
				39, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 46, 71, 97,
				109, 105, 110, 103, 67, 111, 110, 115, 111, 108,
				101, 124, 83, 97, 118, 101, 68, 97, 116, 97,
				0, 0, 0, 0, 38, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 124, 71, 97, 109, 105, 110, 103, 67, 111,
				110, 115, 111, 108, 101, 65, 110, 105, 109, 97,
				116, 111, 114, 0, 0, 0, 0, 48, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 71,
				97, 109, 101, 115, 46, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 124, 71, 97, 109, 105, 110,
				103, 67, 111, 110, 115, 111, 108, 101, 71, 114,
				97, 112, 104, 105, 99, 115, 0, 0, 0, 0,
				33, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 124, 71, 97,
				109, 105, 110, 103, 67, 111, 110, 115, 111, 108,
				101, 72, 85, 68, 0, 0, 0, 0, 18, 124,
				71, 97, 109, 105, 110, 103, 67, 111, 110, 115,
				111, 108, 101, 86, 105, 101, 119, 0, 0, 0,
				0, 25, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 124, 77,
				105, 110, 105, 71, 97, 109, 101, 0, 0, 0,
				0, 38, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 115, 46, 77,
				105, 110, 105, 71, 97, 109, 101, 124, 66, 117,
				116, 116, 111, 110, 83, 116, 97, 116, 117, 115,
				0, 0, 0, 0, 51, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				115, 46, 77, 105, 110, 105, 71, 97, 109, 101,
				124, 77, 105, 110, 105, 71, 97, 109, 101, 73,
				110, 112, 117, 116, 69, 118, 101, 110, 116, 67,
				111, 110, 116, 101, 120, 116, 0, 0, 0, 0,
				34, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 71, 97, 109, 101, 115, 124, 77, 105,
				110, 105, 71, 97, 109, 101, 66, 101, 104, 97,
				118, 105, 111, 117, 114, 0, 0, 0, 0, 37,
				68, 117, 99, 107, 111, 118, 46, 77, 105, 110,
				105, 71, 97, 109, 101, 115, 124, 77, 105, 110,
				105, 71, 97, 109, 101, 73, 110, 112, 117, 116,
				72, 97, 110, 100, 108, 101, 114, 0, 0, 0,
				0, 42, 68, 117, 99, 107, 111, 118, 46, 81,
				117, 101, 115, 116, 115, 124, 81, 117, 101, 115,
				116, 84, 97, 115, 107, 95, 66, 117, 98, 98,
				108, 101, 80, 111, 112, 112, 101, 114, 95, 76,
				101, 118, 101, 108, 0, 0, 0, 0, 39, 68,
				117, 99, 107, 111, 118, 46, 81, 117, 101, 115,
				116, 115, 124, 81, 117, 101, 115, 116, 84, 97,
				115, 107, 95, 71, 111, 108, 100, 77, 105, 110,
				101, 114, 95, 76, 101, 118, 101, 108, 0, 0,
				0, 0, 35, 68, 117, 99, 107, 111, 118, 46,
				81, 117, 101, 115, 116, 115, 124, 81, 117, 101,
				115, 116, 84, 97, 115, 107, 95, 83, 110, 97,
				107, 101, 95, 83, 99, 111, 114, 101, 0, 0,
				0, 0, 21, 124, 73, 77, 105, 110, 105, 77,
				97, 112, 68, 97, 116, 97, 80, 114, 111, 118,
				105, 100, 101, 114, 0, 0, 0, 0, 14, 124,
				73, 77, 105, 110, 105, 77, 97, 112, 69, 110,
				116, 114, 121, 0, 0, 0, 0, 32, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 77,
				97, 112, 115, 124, 77, 97, 112, 77, 97, 114,
				107, 101, 114, 77, 97, 110, 97, 103, 101, 114,
				0, 0, 0, 0, 41, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 77, 97, 112, 115,
				46, 77, 97, 112, 77, 97, 114, 107, 101, 114,
				77, 97, 110, 97, 103, 101, 114, 124, 83, 97,
				118, 101, 68, 97, 116, 97, 0, 0, 0, 0,
				28, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 77, 97, 112, 115, 124, 77, 97, 112,
				77, 97, 114, 107, 101, 114, 80, 79, 73, 0,
				0, 0, 0, 40, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 77, 97, 112, 115, 46,
				77, 97, 112, 77, 97, 114, 107, 101, 114, 80,
				79, 73, 124, 82, 117, 110, 116, 105, 109, 101,
				68, 97, 116, 97, 0, 0, 0, 0, 29, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				77, 97, 112, 115, 124, 77, 105, 110, 105, 77,
				97, 112, 67, 101, 110, 116, 101, 114, 0, 0,
				0, 0, 31, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 77, 97, 112, 115, 124, 77,
				105, 110, 105, 77, 97, 112, 83, 101, 116, 116,
				105, 110, 103, 115, 0, 0, 0, 0, 40, 68,
				117, 99, 107, 111, 118, 46, 77, 105, 110, 105,
				77, 97, 112, 115, 46, 77, 105, 110, 105, 77,
				97, 112, 83, 101, 116, 116, 105, 110, 103, 115,
				124, 77, 97, 112, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 36, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 77, 97, 112, 115, 46,
				77, 105, 110, 105, 77, 97, 112, 83, 101, 116,
				116, 105, 110, 103, 115, 124, 68, 97, 116, 97,
				0, 0, 0, 0, 37, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 77, 97, 112, 115,
				46, 69, 100, 105, 116, 111, 114, 124, 77, 105,
				110, 105, 77, 97, 112, 83, 104, 111, 111, 116,
				101, 114, 0, 0, 0, 0, 33, 68, 117, 99,
				107, 111, 118, 46, 77, 105, 110, 105, 77, 97,
				112, 115, 124, 80, 111, 105, 110, 116, 115, 79,
				102, 73, 110, 116, 101, 114, 101, 115, 116, 115,
				0, 0, 0, 0, 32, 68, 117, 99, 107, 111,
				118, 46, 77, 105, 110, 105, 77, 97, 112, 115,
				124, 73, 80, 111, 105, 110, 116, 79, 102, 73,
				110, 116, 101, 114, 101, 115, 116, 0, 0, 0,
				0, 37, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 77, 97, 112, 115, 124, 83, 105,
				109, 112, 108, 101, 80, 111, 105, 110, 116, 79,
				102, 73, 110, 116, 101, 114, 101, 115, 116, 0,
				0, 0, 0, 21, 124, 77, 97, 112, 77, 97,
				114, 107, 101, 114, 80, 97, 110, 101, 108, 66,
				117, 116, 116, 111, 110, 0, 0, 0, 0, 23,
				124, 77, 97, 112, 77, 97, 114, 107, 101, 114,
				83, 101, 116, 116, 105, 110, 103, 115, 80, 97,
				110, 101, 108, 0, 0, 0, 0, 30, 68, 117,
				99, 107, 111, 118, 46, 77, 105, 110, 105, 77,
				97, 112, 115, 124, 77, 105, 110, 105, 77, 97,
				112, 67, 111, 109, 112, 97, 115, 115, 0, 0,
				0, 0, 33, 68, 117, 99, 107, 111, 118, 46,
				77, 105, 110, 105, 77, 97, 112, 115, 46, 85,
				73, 124, 77, 105, 110, 105, 77, 97, 112, 68,
				105, 115, 112, 108, 97, 121, 0, 0, 0, 0,
				38, 68, 117, 99, 107, 111, 118, 46, 77, 105,
				110, 105, 77, 97, 112, 115, 46, 85, 73, 124,
				77, 105, 110, 105, 77, 97, 112, 68, 105, 115,
				112, 108, 97, 121, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 30, 68, 117, 99, 107, 111, 118,
				46, 77, 105, 110, 105, 77, 97, 112, 115, 46,
				85, 73, 124, 77, 105, 110, 105, 77, 97, 112,
				86, 105, 101, 119, 0, 0, 0, 0, 14, 124,
				80, 97, 99, 107, 101, 100, 77, 97, 112, 68,
				97, 116, 97, 0, 0, 0, 0, 19, 80, 97,
				99, 107, 101, 100, 77, 97, 112, 68, 97, 116,
				97, 124, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 39, 68, 117, 99, 107, 111, 118, 46, 77,
				105, 110, 105, 77, 97, 112, 115, 46, 85, 73,
				124, 80, 111, 105, 110, 116, 79, 102, 73, 110,
				116, 101, 114, 101, 115, 116, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 27, 68, 117, 99, 107,
				111, 118, 46, 77, 111, 100, 100, 105, 110, 103,
				124, 77, 111, 100, 66, 101, 104, 97, 118, 105,
				111, 117, 114, 0, 0, 0, 0, 25, 68, 117,
				99, 107, 111, 118, 46, 77, 111, 100, 100, 105,
				110, 103, 124, 77, 111, 100, 77, 97, 110, 97,
				103, 101, 114, 0, 0, 0, 0, 22, 68, 117,
				99, 107, 111, 118, 46, 77, 111, 100, 100, 105,
				110, 103, 124, 77, 111, 100, 73, 110, 102, 111,
				0, 0, 0, 0, 35, 68, 117, 99, 107, 111,
				118, 46, 77, 111, 100, 100, 105, 110, 103, 124,
				83, 116, 101, 97, 109, 87, 111, 114, 107, 115,
				104, 111, 112, 77, 97, 110, 97, 103, 101, 114,
				0, 0, 0, 0, 26, 68, 117, 99, 107, 111,
				118, 46, 77, 111, 100, 100, 105, 110, 103, 46,
				85, 73, 124, 77, 111, 100, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 30, 68, 117, 99, 107,
				111, 118, 46, 77, 111, 100, 100, 105, 110, 103,
				46, 85, 73, 124, 77, 111, 100, 77, 97, 110,
				97, 103, 101, 114, 85, 73, 0, 0, 0, 0,
				15, 124, 77, 111, 100, 85, 112, 108, 111, 97,
				100, 80, 97, 110, 101, 108, 0, 0, 0, 0,
				27, 68, 117, 99, 107, 111, 118, 46, 78, 111,
				116, 101, 73, 110, 100, 101, 120, 115, 124, 78,
				111, 116, 101, 73, 110, 100, 101, 120, 0, 0,
				0, 0, 36, 68, 117, 99, 107, 111, 118, 46,
				78, 111, 116, 101, 73, 110, 100, 101, 120, 115,
				46, 78, 111, 116, 101, 73, 110, 100, 101, 120,
				124, 83, 97, 118, 101, 68, 97, 116, 97, 0,
				0, 0, 0, 22, 68, 117, 99, 107, 111, 118,
				46, 78, 111, 116, 101, 73, 110, 100, 101, 120,
				115, 124, 78, 111, 116, 101, 0, 0, 0, 0,
				32, 68, 117, 99, 107, 111, 118, 46, 78, 111,
				116, 101, 73, 110, 100, 101, 120, 115, 124, 78,
				111, 116, 101, 73, 110, 100, 101, 120, 80, 114,
				111, 120, 121, 0, 0, 0, 0, 23, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 124, 78, 111,
				116, 101, 73, 110, 100, 101, 120, 86, 105, 101,
				119, 0, 0, 0, 0, 29, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 78, 111, 116, 101,
				73, 110, 100, 101, 120, 86, 105, 101, 119, 95,
				69, 110, 116, 114, 121, 0, 0, 0, 0, 33,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 124,
				78, 111, 116, 101, 73, 110, 100, 101, 120, 86,
				105, 101, 119, 95, 73, 110, 115, 112, 101, 99,
				116, 111, 114, 0, 0, 0, 0, 30, 68, 117,
				99, 107, 111, 118, 46, 78, 111, 116, 101, 73,
				110, 100, 101, 120, 115, 124, 78, 111, 116, 101,
				73, 110, 116, 101, 114, 97, 99, 116, 0, 0,
				0, 0, 42, 68, 117, 99, 107, 111, 118, 46,
				78, 111, 116, 101, 73, 110, 100, 101, 120, 115,
				124, 82, 101, 113, 117, 105, 114, 101, 78, 111,
				116, 101, 73, 110, 100, 101, 120, 85, 110, 108,
				111, 99, 107, 101, 100, 0, 0, 0, 0, 15,
				124, 79, 112, 101, 110, 83, 97, 118, 101, 70,
				111, 108, 100, 101, 114, 0, 0, 0, 0, 27,
				124, 83, 99, 114, 111, 108, 108, 87, 104, 101,
				101, 108, 79, 112, 116, 105, 111, 110, 115, 80,
				114, 111, 118, 105, 100, 101, 114, 0, 0, 0,
				0, 21, 124, 83, 99, 114, 111, 108, 108, 87,
				104, 101, 101, 108, 66, 101, 104, 97, 118, 105,
				111, 117, 114, 0, 0, 0, 0, 24, 124, 76,
				97, 110, 103, 117, 97, 103, 101, 79, 112, 116,
				105, 111, 110, 115, 80, 114, 111, 118, 105, 100,
				101, 114, 0, 0, 0, 0, 29, 68, 117, 99,
				107, 111, 118, 46, 79, 112, 116, 105, 111, 110,
				115, 124, 79, 112, 116, 105, 111, 110, 115, 77,
				97, 110, 97, 103, 101, 114, 0, 0, 0, 0,
				20, 124, 79, 112, 116, 105, 111, 110, 115, 80,
				114, 111, 118, 105, 100, 101, 114, 66, 97, 115,
				101, 0, 0, 0, 0, 18, 124, 70, 117, 108,
				108, 83, 99, 114, 101, 101, 110, 79, 112, 116,
				105, 111, 110, 115, 0, 0, 0, 0, 18, 124,
				82, 101, 115, 111, 108, 117, 116, 105, 111, 110,
				79, 112, 116, 105, 111, 110, 115, 0, 0, 0,
				0, 17, 124, 82, 101, 115, 111, 108, 117, 116,
				105, 111, 110, 83, 101, 116, 116, 101, 114, 0,
				0, 0, 0, 17, 124, 68, 117, 99, 107, 111,
				118, 82, 101, 115, 111, 108, 117, 116, 105, 111,
				110, 0, 0, 0, 0, 20, 124, 68, 105, 115,
				97, 98, 108, 101, 67, 97, 109, 101, 114, 97,
				79, 102, 102, 115, 101, 116, 0, 0, 0, 0,
				15, 124, 69, 100, 103, 101, 76, 105, 103, 104,
				116, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				18, 124, 69, 100, 103, 101, 76, 105, 103, 104,
				116, 83, 101, 116, 116, 105, 110, 103, 115, 0,
				0, 0, 0, 17, 124, 70, 114, 97, 109, 101,
				82, 97, 116, 101, 83, 101, 116, 116, 105, 110,
				103, 0, 0, 0, 0, 11, 124, 70, 115, 114,
				83, 101, 116, 116, 105, 110, 103, 0, 0, 0,
				0, 13, 124, 71, 114, 97, 115, 115, 79, 112,
				116, 105, 111, 110, 115, 0, 0, 0, 0, 13,
				124, 72, 66, 65, 79, 83, 101, 116, 116, 105,
				110, 103, 115, 0, 0, 0, 0, 21, 124, 77,
				111, 118, 101, 68, 105, 114, 101, 99, 116, 105,
				111, 110, 79, 112, 116, 105, 111, 110, 115, 0,
				0, 0, 0, 16, 124, 82, 117, 110, 73, 110,
				112, 117, 116, 79, 112, 116, 105, 111, 110, 115,
				0, 0, 0, 0, 14, 124, 83, 104, 97, 100,
				111, 119, 83, 101, 116, 116, 105, 110, 103, 0,
				0, 0, 0, 18, 124, 83, 111, 102, 116, 83,
				104, 97, 100, 111, 119, 79, 112, 116, 105, 111,
				110, 115, 0, 0, 0, 0, 12, 124, 83, 117,
				110, 70, 111, 103, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 15, 124, 83, 117, 110, 70, 111,
				103, 83, 101, 116, 116, 105, 110, 103, 115, 0,
				0, 0, 0, 16, 124, 85, 73, 83, 104, 97,
				100, 111, 119, 79, 112, 116, 105, 111, 110, 115,
				0, 0, 0, 0, 13, 124, 118, 83, 121, 110,
				99, 83, 101, 116, 116, 105, 110, 103, 0, 0,
				0, 0, 29, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 124, 83, 108, 105, 100, 101, 114, 87,
				105, 116, 104, 84, 101, 120, 116, 70, 105, 101,
				108, 100, 0, 0, 0, 0, 22, 124, 85, 73,
				66, 117, 116, 116, 111, 110, 82, 101, 118, 101,
				114, 116, 66, 105, 110, 100, 105, 110, 103, 0,
				0, 0, 0, 18, 124, 85, 73, 75, 101, 121,
				98, 105, 110, 100, 105, 110, 103, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 30, 68, 117, 99,
				107, 111, 118, 46, 79, 112, 116, 105, 111, 110,
				115, 46, 85, 73, 124, 79, 112, 116, 105, 111,
				110, 115, 80, 97, 110, 101, 108, 0, 0, 0,
				0, 23, 124, 79, 112, 116, 105, 111, 110, 115,
				80, 97, 110, 101, 108, 95, 84, 97, 98, 66,
				117, 116, 116, 111, 110, 0, 0, 0, 0, 41,
				68, 117, 99, 107, 111, 118, 46, 79, 112, 116,
				105, 111, 110, 115, 46, 85, 73, 124, 79, 112,
				116, 105, 111, 110, 115, 85, 73, 69, 110, 116,
				114, 121, 95, 68, 114, 111, 112, 100, 111, 119,
				110, 0, 0, 0, 0, 39, 68, 117, 99, 107,
				111, 118, 46, 79, 112, 116, 105, 111, 110, 115,
				46, 85, 73, 124, 79, 112, 116, 105, 111, 110,
				115, 85, 73, 69, 110, 116, 114, 121, 95, 83,
				108, 105, 100, 101, 114, 0, 0, 0, 0, 39,
				68, 117, 99, 107, 111, 118, 46, 79, 112, 116,
				105, 111, 110, 115, 46, 85, 73, 124, 79, 112,
				116, 105, 111, 110, 115, 85, 73, 69, 110, 116,
				114, 121, 95, 84, 111, 103, 103, 108, 101, 0,
				0, 0, 0, 15, 124, 82, 117, 108, 101, 69,
				110, 116, 114, 121, 95, 66, 111, 111, 108, 0,
				0, 0, 0, 33, 68, 117, 99, 107, 111, 118,
				46, 79, 112, 116, 105, 111, 110, 115, 46, 85,
				73, 124, 82, 117, 108, 101, 69, 110, 116, 114,
				121, 95, 70, 108, 111, 97, 116, 0, 0, 0,
				0, 31, 68, 117, 99, 107, 111, 118, 46, 79,
				112, 116, 105, 111, 110, 115, 46, 85, 73, 124,
				82, 117, 108, 101, 69, 110, 116, 114, 121, 95,
				73, 110, 116, 0, 0, 0, 0, 15, 124, 85,
				73, 83, 104, 97, 100, 111, 119, 83, 101, 116,
				116, 101, 114, 0, 0, 0, 0, 47, 68, 117,
				99, 107, 111, 118, 46, 80, 101, 114, 107, 84,
				114, 101, 101, 115, 46, 73, 110, 116, 101, 114,
				97, 99, 116, 97, 98, 108, 101, 124, 80, 101,
				114, 107, 84, 114, 101, 101, 85, 73, 73, 110,
				118, 111, 107, 101, 114, 0, 0, 0, 0, 21,
				68, 117, 99, 107, 111, 118, 46, 80, 101, 114,
				107, 84, 114, 101, 101, 115, 124, 80, 101, 114,
				107, 0, 0, 0, 0, 32, 68, 117, 99, 107,
				111, 118, 46, 80, 101, 114, 107, 84, 114, 101,
				101, 115, 124, 80, 101, 114, 107, 82, 101, 113,
				117, 105, 114, 101, 109, 101, 110, 116, 0, 0,
				0, 0, 49, 68, 117, 99, 107, 111, 118, 46,
				80, 101, 114, 107, 84, 114, 101, 101, 115, 46,
				80, 101, 114, 107, 82, 101, 113, 117, 105, 114,
				101, 109, 101, 110, 116, 124, 82, 101, 113, 117,
				105, 114, 101, 73, 116, 101, 109, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 30, 68, 117, 99,
				107, 111, 118, 46, 80, 101, 114, 107, 84, 114,
				101, 101, 115, 124, 80, 101, 114, 107, 66, 101,
				104, 97, 118, 105, 111, 117, 114, 0, 0, 0,
				0, 55, 68, 117, 99, 107, 111, 118, 46, 80,
				101, 114, 107, 84, 114, 101, 101, 115, 46, 66,
				101, 104, 97, 118, 105, 111, 117, 114, 115, 124,
				65, 100, 100, 66, 108, 97, 99, 107, 77, 97,
				114, 107, 101, 116, 82, 101, 102, 114, 101, 115,
				104, 67, 104, 97, 110, 99, 101, 0, 0, 0,
				0, 30, 68, 117, 99, 107, 111, 118, 46, 80,
				101, 114, 107, 84, 114, 101, 101, 115, 124, 65,
				100, 100, 71, 97, 114, 100, 101, 110, 83, 105,
				122, 101, 0, 0, 0, 0, 33, 68, 117, 99,
				107, 111, 118, 46, 80, 101, 114, 107, 84, 114,
				101, 101, 115, 124, 65, 100, 100, 80, 108, 97,
				121, 101, 114, 83, 116, 111, 114, 97, 103, 101,
				0, 0, 0, 0, 62, 68, 117, 99, 107, 111,
				118, 46, 80, 101, 114, 107, 84, 114, 101, 101,
				115, 46, 66, 101, 104, 97, 118, 105, 111, 117,
				114, 115, 124, 67, 104, 97, 110, 103, 101, 66,
				108, 97, 99, 107, 77, 97, 114, 107, 101, 116,
				82, 101, 102, 114, 101, 115, 104, 84, 105, 109,
				101, 70, 97, 99, 116, 111, 114, 0, 0, 0,
				0, 32, 68, 117, 99, 107, 111, 118, 46, 80,
				101, 114, 107, 84, 114, 101, 101, 115, 124, 71,
				97, 114, 100, 101, 110, 65, 117, 116, 111, 87,
				97, 116, 101, 114, 0, 0, 0, 0, 52, 68,
				117, 99, 107, 111, 118, 46, 80, 101, 114, 107,
				84, 114, 101, 101, 115, 46, 66, 101, 104, 97,
				118, 105, 111, 117, 114, 115, 124, 77, 111, 100,
				105, 102, 121, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 83, 116, 97, 116, 115, 66, 97, 115,
				101, 0, 0, 0, 0, 58, 68, 117, 99, 107,
				111, 118, 46, 80, 101, 114, 107, 84, 114, 101,
				101, 115, 46, 66, 101, 104, 97, 118, 105, 111,
				117, 114, 115, 46, 77, 111, 100, 105, 102, 121,
				67, 104, 97, 114, 97, 99, 116, 101, 114, 83,
				116, 97, 116, 115, 66, 97, 115, 101, 124, 69,
				110, 116, 114, 121, 0, 0, 0, 0, 59, 68,
				117, 99, 107, 111, 118, 46, 80, 101, 114, 107,
				84, 114, 101, 101, 115, 46, 66, 101, 104, 97,
				118, 105, 111, 117, 114, 115, 46, 77, 111, 100,
				105, 102, 121, 67, 104, 97, 114, 97, 99, 116,
				101, 114, 83, 116, 97, 116, 115, 66, 97, 115,
				101, 124, 82, 101, 99, 111, 114, 100, 0, 0,
				0, 0, 45, 68, 117, 99, 107, 111, 118, 46,
				80, 101, 114, 107, 84, 114, 101, 101, 115, 46,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 115,
				124, 85, 110, 108, 111, 99, 107, 65, 99, 104,
				105, 101, 118, 101, 109, 101, 110, 116, 0, 0,
				0, 0, 41, 68, 117, 99, 107, 111, 118, 46,
				80, 101, 114, 107, 84, 114, 101, 101, 115, 46,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 115,
				124, 85, 110, 108, 111, 99, 107, 70, 111, 114,
				109, 117, 108, 97, 0, 0, 0, 0, 20, 124,
				85, 110, 108, 111, 99, 107, 83, 116, 111, 99,
				107, 83, 104, 111, 112, 73, 116, 101, 109, 0,
				0, 0, 0, 25, 68, 117, 99, 107, 111, 118,
				46, 80, 101, 114, 107, 84, 114, 101, 101, 115,
				124, 80, 101, 114, 107, 84, 114, 101, 101, 0,
				0, 0, 0, 34, 68, 117, 99, 107, 111, 118,
				46, 80, 101, 114, 107, 84, 114, 101, 101, 115,
				46, 80, 101, 114, 107, 84, 114, 101, 101, 124,
				83, 97, 118, 101, 68, 97, 116, 97, 0, 0,
				0, 0, 40, 68, 117, 99, 107, 111, 118, 46,
				80, 101, 114, 107, 84, 114, 101, 101, 115, 46,
				80, 101, 114, 107, 84, 114, 101, 101, 43, 83,
				97, 118, 101, 68, 97, 116, 97, 124, 69, 110,
				116, 114, 121, 0, 0, 0, 0, 16, 124, 80,
				101, 114, 107, 84, 114, 101, 101, 77, 97, 110,
				97, 103, 101, 114, 0, 0, 0, 0, 34, 68,
				117, 99, 107, 111, 118, 46, 80, 101, 114, 107,
				84, 114, 101, 101, 115, 124, 80, 101, 114, 107,
				76, 101, 118, 101, 108, 76, 105, 110, 101, 78,
				111, 100, 101, 0, 0, 0, 0, 39, 68, 117,
				99, 107, 111, 118, 46, 80, 101, 114, 107, 84,
				114, 101, 101, 115, 124, 80, 101, 114, 107, 82,
				101, 108, 97, 116, 105, 111, 110, 67, 111, 110,
				110, 101, 99, 116, 105, 111, 110, 0, 0, 0,
				0, 34, 68, 117, 99, 107, 111, 118, 46, 80,
				101, 114, 107, 84, 114, 101, 101, 115, 124, 80,
				101, 114, 107, 82, 101, 108, 97, 116, 105, 111,
				110, 71, 114, 97, 112, 104, 0, 0, 0, 0,
				33, 68, 117, 99, 107, 111, 118, 46, 80, 101,
				114, 107, 84, 114, 101, 101, 115, 124, 80, 101,
				114, 107, 82, 101, 108, 97, 116, 105, 111, 110,
				78, 111, 100, 101, 0, 0, 0, 0, 37, 68,
				117, 99, 107, 111, 118, 46, 80, 101, 114, 107,
				84, 114, 101, 101, 115, 124, 80, 101, 114, 107,
				82, 101, 108, 97, 116, 105, 111, 110, 78, 111,
				100, 101, 66, 97, 115, 101, 0, 0, 0, 0,
				43, 68, 117, 99, 107, 111, 118, 46, 80, 101,
				114, 107, 84, 114, 101, 101, 115, 124, 80, 101,
				114, 107, 84, 114, 101, 101, 82, 101, 108, 97,
				116, 105, 111, 110, 71, 114, 97, 112, 104, 79,
				119, 110, 101, 114, 0, 0, 0, 0, 18, 124,
				80, 114, 101, 85, 110, 108, 111, 99, 107, 80,
				101, 114, 107, 84, 114, 101, 101, 0, 0, 0,
				0, 10, 70, 88, 124, 80, 111, 112, 84, 101,
				120, 116, 0, 0, 0, 0, 16, 70, 88, 124,
				80, 111, 112, 84, 101, 120, 116, 69, 110, 116,
				105, 116, 121, 0, 0, 0, 0, 35, 68, 117,
				99, 107, 111, 118, 46, 82, 117, 108, 101, 115,
				46, 85, 73, 124, 68, 105, 102, 102, 105, 99,
				117, 108, 116, 121, 83, 101, 108, 101, 99, 116,
				105, 111, 110, 0, 0, 0, 0, 48, 68, 117,
				99, 107, 111, 118, 46, 82, 117, 108, 101, 115,
				46, 85, 73, 46, 68, 105, 102, 102, 105, 99,
				117, 108, 116, 121, 83, 101, 108, 101, 99, 116,
				105, 111, 110, 124, 83, 101, 116, 116, 105, 110,
				103, 69, 110, 116, 114, 121, 0, 0, 0, 0,
				41, 68, 117, 99, 107, 111, 118, 46, 82, 117,
				108, 101, 115, 46, 85, 73, 124, 68, 105, 102,
				102, 105, 99, 117, 108, 116, 121, 83, 101, 108,
				101, 99, 116, 105, 111, 110, 95, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 43, 68, 117, 99,
				107, 111, 118, 46, 69, 110, 100, 111, 119, 109,
				101, 110, 116, 46, 85, 73, 124, 69, 110, 100,
				111, 119, 109, 101, 110, 116, 83, 101, 108, 101,
				99, 116, 105, 111, 110, 69, 110, 116, 114, 121,
				0, 0, 0, 0, 43, 68, 117, 99, 107, 111,
				118, 46, 69, 110, 100, 111, 119, 109, 101, 110,
				116, 46, 85, 73, 124, 69, 110, 100, 111, 119,
				109, 101, 110, 116, 83, 101, 108, 101, 99, 116,
				105, 111, 110, 80, 97, 110, 101, 108, 0, 0,
				0, 0, 19, 124, 71, 97, 109, 101, 80, 114,
				101, 112, 97, 114, 101, 80, 114, 111, 99, 101,
				115, 115, 0, 0, 0, 0, 15, 124, 83, 111,
				100, 97, 95, 74, 111, 121, 115, 116, 105, 99,
				107, 115, 0, 0, 0, 0, 26, 68, 117, 99,
				107, 111, 118, 46, 83, 111, 117, 110, 100, 115,
				124, 83, 111, 117, 110, 100, 68, 105, 115, 112,
				108, 97, 121, 0, 0, 0, 0, 32, 68, 117,
				99, 107, 111, 118, 46, 83, 111, 117, 110, 100,
				115, 124, 83, 111, 117, 110, 100, 86, 105, 115,
				117, 97, 108, 105, 122, 97, 116, 105, 111, 110,
				0, 0, 0, 0, 37, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 83, 112, 108,
				105, 110, 101, 115, 124, 83, 112, 108, 105, 110,
				101, 70, 108, 97, 116, 69, 120, 116, 114, 117,
				100, 101, 0, 0, 0, 0, 40, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 83,
				112, 108, 105, 110, 101, 115, 124, 83, 112, 108,
				105, 110, 101, 80, 114, 111, 102, 105, 108, 101,
				69, 120, 116, 114, 117, 100, 101, 0, 0, 0,
				0, 47, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 83, 112, 108, 105, 110, 101,
				115, 46, 83, 112, 108, 105, 110, 101, 80, 114,
				111, 102, 105, 108, 101, 69, 120, 116, 114, 117,
				100, 101, 124, 86, 101, 114, 116, 101, 120, 0,
				0, 0, 0, 41, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 83, 112, 108, 105,
				110, 101, 115, 124, 83, 112, 108, 105, 110, 101,
				83, 105, 100, 101, 119, 97, 108, 107, 69, 120,
				116, 114, 117, 100, 101, 0, 0, 0, 0, 53,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 83, 112, 108, 105, 110, 101, 115, 46,
				83, 112, 108, 105, 110, 101, 83, 105, 100, 101,
				119, 97, 108, 107, 69, 120, 116, 114, 117, 100,
				101, 124, 80, 114, 111, 102, 105, 108, 101, 76,
				105, 110, 101, 0, 0, 0, 0, 18, 124, 83,
				116, 101, 97, 109, 83, 116, 97, 116, 115, 65,
				80, 73, 84, 101, 115, 116, 0, 0, 0, 0,
				18, 124, 69, 118, 101, 110, 116, 73, 102, 83,
				116, 101, 97, 109, 67, 104, 105, 110, 97, 0,
				0, 0, 0, 15, 124, 83, 116, 101, 97, 109,
				76, 111, 103, 111, 73, 109, 97, 103, 101, 0,
				0, 0, 0, 21, 68, 117, 99, 107, 111, 118,
				46, 84, 97, 115, 107, 115, 124, 84, 97, 115,
				107, 76, 105, 115, 116, 0, 0, 0, 0, 25,
				68, 117, 99, 107, 111, 118, 46, 84, 97, 115,
				107, 115, 124, 80, 97, 114, 97, 108, 108, 101,
				108, 84, 97, 115, 107, 0, 0, 0, 0, 29,
				68, 117, 99, 107, 111, 118, 46, 84, 97, 115,
				107, 115, 124, 80, 108, 97, 121, 84, 105, 109,
				101, 108, 105, 110, 101, 84, 97, 115, 107, 0,
				0, 0, 0, 14, 124, 84, 97, 115, 107, 83,
				107, 105, 112, 112, 101, 114, 85, 73, 0, 0,
				0, 0, 18, 124, 68, 97, 116, 101, 84, 105,
				109, 101, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 0, 0, 0, 0, 18, 124, 84, 105, 109,
				101, 83, 112, 97, 110, 65, 116, 116, 114, 105,
				98, 117, 116, 101, 0, 0, 0, 0, 23, 68,
				117, 99, 107, 111, 118, 46, 84, 105, 112, 115,
				124, 84, 105, 112, 115, 68, 105, 115, 112, 108,
				97, 121, 0, 0, 0, 0, 20, 68, 117, 99,
				107, 111, 118, 46, 84, 105, 112, 115, 124, 84,
				105, 112, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 11, 124, 67, 111, 108, 111, 114, 80, 117,
				110, 99, 104, 0, 0, 0, 0, 36, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 46, 65, 110,
				105, 109, 97, 116, 105, 111, 110, 115, 124, 67,
				97, 110, 118, 97, 115, 71, 114, 111, 117, 112,
				70, 97, 100, 101, 0, 0, 0, 0, 41, 68,
				117, 99, 107, 111, 118, 46, 85, 73, 46, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 115, 124,
				77, 97, 116, 101, 114, 105, 97, 108, 80, 114,
				111, 112, 101, 114, 116, 121, 70, 97, 100, 101,
				0, 0, 0, 0, 38, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 46, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 115, 124, 82, 101, 99, 116,
				84, 114, 97, 110, 115, 102, 111, 114, 109, 70,
				97, 100, 101, 0, 0, 0, 0, 30, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 46, 65, 110,
				105, 109, 97, 116, 105, 111, 110, 115, 124, 83,
				99, 97, 108, 101, 70, 97, 100, 101, 0, 0,
				0, 0, 32, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 46, 65, 110, 105, 109, 97, 116, 105,
				111, 110, 115, 124, 70, 97, 100, 101, 69, 108,
				101, 109, 101, 110, 116, 0, 0, 0, 0, 30,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 46,
				65, 110, 105, 109, 97, 116, 105, 111, 110, 115,
				124, 70, 97, 100, 101, 71, 114, 111, 117, 112,
				0, 0, 0, 0, 43, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 46, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 115, 124, 65, 110, 99, 104,
				111, 114, 101, 100, 80, 111, 115, 105, 116, 105,
				111, 110, 76, 111, 111, 112, 101, 114, 0, 0,
				0, 0, 37, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 46, 65, 110, 105, 109, 97, 116, 105,
				111, 110, 115, 124, 73, 109, 97, 103, 101, 67,
				111, 108, 111, 114, 76, 111, 111, 112, 101, 114,
				0, 0, 0, 0, 40, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 46, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 115, 124, 76, 111, 99, 97,
				108, 80, 111, 115, 105, 116, 105, 111, 110, 76,
				111, 111, 112, 101, 114, 0, 0, 0, 0, 32,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 46,
				65, 110, 105, 109, 97, 116, 105, 111, 110, 115,
				124, 76, 111, 111, 112, 101, 114, 67, 108, 111,
				99, 107, 0, 0, 0, 0, 34, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 46, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 115, 124, 76, 111,
				111, 112, 101, 114, 69, 108, 101, 109, 101, 110,
				116, 0, 0, 0, 0, 35, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 46, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 115, 124, 82, 111, 116,
				97, 116, 105, 111, 110, 76, 111, 111, 112, 101,
				114, 0, 0, 0, 0, 32, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 46, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 115, 124, 83, 99, 97,
				108, 101, 76, 111, 111, 112, 101, 114, 0, 0,
				0, 0, 23, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 124, 80, 117, 110, 99, 104, 82, 101,
				99, 101, 105, 118, 101, 114, 0, 0, 0, 0,
				29, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				46, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				115, 124, 82, 101, 118, 111, 108, 118, 101, 114,
				0, 0, 0, 0, 36, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 46, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 115, 124, 66, 117, 116, 116,
				111, 110, 65, 110, 105, 109, 97, 116, 105, 111,
				110, 0, 0, 0, 0, 46, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 46, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 115, 124, 67, 104, 97,
				110, 103, 101, 71, 114, 97, 112, 104, 105, 99,
				115, 67, 111, 108, 111, 114, 84, 111, 103, 103,
				108, 101, 0, 0, 0, 0, 32, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 46, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 115, 124, 83, 99,
				97, 108, 101, 84, 111, 103, 103, 108, 101, 0,
				0, 0, 0, 36, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 46, 65, 110, 105, 109, 97, 116,
				105, 111, 110, 115, 124, 83, 105, 122, 101, 68,
				101, 108, 116, 97, 84, 111, 103, 103, 108, 101,
				0, 0, 0, 0, 36, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 46, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 115, 124, 84, 111, 103, 103,
				108, 101, 65, 110, 105, 109, 97, 116, 105, 111,
				110, 0, 0, 0, 0, 36, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 46, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 115, 124, 84, 111, 103,
				103, 108, 101, 67, 111, 109, 112, 111, 110, 101,
				110, 116, 0, 0, 0, 0, 42, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 46, 66, 97, 114,
				68, 105, 115, 112, 108, 97, 121, 115, 124, 66,
				97, 114, 68, 105, 115, 112, 108, 97, 121, 67,
				111, 110, 116, 114, 111, 108, 108, 101, 114, 0,
				0, 0, 0, 45, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 46, 66, 97, 114, 68, 105, 115,
				112, 108, 97, 121, 115, 124, 66, 97, 114, 68,
				105, 115, 112, 108, 97, 121, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 95, 72, 80, 0,
				0, 0, 0, 49, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 46, 66, 97, 114, 68, 105, 115,
				112, 108, 97, 121, 115, 124, 66, 97, 114, 68,
				105, 115, 112, 108, 97, 121, 67, 111, 110, 116,
				114, 111, 108, 108, 101, 114, 95, 72, 117, 110,
				103, 101, 114, 0, 0, 0, 0, 50, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 46, 66, 97,
				114, 68, 105, 115, 112, 108, 97, 121, 115, 124,
				66, 97, 114, 68, 105, 115, 112, 108, 97, 121,
				67, 111, 110, 116, 114, 111, 108, 108, 101, 114,
				95, 83, 116, 101, 109, 105, 110, 97, 0, 0,
				0, 0, 49, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 46, 66, 97, 114, 68, 105, 115, 112,
				108, 97, 121, 115, 124, 66, 97, 114, 68, 105,
				115, 112, 108, 97, 121, 67, 111, 110, 116, 114,
				111, 108, 108, 101, 114, 95, 84, 104, 117, 114,
				115, 116, 0, 0, 0, 0, 20, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 124, 66, 97, 114,
				68, 105, 115, 112, 108, 97, 121, 0, 0, 0,
				0, 23, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 71, 101, 110, 101, 114, 105, 99, 66,
				117, 116, 116, 111, 110, 0, 0, 0, 0, 22,
				124, 73, 73, 116, 101, 109, 77, 101, 116, 97,
				68, 97, 116, 97, 80, 114, 111, 118, 105, 100,
				101, 114, 0, 0, 0, 0, 23, 124, 73, 110,
				118, 101, 110, 116, 111, 114, 121, 70, 105, 108,
				116, 101, 114, 68, 105, 115, 112, 108, 97, 121,
				0, 0, 0, 0, 28, 124, 73, 110, 118, 101,
				110, 116, 111, 114, 121, 70, 105, 108, 116, 101,
				114, 68, 105, 115, 112, 108, 97, 121, 69, 110,
				116, 114, 121, 0, 0, 0, 0, 24, 124, 73,
				110, 118, 101, 110, 116, 111, 114, 121, 70, 105,
				108, 116, 101, 114, 80, 114, 111, 118, 105, 100,
				101, 114, 0, 0, 0, 0, 35, 73, 110, 118,
				101, 110, 116, 111, 114, 121, 70, 105, 108, 116,
				101, 114, 80, 114, 111, 118, 105, 100, 101, 114,
				124, 70, 105, 108, 116, 101, 114, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 26, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 124, 73, 110, 118,
				101, 110, 116, 111, 114, 121, 68, 105, 115, 112,
				108, 97, 121, 0, 0, 0, 0, 24, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 124, 73, 110,
				118, 101, 110, 116, 111, 114, 121, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 18, 124, 66, 117,
				108, 108, 101, 116, 84, 121, 112, 101, 68, 105,
				115, 112, 108, 97, 121, 0, 0, 0, 0, 28,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 124,
				73, 116, 101, 109, 68, 101, 116, 97, 105, 108,
				115, 68, 105, 115, 112, 108, 97, 121, 0, 0,
				0, 0, 26, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 124, 73, 116, 101, 109, 68, 101, 116,
				97, 105, 108, 115, 80, 97, 110, 101, 108, 0,
				0, 0, 0, 25, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 73, 116, 101, 109, 69, 102,
				102, 101, 99, 116, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 27, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 73, 116, 101, 109, 77, 111,
				100, 105, 102, 105, 101, 114, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 23, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 73, 116, 101, 109,
				83, 116, 97, 116, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 27, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 73, 116, 101, 109, 86, 97,
				114, 105, 97, 98, 108, 101, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 26, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 83, 116, 97, 116,
				73, 110, 102, 111, 68, 97, 116, 97, 98, 97,
				115, 101, 0, 0, 0, 0, 32, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 46, 83, 116, 97,
				116, 73, 110, 102, 111, 68, 97, 116, 97, 98,
				97, 115, 101, 124, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 31, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 85, 115, 97, 103, 101, 85,
				116, 105, 108, 105, 116, 105, 101, 115, 68, 105,
				115, 112, 108, 97, 121, 0, 0, 0, 0, 37,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 124,
				85, 115, 97, 103, 101, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 68, 105, 115, 112, 108, 97,
				121, 95, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 21, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 73, 116, 101, 109, 68, 105, 115, 112,
				108, 97, 121, 0, 0, 0, 0, 16, 124, 73,
				116, 101, 109, 77, 101, 116, 97, 68, 105, 115,
				112, 108, 97, 121, 0, 0, 0, 0, 27, 68,
				117, 99, 107, 111, 118, 46, 85, 73, 124, 73,
				116, 101, 109, 79, 112, 101, 114, 97, 116, 105,
				111, 110, 77, 101, 110, 117, 0, 0, 0, 0,
				35, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 73, 116, 101, 109, 83, 108, 111, 116, 67,
				111, 108, 108, 101, 99, 116, 105, 111, 110, 68,
				105, 115, 112, 108, 97, 121, 0, 0, 0, 0,
				14, 124, 77, 105, 110, 105, 109, 97, 112, 66,
				117, 116, 116, 111, 110, 0, 0, 0, 0, 21,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 124,
				83, 108, 111, 116, 68, 105, 115, 112, 108, 97,
				121, 0, 0, 0, 0, 37, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 83, 108, 111, 116,
				68, 105, 115, 112, 108, 97, 121, 79, 112, 101,
				114, 97, 116, 105, 111, 110, 67, 111, 110, 116,
				101, 120, 116, 0, 0, 0, 0, 23, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 124, 83, 108,
				111, 116, 73, 110, 100, 105, 99, 97, 116, 111,
				114, 0, 0, 0, 0, 14, 124, 83, 112, 108,
				105, 116, 68, 105, 97, 108, 111, 103, 117, 101,
				0, 0, 0, 0, 21, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 124, 84, 97, 103, 115, 68,
				105, 115, 112, 108, 97, 121, 0, 0, 0, 0,
				26, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 84, 97, 103, 115, 68, 105, 115, 112, 108,
				97, 121, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 43, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 73, 110, 118, 101, 110, 116, 111, 114,
				121, 69, 110, 116, 114, 121, 84, 114, 97, 100,
				105, 110, 103, 80, 114, 105, 99, 101, 68, 105,
				115, 112, 108, 97, 121, 0, 0, 0, 0, 22,
				68, 117, 99, 107, 111, 118, 46, 85, 73, 124,
				87, 101, 97, 112, 111, 110, 66, 117, 116, 116,
				111, 110, 0, 0, 0, 0, 13, 124, 68, 101,
				98, 117, 103, 85, 73, 83, 101, 116, 117, 112,
				0, 0, 0, 0, 11, 124, 69, 120, 112, 68,
				105, 115, 112, 108, 97, 121, 0, 0, 0, 0,
				19, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 72, 101, 97, 108, 116, 104, 66, 97, 114,
				0, 0, 0, 0, 26, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 124, 72, 101, 97, 108, 116,
				104, 66, 97, 114, 77, 97, 110, 97, 103, 101,
				114, 0, 0, 0, 0, 20, 124, 72, 101, 97,
				108, 116, 104, 66, 97, 114, 95, 68, 97, 109,
				97, 103, 101, 66, 97, 114, 0, 0, 0, 0,
				17, 124, 77, 117, 108, 116, 105, 73, 110, 116,
				101, 114, 97, 99, 116, 105, 111, 110, 0, 0,
				0, 0, 21, 124, 77, 117, 108, 116, 105, 73,
				110, 116, 101, 114, 97, 99, 116, 105, 111, 110,
				77, 101, 110, 117, 0, 0, 0, 0, 27, 124,
				77, 117, 108, 116, 105, 73, 110, 116, 101, 114,
				97, 99, 116, 105, 111, 110, 77, 101, 110, 117,
				66, 117, 116, 116, 111, 110, 0, 0, 0, 0,
				25, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 73, 116, 101, 109, 85, 73, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 0, 0, 0, 0,
				26, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 77, 97, 110, 97, 103, 101, 100, 85, 73,
				69, 108, 101, 109, 101, 110, 116, 0, 0, 0,
				0, 24, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 68, 105, 97, 108, 111, 103, 117, 101,
				67, 97, 110, 118, 97, 115, 0, 0, 0, 0,
				27, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 71, 97, 109, 101, 112, 108, 97, 121, 85,
				73, 77, 97, 110, 97, 103, 101, 114, 0, 0,
				0, 0, 11, 124, 72, 85, 68, 77, 97, 110,
				97, 103, 101, 114, 0, 0, 0, 0, 14, 124,
				85, 73, 95, 66, 117, 115, 95, 83, 108, 105,
				100, 101, 114, 0, 0, 0, 0, 28, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 124, 73, 116,
				101, 109, 83, 104, 111, 114, 116, 99, 117, 116,
				66, 117, 116, 116, 111, 110, 0, 0, 0, 0,
				33, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 73, 116, 101, 109, 83, 104, 111, 114, 116,
				99, 117, 116, 69, 100, 105, 116, 111, 114, 69,
				110, 116, 114, 121, 0, 0, 0, 0, 33, 68,
				117, 99, 107, 111, 118, 46, 85, 73, 124, 73,
				116, 101, 109, 83, 104, 111, 114, 116, 99, 117,
				116, 69, 100, 105, 116, 111, 114, 80, 97, 110,
				101, 108, 0, 0, 0, 0, 27, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 124, 73, 116, 101,
				109, 83, 104, 111, 114, 116, 99, 117, 116, 80,
				97, 110, 101, 108, 0, 0, 0, 0, 51, 68,
				117, 99, 107, 111, 118, 46, 85, 73, 46, 80,
				108, 97, 121, 101, 114, 83, 116, 97, 116, 115,
				124, 77, 97, 105, 110, 67, 104, 97, 114, 97,
				99, 116, 101, 114, 83, 116, 97, 116, 86, 97,
				108, 117, 101, 68, 105, 115, 112, 108, 97, 121,
				0, 0, 0, 0, 21, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 124, 83, 116, 111, 114, 97,
				103, 101, 68, 111, 99, 107, 0, 0, 0, 0,
				20, 124, 83, 116, 111, 114, 97, 103, 101, 68,
				111, 99, 107, 67, 111, 117, 110, 116, 84, 77,
				80, 0, 0, 0, 0, 26, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 83, 116, 111, 114,
				97, 103, 101, 68, 111, 99, 107, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 29, 68, 117, 99,
				107, 111, 118, 124, 73, 116, 101, 109, 85, 110,
				108, 111, 99, 107, 78, 111, 116, 105, 102, 105,
				99, 97, 116, 105, 111, 110, 0, 0, 0, 0,
				25, 68, 117, 99, 107, 111, 118, 124, 83, 116,
				114, 111, 110, 103, 78, 111, 116, 105, 102, 105,
				99, 97, 116, 105, 111, 110, 0, 0, 0, 0,
				32, 68, 117, 99, 107, 111, 118, 124, 83, 116,
				114, 111, 110, 103, 78, 111, 116, 105, 102, 105,
				99, 97, 116, 105, 111, 110, 67, 111, 110, 116,
				101, 110, 116, 0, 0, 0, 0, 10, 124, 73,
				77, 101, 114, 99, 104, 97, 110, 116, 0, 0,
				0, 0, 28, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 124, 84, 114, 97, 100, 105, 110, 103,
				85, 73, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 0, 0, 0, 0, 21, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 67, 108, 111, 115,
				117, 114, 101, 86, 105, 101, 119, 0, 0, 0,
				0, 16, 124, 68, 101, 99, 111, 109, 112, 111,
				115, 101, 83, 108, 105, 100, 101, 114, 0, 0,
				0, 0, 23, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 124, 73, 110, 118, 101, 110, 116, 111,
				114, 121, 86, 105, 101, 119, 0, 0, 0, 0,
				36, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 73, 116, 101, 109, 67, 117, 115, 116, 111,
				109, 105, 122, 101, 83, 101, 108, 101, 99, 116,
				105, 111, 110, 86, 105, 101, 119, 0, 0, 0,
				0, 27, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 73, 116, 101, 109, 67, 117, 115, 116,
				111, 109, 105, 122, 101, 86, 105, 101, 119, 0,
				0, 0, 0, 27, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 73, 116, 101, 109, 68, 101,
				99, 111, 109, 112, 111, 115, 101, 86, 105, 101,
				119, 0, 0, 0, 0, 24, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 73, 116, 101, 109,
				82, 101, 112, 97, 105, 114, 86, 105, 101, 119,
				0, 0, 0, 0, 26, 124, 73, 116, 101, 109,
				82, 101, 112, 97, 105, 114, 95, 82, 101, 112,
				97, 105, 114, 65, 108, 108, 80, 97, 110, 101,
				108, 0, 0, 0, 0, 18, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 76, 111, 111, 116,
				86, 105, 101, 119, 0, 0, 0, 0, 34, 68,
				117, 99, 107, 111, 118, 46, 85, 73, 46, 73,
				110, 118, 101, 110, 116, 111, 114, 105, 101, 115,
				124, 80, 97, 103, 101, 115, 67, 111, 110, 116,
				114, 111, 108, 0, 0, 0, 0, 40, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 46, 73, 110,
				118, 101, 110, 116, 111, 114, 105, 101, 115, 124,
				80, 97, 103, 101, 115, 67, 111, 110, 116, 114,
				111, 108, 95, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 27, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 124, 77, 97, 112, 83, 101, 108, 101,
				99, 116, 105, 111, 110, 69, 110, 116, 114, 121,
				0, 0, 0, 0, 26, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 124, 77, 97, 112, 83, 101,
				108, 101, 99, 116, 105, 111, 110, 86, 105, 101,
				119, 0, 0, 0, 0, 21, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 80, 101, 114, 107,
				68, 101, 116, 97, 105, 108, 115, 0, 0, 0,
				0, 19, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 80, 101, 114, 107, 69, 110, 116, 114,
				121, 0, 0, 0, 0, 24, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 46, 80, 101, 114, 107,
				69, 110, 116, 114, 121, 124, 76, 111, 111, 107,
				0, 0, 0, 0, 23, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 124, 80, 101, 114, 107, 76,
				105, 110, 101, 69, 110, 116, 114, 121, 0, 0,
				0, 0, 26, 68, 117, 99, 107, 111, 118, 46,
				85, 73, 124, 82, 101, 113, 117, 105, 114, 101,
				73, 116, 101, 109, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 22, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 80, 101, 114, 107, 84, 114,
				101, 101, 86, 105, 101, 119, 0, 0, 0, 0,
				25, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 80, 108, 97, 121, 101, 114, 83, 116, 97,
				116, 115, 86, 105, 101, 119, 0, 0, 0, 0,
				36, 68, 117, 99, 107, 111, 118, 46, 69, 99,
				111, 110, 111, 109, 121, 46, 85, 73, 124, 83,
				116, 111, 99, 107, 83, 104, 111, 112, 73, 116,
				101, 109, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 31, 68, 117, 99, 107, 111, 118, 46, 69,
				99, 111, 110, 111, 109, 121, 46, 85, 73, 124,
				83, 116, 111, 99, 107, 83, 104, 111, 112, 86,
				105, 101, 119, 0, 0, 0, 0, 33, 68, 117,
				99, 107, 111, 118, 46, 85, 73, 124, 67, 108,
				111, 115, 101, 86, 105, 101, 119, 79, 110, 80,
				111, 105, 110, 116, 101, 114, 67, 108, 105, 99,
				107, 0, 0, 0, 0, 14, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 86, 105, 101, 119,
				0, 0, 0, 0, 9, 124, 86, 105, 101, 119,
				84, 97, 98, 115, 0, 0, 0, 0, 20, 124,
				86, 105, 101, 119, 84, 97, 98, 68, 105, 115,
				112, 108, 97, 121, 69, 110, 116, 114, 121, 0,
				0, 0, 0, 26, 68, 117, 99, 107, 111, 118,
				46, 85, 73, 124, 87, 101, 105, 103, 104, 116,
				66, 97, 114, 67, 111, 109, 112, 108, 101, 120,
				0, 0, 0, 0, 22, 68, 117, 99, 107, 111,
				118, 46, 85, 73, 124, 70, 111, 108, 108, 111,
				119, 67, 117, 114, 115, 111, 114, 0, 0, 0,
				0, 16, 124, 70, 111, 114, 99, 101, 85, 110,
				109, 97, 115, 107, 97, 98, 108, 101, 0, 0,
				0, 0, 20, 124, 80, 111, 105, 110, 116, 101,
				114, 68, 111, 119, 110, 85, 112, 69, 118, 101,
				110, 116, 115, 0, 0, 0, 0, 28, 124, 80,
				114, 111, 99, 101, 100, 117, 114, 97, 108, 73,
				109, 97, 103, 101, 72, 97, 115, 104, 80, 114,
				111, 118, 105, 100, 101, 114, 0, 0, 0, 0,
				41, 68, 117, 99, 107, 111, 118, 46, 85, 73,
				124, 82, 101, 99, 116, 84, 114, 97, 110, 115,
				102, 111, 114, 109, 67, 104, 97, 110, 103, 101,
				69, 118, 101, 110, 116, 69, 109, 105, 116, 116,
				101, 114, 0, 0, 0, 0, 31, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 124, 83, 99, 114,
				111, 108, 108, 86, 105, 101, 119, 66, 111, 114,
				100, 101, 114, 70, 114, 97, 109, 101, 0, 0,
				0, 0, 24, 124, 83, 99, 114, 111, 108, 108,
				86, 105, 101, 119, 69, 118, 101, 110, 116, 82,
				101, 99, 101, 105, 118, 101, 114, 0, 0, 0,
				0, 29, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 83, 99, 114, 111, 108, 108, 86, 105,
				101, 119, 77, 97, 120, 72, 101, 105, 103, 104,
				116, 0, 0, 0, 0, 21, 68, 117, 99, 107,
				111, 118, 46, 85, 73, 124, 75, 111, 110, 116,
				101, 120, 116, 77, 101, 110, 117, 0, 0, 0,
				0, 30, 68, 117, 99, 107, 111, 118, 46, 85,
				73, 124, 75, 111, 110, 116, 101, 120, 116, 77,
				101, 110, 117, 68, 97, 116, 97, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 26, 68, 117, 99,
				107, 111, 118, 46, 85, 73, 124, 75, 111, 110,
				116, 101, 120, 116, 77, 101, 110, 117, 69, 110,
				116, 114, 121, 0, 0, 0, 0, 14, 124, 85,
				73, 84, 111, 111, 108, 107, 105, 116, 84, 101,
				115, 116, 0, 0, 0, 0, 30, 68, 117, 99,
				107, 111, 118, 46, 87, 101, 97, 116, 104, 101,
				114, 115, 124, 87, 101, 97, 116, 104, 101, 114,
				77, 97, 110, 97, 103, 101, 114, 0, 0, 0,
				0, 39, 68, 117, 99, 107, 111, 118, 46, 87,
				101, 97, 116, 104, 101, 114, 115, 46, 87, 101,
				97, 116, 104, 101, 114, 77, 97, 110, 97, 103,
				101, 114, 124, 83, 97, 118, 101, 68, 97, 116,
				97, 0, 0, 0, 0, 21, 68, 117, 99, 107,
				111, 118, 46, 87, 101, 97, 116, 104, 101, 114,
				115, 124, 83, 116, 111, 114, 109, 0, 0, 0,
				0, 29, 68, 117, 99, 107, 111, 118, 46, 87,
				101, 97, 116, 104, 101, 114, 115, 124, 80, 114,
				101, 99, 105, 112, 105, 116, 97, 116, 105, 111,
				110
			},
			TotalFiles = 935,
			TotalTypes = 1122,
			IsEditorOnly = false
		};
	}
}
namespace UnityEngine.Splines
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
	[AddComponentMenu("Splines/Spline Flat Extrude")]
	public class SplineFlatExtrude : MonoBehaviour
	{
		[SerializeField]
		[Tooltip("The Spline to extrude.")]
		private SplineContainer m_Container;

		[SerializeField]
		[Tooltip("Enable to regenerate the extruded mesh when the target Spline is modified. Disable this option if the Spline will not be modified at runtime.")]
		private bool m_RebuildOnSplineChange;

		[SerializeField]
		[Tooltip("The maximum number of times per-second that the mesh will be rebuilt.")]
		private int m_RebuildFrequency = 30;

		[SerializeField]
		[Tooltip("Automatically update any Mesh, Box, or Sphere collider components when the mesh is extruded.")]
		private bool m_UpdateColliders = true;

		[SerializeField]
		[Tooltip("The number of edge loops that comprise the length of one unit of the mesh. The total number of sections is equal to \"Spline.GetLength() * segmentsPerUnit\".")]
		private float m_SegmentsPerUnit = 4f;

		[SerializeField]
		[Tooltip("The radius of the extruded mesh.")]
		private float m_Width = 0.25f;

		[SerializeField]
		private int m_ProfileSeg = 2;

		[SerializeField]
		private float m_Height = 0.05f;

		[SerializeField]
		[Tooltip("The section of the Spline to extrude.")]
		private Vector2 m_Range = new Vector2(0f, 0.999f);

		[SerializeField]
		private float uFactor = 1f;

		[SerializeField]
		private float vFactor = 1f;

		private Mesh m_Mesh;

		private bool m_RebuildRequested;

		private float m_NextScheduledRebuild;

		[Obsolete("Use Container instead.", false)]
		public SplineContainer container => Container;

		public SplineContainer Container
		{
			get
			{
				return m_Container;
			}
			set
			{
				m_Container = value;
			}
		}

		[Obsolete("Use RebuildOnSplineChange instead.", false)]
		public bool rebuildOnSplineChange => RebuildOnSplineChange;

		public bool RebuildOnSplineChange
		{
			get
			{
				return m_RebuildOnSplineChange;
			}
			set
			{
				m_RebuildOnSplineChange = value;
			}
		}

		public int RebuildFrequency
		{
			get
			{
				return m_RebuildFrequency;
			}
			set
			{
				m_RebuildFrequency = Mathf.Max(value, 1);
			}
		}

		public float SegmentsPerUnit
		{
			get
			{
				return m_SegmentsPerUnit;
			}
			set
			{
				m_SegmentsPerUnit = Mathf.Max(value, 0.0001f);
			}
		}

		public float Width
		{
			get
			{
				return m_Width;
			}
			set
			{
				m_Width = Mathf.Max(value, 1E-05f);
			}
		}

		public int ProfileSeg
		{
			get
			{
				return m_ProfileSeg;
			}
			set
			{
				m_ProfileSeg = value;
			}
		}

		public float Height
		{
			get
			{
				return m_Height;
			}
			set
			{
				m_Height = value;
			}
		}

		public Vector2 Range
		{
			get
			{
				return m_Range;
			}
			set
			{
				m_Range = new Vector2(Mathf.Min(value.x, value.y), Mathf.Max(value.x, value.y));
			}
		}

		public Spline Spline => m_Container?.Spline;

		public IReadOnlyList<Spline> Splines => m_Container?.Splines;

		internal void Reset()
		{
			TryGetComponent<SplineContainer>(out m_Container);
			if (TryGetComponent<MeshFilter>(out var component))
			{
				component.sharedMesh = (m_Mesh = CreateMeshAsset());
			}
			if (TryGetComponent<MeshRenderer>(out var component2) && component2.sharedMaterial == null)
			{
				GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
				Material sharedMaterial = obj.GetComponent<MeshRenderer>().sharedMaterial;
				Object.DestroyImmediate(obj);
				component2.sharedMaterial = sharedMaterial;
			}
			Rebuild();
		}

		private void Start()
		{
			if (m_Container == null || m_Container.Spline == null)
			{
				Debug.LogError("Spline Extrude does not have a valid SplineContainer set.");
				return;
			}
			if ((m_Mesh = GetComponent<MeshFilter>().sharedMesh) == null)
			{
				Debug.LogError("SplineExtrude.createMeshInstance is disabled, but there is no valid mesh assigned. Please create or assign a writable mesh asset.");
			}
			Rebuild();
		}

		private void OnEnable()
		{
			Spline.Changed += OnSplineChanged;
		}

		private void OnDisable()
		{
			Spline.Changed -= OnSplineChanged;
		}

		private void OnSplineChanged(Spline spline, int knotIndex, SplineModification modificationType)
		{
			if (m_Container != null && Splines.Contains(spline) && m_RebuildOnSplineChange)
			{
				m_RebuildRequested = true;
			}
		}

		private void Update()
		{
			if (m_RebuildRequested && Time.time >= m_NextScheduledRebuild)
			{
				Rebuild();
			}
		}

		public void Rebuild()
		{
			if (!((m_Mesh = GetComponent<MeshFilter>().sharedMesh) == null))
			{
				Extrude(Splines[0], m_Mesh, m_Width, m_ProfileSeg, m_Height, m_SegmentsPerUnit, m_Range);
				m_NextScheduledRebuild = Time.time + 1f / (float)m_RebuildFrequency;
			}
		}

		private void Extrude<T>(T spline, Mesh mesh, float width, int profileSegments, float height, float segmentsPerUnit, float2 range) where T : ISpline
		{
			if (profileSegments < 2)
			{
				return;
			}
			float num = Mathf.Abs(range.y - range.x);
			int num2 = Mathf.Max((int)Mathf.Ceil(spline.GetLength() * num * segmentsPerUnit), 1);
			float num3 = 0f;
			List<Vector3> list = new List<Vector3>();
			List<Vector3> list2 = new List<Vector3>();
			List<Vector2> list3 = new List<Vector2>();
			Vector3 vector = Vector3.zero;
			for (int i = 0; i < num2; i++)
			{
				float num4 = math.lerp(range.x, range.y, (float)i / ((float)num2 - 1f));
				if (num4 > 1f)
				{
					num4 = 1f;
				}
				spline.Evaluate(num4, out var position, out var tangent, out var upVector);
				Vector3 normalized = ((Vector3)tangent).normalized;
				Vector3 normalized2 = ((Vector3)upVector).normalized;
				Vector3 vector2 = Vector3.Cross(normalized, normalized2);
				float num5 = 1f / (float)(profileSegments - 1);
				if (i > 0)
				{
					num3 += ((Vector3)position - vector).magnitude;
				}
				for (int j = 0; j < profileSegments; j++)
				{
					float num6 = num5 * (float)j;
					float num7 = (num6 - 0.5f) * 2f;
					float num8 = Mathf.Cos(num7 * MathF.PI * 0.5f) * height;
					float num9 = num7 * width;
					Vector3 item = (Vector3)position + num9 * vector2 + num8 * normalized2;
					list.Add(item);
					list3.Add(new Vector2(num6 * uFactor, num3 * vFactor));
					list2.Add(normalized2);
				}
				vector = position;
			}
			List<int> triangles = new List<int>();
			for (int k = 0; k < num2 - 1; k++)
			{
				int num10 = k * profileSegments;
				for (int l = 0; l < profileSegments - 1; l++)
				{
					int num11 = num10 + l;
					AddTriangles(new int[3]
					{
						num11,
						num11 + 1,
						num11 + profileSegments
					});
					AddTriangles(new int[3]
					{
						num11 + 1,
						num11 + 1 + profileSegments,
						num11 + profileSegments
					});
				}
			}
			mesh.Clear();
			mesh.vertices = list.ToArray();
			mesh.uv = list3.ToArray();
			mesh.triangles = triangles.ToArray();
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			void AddTriangles(int[] indicies)
			{
				triangles.AddRange(indicies);
			}
		}

		private void OnValidate()
		{
			Rebuild();
		}

		internal Mesh CreateMeshAsset()
		{
			return new Mesh
			{
				name = base.name
			};
		}

		private void FlattenSpline()
		{
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
	[AddComponentMenu("Splines/Spline Profile Extrude")]
	public class SplineProfileExtrude : MonoBehaviour
	{
		[Serializable]
		private struct Vertex
		{
			public Vector3 position;

			public Vector3 normal;

			public float u;
		}

		[SerializeField]
		[Tooltip("The Spline to extrude.")]
		private SplineContainer m_Container;

		[SerializeField]
		private Vertex[] profile;

		[SerializeField]
		[Tooltip("Enable to regenerate the extruded mesh when the target Spline is modified. Disable this option if the Spline will not be modified at runtime.")]
		private bool m_RebuildOnSplineChange;

		[SerializeField]
		[Tooltip("The maximum number of times per-second that the mesh will be rebuilt.")]
		private int m_RebuildFrequency = 30;

		[SerializeField]
		[Tooltip("Automatically update any Mesh, Box, or Sphere collider components when the mesh is extruded.")]
		private bool m_UpdateColliders = true;

		[SerializeField]
		[Tooltip("The number of edge loops that comprise the length of one unit of the mesh. The total number of sections is equal to \"Spline.GetLength() * segmentsPerUnit\".")]
		private float m_SegmentsPerUnit = 4f;

		[SerializeField]
		[Tooltip("The radius of the extruded mesh.")]
		private float m_Width = 0.25f;

		[SerializeField]
		private float m_Height = 0.05f;

		[SerializeField]
		[Tooltip("The section of the Spline to extrude.")]
		private Vector2 m_Range = new Vector2(0f, 1f);

		[SerializeField]
		private float uFactor = 1f;

		[SerializeField]
		private float vFactor = 1f;

		private Mesh m_Mesh;

		private bool m_RebuildRequested;

		private float m_NextScheduledRebuild;

		[Obsolete("Use Container instead.", false)]
		public SplineContainer container => Container;

		public SplineContainer Container
		{
			get
			{
				return m_Container;
			}
			set
			{
				m_Container = value;
			}
		}

		[Obsolete("Use RebuildOnSplineChange instead.", false)]
		public bool rebuildOnSplineChange => RebuildOnSplineChange;

		public bool RebuildOnSplineChange
		{
			get
			{
				return m_RebuildOnSplineChange;
			}
			set
			{
				m_RebuildOnSplineChange = value;
			}
		}

		public int RebuildFrequency
		{
			get
			{
				return m_RebuildFrequency;
			}
			set
			{
				m_RebuildFrequency = Mathf.Max(value, 1);
			}
		}

		public float SegmentsPerUnit
		{
			get
			{
				return m_SegmentsPerUnit;
			}
			set
			{
				m_SegmentsPerUnit = Mathf.Max(value, 0.0001f);
			}
		}

		public float Width
		{
			get
			{
				return m_Width;
			}
			set
			{
				m_Width = Mathf.Max(value, 1E-05f);
			}
		}

		public int ProfileSeg => profile.Length;

		public float Height
		{
			get
			{
				return m_Height;
			}
			set
			{
				m_Height = value;
			}
		}

		public Vector2 Range
		{
			get
			{
				return m_Range;
			}
			set
			{
				m_Range = new Vector2(Mathf.Min(value.x, value.y), Mathf.Max(value.x, value.y));
			}
		}

		public Spline Spline => m_Container?.Spline;

		public IReadOnlyList<Spline> Splines => m_Container?.Splines;

		internal void Reset()
		{
			TryGetComponent<SplineContainer>(out m_Container);
			if (TryGetComponent<MeshFilter>(out var component))
			{
				component.sharedMesh = (m_Mesh = CreateMeshAsset());
			}
			if (TryGetComponent<MeshRenderer>(out var component2) && component2.sharedMaterial == null)
			{
				GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
				Material sharedMaterial = obj.GetComponent<MeshRenderer>().sharedMaterial;
				Object.DestroyImmediate(obj);
				component2.sharedMaterial = sharedMaterial;
			}
			Rebuild();
		}

		private void Start()
		{
			if (m_Container == null || m_Container.Spline == null)
			{
				Debug.LogError("Spline Extrude does not have a valid SplineContainer set.");
				return;
			}
			if ((m_Mesh = GetComponent<MeshFilter>().sharedMesh) == null)
			{
				Debug.LogError("SplineExtrude.createMeshInstance is disabled, but there is no valid mesh assigned. Please create or assign a writable mesh asset.");
			}
			Rebuild();
		}

		private void OnEnable()
		{
			Spline.Changed += OnSplineChanged;
		}

		private void OnDisable()
		{
			Spline.Changed -= OnSplineChanged;
		}

		private void OnSplineChanged(Spline spline, int knotIndex, SplineModification modificationType)
		{
			if (m_Container != null && Splines.Contains(spline) && m_RebuildOnSplineChange)
			{
				m_RebuildRequested = true;
			}
		}

		private void Update()
		{
			if (m_RebuildRequested && Time.time >= m_NextScheduledRebuild)
			{
				Rebuild();
			}
		}

		public void Rebuild()
		{
			if (!((m_Mesh = GetComponent<MeshFilter>().sharedMesh) == null))
			{
				Extrude(Splines[0], profile, m_Mesh, m_SegmentsPerUnit, m_Range);
				m_NextScheduledRebuild = Time.time + 1f / (float)m_RebuildFrequency;
			}
		}

		private void Extrude<T>(T spline, Vertex[] profile, Mesh mesh, float segmentsPerUnit, float2 range) where T : ISpline
		{
			int num = profile.Length;
			if (num < 2)
			{
				return;
			}
			float num2 = Mathf.Abs(range.y - range.x);
			int num3 = Mathf.Max((int)Mathf.Ceil(spline.GetLength() * num2 * segmentsPerUnit), 1);
			float num4 = 0f;
			List<Vector3> list = new List<Vector3>();
			List<Vector3> list2 = new List<Vector3>();
			List<Vector2> list3 = new List<Vector2>();
			Vector3 vector = Vector3.zero;
			for (int i = 0; i < num3; i++)
			{
				float num5 = math.lerp(range.x, range.y, (float)i / ((float)num3 - 1f));
				if (num5 > 1f)
				{
					num5 = 1f;
				}
				if (num5 < 1E-07f)
				{
					num5 = 1E-07f;
				}
				spline.Evaluate(num5, out var position, out var tangent, out var upVector);
				Vector3 normalized = ((Vector3)tangent).normalized;
				Vector3 normalized2 = ((Vector3)upVector).normalized;
				Vector3 vector2 = Vector3.Cross(normalized, normalized2);
				_ = 1f / (float)(num - 1);
				if (i > 0)
				{
					num4 += ((Vector3)position - vector).magnitude;
				}
				for (int j = 0; j < num; j++)
				{
					Vertex vertex = profile[j];
					float u = vertex.u;
					float y = vertex.position.y;
					float x = vertex.position.x;
					float z = vertex.position.z;
					Vector3 item = Quaternion.FromToRotation(Vector3.up, normalized2) * vertex.normal;
					Vector3 item2 = (Vector3)position + x * vector2 + y * normalized2 + z * normalized;
					list.Add(item2);
					list3.Add(new Vector2(u * uFactor, num4 * vFactor));
					list2.Add(item);
				}
				vector = position;
			}
			List<int> triangles = new List<int>();
			for (int k = 0; k < num3 - 1; k++)
			{
				int num6 = k * num;
				for (int l = 0; l < num - 1; l++)
				{
					int num7 = num6 + l;
					AddTriangles(new int[3]
					{
						num7,
						num7 + 1,
						num7 + num
					});
					AddTriangles(new int[3]
					{
						num7 + 1,
						num7 + 1 + num,
						num7 + num
					});
				}
			}
			mesh.Clear();
			mesh.vertices = list.ToArray();
			mesh.uv = list3.ToArray();
			mesh.triangles = triangles.ToArray();
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			void AddTriangles(int[] indicies)
			{
				triangles.AddRange(indicies);
			}
		}

		private void OnValidate()
		{
			Rebuild();
		}

		internal Mesh CreateMeshAsset()
		{
			return new Mesh
			{
				name = base.name
			};
		}

		private void FlattenSpline()
		{
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
	[AddComponentMenu("Splines/Spline Sidewalk Extrude")]
	public class SplineSidewalkExtrude : MonoBehaviour
	{
		[Flags]
		public enum Sides
		{
			None = 0,
			Left = 1,
			Right = 2,
			Both = 3
		}

		private struct ProfileLine
		{
			public Vector3 start;

			public Vector3 end;

			public float u0;

			public float u1;

			public ProfileLine(Vector3 start, Vector3 end, float u0, float u1)
			{
				this.start = start;
				this.end = end;
				this.u0 = u0;
				this.u1 = u1;
			}
		}

		[SerializeField]
		[Tooltip("The Spline to extrude.")]
		private SplineContainer m_Container;

		[SerializeField]
		private float offset;

		[SerializeField]
		private float height;

		[SerializeField]
		private float width;

		[SerializeField]
		private float bevel;

		[SerializeField]
		private Sides sides = Sides.Both;

		[SerializeField]
		[Tooltip("Enable to regenerate the extruded mesh when the target Spline is modified. Disable this option if the Spline will not be modified at runtime.")]
		private bool m_RebuildOnSplineChange;

		[SerializeField]
		[Tooltip("The maximum number of times per-second that the mesh will be rebuilt.")]
		private int m_RebuildFrequency = 30;

		[SerializeField]
		[Tooltip("Automatically update any Mesh, Box, or Sphere collider components when the mesh is extruded.")]
		private bool m_UpdateColliders = true;

		[SerializeField]
		[Tooltip("The number of edge loops that comprise the length of one unit of the mesh. The total number of sections is equal to \"Spline.GetLength() * segmentsPerUnit\".")]
		private float m_SegmentsPerUnit = 4f;

		[SerializeField]
		[Tooltip("The radius of the extruded mesh.")]
		private float m_Width = 0.25f;

		[SerializeField]
		private float m_Height = 0.05f;

		[SerializeField]
		[Tooltip("The section of the Spline to extrude.")]
		private Vector2 m_Range = new Vector2(0f, 0.999f);

		[SerializeField]
		private float uFactor = 1f;

		[SerializeField]
		private float vFactor = 1f;

		private Mesh m_Mesh;

		private bool m_RebuildRequested;

		private float m_NextScheduledRebuild;

		[Obsolete("Use Container instead.", false)]
		public SplineContainer container => Container;

		public SplineContainer Container
		{
			get
			{
				return m_Container;
			}
			set
			{
				m_Container = value;
			}
		}

		[Obsolete("Use RebuildOnSplineChange instead.", false)]
		public bool rebuildOnSplineChange => RebuildOnSplineChange;

		public bool RebuildOnSplineChange
		{
			get
			{
				return m_RebuildOnSplineChange;
			}
			set
			{
				m_RebuildOnSplineChange = value;
			}
		}

		public int RebuildFrequency
		{
			get
			{
				return m_RebuildFrequency;
			}
			set
			{
				m_RebuildFrequency = Mathf.Max(value, 1);
			}
		}

		public float SegmentsPerUnit
		{
			get
			{
				return m_SegmentsPerUnit;
			}
			set
			{
				m_SegmentsPerUnit = Mathf.Max(value, 0.0001f);
			}
		}

		public float Width
		{
			get
			{
				return m_Width;
			}
			set
			{
				m_Width = Mathf.Max(value, 1E-05f);
			}
		}

		public float Height
		{
			get
			{
				return m_Height;
			}
			set
			{
				m_Height = value;
			}
		}

		public Vector2 Range
		{
			get
			{
				return m_Range;
			}
			set
			{
				m_Range = new Vector2(Mathf.Min(value.x, value.y), Mathf.Max(value.x, value.y));
			}
		}

		public Spline Spline => m_Container?.Spline;

		public IReadOnlyList<Spline> Splines => m_Container?.Splines;

		internal void Reset()
		{
			TryGetComponent<SplineContainer>(out m_Container);
			if (TryGetComponent<MeshFilter>(out var component))
			{
				component.sharedMesh = (m_Mesh = CreateMeshAsset());
			}
			if (TryGetComponent<MeshRenderer>(out var component2) && component2.sharedMaterial == null)
			{
				GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);
				Material sharedMaterial = obj.GetComponent<MeshRenderer>().sharedMaterial;
				Object.DestroyImmediate(obj);
				component2.sharedMaterial = sharedMaterial;
			}
			Rebuild();
		}

		private void Start()
		{
			if (m_Container == null || m_Container.Spline == null)
			{
				Debug.LogError("Spline Extrude does not have a valid SplineContainer set.");
				return;
			}
			if ((m_Mesh = GetComponent<MeshFilter>().sharedMesh) == null)
			{
				Debug.LogError("SplineExtrude.createMeshInstance is disabled, but there is no valid mesh assigned. Please create or assign a writable mesh asset.");
			}
			Rebuild();
		}

		private void OnEnable()
		{
			Spline.Changed += OnSplineChanged;
		}

		private void OnDisable()
		{
			Spline.Changed -= OnSplineChanged;
		}

		private void OnSplineChanged(Spline spline, int knotIndex, SplineModification modificationType)
		{
			if (m_Container != null && Splines.Contains(spline) && m_RebuildOnSplineChange)
			{
				m_RebuildRequested = true;
			}
		}

		private void Update()
		{
			if (m_RebuildRequested && Time.time >= m_NextScheduledRebuild)
			{
				Rebuild();
			}
		}

		public void Rebuild()
		{
			if (!((m_Mesh = GetComponent<MeshFilter>().sharedMesh) == null))
			{
				Extrude(Splines[0], m_Mesh, m_SegmentsPerUnit, m_Range);
				m_NextScheduledRebuild = Time.time + 1f / (float)m_RebuildFrequency;
			}
		}

		private void Extrude<T>(T spline, Mesh mesh, float segmentsPerUnit, float2 range) where T : ISpline
		{
			mesh.Clear();
			if (sides == Sides.None)
			{
				return;
			}
			float num = Mathf.Abs(range.y - range.x);
			int num2 = Mathf.Max((int)Mathf.Ceil(spline.GetLength() * num * segmentsPerUnit), 1);
			float v = 0f;
			List<Vector3> verts = new List<Vector3>();
			List<Vector3> n = new List<Vector3>();
			List<Vector2> uv = new List<Vector2>();
			List<int> triangles = new List<int>();
			Vector3 vector = Vector3.zero;
			ProfileLine[] array = GenerateProfile();
			int profileVertexCount = array.Length * 2;
			float3 center;
			Vector3 forward;
			Vector3 up;
			Vector3 right;
			for (int i = 0; i < num2; i++)
			{
				bool isLastSegment = i == num2 - 1;
				float num3 = math.lerp(range.x, range.y, (float)i / ((float)num2 - 1f));
				if (num3 > 1f)
				{
					num3 = 1f;
				}
				if (num3 < 1E-07f)
				{
					num3 = 1E-07f;
				}
				spline.Evaluate(num3, out center, out var tangent, out var upVector);
				forward = ((Vector3)tangent).normalized;
				up = ((Vector3)upVector).normalized;
				right = Vector3.Cross(forward, up);
				if (i > 0)
				{
					v += ((Vector3)center - vector).magnitude;
				}
				ProfileLine[] array2 = array;
				for (int j = 0; j < array2.Length; j++)
				{
					ProfileLine profileLine = array2[j];
					DrawLine(profileLine.start, profileLine.end, profileLine.u0, profileLine.u1);
				}
				vector = center;
				void DrawLine(Vector3 p0, Vector3 p1, float u0, float u1)
				{
					Vector3 vector2 = ProfileToObject(p0);
					Vector3 vector3 = ProfileToObject(p1);
					Vector3 item = Vector3.Cross(vector3 - vector2, forward);
					int count = verts.Count;
					verts.Add(vector2);
					verts.Add(vector3);
					n.Add(item);
					n.Add(item);
					uv.Add(new Vector2(u0 * uFactor, v * vFactor));
					uv.Add(new Vector2(u1 * uFactor, v * vFactor));
					if (!isLastSegment)
					{
						AddTriangles(new int[3]
						{
							count,
							count + 1,
							count + profileVertexCount
						});
						AddTriangles(new int[3]
						{
							count + 1,
							count + 1 + profileVertexCount,
							count + profileVertexCount
						});
					}
				}
			}
			mesh.vertices = verts.ToArray();
			mesh.uv = uv.ToArray();
			mesh.triangles = triangles.ToArray();
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			void AddTriangles(int[] indicies)
			{
				triangles.AddRange(indicies);
			}
			Vector3 ProfileToObject(Vector3 profilePos)
			{
				return (Vector3)center + profilePos.x * right + profilePos.y * up + profilePos.z * forward;
			}
		}

		private ProfileLine[] GenerateProfile()
		{
			List<ProfileLine> lines = new List<ProfileLine>();
			float num = height - bevel;
			float num2 = Mathf.Sqrt(2f * bevel * bevel);
			float num3 = width - 2f * bevel;
			float uFactor = num + num2 + num3 + num2 + num;
			if ((sides | Sides.Left) == sides)
			{
				Add(0f - offset - width, 0f, 0f - offset - width, height - bevel, 0f, num);
				Add(0f - offset - width + bevel, height, 0f - offset - bevel, height, num + num2, num + num2 + num3);
				Add(0f - offset, height - bevel, 0f - offset, 0f, num + num2 + num3 + num2, num + num2 + num3 + num2 + num);
				if (bevel > 0f)
				{
					Add(0f - offset - width, height - bevel, 0f - offset - width + bevel, height, num, num + num2);
					Add(0f - offset - bevel, height, 0f - offset, height - bevel, num + num2 + num3, num + num2 + num3 + num2);
				}
			}
			if ((sides | Sides.Right) == sides)
			{
				Add(offset, 0f, offset, height - bevel, num + num2 + num3 + num2 + num, num + num2 + num3 + num2);
				Add(offset + bevel, height, offset + width - bevel, height, num + num2 + num3, num + num2);
				Add(offset + width, height - bevel, offset + width, 0f, num, 0f);
				if (bevel > 0f)
				{
					Add(offset, height - bevel, offset + bevel, height, num + num2 + num3 + num2, num + num2 + num3);
					Add(offset + width - bevel, height, offset + width, height - bevel, num + num2, num);
				}
			}
			return lines.ToArray();
			void Add(float x0, float y0, float x1, float y1, float u0, float u1)
			{
				lines.Add(new ProfileLine(new Vector3(x0, y0), new Vector3(x1, y1), u0 / uFactor, u1 / uFactor));
			}
		}

		private void OnValidate()
		{
			Rebuild();
		}

		internal Mesh CreateMeshAsset()
		{
			return new Mesh
			{
				name = base.name
			};
		}

		private void FlattenSpline()
		{
		}
	}
}
namespace FX
{
	public class PopText : MonoBehaviour
	{
		public static PopText instance;

		public PopTextEntity popTextPrefab;

		public List<PopTextEntity> inactiveEntries;

		public List<PopTextEntity> activeEntries;

		public float spawnVelocity = 5f;

		public float gravityValue = -9.8f;

		public float lifeTime = 1f;

		public AnimationCurve sizeOverLife;

		public float randomAngle = 10f;

		public Sprite debugSprite;

		private List<PopTextEntity> recycleList = new List<PopTextEntity>();

		private void Awake()
		{
			instance = this;
		}

		private PopTextEntity GetOrCreateEntry()
		{
			PopTextEntity popTextEntity;
			if (inactiveEntries.Count > 0)
			{
				popTextEntity = inactiveEntries[0];
				inactiveEntries.RemoveAt(0);
			}
			popTextEntity = UnityEngine.Object.Instantiate(popTextPrefab, base.transform);
			activeEntries.Add(popTextEntity);
			popTextEntity.gameObject.SetActive(value: true);
			return popTextEntity;
		}

		public void InstancePop(string text, Vector3 worldPosition, Color color, float size, Sprite sprite = null)
		{
			PopTextEntity orCreateEntry = GetOrCreateEntry();
			orCreateEntry.Color = color;
			orCreateEntry.size = size;
			orCreateEntry.transform.localScale = Vector3.one * size;
			Transform obj = orCreateEntry.transform;
			obj.position = worldPosition;
			obj.rotation = LookAtMainCamera(worldPosition);
			float x = UnityEngine.Random.Range(0f - randomAngle, randomAngle);
			float z = UnityEngine.Random.Range(0f - randomAngle, randomAngle);
			Vector3 vector = Quaternion.Euler(x, 0f, z) * Vector3.up;
			orCreateEntry.SetupContent(text, sprite);
			orCreateEntry.velocity = vector * spawnVelocity;
			orCreateEntry.spawnTime = Time.time;
		}

		private static Quaternion LookAtMainCamera(Vector3 position)
		{
			if ((bool)Camera.main)
			{
				Transform transform = Camera.main.transform;
				return Quaternion.LookRotation(-(transform.position - position), transform.up);
			}
			return Quaternion.identity;
		}

		public void Recycle(PopTextEntity entry)
		{
			entry.gameObject.SetActive(value: false);
			activeEntries.Remove(entry);
			inactiveEntries.Add(entry);
		}

		private void Update()
		{
			float deltaTime = Time.deltaTime;
			Vector3 vector = Vector3.up * gravityValue;
			bool flag = false;
			foreach (PopTextEntity activeEntry in activeEntries)
			{
				if (activeEntry == null)
				{
					flag = true;
					continue;
				}
				Transform obj = activeEntry.transform;
				obj.position += activeEntry.velocity * deltaTime;
				obj.rotation = LookAtMainCamera(obj.position);
				activeEntry.velocity += vector * deltaTime;
				activeEntry.transform.localScale = sizeOverLife.Evaluate(activeEntry.timeSinceSpawn / lifeTime) * activeEntry.size * Vector3.one;
				float t = Mathf.Clamp01(activeEntry.timeSinceSpawn / lifeTime * 2f - 1f);
				Color color = Color.Lerp(activeEntry.Color, activeEntry.EndColor, t);
				activeEntry.SetColor(color);
				if (activeEntry.timeSinceSpawn > lifeTime)
				{
					recycleList.Add(activeEntry);
				}
			}
			if (recycleList.Count > 0)
			{
				foreach (PopTextEntity recycle in recycleList)
				{
					Recycle(recycle);
				}
				recycleList.Clear();
			}
			if (flag)
			{
				activeEntries.RemoveAll((PopTextEntity e) => e == null);
			}
		}

		private void PopTest()
		{
			Vector3 worldPosition = base.transform.position;
			CharacterMainControl main = CharacterMainControl.Main;
			if (main != null)
			{
				worldPosition = main.transform.position + Vector3.up * 2f;
			}
			InstancePop("Test", worldPosition, Color.white, 1f, debugSprite);
		}

		public static void Pop(string text, Vector3 worldPosition, Color color, float size, Sprite sprite = null)
		{
			if (!DevCam.devCamOn && (bool)instance)
			{
				instance.InstancePop(text, worldPosition, color, size, sprite);
			}
		}
	}
	public class PopTextEntity : MonoBehaviour
	{
		[SerializeField]
		private SpriteRenderer spriteRenderer;

		private RectTransform _spriteRendererRectTransform_cache;

		[SerializeField]
		private TextMeshPro _tmp;

		public Vector3 velocity;

		public float size;

		private Color color;

		private Color endColor;

		public float spawnTime;

		private RectTransform spriteRendererRectTransform
		{
			get
			{
				if (_spriteRendererRectTransform_cache == null)
				{
					_spriteRendererRectTransform_cache = spriteRenderer.GetComponent<RectTransform>();
				}
				return _spriteRendererRectTransform_cache;
			}
		}

		private TextMeshPro tmp => _tmp;

		public TextMeshPro Tmp => tmp;

		public Color EndColor => endColor;

		public Color Color
		{
			get
			{
				return color;
			}
			set
			{
				color = value;
				endColor = color;
				endColor.a = 0f;
			}
		}

		public float timeSinceSpawn => Time.time - spawnTime;

		private string text
		{
			get
			{
				return tmp.text;
			}
			set
			{
				tmp.text = value;
			}
		}

		public void SetupContent(string text, Sprite sprite = null)
		{
			this.text = text;
			if (sprite == null)
			{
				spriteRenderer.gameObject.SetActive(value: false);
				return;
			}
			spriteRenderer.gameObject.SetActive(value: true);
			spriteRenderer.sprite = sprite;
			spriteRenderer.transform.localScale = Vector3.one * (0.5f / (sprite.rect.width / sprite.pixelsPerUnit));
		}

		internal void SetColor(Color newColor)
		{
			Tmp.color = newColor;
			spriteRenderer.color = newColor;
		}
	}
}
namespace UI
{
	public class Menu : MonoBehaviour
	{
		[SerializeField]
		private bool focused;

		[SerializeField]
		private MenuItem cursor;

		[SerializeField]
		private LayoutGroup layout;

		private HashSet<MenuItem> items = new HashSet<MenuItem>();

		public bool Focused
		{
			get
			{
				return focused;
			}
			set
			{
				SetFocused(value);
			}
		}

		public event Action<Menu, MenuItem> onSelectionChanged;

		public event Action<Menu, MenuItem> onConfirmed;

		public event Action<Menu, MenuItem> onCanceled;

		private void SetFocused(bool value)
		{
			focused = value;
			if (focused && cursor == null)
			{
				SelectDefault();
			}
			cursor?.NotifyMasterFocusStatusChanged();
		}

		public MenuItem GetSelected()
		{
			return cursor;
		}

		public T GetSelected<T>() where T : UnityEngine.Component
		{
			if (cursor == null)
			{
				return null;
			}
			return cursor.GetComponent<T>();
		}

		public void Select(MenuItem toSelect)
		{
			if (toSelect.transform.parent != base.transform)
			{
				UnityEngine.Debug.LogError("正在尝试选中不属于此菜单的项目。已取消。");
				return;
			}
			if (!items.Contains(toSelect))
			{
				items.Add(toSelect);
			}
			if (toSelect.Selectable)
			{
				if (cursor != null)
				{
					DeselectCurrent();
				}
				cursor = toSelect;
				cursor.NotifySelected();
				OnSelectionChanged();
			}
		}

		public void SelectDefault()
		{
			MenuItem[] componentsInChildren = GetComponentsInChildren<MenuItem>(includeInactive: false);
			if (componentsInChildren == null)
			{
				return;
			}
			foreach (MenuItem menuItem in componentsInChildren)
			{
				if (!(menuItem == null) && menuItem.Selectable)
				{
					Select(menuItem);
				}
			}
		}

		public void Confirm()
		{
			if (cursor != null)
			{
				cursor.NotifyConfirmed();
			}
			this.onConfirmed?.Invoke(this, cursor);
		}

		public void Cancel()
		{
			if (cursor != null)
			{
				cursor.NotifyCanceled();
			}
			this.onCanceled?.Invoke(this, cursor);
		}

		private void DeselectCurrent()
		{
			cursor.NotifyDeselected();
		}

		private void OnSelectionChanged()
		{
			this.onSelectionChanged?.Invoke(this, cursor);
		}

		public void Navigate(Vector2 direction)
		{
			if (cursor == null)
			{
				SelectDefault();
			}
			if (!(cursor == null) && !Mathf.Approximately(direction.sqrMagnitude, 0f))
			{
				MenuItem menuItem = FindClosestEntryInDirection(cursor, direction);
				if (!(menuItem == null))
				{
					Select(menuItem);
				}
			}
		}

		private MenuItem FindClosestEntryInDirection(MenuItem cursor, Vector2 direction)
		{
			if (cursor == null)
			{
				return null;
			}
			direction = direction.normalized;
			float num = Mathf.Cos(MathF.PI / 4f);
			MenuItem bestMatch = null;
			float bestSqrDist = float.MaxValue;
			float bestDot = num;
			foreach (MenuItem item in items)
			{
				MenuItem cur = item;
				if (cur == null || cur == cursor || !cur.Selectable)
				{
					continue;
				}
				Vector3 vector = cur.transform.localPosition - cursor.transform.localPosition;
				Vector3 normalized = vector.normalized;
				float dot = Vector3.Dot(normalized, direction);
				if (dot < num)
				{
					continue;
				}
				float sqrDist = vector.magnitude;
				if (!(sqrDist > bestSqrDist))
				{
					if (sqrDist < bestSqrDist)
					{
						SetBestAsCur();
					}
					else if (sqrDist == bestSqrDist && dot > bestDot)
					{
						SetBestAsCur();
					}
				}
				void SetBestAsCur()
				{
					bestMatch = cur;
					bestSqrDist = sqrDist;
					bestDot = dot;
				}
			}
			return bestMatch;
		}

		internal void Register(MenuItem menuItem)
		{
			items.Add(menuItem);
		}

		internal void Unegister(MenuItem menuItem)
		{
			items.Remove(menuItem);
		}
	}
	public class MenuItem : MonoBehaviour
	{
		private Menu _master;

		[SerializeField]
		private bool selectable = true;

		private bool cacheSelected;

		public Action<MenuItem> onSelected;

		public Action<MenuItem> onDeselected;

		public Action<MenuItem> onConfirmed;

		public Action<MenuItem> onCanceled;

		public Action<MenuItem, bool> onFocusStatusChanged;

		public Menu Master
		{
			get
			{
				if (_master == null)
				{
					_master = base.transform.parent?.GetComponent<Menu>();
				}
				return _master;
			}
			set
			{
				_master = value;
			}
		}

		public bool Selectable
		{
			get
			{
				if (!base.gameObject.activeSelf)
				{
					return false;
				}
				return selectable;
			}
			set
			{
				selectable = value;
			}
		}

		public bool IsSelected => cacheSelected;

		private void OnTransformParentChanged()
		{
			if (!(Master == null))
			{
				Master.Register(this);
			}
		}

		private void OnEnable()
		{
			if (!(Master == null))
			{
				Master.Register(this);
			}
		}

		private void OnDisable()
		{
			if (!(Master == null))
			{
				Master.Unegister(this);
			}
		}

		public void Select()
		{
			if (Master == null)
			{
				UnityEngine.Debug.LogError("Menu Item " + base.name + " 没有Master。");
			}
			else
			{
				Master.Select(this);
			}
		}

		internal void NotifySelected()
		{
			cacheSelected = true;
			onSelected?.Invoke(this);
		}

		internal void NotifyDeselected()
		{
			cacheSelected = false;
			onDeselected?.Invoke(this);
		}

		internal void NotifyConfirmed()
		{
			onConfirmed?.Invoke(this);
		}

		internal void NotifyCanceled()
		{
			onCanceled?.Invoke(this);
		}

		internal void NotifyMasterFocusStatusChanged()
		{
			onFocusStatusChanged?.Invoke(this, Master.Focused);
		}
	}
}
namespace CameraSystems
{
	public class CameraPropertiesControl : MonoBehaviour
	{
		private CinemachineVirtualCamera vCam;

		private CinemachineVolumeSettings volumeSettings;

		[SerializeField]
		private VolumeProfile volumeProfile;

		private void Awake()
		{
			vCam = GetComponent<CinemachineVirtualCamera>();
			volumeSettings = GetComponent<CinemachineVolumeSettings>();
		}

		private void Update()
		{
			_ = Gamepad.current.dpad.x.value;
			_ = 0f;
			if (Gamepad.current.dpad.y.value != 0f)
			{
				float num = 0f - Gamepad.current.dpad.y.value;
				if (Gamepad.current.rightShoulder.value > 0f)
				{
					num *= 10f;
				}
				vCam.m_Lens.FieldOfView = Mathf.Clamp(vCam.m_Lens.FieldOfView + num * 5f * Time.deltaTime, 8f, 100f);
			}
		}
	}
}
namespace Fishing
{
	[CreateAssetMenu(menuName = "Fishing/Fishing Pool")]
	public class FishingPool : ScriptableObject
	{
		[SerializeField]
		private List<FishingPoolEntry> entries;

		public int GetRandom(WeightModifications[] modifications)
		{
			if (entries == null || entries.Count <= 0)
			{
				UnityEngine.Debug.LogError("Fishing Pool " + base.name + " 里面没有配置任何项目，返回-1");
				return -1;
			}
			if (modifications != null && modifications.Length != 0)
			{
				return entries.GetRandomWeighted(delegate(FishingPoolEntry e)
				{
					WeightModifications[] array = modifications;
					for (int i = 0; i < array.Length; i++)
					{
						WeightModifications weightModifications = array[i];
						if (weightModifications.id == e.ID)
						{
							return e.Weight + weightModifications.addAmount;
						}
					}
					return e.Weight;
				}).ID;
			}
			return entries.GetRandomWeighted((FishingPoolEntry e) => e.Weight).ID;
		}
	}
	public struct WeightModifications
	{
		public int id;

		public float addAmount;
	}
	[Serializable]
	internal struct FishingPoolEntry
	{
		[SerializeField]
		[ItemTypeID]
		private int id;

		[SerializeField]
		private float weight;

		public int ID => id;

		public float Weight => weight;
	}
	public class FishingHUD : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private UnityEngine.UI.Image countDownFill;

		[SerializeField]
		private FadeGroup succeedIndicator;

		[SerializeField]
		private FadeGroup failIndicator;

		private void Awake()
		{
			Action_Fishing.OnPlayerStartCatching += OnStartCatching;
			Action_Fishing.OnPlayerStopCatching += OnStopCatching;
			Action_Fishing.OnPlayerStopFishing += OnStopFishing;
		}

		private void OnDestroy()
		{
			Action_Fishing.OnPlayerStartCatching -= OnStartCatching;
			Action_Fishing.OnPlayerStopCatching -= OnStopCatching;
			Action_Fishing.OnPlayerStopFishing -= OnStopFishing;
		}

		private void OnStopFishing(Action_Fishing fishing)
		{
			fadeGroup.Hide();
		}

		private void OnStopCatching(Action_Fishing fishing, Item item, Action<bool> action)
		{
			StopCatchingTask(item, action).Forget();
		}

		private void OnStartCatching(Action_Fishing fishing, float totalTime, Func<float> currentTimeGetter)
		{
			CatchingTask(fishing, totalTime, currentTimeGetter).Forget();
		}

		private async UniTask CatchingTask(Action_Fishing fishing, float totalTime, Func<float> currentTimeGetter)
		{
			succeedIndicator.SkipHide();
			failIndicator.SkipHide();
			fadeGroup.Show();
			while (fishing.Running && fishing.FishingState == Action_Fishing.FishingStates.catching)
			{
				UpdateBar(totalTime, currentTimeGetter());
				await UniTask.Yield();
			}
			if (!fishing.Running)
			{
				fadeGroup.Hide();
			}
		}

		private void UpdateBar(float totalTime, float currentTime)
		{
			if (!(totalTime <= 0f))
			{
				float fillAmount = 1f - currentTime / totalTime;
				countDownFill.fillAmount = fillAmount;
			}
		}

		private async UniTask StopCatchingTask(Item item, Action<bool> confirmCallback)
		{
			if (item == null)
			{
				failIndicator.Show();
			}
			else
			{
				succeedIndicator.Show();
			}
			fadeGroup.Hide();
		}
	}
}
namespace Fishing.UI
{
	public class BaitSelectPanel : MonoBehaviour, ISingleSelectionMenu<BaitSelectPanelEntry>
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button confirmButton;

		[SerializeField]
		private UnityEngine.UI.Button cancelButton;

		[SerializeField]
		private ItemDetailsDisplay details;

		[SerializeField]
		private FadeGroup detailsFadeGroup;

		[SerializeField]
		private BaitSelectPanelEntry entry;

		private PrefabPool<BaitSelectPanelEntry> _entryPool;

		private BaitSelectPanelEntry selectedEntry;

		private bool canceled;

		private bool confirmed;

		private PrefabPool<BaitSelectPanelEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<BaitSelectPanelEntry>(entry);
				}
				return _entryPool;
			}
		}

		private Item SelectedItem => selectedEntry?.Target;

		internal event Action onSetSelection;

		internal async UniTask DoBaitSelection(ICollection<Item> availableBaits, Func<Item, bool> baitSelectionResultCallback)
		{
			detailsFadeGroup.SkipHide();
			Setup(availableBaits);
			Open();
			baitSelectionResultCallback(await WaitForSelection());
			Close();
		}

		private void Open()
		{
			fadeGroup.Show();
		}

		private void Close()
		{
			fadeGroup.Hide();
		}

		private async UniTask<Item> WaitForSelection()
		{
			selectedEntry = null;
			canceled = false;
			confirmed = false;
			while (base.gameObject.activeInHierarchy && !confirmed && !canceled)
			{
				await UniTask.Yield();
			}
			if (canceled)
			{
				return null;
			}
			return SelectedItem;
		}

		private void Setup(ICollection<Item> availableBaits)
		{
			selectedEntry = null;
			EntryPool.ReleaseAll();
			foreach (Item availableBait in availableBaits)
			{
				EntryPool.Get().Setup(this, availableBait);
			}
		}

		internal void NotifyStop()
		{
			Close();
		}

		private void Awake()
		{
			confirmButton.onClick.AddListener(OnConfirmButtonClicked);
			cancelButton.onClick.AddListener(OnCancelButtonClicked);
		}

		private void OnConfirmButtonClicked()
		{
			if (SelectedItem == null)
			{
				NotificationText.Push("Fishing_PleaseSelectBait".ToPlainText());
			}
			else
			{
				confirmed = true;
			}
		}

		private void OnCancelButtonClicked()
		{
			canceled = true;
		}

		internal void NotifySelect(BaitSelectPanelEntry baitSelectPanelEntry)
		{
			SetSelection(baitSelectPanelEntry);
			if (SelectedItem != null)
			{
				details.Setup(SelectedItem);
				detailsFadeGroup.Show();
			}
			else
			{
				detailsFadeGroup.SkipHide();
			}
		}

		public BaitSelectPanelEntry GetSelection()
		{
			return selectedEntry;
		}

		public bool SetSelection(BaitSelectPanelEntry selection)
		{
			selectedEntry = selection;
			this.onSetSelection?.Invoke();
			return true;
		}
	}
	public class BaitSelectPanelEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private GameObject selectedIndicator;

		[SerializeField]
		private ItemDisplay itemDisplay;

		private BaitSelectPanel master;

		private Item targetItem;

		public Item Target => targetItem;

		private bool Selected
		{
			get
			{
				if (master == null)
				{
					return false;
				}
				return master.GetSelection() == this;
			}
		}

		internal void Setup(BaitSelectPanel master, Item cur)
		{
			UnregisterEvents();
			this.master = master;
			targetItem = cur;
			itemDisplay.Setup(targetItem);
			RegisterEvents();
			Refresh();
		}

		private void RegisterEvents()
		{
			if (!(master == null))
			{
				master.onSetSelection += Refresh;
			}
		}

		private void UnregisterEvents()
		{
			if (!(master == null))
			{
				master.onSetSelection -= Refresh;
			}
		}

		private void Refresh()
		{
			selectedIndicator.SetActive(Selected);
		}

		private void Awake()
		{
			itemDisplay.onPointerClick += OnPointerClick;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			eventData.Use();
			master.NotifySelect(this);
		}

		private void OnPointerClick(ItemDisplay display, PointerEventData data)
		{
			OnPointerClick(data);
		}
	}
	public class ConfirmPanel : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private TextMeshProUGUI titleText;

		[SerializeField]
		[LocalizationKey("Default")]
		private string succeedTextKey = "Fishing_Succeed";

		[SerializeField]
		[LocalizationKey("Default")]
		private string failedTextKey = "Fishing_Failed";

		[SerializeField]
		private ItemDisplay itemDisplay;

		[SerializeField]
		private UnityEngine.UI.Button continueButton;

		[SerializeField]
		private UnityEngine.UI.Button quitButton;

		private bool confirmed;

		private bool continueFishing;

		private void Awake()
		{
			continueButton.onClick.AddListener(OnContinueButtonClicked);
			quitButton.onClick.AddListener(OnQuitButtonClicked);
			itemDisplay.onPointerClick += OnItemDisplayClick;
		}

		private void OnItemDisplayClick(ItemDisplay display, PointerEventData data)
		{
			data.Use();
		}

		private void OnContinueButtonClicked()
		{
			confirmed = true;
			continueFishing = true;
		}

		private void OnQuitButtonClicked()
		{
			confirmed = true;
			continueFishing = false;
		}

		internal async UniTask DoConfirmDialogue(Item catchedItem, Action<bool> confirmCallback)
		{
			Setup(catchedItem);
			fadeGroup.Show();
			confirmed = false;
			while (base.gameObject.activeInHierarchy && !confirmed)
			{
				await UniTask.Yield();
			}
			confirmCallback(continueFishing);
			fadeGroup.Hide();
		}

		private void Setup(Item item)
		{
			if (item == null)
			{
				titleText.text = failedTextKey.ToPlainText();
				itemDisplay.gameObject.SetActive(value: false);
			}
			else
			{
				titleText.text = succeedTextKey.ToPlainText();
				itemDisplay.Setup(item);
				itemDisplay.gameObject.SetActive(value: true);
			}
		}

		internal void NotifyStop()
		{
			fadeGroup.Hide();
		}
	}
	public class FishingUI : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private BaitSelectPanel baitSelectPanel;

		[SerializeField]
		private ConfirmPanel confirmPanel;

		protected override void Awake()
		{
			base.Awake();
			Action_Fishing.OnPlayerStartSelectBait += OnStartSelectBait;
			Action_Fishing.OnPlayerStopCatching += OnStopCatching;
			Action_Fishing.OnPlayerStopFishing += OnStopFishing;
		}

		protected override void OnDestroy()
		{
			Action_Fishing.OnPlayerStopFishing -= OnStopFishing;
			Action_Fishing.OnPlayerStartSelectBait -= OnStartSelectBait;
			Action_Fishing.OnPlayerStopCatching -= OnStopCatching;
			base.OnDestroy();
		}

		internal override void TryQuit()
		{
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
			UnityEngine.Debug.Log("Open Fishing Panel");
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		private void OnStopFishing(Action_Fishing fishing)
		{
			baitSelectPanel.NotifyStop();
			confirmPanel.NotifyStop();
			Close();
		}

		private void OnStartSelectBait(Action_Fishing fishing, ICollection<Item> availableBaits, Func<Item, bool> baitSelectionResultCallback)
		{
			SelectBaitTask(availableBaits, baitSelectionResultCallback).Forget();
		}

		private async UniTask SelectBaitTask(ICollection<Item> availableBaits, Func<Item, bool> baitSelectionResultCallback)
		{
			Open();
			await baitSelectPanel.DoBaitSelection(availableBaits, baitSelectionResultCallback);
			Close();
		}

		private void OnStopCatching(Action_Fishing fishing, Item catchedItem, Action<bool> confirmCallback)
		{
			ConfirmTask(catchedItem, confirmCallback).Forget();
		}

		private async UniTask ConfirmTask(Item catchedItem, Action<bool> confirmCallback)
		{
			Open();
			await confirmPanel.DoConfirmDialogue(catchedItem, confirmCallback);
			Close();
		}
	}
}
namespace Dialogues
{
	public class DialogueUI : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		private static DialogueUI instance;

		[SerializeField]
		private FadeGroup mainFadeGroup;

		[SerializeField]
		private FadeGroup textAreaFadeGroup;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private GameObject continueIndicator;

		[SerializeField]
		private float speed = 10f;

		[SerializeField]
		private RectTransform actorPositionIndicator;

		[SerializeField]
		private FadeGroup actorNameFadeGroup;

		[SerializeField]
		private TextMeshProUGUI actorNameText;

		[SerializeField]
		private GameObject actorPortraitContainer;

		[SerializeField]
		private UnityEngine.UI.Image actorPortraitDisplay;

		[SerializeField]
		private FadeGroup choiceListFadeGroup;

		[SerializeField]
		private Menu choiceMenu;

		[SerializeField]
		private DialogueUIChoice choiceTemplate;

		private PrefabPool<DialogueUIChoice> _choicePool;

		private DuckovDialogueActor talkingActor;

		private int confirmedChoice;

		private bool waitingForChoice;

		private bool confirmed;

		private PrefabPool<DialogueUIChoice> ChoicePool
		{
			get
			{
				if (_choicePool == null)
				{
					_choicePool = new PrefabPool<DialogueUIChoice>(choiceTemplate);
				}
				return _choicePool;
			}
		}

		public static bool Active
		{
			get
			{
				if (instance == null)
				{
					return false;
				}
				return instance.mainFadeGroup.IsShown;
			}
		}

		public static event Action OnDialogueStatusChanged;

		private void Awake()
		{
			instance = this;
			choiceTemplate.gameObject.SetActive(value: false);
			RegisterEvents();
		}

		private void OnDestroy()
		{
			UnregisterEvents();
		}

		private void Update()
		{
			RefreshActorPositionIndicator();
			if (Keyboard.current != null && Keyboard.current.spaceKey.wasPressedThisFrame)
			{
				Confirm();
			}
		}

		private void OnEnable()
		{
		}

		private void OnDisable()
		{
		}

		private void RegisterEvents()
		{
			DialogueTree.OnDialogueStarted += OnDialogueStarted;
			DialogueTree.OnDialoguePaused += OnDialoguePaused;
			DialogueTree.OnDialogueFinished += OnDialogueFinished;
			DialogueTree.OnSubtitlesRequest += OnSubtitlesRequest;
			DialogueTree.OnMultipleChoiceRequest += OnMultipleChoiceRequest;
		}

		private void UnregisterEvents()
		{
			DialogueTree.OnDialogueStarted -= OnDialogueStarted;
			DialogueTree.OnDialoguePaused -= OnDialoguePaused;
			DialogueTree.OnDialogueFinished -= OnDialogueFinished;
			DialogueTree.OnSubtitlesRequest -= OnSubtitlesRequest;
			DialogueTree.OnMultipleChoiceRequest -= OnMultipleChoiceRequest;
		}

		private void OnMultipleChoiceRequest(MultipleChoiceRequestInfo info)
		{
			DoMultipleChoice(info).Forget();
		}

		private void OnSubtitlesRequest(SubtitlesRequestInfo info)
		{
			DoSubtitle(info).Forget();
		}

		public static void HideTextFadeGroup()
		{
			instance.MHideTextFadeGroup();
		}

		private void MHideTextFadeGroup()
		{
			textAreaFadeGroup.Hide();
		}

		private void OnDialogueFinished(DialogueTree tree)
		{
			textAreaFadeGroup.Hide();
			InputManager.ActiveInput(base.gameObject);
			mainFadeGroup.Hide();
			DialogueUI.OnDialogueStatusChanged?.Invoke();
		}

		private void OnDialoguePaused(DialogueTree tree)
		{
			DialogueUI.OnDialogueStatusChanged?.Invoke();
		}

		private void OnDialogueStarted(DialogueTree tree)
		{
			InputManager.DisableInput(base.gameObject);
			mainFadeGroup.Show();
			DialogueUI.OnDialogueStatusChanged?.Invoke();
			actorNameFadeGroup.SkipHide();
		}

		private async UniTask DoSubtitle(SubtitlesRequestInfo info)
		{
			SetupActorInfo(info.actor);
			continueIndicator.SetActive(value: false);
			string text = info.statement.text;
			TMP_TextInfo textInfo = this.text.GetTextInfo(text);
			this.text.text = text;
			this.text.maxVisibleCharacters = 0;
			await textAreaFadeGroup.ShowAndReturnTask();
			int totalCharacterCount = textInfo.characterCount;
			float buffer = 0f;
			confirmed = false;
			for (int c = 1; c <= totalCharacterCount; c++)
			{
				while (buffer < 1f && !confirmed)
				{
					buffer += Time.unscaledDeltaTime * speed;
					await UniTask.NextFrame();
				}
				buffer -= 1f;
				if (c == 1)
				{
					AudioManager.Post("UI/dialogue_start");
				}
				else
				{
					AudioManager.Post("UI/dialogue_bump");
				}
				this.text.maxVisibleCharacters = c;
			}
			this.text.maxVisibleCharacters = totalCharacterCount;
			await WaitForConfirm();
			await textAreaFadeGroup.HideAndReturnTask();
			this.text.text = string.Empty;
			talkingActor = null;
			info.Continue();
		}

		private void SetupActorInfo(IDialogueActor actor)
		{
			if (!(actor is DuckovDialogueActor duckovDialogueActor))
			{
				actorNameFadeGroup.Hide();
				actorPortraitContainer.gameObject.SetActive(value: false);
				actorPositionIndicator.gameObject.SetActive(value: false);
				talkingActor = null;
				return;
			}
			talkingActor = duckovDialogueActor;
			Sprite portraitSprite = duckovDialogueActor.portraitSprite;
			string nameKey = duckovDialogueActor.NameKey;
			_ = duckovDialogueActor.transform;
			actorNameText.text = nameKey.ToPlainText();
			actorNameFadeGroup.Show();
			actorPortraitContainer.SetActive(portraitSprite);
			actorPortraitDisplay.sprite = portraitSprite;
			if (talkingActor.transform != null)
			{
				actorPositionIndicator.gameObject.SetActive(value: true);
			}
			RefreshActorPositionIndicator();
		}

		private void RefreshActorPositionIndicator()
		{
			if (talkingActor == null)
			{
				actorPositionIndicator.gameObject.SetActive(value: false);
			}
			else
			{
				actorPositionIndicator.MatchWorldPosition(talkingActor.transform.position + talkingActor.Offset);
			}
		}

		private async UniTask DoMultipleChoice(MultipleChoiceRequestInfo info)
		{
			await DisplayOptions(info.options);
			int choice = await WaitForChoice();
			await choiceListFadeGroup.HideAndReturnTask();
			info.SelectOption(choice);
		}

		private async UniTask DisplayOptions(Dictionary<IStatement, int> options)
		{
			ChoicePool.ReleaseAll();
			foreach (KeyValuePair<IStatement, int> option in options)
			{
				DialogueUIChoice dialogueUIChoice = ChoicePool.Get();
				dialogueUIChoice.Setup(this, option);
				dialogueUIChoice.transform.SetAsLastSibling();
			}
			choiceMenu.SelectDefault();
			await choiceListFadeGroup.ShowAndReturnTask();
			choiceMenu.Focused = true;
		}

		internal void NotifyChoiceConfirmed(DialogueUIChoice choice)
		{
			confirmedChoice = choice.Index;
		}

		private async UniTask<int> WaitForChoice()
		{
			confirmedChoice = -1;
			waitingForChoice = true;
			while (confirmedChoice < 0)
			{
				await UniTask.NextFrame();
			}
			waitingForChoice = false;
			return confirmedChoice;
		}

		public void Confirm()
		{
			confirmed = true;
		}

		private async UniTask WaitForConfirm()
		{
			continueIndicator.SetActive(value: true);
			confirmed = false;
			while (!confirmed)
			{
				await UniTask.NextFrame();
			}
			continueIndicator.SetActive(value: false);
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Confirm();
		}
	}
	public class DialogueUIChoice : MonoBehaviour, IPointerClickHandler, IEventSystemHandler, IPointerEnterHandler
	{
		[SerializeField]
		private MenuItem menuItem;

		[SerializeField]
		private GameObject selectionIndicator;

		[SerializeField]
		private UnityEngine.UI.Image confirmIndicator;

		[SerializeField]
		private Gradient confirmAnimationColor;

		[SerializeField]
		private float confirmAnimationDuration = 0.2f;

		[SerializeField]
		private TextMeshProUGUI text;

		private DialogueUI master;

		private int index;

		public int Index => index;

		private void Awake()
		{
			MenuItem obj = menuItem;
			obj.onSelected = (Action<MenuItem>)Delegate.Combine(obj.onSelected, new Action<MenuItem>(Refresh));
			MenuItem obj2 = menuItem;
			obj2.onDeselected = (Action<MenuItem>)Delegate.Combine(obj2.onDeselected, new Action<MenuItem>(Refresh));
			MenuItem obj3 = menuItem;
			obj3.onFocusStatusChanged = (Action<MenuItem, bool>)Delegate.Combine(obj3.onFocusStatusChanged, new Action<MenuItem, bool>(Refresh));
			MenuItem obj4 = menuItem;
			obj4.onConfirmed = (Action<MenuItem>)Delegate.Combine(obj4.onConfirmed, new Action<MenuItem>(OnConfirm));
		}

		private void OnConfirm(MenuItem item)
		{
			Confirm();
		}

		private void AnimateConfirm()
		{
			confirmIndicator.DOKill();
			confirmIndicator.DOGradientColor(confirmAnimationColor, confirmAnimationDuration).OnComplete(delegate
			{
				confirmIndicator.color = Color.clear;
			}).OnKill(delegate
			{
				confirmIndicator.color = Color.clear;
			});
		}

		private void Refresh(MenuItem item, bool focus)
		{
			selectionIndicator.SetActive(menuItem.IsSelected);
		}

		private void Refresh(MenuItem item)
		{
			selectionIndicator.SetActive(menuItem.IsSelected);
		}

		private void Confirm()
		{
			master.NotifyChoiceConfirmed(this);
			AnimateConfirm();
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Confirm();
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			menuItem.Select();
		}

		internal void Setup(DialogueUI master, KeyValuePair<IStatement, int> cur)
		{
			this.master = master;
			index = cur.Value;
			text.text = cur.Key.text;
			confirmIndicator.color = Color.clear;
			Refresh(menuItem);
		}
	}
	[Serializable]
	public class LocalizedStatement : IStatement
	{
		[SerializeField]
		private string _textKey = string.Empty;

		[SerializeField]
		private AudioClip _audio;

		[SerializeField]
		private string _meta = string.Empty;

		public string text => textKey.ToPlainText();

		public string textKey
		{
			get
			{
				return _textKey;
			}
			set
			{
				_textKey = value;
			}
		}

		public AudioClip audio
		{
			get
			{
				return _audio;
			}
			set
			{
				_audio = value;
			}
		}

		public string meta
		{
			get
			{
				return _meta;
			}
			set
			{
				_meta = value;
			}
		}

		public LocalizedStatement()
		{
		}

		public LocalizedStatement(string textKey)
		{
			_textKey = textKey;
		}

		public LocalizedStatement(string textKey, AudioClip audio)
		{
			_textKey = textKey;
			this.audio = audio;
		}

		public LocalizedStatement(string textKey, AudioClip audio, string meta)
		{
			_textKey = textKey;
			this.audio = audio;
			this.meta = meta;
		}
	}
	public class LocalizedStatementNode : DTNode
	{
		public BBParameter<string> key;

		public BBParameter<bool> useSequence;

		public BBParameter<int> sequenceIndex;

		public override bool requireActorSelection => true;

		private string Key
		{
			get
			{
				if (useSequence.value)
				{
					return $"{key.value}_{sequenceIndex.value}";
				}
				return key.value;
			}
		}

		private LocalizedStatement CreateStatement()
		{
			return new LocalizedStatement(Key);
		}

		protected override Status OnExecute(UnityEngine.Component agent, IBlackboard bb)
		{
			LocalizedStatement statement = CreateStatement();
			DialogueTree.RequestSubtitles(new SubtitlesRequestInfo(base.finalActor, statement, OnStatementFinish));
			return Status.Running;
		}

		private void OnStatementFinish()
		{
			base.status = Status.Success;
			base.DLGTree.Continue();
		}
	}
	public class LocalizedStatementSequence : DTNode
	{
		public BBParameter<string> keyPrefix;

		public BBParameter<int> beginIndex;

		public BBParameter<int> endIndex;

		public BBParameter<string> format = new BBParameter<string>("{keyPrefix}_{index}");

		private int index;

		public override bool requireActorSelection => true;

		protected override Status OnExecute(UnityEngine.Component agent, IBlackboard bb)
		{
			Begin();
			return Status.Running;
		}

		private void Begin()
		{
			index = beginIndex.value - 1;
			Next();
		}

		private void Next()
		{
			index++;
			if (index > endIndex.value)
			{
				base.status = Status.Success;
				base.DLGTree.Continue();
			}
			else
			{
				LocalizedStatement statement = new LocalizedStatement(format.value.Format(new
				{
					keyPrefix = keyPrefix.value,
					index = index
				}));
				DialogueTree.RequestSubtitles(new SubtitlesRequestInfo(base.finalActor, statement, OnStatementFinish));
			}
		}

		private void OnStatementFinish()
		{
			Next();
		}
	}
}
namespace Debugging
{
	public class InstantiateTiming : MonoBehaviour
	{
		public GameObject prefab;

		public void InstantiatePrefab()
		{
			UnityEngine.Debug.Log("Start Instantiate");
			UnityEngine.Object.Instantiate(prefab);
			UnityEngine.Debug.Log("Instantiated");
		}

		private void Awake()
		{
			UnityEngine.Debug.Log("Awake");
		}

		private void Start()
		{
			UnityEngine.Debug.Log("Start");
		}
	}
	public class InventorySaveLoad : MonoBehaviour
	{
		public Inventory inventory;

		public string key = "helloInventory";

		private bool loading;

		public void Save()
		{
			inventory.Save(key);
		}

		public async UniTask Load()
		{
			loading = true;
			await ItemSavesUtilities.LoadInventory(key, inventory);
			loading = false;
			OnLoadFinished();
		}

		private void OnLoadFinished()
		{
		}

		public void BeginLoad()
		{
			Load().Forget();
		}
	}
}
namespace Duckvo.Beacons
{
	public class BeaconManager : MonoBehaviour
	{
		[Serializable]
		public struct BeaconStatus
		{
			public string beaconID;

			public int beaconIndex;
		}

		[Serializable]
		public struct Data
		{
			public List<BeaconStatus> entries;
		}

		private Data data;

		public static Action<string, int> OnBeaconUnlocked;

		private const string SaveKey = "BeaconManager";

		public static BeaconManager Instance { get; private set; }

		private void Awake()
		{
			Instance = this;
			Load();
			SavesSystem.OnCollectSaveData += Save;
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
		}

		public void Load()
		{
			if (SavesSystem.KeyExisits("BeaconManager"))
			{
				data = SavesSystem.Load<Data>("BeaconManager");
			}
			if (data.entries == null)
			{
				data.entries = new List<BeaconStatus>();
			}
		}

		public void Save()
		{
			SavesSystem.Save("BeaconManager", data);
		}

		public static void UnlockBeacon(string id, int index)
		{
			if (!(Instance == null) && !GetBeaconUnlocked(id, index))
			{
				Instance.data.entries.Add(new BeaconStatus
				{
					beaconID = id,
					beaconIndex = index
				});
				OnBeaconUnlocked?.Invoke(id, index);
			}
		}

		public static bool GetBeaconUnlocked(string id, int index)
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.data.entries.Any((BeaconStatus e) => e.beaconID == id && e.beaconIndex == index);
		}
	}
}
namespace UnityTemplateProjects
{
	public class SimpleCameraController : MonoBehaviour
	{
		private class CameraState
		{
			public float yaw;

			public float pitch;

			public float roll;

			public float x;

			public float y;

			public float z;

			public void SetFromTransform(Transform t)
			{
				pitch = t.eulerAngles.x;
				yaw = t.eulerAngles.y;
				roll = t.eulerAngles.z;
				x = t.position.x;
				y = t.position.y;
				z = t.position.z;
			}

			public void Translate(Vector3 translation)
			{
				Vector3 vector = Quaternion.Euler(pitch, yaw, roll) * translation;
				x += vector.x;
				y += vector.y;
				z += vector.z;
			}

			public void LerpTowards(CameraState target, float positionLerpPct, float rotationLerpPct)
			{
				yaw = Mathf.Lerp(yaw, target.yaw, rotationLerpPct);
				pitch = Mathf.Lerp(pitch, target.pitch, rotationLerpPct);
				roll = Mathf.Lerp(roll, target.roll, rotationLerpPct);
				x = Mathf.Lerp(x, target.x, positionLerpPct);
				y = Mathf.Lerp(y, target.y, positionLerpPct);
				z = Mathf.Lerp(z, target.z, positionLerpPct);
			}

			public void UpdateTransform(Transform t)
			{
				t.eulerAngles = new Vector3(pitch, yaw, roll);
				t.position = new Vector3(x, y, z);
			}
		}

		private CameraState m_TargetCameraState = new CameraState();

		private CameraState m_InterpolatingCameraState = new CameraState();

		[UnityEngine.Header("Movement Settings")]
		[Tooltip("Exponential boost factor on translation, controllable by mouse wheel.")]
		public float boost = 3.5f;

		[Tooltip("Time it takes to interpolate camera position 99% of the way to the target.")]
		[Range(0.001f, 1f)]
		public float positionLerpTime = 0.2f;

		[UnityEngine.Header("Rotation Settings")]
		[Tooltip("X = Change in mouse position.\nY = Multiplicative factor for camera rotation.")]
		public AnimationCurve mouseSensitivityCurve = new AnimationCurve(new Keyframe(0f, 0.5f, 0f, 5f), new Keyframe(1f, 2.5f, 0f, 0f));

		[Tooltip("Time it takes to interpolate camera rotation 99% of the way to the target.")]
		[Range(0.001f, 1f)]
		public float rotationLerpTime = 0.01f;

		[Tooltip("Whether or not to invert our Y axis for mouse input to rotation.")]
		public bool invertY;

		private InputAction movementAction;

		private InputAction verticalMovementAction;

		private InputAction lookAction;

		private InputAction boostFactorAction;

		private bool mouseRightButtonPressed;

		private void Start()
		{
			InputActionMap map = new InputActionMap("Simple Camera Controller");
			lookAction = map.AddAction("look", InputActionType.Value, "<Mouse>/delta");
			movementAction = map.AddAction("move", InputActionType.Value, "<Gamepad>/leftStick");
			verticalMovementAction = map.AddAction("Vertical Movement");
			boostFactorAction = map.AddAction("Boost Factor", InputActionType.Value, "<Mouse>/scroll");
			lookAction.AddBinding("<Gamepad>/rightStick").WithProcessor("scaleVector2(x=15, y=15)");
			movementAction.AddCompositeBinding("Dpad").With("Up", "<Keyboard>/w").With("Up", "<Keyboard>/upArrow")
				.With("Down", "<Keyboard>/s")
				.With("Down", "<Keyboard>/downArrow")
				.With("Left", "<Keyboard>/a")
				.With("Left", "<Keyboard>/leftArrow")
				.With("Right", "<Keyboard>/d")
				.With("Right", "<Keyboard>/rightArrow");
			verticalMovementAction.AddCompositeBinding("Dpad").With("Up", "<Keyboard>/pageUp").With("Down", "<Keyboard>/pageDown")
				.With("Up", "<Keyboard>/e")
				.With("Down", "<Keyboard>/q")
				.With("Up", "<Gamepad>/rightshoulder")
				.With("Down", "<Gamepad>/leftshoulder");
			boostFactorAction.AddBinding("<Gamepad>/Dpad").WithProcessor("scaleVector2(x=1, y=4)");
			movementAction.Enable();
			lookAction.Enable();
			verticalMovementAction.Enable();
			boostFactorAction.Enable();
		}

		private void OnEnable()
		{
			m_TargetCameraState.SetFromTransform(base.transform);
			m_InterpolatingCameraState.SetFromTransform(base.transform);
		}

		private Vector3 GetInputTranslationDirection()
		{
			Vector3 zero = Vector3.zero;
			Vector2 vector = movementAction.ReadValue<Vector2>();
			zero.x = vector.x;
			zero.z = vector.y;
			zero.y = verticalMovementAction.ReadValue<Vector2>().y;
			return zero;
		}

		private void Update()
		{
			if (IsEscapePressed())
			{
				Application.Quit();
			}
			if (IsRightMouseButtonDown())
			{
				UnityEngine.Cursor.lockState = CursorLockMode.Locked;
			}
			if (IsRightMouseButtonUp())
			{
				UnityEngine.Cursor.visible = true;
				UnityEngine.Cursor.lockState = CursorLockMode.None;
			}
			if (IsCameraRotationAllowed())
			{
				Vector2 vector = GetInputLookRotation() * Time.deltaTime * 5f;
				if (invertY)
				{
					vector.y = 0f - vector.y;
				}
				float num = mouseSensitivityCurve.Evaluate(vector.magnitude);
				m_TargetCameraState.yaw += vector.x * num;
				m_TargetCameraState.pitch += vector.y * num;
			}
			Vector3 translation = GetInputTranslationDirection() * Time.deltaTime;
			if (IsBoostPressed())
			{
				translation *= 10f;
			}
			boost += GetBoostFactor();
			translation *= Mathf.Pow(2f, boost);
			m_TargetCameraState.Translate(translation);
			float positionLerpPct = 1f - Mathf.Exp(Mathf.Log(0.00999999f) / positionLerpTime * Time.deltaTime);
			float rotationLerpPct = 1f - Mathf.Exp(Mathf.Log(0.00999999f) / rotationLerpTime * Time.deltaTime);
			m_InterpolatingCameraState.LerpTowards(m_TargetCameraState, positionLerpPct, rotationLerpPct);
			m_InterpolatingCameraState.UpdateTransform(base.transform);
		}

		private float GetBoostFactor()
		{
			return boostFactorAction.ReadValue<Vector2>().y * 0.01f;
		}

		private Vector2 GetInputLookRotation()
		{
			return lookAction.ReadValue<Vector2>();
		}

		private bool IsBoostPressed()
		{
			return (Keyboard.current != null && Keyboard.current.leftShiftKey.isPressed) | (Gamepad.current != null && Gamepad.current.xButton.isPressed);
		}

		private bool IsEscapePressed()
		{
			if (Keyboard.current == null)
			{
				return false;
			}
			return Keyboard.current.escapeKey.isPressed;
		}

		private bool IsCameraRotationAllowed()
		{
			return (Mouse.current != null && Mouse.current.rightButton.isPressed) | (Gamepad.current != null && Gamepad.current.rightStick.ReadValue().magnitude > 0f);
		}

		private bool IsRightMouseButtonDown()
		{
			if (Mouse.current == null)
			{
				return false;
			}
			return Mouse.current.rightButton.isPressed;
		}

		private bool IsRightMouseButtonUp()
		{
			if (Mouse.current == null)
			{
				return false;
			}
			return !Mouse.current.rightButton.isPressed;
		}
	}
}
namespace Saves
{
	public interface ISaveDataProvider
	{
		object GenerateSaveData();

		void SetupSaveData(object data);
	}
	public static class ItemSavesUtilities
	{
		private const string InventoryPrefix = "Inventory/";

		private const string ItemPrefix = "Item/";

		public static void SaveAsLastDeadCharacter(Item item)
		{
			uint num = SavesSystem.Load<uint>("DeadCharacterToken");
			uint num2 = num;
			do
			{
				num2++;
			}
			while (num2 == num);
			SavesSystem.Save("DeadCharacterToken", num2);
			item.Save("LastDeadCharacter");
		}

		public static async UniTask<Item> LoadLastDeadCharacterItem()
		{
			return await LoadItem("LastDeadCharacter");
		}

		public static void Save(this Item item, string key)
		{
			ItemTreeData value = ItemTreeData.FromItem(item);
			SavesSystem.Save("Item/", key, value);
		}

		public static void Save(this Inventory inventory, string key)
		{
			InventoryData value = InventoryData.FromInventory(inventory);
			SavesSystem.Save("Inventory/", key, value);
		}

		public static async UniTask<Item> LoadItem(string key)
		{
			return await ItemTreeData.InstantiateAsync(SavesSystem.Load<ItemTreeData>("Item/", key));
		}

		public static async UniTask LoadInventory(string key, Inventory inventoryInstance)
		{
			if (!(inventoryInstance == null))
			{
				inventoryInstance.Loading = true;
				InventoryData inventoryData = SavesSystem.Load<InventoryData>("Inventory/", key);
				if (inventoryData == null)
				{
					UnityEngine.Debug.LogWarning("Key Doesn't exist " + key + ", aborting operation");
					inventoryInstance.Loading = false;
				}
				else
				{
					inventoryInstance.DestroyAllContent();
					await InventoryData.LoadIntoInventory(inventoryData, inventoryInstance);
					inventoryInstance.Loading = false;
				}
			}
		}
	}
	public class SavesSystem
	{
		public struct BackupInfo
		{
			public int slot;

			public int index;

			public string path;

			public bool exists;

			public long time_raw;

			public bool TimeValid => time_raw > 0;

			public DateTime Time => DateTime.FromBinary(time_raw);
		}

		private static int? _currentSlot = null;

		private static bool saving;

		private static ES3Settings settings = ES3Settings.defaultSettings;

		private static bool cached;

		private const int BackupListCount = 10;

		private static DateTime _lastSavedTime = DateTime.MinValue;

		private static DateTime _lastIndexedBackupTime = DateTime.MinValue;

		private static bool globalCached;

		private static ES3Settings GlobalFileSetting = new ES3Settings
		{
			location = ES3.Location.File
		};

		public static int CurrentSlot
		{
			get
			{
				if (!_currentSlot.HasValue)
				{
					_currentSlot = PlayerPrefs.GetInt("CurrentSlot", 1);
					if (_currentSlot < 1)
					{
						_currentSlot = 1;
					}
				}
				return _currentSlot.Value;
			}
			private set
			{
				_currentSlot = value;
				PlayerPrefs.SetInt("CurrentSlot", value);
				CacheFile();
			}
		}

		public static string CurrentFilePath => GetFilePath(CurrentSlot);

		public static bool IsSaving => saving;

		public static string SavesFolder => "Saves";

		public static bool RestoreFailureMarker { get; private set; }

		private static DateTime LastSavedTime
		{
			get
			{
				if (_lastSavedTime > DateTime.UtcNow)
				{
					_lastSavedTime = DateTime.UtcNow;
					GameManager.TimeTravelDetected();
				}
				return _lastSavedTime;
			}
			set
			{
				_lastSavedTime = value;
			}
		}

		private static TimeSpan TimeSinceLastSave => DateTime.UtcNow - LastSavedTime;

		private static DateTime LastIndexedBackupTime
		{
			get
			{
				if (_lastIndexedBackupTime > DateTime.UtcNow)
				{
					_lastIndexedBackupTime = DateTime.UtcNow;
					GameManager.TimeTravelDetected();
				}
				return _lastIndexedBackupTime;
			}
			set
			{
				_lastIndexedBackupTime = value;
			}
		}

		private static TimeSpan TimeSinceLastIndexedBackup => DateTime.UtcNow - LastIndexedBackupTime;

		public static string GlobalSaveDataFilePath => System.IO.Path.Combine(SavesFolder, GlobalSaveDataFileName);

		public static string GlobalSaveDataFileName => "Global.json";

		public static event Action OnSetFile;

		public static event Action OnSaveDeleted;

		public static event Action OnCollectSaveData;

		public static event Action OnRestoreFailureDetected;

		public static string GetFullPathToSavesFolder()
		{
			return System.IO.Path.Combine(Application.persistentDataPath, SavesFolder);
		}

		public static string GetFilePath(int slot)
		{
			return System.IO.Path.Combine(SavesFolder, GetSaveFileName(slot));
		}

		public static string GetSaveFileName(int slot)
		{
			return $"Save_{slot}.sav";
		}

		public static bool IsOldSave(int index)
		{
			return !KeyExisits("CreatedWithVersion", index);
		}

		public static void SetFile(int index)
		{
			cached = false;
			CurrentSlot = index;
			SavesSystem.OnSetFile?.Invoke();
		}

		public static BackupInfo[] GetBackupList()
		{
			return GetBackupList(CurrentSlot);
		}

		public static BackupInfo[] GetBackupList(int slot)
		{
			return GetBackupList(GetFilePath(slot), slot);
		}

		public static BackupInfo[] GetBackupList(string mainPath, int slot = -1)
		{
			BackupInfo[] array = new BackupInfo[10];
			for (int i = 0; i < 10; i++)
			{
				try
				{
					string backupPathByIndex = GetBackupPathByIndex(mainPath, i);
					ES3Settings eS3Settings = new ES3Settings(backupPathByIndex);
					eS3Settings.location = ES3.Location.File;
					bool flag = ES3.FileExists(backupPathByIndex, eS3Settings);
					long num = 0L;
					if (flag && ES3.KeyExists("SaveTime", backupPathByIndex, eS3Settings))
					{
						num = ES3.Load<long>("SaveTime", backupPathByIndex, eS3Settings);
					}
					DateTime.FromBinary(num);
					BackupInfo backupInfo = new BackupInfo
					{
						slot = slot,
						index = i,
						path = backupPathByIndex,
						exists = flag,
						time_raw = num
					};
					array[i] = backupInfo;
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					array[i] = default(BackupInfo);
				}
			}
			return array;
		}

		private static int GetEmptyOrOldestBackupIndex()
		{
			BackupInfo[] backupList = GetBackupList();
			int result = -1;
			DateTime dateTime = DateTime.MaxValue;
			BackupInfo[] array = backupList;
			for (int i = 0; i < array.Length; i++)
			{
				BackupInfo backupInfo = array[i];
				if (!backupInfo.exists)
				{
					return backupInfo.index;
				}
				if (backupInfo.Time < dateTime)
				{
					result = backupInfo.index;
					dateTime = backupInfo.Time;
				}
			}
			return result;
		}

		private static int GetOldestBackupIndex()
		{
			BackupInfo[] backupList = GetBackupList();
			int result = -1;
			DateTime dateTime = DateTime.MaxValue;
			BackupInfo[] array = backupList;
			for (int i = 0; i < array.Length; i++)
			{
				BackupInfo backupInfo = array[i];
				if (backupInfo.exists && backupInfo.Time < dateTime)
				{
					result = backupInfo.index;
					dateTime = backupInfo.Time;
				}
			}
			return result;
		}

		private static int GetNewestBackupIndex()
		{
			BackupInfo[] backupList = GetBackupList();
			int result = -1;
			DateTime dateTime = DateTime.MinValue;
			BackupInfo[] array = backupList;
			for (int i = 0; i < array.Length; i++)
			{
				BackupInfo backupInfo = array[i];
				if (backupInfo.exists && backupInfo.Time > dateTime)
				{
					result = backupInfo.index;
					dateTime = backupInfo.Time;
				}
			}
			return result;
		}

		private static string GetBackupPathByIndex(int index)
		{
			return GetBackupPathByIndex(CurrentSlot, index);
		}

		private static string GetBackupPathByIndex(int slot, int index)
		{
			return GetBackupPathByIndex(GetFilePath(slot), index);
		}

		private static string GetBackupPathByIndex(string path, int index)
		{
			return $"{path}.bac.{index + 1:00}";
		}

		private static void CreateIndexedBackup(int index = -1)
		{
			LastIndexedBackupTime = DateTime.UtcNow;
			try
			{
				if (index < 0)
				{
					index = GetEmptyOrOldestBackupIndex();
				}
				string backupPathByIndex = GetBackupPathByIndex(index);
				ES3.DeleteFile(backupPathByIndex, settings);
				ES3.CopyFile(CurrentFilePath, backupPathByIndex);
				ES3.StoreCachedFile(backupPathByIndex);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				UnityEngine.Debug.Log("[Saves] Failed creating indexed backup");
			}
		}

		private static void CreateBackup()
		{
			try
			{
				CreateBackup(CurrentFilePath);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				UnityEngine.Debug.Log("[Saves] Failed creating backup");
			}
		}

		private static void CreateBackup(string path)
		{
			try
			{
				string filePath = path + ".bac";
				ES3.DeleteFile(filePath, settings);
				ES3.CreateBackup(path);
				ES3.StoreCachedFile(filePath);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				UnityEngine.Debug.Log("[Saves] Failed creating backup for path " + path);
			}
		}

		public static void UpgradeSaveFileAssemblyInfo(string path)
		{
			if (!File.Exists(path))
			{
				UnityEngine.Debug.Log("没有找到存档文件：" + path);
				return;
			}
			string text;
			using (StreamReader streamReader = File.OpenText(path))
			{
				text = streamReader.ReadToEnd();
				if (text.Contains("TeamSoda.Duckov.Core"))
				{
					streamReader.Close();
					return;
				}
				text = text.Replace("Assembly-CSharp", "TeamSoda.Duckov.Core");
				streamReader.Close();
			}
			File.Delete(path);
			using (FileStream fileStream = File.OpenWrite(path))
			{
				StreamWriter streamWriter = new StreamWriter(fileStream);
				streamWriter.Write(text);
				streamWriter.Close();
				fileStream.Close();
			}
			UnityEngine.Debug.Log("存档格式已更新：" + path);
		}

		public static void RestoreIndexedBackup(int slot, int index)
		{
			string backupPathByIndex = GetBackupPathByIndex(slot, index);
			UpgradeSaveFileAssemblyInfo(System.IO.Path.Combine(Application.persistentDataPath, backupPathByIndex));
			string filePath = GetFilePath(slot);
			string text = filePath + ".bac";
			try
			{
				ES3.CacheFile(backupPathByIndex);
				ES3.DeleteFile(text, settings);
				ES3.CopyFile(backupPathByIndex, text);
				ES3.DeleteFile(filePath, settings);
				ES3.RestoreBackup(filePath, settings);
				ES3.StoreCachedFile(filePath);
				ES3.CacheFile(filePath);
				SavesSystem.OnSetFile?.Invoke();
			}
			catch
			{
				RestoreFailureMarker = true;
				UnityEngine.Debug.LogError("文件损坏，且无法修复。");
				ES3.DeleteFile(filePath);
				File.Delete(filePath);
				ES3.Save("Created", value: true, filePath);
				ES3.StoreCachedFile(filePath);
				ES3.CacheFile(filePath);
				SavesSystem.OnRestoreFailureDetected?.Invoke();
			}
		}

		private static bool RestoreBackup(string path)
		{
			bool flag = false;
			try
			{
				string text = path + ".bac";
				UpgradeSaveFileAssemblyInfo(System.IO.Path.Combine(Application.persistentDataPath, text));
				ES3.CacheFile(text);
				ES3.DeleteFile(path, settings);
				ES3.RestoreBackup(path, settings);
				ES3.StoreCachedFile(path);
				ES3.CacheFile(path);
				ES3.CacheFile(path);
				flag = true;
			}
			catch
			{
				UnityEngine.Debug.Log("默认备份损坏。");
			}
			if (!flag)
			{
				RestoreFailureMarker = true;
				UnityEngine.Debug.LogError("恢复默认备份失败");
				ES3.DeleteFile(path);
				ES3.Save("Created", value: true, path);
				ES3.StoreCachedFile(path);
				ES3.CacheFile(path);
				SavesSystem.OnRestoreFailureDetected?.Invoke();
			}
			return flag;
		}

		public DateTime GetSaveTimeUTC(int slot = -1)
		{
			if (slot < 0)
			{
				slot = CurrentSlot;
			}
			if (!KeyExisits("SaveTime", slot))
			{
				return default(DateTime);
			}
			return DateTime.FromBinary(Load<long>("SaveTime", slot));
		}

		public DateTime GetSaveTimeLocal(int slot = -1)
		{
			if (slot < 0)
			{
				slot = CurrentSlot;
			}
			DateTime saveTimeUTC = GetSaveTimeUTC(slot);
			if (saveTimeUTC == default(DateTime))
			{
				return default(DateTime);
			}
			return saveTimeUTC.ToLocalTime();
		}

		public static void SaveFile(bool writeSaveTime = true)
		{
			TimeSpan timeSinceLastIndexedBackup = TimeSinceLastIndexedBackup;
			LastSavedTime = DateTime.UtcNow;
			if (writeSaveTime)
			{
				Save("SaveTime", DateTime.UtcNow.ToBinary());
			}
			saving = true;
			CreateBackup();
			if (timeSinceLastIndexedBackup > TimeSpan.FromMinutes(5.0))
			{
				CreateIndexedBackup();
			}
			SetAsOldGame();
			ES3.StoreCachedFile(CurrentFilePath);
			saving = false;
		}

		private static void CacheFile()
		{
			CacheFile(CurrentSlot);
			cached = true;
		}

		private static void CacheFile(int slot)
		{
			if (slot == CurrentSlot && cached)
			{
				return;
			}
			string filePath = GetFilePath(slot);
			if (!CacheFile(filePath))
			{
				UnityEngine.Debug.Log("尝试恢复 indexed backups");
				List<BackupInfo> list = (from e in GetBackupList(filePath, slot)
					where e.exists
					select e).ToList();
				list.Sort((BackupInfo a, BackupInfo b) => (!(a.Time > b.Time)) ? 1 : (-1));
				bool flag = false;
				if (list.Count > 0)
				{
					for (int num = 0; num < list.Count; num++)
					{
						BackupInfo backupInfo = list[num];
						try
						{
							UnityEngine.Debug.Log($"Restoreing {slot}.bac.{backupInfo.index} \t" + backupInfo.Time.ToString("MM/dd HH:mm:ss"));
							RestoreIndexedBackup(slot, backupInfo.index);
							flag = true;
						}
						catch
						{
							UnityEngine.Debug.LogError($"slot:{slot} backup_index:{backupInfo.index} 恢复失败。");
							continue;
						}
						break;
					}
				}
			}
			if (!ES3.FileExists(filePath))
			{
				ES3.Save("Created", value: true, filePath);
				ES3.StoreCachedFile(filePath);
				ES3.CacheFile(filePath);
			}
		}

		private static bool CacheFile(string path)
		{
			try
			{
				ES3.CacheFile(path);
				return true;
			}
			catch
			{
				return RestoreBackup(path);
			}
		}

		public static void Save<T>(string prefix, string key, T value)
		{
			Save(prefix + key, value);
		}

		public static void Save<T>(string realKey, T value)
		{
			if (!cached)
			{
				CacheFile();
			}
			if (string.IsNullOrWhiteSpace(CurrentFilePath))
			{
				UnityEngine.Debug.Log("Save failed " + realKey);
			}
			else
			{
				ES3.Save(realKey, value, CurrentFilePath);
			}
		}

		public static T Load<T>(string prefix, string key)
		{
			return Load<T>(prefix + key);
		}

		public static T Load<T>(string realKey)
		{
			if (!cached)
			{
				CacheFile();
			}
			string.IsNullOrWhiteSpace(realKey);
			if (ES3.KeyExists(realKey, CurrentFilePath))
			{
				return ES3.Load<T>(realKey, CurrentFilePath);
			}
			return default(T);
		}

		public static bool KeyExisits(string prefix, string key)
		{
			return ES3.KeyExists(prefix + key);
		}

		public static bool KeyExisits(string realKey)
		{
			if (!cached)
			{
				CacheFile();
			}
			return ES3.KeyExists(realKey, CurrentFilePath);
		}

		public static bool KeyExisits(string realKey, int slotIndex)
		{
			if (slotIndex == CurrentSlot)
			{
				return KeyExisits(realKey);
			}
			string filePath = GetFilePath(slotIndex);
			CacheFile(slotIndex);
			return ES3.KeyExists(realKey, filePath);
		}

		public static T Load<T>(string realKey, int slotIndex)
		{
			if (slotIndex == CurrentSlot)
			{
				return Load<T>(realKey);
			}
			string filePath = GetFilePath(slotIndex);
			CacheFile(slotIndex);
			if (ES3.KeyExists(realKey, filePath))
			{
				return ES3.Load<T>(realKey, filePath);
			}
			return default(T);
		}

		public static void SaveGlobal<T>(string key, T value)
		{
			if (!globalCached)
			{
				CacheFile(GlobalSaveDataFilePath);
				globalCached = true;
			}
			ES3.Save(key, value, GlobalSaveDataFilePath);
			CreateBackup(GlobalSaveDataFilePath);
			ES3.StoreCachedFile(GlobalSaveDataFilePath);
		}

		public static T LoadGlobal<T>(string key, T defaultValue = default(T))
		{
			if (!globalCached)
			{
				CacheFile(GlobalSaveDataFilePath);
				globalCached = true;
			}
			if (ES3.KeyExists(key, GlobalSaveDataFilePath))
			{
				return ES3.Load<T>(key, GlobalSaveDataFilePath);
			}
			return defaultValue;
		}

		public static void CollectSaveData()
		{
			SavesSystem.OnCollectSaveData?.Invoke();
		}

		public static bool IsOldGame()
		{
			return Load<bool>("IsOldGame");
		}

		public static bool IsOldGame(int index)
		{
			return Load<bool>("IsOldGame", index);
		}

		private static void SetAsOldGame()
		{
			Save("IsOldGame", value: true);
		}

		public static void DeleteCurrentSave()
		{
			ES3.CacheFile(CurrentFilePath);
			ES3.DeleteFile(CurrentFilePath);
			ES3.Save("Created", value: false, CurrentFilePath);
			ES3.StoreCachedFile(CurrentFilePath);
			UnityEngine.Debug.Log($"已删除存档{CurrentSlot}");
			SavesSystem.OnSaveDeleted?.Invoke();
		}
	}
}
namespace Soda
{
	public class DebugView : MonoBehaviour
	{
		private DebugView instance;

		private Vector2 screenRes;

		private ResModes resMode;

		private TextureModes texMode;

		public TextMeshProUGUI resText;

		public TextMeshProUGUI texText;

		public TextMeshProUGUI fpsText1;

		public TextMeshProUGUI fpsText2;

		public TextMeshProUGUI inputDeviceText;

		public TextMeshProUGUI bloomText;

		public TextMeshProUGUI edgeLightText;

		public TextMeshProUGUI aoText;

		public TextMeshProUGUI dofText;

		public TextMeshProUGUI invincibleText;

		public TextMeshProUGUI reporterText;

		public UniversalRendererData rendererData;

		private float[] deltaTimes;

		private int frameIndex;

		public int frameSampleCount = 30;

		public GameObject openButton;

		public GameObject panel;

		public VolumeProfile volumeProfile;

		private bool bloomActive;

		private bool edgeLightActive;

		private bool aoActive;

		private int inputDevice;

		private bool dofActive;

		private bool invincible;

		private bool reporterActive;

		private Light light;

		[ItemTypeID]
		public int createItemID;

		public DebugView Instance => instance;

		public bool EdgeLightActive => edgeLightActive;

		public static event Action<DebugView> OnDebugViewConfigChanged;

		private void Awake()
		{
		}

		private void OnDestroy()
		{
			LevelManager.OnLevelInitialized -= OnlevelInited;
			SceneManager.activeSceneChanged -= OnSceneLoaded;
		}

		private void InitFromData()
		{
			if (PlayerPrefs.HasKey("ResMode"))
			{
				resMode = (ResModes)PlayerPrefs.GetInt("ResMode");
			}
			else
			{
				resMode = ResModes.R720p;
			}
			if (PlayerPrefs.HasKey("TexMode"))
			{
				texMode = (TextureModes)PlayerPrefs.GetInt("TexMode");
			}
			else
			{
				texMode = TextureModes.High;
			}
			if (PlayerPrefs.HasKey("InputDevice"))
			{
				inputDevice = PlayerPrefs.GetInt("InputDevice");
			}
			else
			{
				inputDevice = 1;
			}
			if (PlayerPrefs.HasKey("BloomActive"))
			{
				bloomActive = PlayerPrefs.GetInt("BloomActive") != 0;
			}
			else
			{
				bloomActive = true;
			}
			if (PlayerPrefs.HasKey("EdgeLightActive"))
			{
				edgeLightActive = PlayerPrefs.GetInt("EdgeLightActive") != 0;
			}
			else
			{
				edgeLightActive = true;
			}
			if (PlayerPrefs.HasKey("AOActive"))
			{
				aoActive = PlayerPrefs.GetInt("AOActive") != 0;
			}
			else
			{
				aoActive = false;
			}
			if (PlayerPrefs.HasKey("DofActive"))
			{
				dofActive = PlayerPrefs.GetInt("DofActive") != 0;
			}
			else
			{
				dofActive = false;
			}
			if (PlayerPrefs.HasKey("ReporterActive"))
			{
				reporterActive = PlayerPrefs.GetInt("ReporterActive") != 0;
			}
			else
			{
				reporterActive = false;
			}
		}

		private void Update()
		{
			deltaTimes[frameIndex] = Time.deltaTime;
			frameIndex++;
			if (frameIndex >= frameSampleCount)
			{
				frameIndex = 0;
				float num = 0f;
				for (int i = 0; i < frameSampleCount; i++)
				{
					num += deltaTimes[i];
				}
				int num2 = Mathf.RoundToInt((float)frameSampleCount / Mathf.Max(0.0001f, num));
				fpsText1.text = num2.ToString();
				fpsText2.text = num2.ToString();
			}
		}

		public void SetInputDevice(int type)
		{
			type = 1;
			if (type == 0)
			{
				InputManager.SetInputDevice(InputManager.InputDevices.touch);
				inputDeviceText.text = "触摸";
				PlayerPrefs.SetInt("InputDevice", 0);
			}
			else
			{
				InputManager.SetInputDevice(InputManager.InputDevices.mouseKeyboard);
				inputDeviceText.text = "键鼠";
				PlayerPrefs.SetInt("InputDevice", 1);
			}
		}

		public void SetRes(int resModeIndex)
		{
			SetRes((ResModes)resModeIndex);
		}

		public void SetRes(ResModes mode)
		{
			resMode = mode;
			screenRes.x = Display.main.systemWidth;
			screenRes.y = Display.main.systemHeight;
			PlayerPrefs.SetInt("ResMode", (int)mode);
			int num = 1;
			int num2 = 1;
			switch (resMode)
			{
			case ResModes.Source:
				num = Mathf.RoundToInt(screenRes.x);
				num2 = Mathf.RoundToInt(screenRes.y);
				break;
			case ResModes.HalfRes:
				num = Mathf.RoundToInt(screenRes.x / 2f);
				num2 = Mathf.RoundToInt(screenRes.y / 2f);
				break;
			case ResModes.R720p:
				num = Mathf.RoundToInt(screenRes.x / screenRes.y * 720f);
				num2 = 720;
				break;
			case ResModes.R480p:
				num = Mathf.RoundToInt(screenRes.x / screenRes.y * 480f);
				num2 = 480;
				break;
			}
			resText.text = $"{num}x{num2}";
			Screen.SetResolution(num, num2, FullScreenMode.FullScreenWindow);
			DebugView.OnDebugViewConfigChanged?.Invoke(this);
		}

		public void SetTexture(int texModeIndex)
		{
			SetTexture((TextureModes)texModeIndex);
		}

		public void SetTexture(TextureModes mode)
		{
			texMode = mode;
			QualitySettings.globalTextureMipmapLimit = (int)texMode;
			switch (texMode)
			{
			case TextureModes.High:
				texText.text = "高";
				break;
			case TextureModes.Middle:
				texText.text = "中";
				break;
			case TextureModes.Low:
				texText.text = "低";
				break;
			case TextureModes.VeryLow:
				texText.text = "极低";
				break;
			}
			PlayerPrefs.SetInt("TexMode", (int)texMode);
			DebugView.OnDebugViewConfigChanged?.Invoke(this);
		}

		private void OnlevelInited()
		{
			SetInvincible(invincible);
		}

		private void OnSceneLoaded(Scene s1, Scene s2)
		{
			SetShadow().Forget();
		}

		private async UniTaskVoid SetShadow()
		{
			await UniTask.WaitForEndOfFrame(this);
			await UniTask.WaitForEndOfFrame(this);
			await UniTask.WaitForSeconds(0.2f, ignoreTimeScale: true);
			light = RenderSettings.sun;
			if ((bool)light)
			{
				light.shadows = (edgeLightActive ? LightShadows.Soft : LightShadows.None);
			}
		}

		public void ToggleBloom()
		{
			bloomActive = !bloomActive;
			SetBloom(bloomActive);
		}

		private void SetBloom(bool active)
		{
			Bloom component;
			bool num = volumeProfile.TryGet<Bloom>(out component);
			bloomText.text = (active ? "开" : "关");
			if (num)
			{
				component.active = active;
			}
			bloomActive = active;
			PlayerPrefs.SetInt("BloomActive", bloomActive ? 1 : 0);
			DebugView.OnDebugViewConfigChanged?.Invoke(this);
		}

		public void ToggleEdgeLight()
		{
			edgeLightActive = !edgeLightActive;
			SetEdgeLight(edgeLightActive);
		}

		private void SetEdgeLight(bool active)
		{
			edgeLightText.text = (active ? "开" : "关");
			edgeLightActive = active;
			PlayerPrefs.SetInt("EdgeLightActive", edgeLightActive ? 1 : 0);
			UniversalRenderPipelineAsset universalRenderPipelineAsset = GraphicsSettings.currentRenderPipeline as UniversalRenderPipelineAsset;
			if (universalRenderPipelineAsset != null)
			{
				universalRenderPipelineAsset.supportsCameraDepthTexture = (active ? true : false);
			}
			SetShadow();
			DebugView.OnDebugViewConfigChanged?.Invoke(this);
		}

		public void ToggleAO()
		{
			aoActive = !aoActive;
			SetAO(aoActive);
		}

		public void ToggleDof()
		{
			dofActive = !dofActive;
			SetDof(dofActive);
		}

		public void ToggleInvincible()
		{
			invincible = !invincible;
			SetInvincible(invincible);
		}

		private void SetReporter(bool active)
		{
		}

		public void ToggleReporter()
		{
			SetReporter(!reporterActive);
		}

		private void SetAO(bool active)
		{
			ScriptableRendererFeature scriptableRendererFeature = rendererData.rendererFeatures.Find((ScriptableRendererFeature a) => a.name == "ScreenSpaceAmbientOcclusion");
			if (scriptableRendererFeature != null)
			{
				scriptableRendererFeature.SetActive(active);
				aoText.text = (active ? "开" : "关");
				PlayerPrefs.SetInt("AOActive", active ? 1 : 0);
			}
			DebugView.OnDebugViewConfigChanged?.Invoke(this);
		}

		private void SetDof(bool active)
		{
		}

		private void SetInvincible(bool active)
		{
			invincibleText.text = (active ? "开" : "关");
			invincible = active;
			DebugView.OnDebugViewConfigChanged?.Invoke(this);
		}

		public void CreateItem()
		{
			CreateItemTask().Forget();
		}

		private async UniTaskVoid CreateItemTask()
		{
			if (CharacterMainControl.Main != null)
			{
				Item item = await ItemAssetsCollection.InstantiateAsync(createItemID);
				if (!(item == null))
				{
					item.Drop(CharacterMainControl.Main, createRigidbody: true);
				}
			}
		}
	}
}
namespace EventReports
{
	public class BDSManager : MonoBehaviour
	{
		private enum EventName
		{
			none,
			app_start,
			begin_new_game,
			delete_save_data,
			raid_new,
			raid_end,
			scene_load_start,
			scene_load_finish,
			level_initialized,
			level_evacuated,
			main_character_dead,
			quest_activate,
			quest_complete,
			pay_money,
			pay_cost,
			item_to_inventory,
			item_to_storage,
			shop_purchased,
			craft_craft,
			craft_formula_unlock,
			enemy_kill,
			role_level_changed,
			building_built,
			building_destroyed,
			perk_unlocked,
			masterkey_unlocked,
			role_equip,
			item_sold,
			reward_claimed,
			item_use,
			interact_start,
			face_customize_begin,
			face_customize_finish,
			heartbeat,
			cheat_mode_changed,
			app_end
		}

		private struct CheatModeStatusChangeContext
		{
			public bool cheatModeActive;
		}

		private struct InteractEventContext
		{
			public string interactGameObjectName;

			public string typeName;
		}

		private struct ItemUseEventContext
		{
			public int itemTypeID;
		}

		private struct RewardClaimEventContext
		{
			public int questID;

			public int rewardID;
		}

		private struct ItemSoldEventContext
		{
			public string stockShopID;

			public int itemID;

			public int price;
		}

		private struct EquipEventContext
		{
			public string slotKey;

			public int contentItemTypeID;
		}

		private struct MasterKeyUnlockContext
		{
			public int keyID;
		}

		private struct PerkInfo
		{
			public string perkTreeID;

			public string perkName;
		}

		private struct BuildingEventContext
		{
			public string buildingID;
		}

		private struct LevelChangedEventContext
		{
			public int from;

			public int to;

			public LevelChangedEventContext(int from, int to)
			{
				this.from = from;
				this.to = to;
			}
		}

		private struct EnemyKillInfo
		{
			public string enemyPresetName;

			public DamageInfo damageInfo;
		}

		[Serializable]
		public struct PurchaseInfo
		{
			public string shopID;

			public int itemTypeID;

			public int itemAmount;
		}

		private struct ItemInfo
		{
			public int itemId;

			public int amount;
		}

		public struct CharacterDeathContext
		{
			public DamageInfo damageInfo;

			public string fromCharacterPresetName;

			public string fromCharacterNameKey;

			public LevelManager.LevelInfo levelInfo;
		}

		[Serializable]
		private struct PlayerStatus
		{
			public bool valid;

			public float healthMax;

			public float health;

			public float waterMax;

			public float foodMax;

			public float water;

			public float food;

			public string[] activeEffects;

			public int totalItemValue;

			public static PlayerStatus CreateFromCurrent()
			{
				CharacterMainControl main = CharacterMainControl.Main;
				if (main == null)
				{
					return default(PlayerStatus);
				}
				Health health = main.Health;
				if (health == null)
				{
					return default(PlayerStatus);
				}
				CharacterBuffManager buffManager = main.GetBuffManager();
				if (buffManager == null)
				{
					return default(PlayerStatus);
				}
				if (main.CharacterItem == null)
				{
					return default(PlayerStatus);
				}
				string[] array = new string[buffManager.Buffs.Count];
				for (int i = 0; i < buffManager.Buffs.Count; i++)
				{
					Buff buff = buffManager.Buffs[i];
					if (!(buff == null))
					{
						array[i] = $"{buff.ID} {buff.DisplayNameKey}";
					}
				}
				int totalRawValue = main.CharacterItem.GetTotalRawValue();
				return new PlayerStatus
				{
					valid = true,
					healthMax = health.MaxHealth,
					health = main.CurrentEnergy,
					water = main.CurrentWater,
					food = main.CurrentEnergy,
					waterMax = main.MaxWater,
					foodMax = main.MaxEnergy,
					totalItemValue = totalRawValue
				};
			}
		}

		private struct EvacuationEventData
		{
			public EvacuationInfo evacuationInfo;

			public string mapID;

			public RaidUtilities.RaidInfo raidInfo;

			public PlayerStatus playerStatus;
		}

		[Serializable]
		private struct SessionInfo
		{
			public int startCount;

			public bool isFirstTimeStart;

			public int session_id;

			public int session_duration_seconds;
		}

		public struct PlayerInfo
		{
			public string role_name;

			public string profession_type;

			public string gender;

			public string level;

			public string b_account_id;

			public string b_role_id;

			public string b_tour_indicator;

			public string b_zone_id;

			public string b_sdk_uid;

			public PlayerInfo(int level, string steamAccountID, int saveSlot, string location, string language, string displayName, string difficulty, string platform, string version, string system)
			{
				role_name = displayName;
				profession_type = language;
				gender = version;
				this.level = $"{level}";
				b_account_id = steamAccountID;
				b_role_id = $"{saveSlot}|{difficulty}";
				b_tour_indicator = "0";
				b_zone_id = location;
				b_sdk_uid = platform + "|" + system;
			}

			public static PlayerInfo GetCurrent()
			{
				string iD = PlatformInfo.GetID();
				string displayName = PlatformInfo.GetDisplayName();
				PlayerInfo result = new PlayerInfo(EXPManager.Level, iD, SavesSystem.CurrentSlot, RegionInfo.CurrentRegion.Name, Application.systemLanguage.ToString(), displayName, GameRulesManager.Current.displayNameKey, PlatformInfo.Platform.ToString(), GameMetaData.Instance.Version.ToString(), Environment.OSVersion.Platform.ToString());
				result.gender = GameMetaData.Instance.Version.ToString();
				return result;
			}

			public static string GetCurrentJson()
			{
				return GetCurrent().ToJson();
			}

			public string ToJson()
			{
				return JsonUtility.ToJson(this);
			}
		}

		private float lastTimeHeartbeat;

		private int sessionID;

		private DateTime sessionStartTime;

		private SessionInfo sessionInfo;

		public static Action<string, string> OnReportCustomEvent;

		private float TimeSinceLastHeartbeat => Time.unscaledTime - lastTimeHeartbeat;

		private void Awake()
		{
			if (PlatformInfo.Platform == Duckov.Platform.Steam)
			{
				if (SteamManager.Initialized && !SteamUtils.IsSteamChinaLauncher())
				{
				}
			}
			else
			{
				_ = $"{PlatformInfo.Platform}";
			}
			UnityEngine.Debug.Log("Player Info:\n" + PlayerInfo.GetCurrent().ToJson());
		}

		private void Start()
		{
			OnGameStarted();
		}

		private void OnDestroy()
		{
		}

		private void Update()
		{
			_ = Application.isPlaying;
		}

		private void UpdateHeartbeat()
		{
			if (TimeSinceLastHeartbeat > 60f)
			{
				ReportCustomEvent(EventName.heartbeat);
				lastTimeHeartbeat = Time.unscaledTime;
			}
		}

		private void RegisterEvents()
		{
			UnregisterEvents();
			SavesSystem.OnSaveDeleted += OnSaveDeleted;
			RaidUtilities.OnNewRaid = (Action<RaidUtilities.RaidInfo>)Delegate.Combine(RaidUtilities.OnNewRaid, new Action<RaidUtilities.RaidInfo>(OnNewRaid));
			RaidUtilities.OnRaidEnd = (Action<RaidUtilities.RaidInfo>)Delegate.Combine(RaidUtilities.OnRaidEnd, new Action<RaidUtilities.RaidInfo>(OnRaidEnd));
			SceneLoader.onStartedLoadingScene += OnSceneLoadingStart;
			SceneLoader.onFinishedLoadingScene += OnSceneLoadingFinish;
			LevelManager.OnLevelInitialized += OnLevelInitialized;
			LevelManager.OnEvacuated += OnEvacuated;
			LevelManager.OnMainCharacterDead += OnMainCharacterDead;
			Quest.onQuestActivated += OnQuestActivated;
			Quest.onQuestCompleted += OnQuestCompleted;
			EconomyManager.OnCostPaid += OnCostPaid;
			EconomyManager.OnMoneyPaid += OnMoneyPaid;
			ItemUtilities.OnItemSentToPlayerInventory += OnItemSentToPlayerInventory;
			ItemUtilities.OnItemSentToPlayerStorage += OnItemSentToPlayerStorage;
			StockShop.OnItemPurchased += OnItemPurchased;
			CraftingManager.OnItemCrafted = (Action<CraftingFormula, Item>)Delegate.Combine(CraftingManager.OnItemCrafted, new Action<CraftingFormula, Item>(OnItemCrafted));
			CraftingManager.OnFormulaUnlocked = (Action<string>)Delegate.Combine(CraftingManager.OnFormulaUnlocked, new Action<string>(OnFormulaUnlocked));
			Health.OnDead += OnHealthDead;
			EXPManager.onLevelChanged = (Action<int, int>)Delegate.Combine(EXPManager.onLevelChanged, new Action<int, int>(OnLevelChanged));
			BuildingManager.OnBuildingBuiltComplex += OnBuildingBuilt;
			BuildingManager.OnBuildingDestroyedComplex += OnBuildingDestroyed;
			Perk.OnPerkUnlockConfirmed += OnPerkUnlockConfirmed;
			MasterKeysManager.OnMasterKeyUnlocked += OnMasterKeyUnlocked;
			CharacterMainControl.OnMainCharacterSlotContentChangedEvent = (Action<CharacterMainControl, Slot>)Delegate.Combine(CharacterMainControl.OnMainCharacterSlotContentChangedEvent, new Action<CharacterMainControl, Slot>(OnMainCharacterSlotContentChanged));
			StockShop.OnItemSoldByPlayer += OnItemSold;
			Reward.OnRewardClaimed += OnRewardClaimed;
			UsageUtilities.OnItemUsedStaticEvent += OnItemUsed;
			InteractableBase.OnInteractStartStaticEvent += OnInteractStart;
			LevelManager.OnNewGameReport += OnNewGameReport;
			Interact_CustomFace.OnCustomFaceStartEvent += OnCustomFaceStart;
			Interact_CustomFace.OnCustomFaceFinishedEvent += OnCustomFaceFinish;
			CheatMode.OnCheatModeStatusChanged += OnCheatModeStatusChanged;
		}

		private void UnregisterEvents()
		{
			SavesSystem.OnSaveDeleted -= OnSaveDeleted;
			RaidUtilities.OnNewRaid = (Action<RaidUtilities.RaidInfo>)Delegate.Remove(RaidUtilities.OnNewRaid, new Action<RaidUtilities.RaidInfo>(OnNewRaid));
			RaidUtilities.OnRaidEnd = (Action<RaidUtilities.RaidInfo>)Delegate.Remove(RaidUtilities.OnRaidEnd, new Action<RaidUtilities.RaidInfo>(OnRaidEnd));
			SceneLoader.onStartedLoadingScene -= OnSceneLoadingStart;
			SceneLoader.onFinishedLoadingScene -= OnSceneLoadingFinish;
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
			LevelManager.OnEvacuated -= OnEvacuated;
			LevelManager.OnMainCharacterDead -= OnMainCharacterDead;
			Quest.onQuestActivated -= OnQuestActivated;
			Quest.onQuestCompleted -= OnQuestCompleted;
			EconomyManager.OnCostPaid -= OnCostPaid;
			EconomyManager.OnMoneyPaid -= OnMoneyPaid;
			ItemUtilities.OnItemSentToPlayerInventory -= OnItemSentToPlayerInventory;
			ItemUtilities.OnItemSentToPlayerStorage -= OnItemSentToPlayerStorage;
			StockShop.OnItemPurchased -= OnItemPurchased;
			CraftingManager.OnItemCrafted = (Action<CraftingFormula, Item>)Delegate.Remove(CraftingManager.OnItemCrafted, new Action<CraftingFormula, Item>(OnItemCrafted));
			CraftingManager.OnFormulaUnlocked = (Action<string>)Delegate.Remove(CraftingManager.OnFormulaUnlocked, new Action<string>(OnFormulaUnlocked));
			Health.OnDead -= OnHealthDead;
			EXPManager.onLevelChanged = (Action<int, int>)Delegate.Remove(EXPManager.onLevelChanged, new Action<int, int>(OnLevelChanged));
			BuildingManager.OnBuildingBuiltComplex -= OnBuildingBuilt;
			BuildingManager.OnBuildingDestroyedComplex -= OnBuildingDestroyed;
			Perk.OnPerkUnlockConfirmed -= OnPerkUnlockConfirmed;
			MasterKeysManager.OnMasterKeyUnlocked -= OnMasterKeyUnlocked;
			CharacterMainControl.OnMainCharacterSlotContentChangedEvent = (Action<CharacterMainControl, Slot>)Delegate.Remove(CharacterMainControl.OnMainCharacterSlotContentChangedEvent, new Action<CharacterMainControl, Slot>(OnMainCharacterSlotContentChanged));
			StockShop.OnItemSoldByPlayer -= OnItemSold;
			Reward.OnRewardClaimed -= OnRewardClaimed;
			UsageUtilities.OnItemUsedStaticEvent -= OnItemUsed;
			InteractableBase.OnInteractStartStaticEvent -= OnInteractStart;
			LevelManager.OnNewGameReport -= OnNewGameReport;
			Interact_CustomFace.OnCustomFaceStartEvent -= OnCustomFaceStart;
			Interact_CustomFace.OnCustomFaceFinishedEvent -= OnCustomFaceFinish;
			CheatMode.OnCheatModeStatusChanged -= OnCheatModeStatusChanged;
		}

		private void OnCheatModeStatusChanged(bool value)
		{
			ReportCustomEvent(EventName.cheat_mode_changed, new CheatModeStatusChangeContext
			{
				cheatModeActive = value
			});
		}

		private void OnCustomFaceFinish()
		{
			ReportCustomEvent(EventName.face_customize_finish);
		}

		private void OnCustomFaceStart()
		{
			ReportCustomEvent(EventName.face_customize_begin);
		}

		private void OnNewGameReport()
		{
			ReportCustomEvent(EventName.begin_new_game);
		}

		private void OnInteractStart(InteractableBase target)
		{
			if (!(target == null))
			{
				ReportCustomEvent(EventName.interact_start, new InteractEventContext
				{
					interactGameObjectName = target.name,
					typeName = target.GetType().Name
				});
			}
		}

		private void OnItemUsed(Item item)
		{
			ReportCustomEvent(EventName.item_use, new ItemUseEventContext
			{
				itemTypeID = item.TypeID
			});
		}

		private void OnRewardClaimed(Reward reward)
		{
			int questID = ((reward.Master != null) ? reward.Master.ID : (-1));
			ReportCustomEvent(EventName.reward_claimed, new RewardClaimEventContext
			{
				questID = questID,
				rewardID = reward.ID
			});
		}

		private void OnItemSold(StockShop shop, Item item, int price)
		{
			if (!(item == null))
			{
				string stockShopID = shop?.MerchantID;
				ReportCustomEvent(EventName.item_sold, new ItemSoldEventContext
				{
					stockShopID = stockShopID,
					itemID = item.TypeID,
					price = price
				});
			}
		}

		private void OnMainCharacterSlotContentChanged(CharacterMainControl control, Slot slot)
		{
			if (!(control == null) && slot != null && !(slot.Content == null))
			{
				ReportCustomEvent(EventName.role_equip, new EquipEventContext
				{
					slotKey = slot.Key,
					contentItemTypeID = slot.Content.TypeID
				});
			}
		}

		private void OnMasterKeyUnlocked(int id)
		{
			ReportCustomEvent(EventName.masterkey_unlocked, new MasterKeyUnlockContext
			{
				keyID = id
			});
		}

		private void OnPerkUnlockConfirmed(Perk perk)
		{
			if (!(perk == null))
			{
				ReportCustomEvent(EventName.perk_unlocked, new PerkInfo
				{
					perkTreeID = perk.Master?.ID,
					perkName = perk.name
				});
			}
		}

		private void OnBuildingBuilt(int guid, BuildingInfo info)
		{
			ReportCustomEvent(EventName.building_built, new BuildingEventContext
			{
				buildingID = info.id
			});
		}

		private void OnBuildingDestroyed(int guid, BuildingInfo info)
		{
			ReportCustomEvent(EventName.building_destroyed, new BuildingEventContext
			{
				buildingID = info.id
			});
		}

		private void OnLevelChanged(int from, int to)
		{
			ReportCustomEvent(EventName.role_level_changed, new LevelChangedEventContext(from, to));
		}

		private void OnHealthDead(Health health, DamageInfo info)
		{
			if (!(health == null))
			{
				_ = health.team;
				bool flag = false;
				if (info.fromCharacter != null && info.fromCharacter.IsMainCharacter())
				{
					flag = true;
				}
				if (flag)
				{
					ReportCustomEvent(EventName.enemy_kill, new EnemyKillInfo
					{
						enemyPresetName = GetPresetName(health),
						damageInfo = info
					});
				}
			}
			static string GetPresetName(Health health2)
			{
				CharacterMainControl characterMainControl = health2.TryGetCharacter();
				if (characterMainControl == null)
				{
					return "None";
				}
				CharacterRandomPreset characterPreset = characterMainControl.characterPreset;
				if (characterPreset == null)
				{
					return "None";
				}
				return characterPreset.Name;
			}
		}

		private void OnFormulaUnlocked(string formulaID)
		{
			ReportCustomEvent(EventName.craft_formula_unlock, StrJson.Create("id", formulaID));
		}

		private void OnItemCrafted(CraftingFormula formula, Item item)
		{
			ReportCustomEvent(EventName.craft_craft, formula);
		}

		private void OnItemPurchased(StockShop shop, Item item)
		{
			if (!(shop == null) && !(item == null))
			{
				ReportCustomEvent(EventName.shop_purchased, new PurchaseInfo
				{
					shopID = shop.MerchantID,
					itemTypeID = item.TypeID,
					itemAmount = item.StackCount
				});
			}
		}

		private void OnItemSentToPlayerStorage(Item item)
		{
			if (!(item == null))
			{
				ReportCustomEvent(EventName.item_to_storage, new ItemInfo
				{
					itemId = item.TypeID,
					amount = item.StackCount
				});
			}
		}

		private void OnItemSentToPlayerInventory(Item item)
		{
			if (!(item == null))
			{
				ReportCustomEvent(EventName.item_to_inventory, new ItemInfo
				{
					itemId = item.TypeID,
					amount = item.StackCount
				});
			}
		}

		private void OnMoneyPaid(long money)
		{
			ReportCustomEvent(EventName.pay_money, new Cost
			{
				money = money,
				items = new Cost.ItemEntry[0]
			});
		}

		private void OnCostPaid(Cost cost)
		{
			ReportCustomEvent(EventName.pay_cost, cost);
		}

		private void OnQuestActivated(Quest quest)
		{
			if (!(quest == null))
			{
				ReportCustomEvent(EventName.quest_activate, quest.GetInfo());
			}
		}

		private void OnQuestCompleted(Quest quest)
		{
			if (!(quest == null))
			{
				ReportCustomEvent(EventName.quest_complete, quest.GetInfo());
			}
		}

		private void OnMainCharacterDead(DamageInfo info)
		{
			string fromCharacterPresetName = "None";
			string fromCharacterNameKey = "None";
			if ((bool)info.fromCharacter)
			{
				CharacterRandomPreset characterPreset = info.fromCharacter.characterPreset;
				if (characterPreset != null)
				{
					fromCharacterPresetName = characterPreset.name;
					fromCharacterNameKey = characterPreset.nameKey;
				}
			}
			ReportCustomEvent(EventName.main_character_dead, new CharacterDeathContext
			{
				damageInfo = info,
				levelInfo = LevelManager.GetCurrentLevelInfo(),
				fromCharacterPresetName = fromCharacterPresetName,
				fromCharacterNameKey = fromCharacterNameKey
			});
		}

		private void OnEvacuated(EvacuationInfo evacuationInfo)
		{
			LevelManager.LevelInfo currentLevelInfo = LevelManager.GetCurrentLevelInfo();
			RaidUtilities.RaidInfo currentRaid = RaidUtilities.CurrentRaid;
			PlayerStatus playerStatus = PlayerStatus.CreateFromCurrent();
			ReportCustomEvent(EventName.level_evacuated, new EvacuationEventData
			{
				evacuationInfo = evacuationInfo,
				mapID = currentLevelInfo.activeSubSceneID,
				raidInfo = currentRaid,
				playerStatus = playerStatus
			});
		}

		private void OnLevelInitialized()
		{
			ReportCustomEvent(EventName.level_initialized, LevelManager.GetCurrentLevelInfo());
		}

		private void OnSceneLoadingFinish(SceneLoadingContext context)
		{
			ReportCustomEvent(EventName.scene_load_start, context);
		}

		private void OnSceneLoadingStart(SceneLoadingContext context)
		{
			ReportCustomEvent(EventName.scene_load_finish, context);
		}

		private void OnRaidEnd(RaidUtilities.RaidInfo info)
		{
			ReportCustomEvent(EventName.raid_end, info);
		}

		private void OnNewRaid(RaidUtilities.RaidInfo info)
		{
			ReportCustomEvent(EventName.raid_new, info);
		}

		private void OnSaveDeleted()
		{
			ReportCustomEvent(EventName.delete_save_data, StrJson.Create("slot", $"{SavesSystem.CurrentSlot}"));
		}

		private void OnGameStarted()
		{
			int num = PlayerPrefs.GetInt("AppStartCount", 0);
			sessionInfo = new SessionInfo
			{
				startCount = num,
				isFirstTimeStart = (num <= 0),
				session_id = DateTime.Now.ToBinary().GetHashCode()
			};
			sessionStartTime = DateTime.Now;
			ReportCustomEvent(EventName.app_start, sessionInfo);
			PlayerPrefs.SetInt("AppStartCount", ++num);
			PlayerPrefs.Save();
		}

		private void ReportCustomEvent(EventName eventName, StrJson customParameters)
		{
			ReportCustomEvent(eventName, customParameters.ToString());
		}

		private void ReportCustomEvent<T>(EventName eventName, T customParameters)
		{
			string customParameters2 = ((customParameters != null) ? JsonUtility.ToJson(customParameters) : "");
			ReportCustomEvent(eventName, customParameters2);
		}

		private void ReportCustomEvent(EventName eventName, string customParameters = "")
		{
			string strPlayerInfo = PlayerInfo.GetCurrent().ToJson();
			SDK.ReportCustomEvent(eventName.ToString(), strPlayerInfo, "", customParameters);
			try
			{
				OnReportCustomEvent?.Invoke(eventName.ToString(), customParameters);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}
	}
}
namespace ItemStatsSystem
{
	[MenuPath("General/On Shoot&Attack")]
	public class OnShootAttackTrigger : EffectTrigger
	{
		[SerializeField]
		private bool onShoot = true;

		[SerializeField]
		private bool onAttack = true;

		private CharacterMainControl target;

		private void OnEnable()
		{
			RegisterEvents();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			UnregisterEvents();
		}

		protected override void OnMasterSetTargetItem(Effect effect, Item item)
		{
			RegisterEvents();
		}

		private void RegisterEvents()
		{
			UnregisterEvents();
			if (base.Master == null)
			{
				return;
			}
			Item item = base.Master.Item;
			if (item == null)
			{
				return;
			}
			target = item.GetCharacterMainControl();
			if (!(target == null))
			{
				if (onShoot)
				{
					target.OnShootEvent += OnShootAttack;
				}
				if (onAttack)
				{
					target.OnAttackEvent += OnShootAttack;
				}
			}
		}

		private void UnregisterEvents()
		{
			if (!(target == null))
			{
				if (onShoot)
				{
					target.OnShootEvent -= OnShootAttack;
				}
				if (onAttack)
				{
					target.OnAttackEvent -= OnShootAttack;
				}
			}
		}

		private void OnShootAttack(DuckovItemAgent agent)
		{
			Trigger();
		}
	}
	[MenuPath("General/On Take Damage")]
	public class OnTakeDamageTrigger : EffectTrigger
	{
		[SerializeField]
		public int threshold;

		private Health target;

		private void OnEnable()
		{
			RegisterEvents();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			UnregisterEvents();
		}

		protected override void OnMasterSetTargetItem(Effect effect, Item item)
		{
			RegisterEvents();
		}

		private void RegisterEvents()
		{
			UnregisterEvents();
			if (base.Master == null)
			{
				return;
			}
			Item item = base.Master.Item;
			if (!(item == null))
			{
				CharacterMainControl characterMainControl = item.GetCharacterMainControl();
				if (!(characterMainControl == null))
				{
					target = characterMainControl.Health;
					target.OnHurtEvent.AddListener(OnTookDamage);
				}
			}
		}

		private void UnregisterEvents()
		{
			if (!(target == null))
			{
				target.OnHurtEvent.RemoveListener(OnTookDamage);
			}
		}

		private void OnTookDamage(DamageInfo info)
		{
			if (!(info.damageValue < (float)threshold))
			{
				Trigger();
			}
		}
	}
	public class TestitemGraphic : MonoBehaviour
	{
		private ItemGraphicInfo instance;

		private void Start()
		{
		}

		private void Update()
		{
			if (Keyboard.current.gKey.wasPressedThisFrame)
			{
				if ((bool)instance)
				{
					UnityEngine.Object.Destroy(instance.gameObject);
				}
				DuckovItemAgent currentHoldItemAgent = CharacterMainControl.Main.CurrentHoldItemAgent;
				if ((bool)currentHoldItemAgent)
				{
					instance = ItemGraphicInfo.CreateAGraphic(currentHoldItemAgent.Item, base.transform);
				}
			}
		}
	}
}
namespace Duckov
{
	public class AudioManager : MonoBehaviour
	{
		[Serializable]
		public class Bus
		{
			[SerializeField]
			private string volumeRTPC = "Master";

			[HideInInspector]
			[SerializeField]
			private float volume = 1f;

			[HideInInspector]
			[SerializeField]
			private bool mute;

			private float appliedVolume = float.MinValue;

			public string Name => volumeRTPC;

			public float Volume
			{
				get
				{
					return volume;
				}
				set
				{
					volume = value;
					Apply();
				}
			}

			public bool Mute
			{
				get
				{
					return mute;
				}
				set
				{
					mute = value;
					Apply();
				}
			}

			public bool Dirty => appliedVolume != Volume;

			private string SaveKey => "Audio/" + volumeRTPC;

			public void Apply()
			{
				try
				{
					FMOD.Studio.Bus bus = RuntimeManager.GetBus("bus:/" + volumeRTPC);
					bus.setVolume(Volume);
					bus.setMute(Mute);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				appliedVolume = Volume;
				OptionsManager.Save(SaveKey, volume);
			}

			public Bus(string rtpc)
			{
				volumeRTPC = rtpc;
			}

			internal void LoadOptions()
			{
				volume = OptionsManager.Load(SaveKey, 1f);
			}

			internal void NotifyOptionsChanged(string key)
			{
				if (key == SaveKey)
				{
					LoadOptions();
				}
			}
		}

		public enum FootStepMaterialType
		{
			organic,
			mech,
			danger
		}

		public enum VoiceType
		{
			Duck,
			Robot,
			Wolf,
			Chicken,
			Crow,
			Eagle
		}

		private bool useArchivedSound;

		[SerializeField]
		private AudioObject ambientSource;

		[SerializeField]
		private AudioObject bgmSource;

		[SerializeField]
		private AudioObject stingerSource;

		[SerializeField]
		private Bus masterBus = new Bus("Master");

		[SerializeField]
		private Bus sfxBus = new Bus("Master/SFX");

		[SerializeField]
		private Bus musicBus = new Bus("Master/Music");

		private static Transform _soundSourceParent;

		private static UnityEngine.Pool.ObjectPool<GameObject> _soundSourcePool;

		private const string path_hitmarker_norm = "SFX/Combat/Marker/hitmarker";

		private const string path_hitmarker_crit = "SFX/Combat/Marker/hitmarker_head";

		private const string path_killmarker_norm = "SFX/Combat/Marker/killmarker";

		private const string path_killmarker_crit = "SFX/Combat/Marker/killmarker_head";

		private const string path_music_death = "Music/Stinger/stg_death";

		private const string path_bullet_flyby = "SFX/Combat/Bullet/flyby";

		private const string path_pickup_item_fmt_soundkey = "SFX/Item/pickup_{soundkey}";

		private const string path_put_item_fmt_soundkey = "SFX/Item/put_{soundkey}";

		private const string path_ambient_fmt_soundkey = "Amb/amb_{soundkey}";

		private const string path_music_loop_fmt_soundkey = "Music/Loop/{soundkey}";

		private const string path_footstep_fmt_soundkey = "Char/Footstep/footstep_{charaType}_{strengthType}";

		public const string path_reload_fmt_soundkey = "SFX/Combat/Gun/Reload/{soundkey}";

		public const string path_shoot_fmt_gunkey = "SFX/Combat/Gun/Shoot/{soundkey}";

		public const string path_task_finished = "UI/mission_small";

		public const string path_building_built = "UI/building_up";

		public const string path_gun_unload = "SFX/Combat/Gun/unload";

		public const string path_stinger_fmt_key = "Music/Stinger/{key}";

		private static bool playingBGM;

		private static FMOD.Studio.EventInstance bgmEvent;

		private static string currentBGMName;

		private static Dictionary<string, string> globalStates = new Dictionary<string, string>();

		private static Dictionary<int, VoiceType> gameObjectVoiceTypes = new Dictionary<int, VoiceType>();

		public static AudioManager Instance => GameManager.AudioManager;

		public static bool IsStingerPlaying
		{
			get
			{
				if (Instance == null)
				{
					return false;
				}
				if (Instance.stingerSource == null)
				{
					return false;
				}
				return Instance.stingerSource.events.Any((FMOD.Studio.EventInstance e) => e.isValid());
			}
		}

		private Transform listener => base.transform;

		private static Transform SoundSourceParent
		{
			get
			{
				if (_soundSourceParent == null)
				{
					GameObject obj = new GameObject("Sound Sources");
					_soundSourceParent = obj.transform;
					UnityEngine.Object.DontDestroyOnLoad(obj);
				}
				return _soundSourceParent;
			}
		}

		private static UnityEngine.Pool.ObjectPool<GameObject> SoundSourcePool
		{
			get
			{
				if (_soundSourcePool == null)
				{
					_soundSourcePool = new UnityEngine.Pool.ObjectPool<GameObject>(delegate
					{
						GameObject obj = new GameObject("SoundSource");
						obj.transform.SetParent(SoundSourceParent);
						return obj;
					}, delegate(GameObject e)
					{
						e.SetActive(value: true);
					}, delegate(GameObject e)
					{
						e.SetActive(value: false);
					});
				}
				return _soundSourcePool;
			}
		}

		public static bool PlayingBGM => playingBGM;

		private static bool LogEvent => false;

		public static bool Initialized => RuntimeManager.IsInitialized;

		private IEnumerable<Bus> AllBueses()
		{
			yield return masterBus;
			yield return sfxBus;
			yield return musicBus;
		}

		public static FMOD.Studio.EventInstance? Post(string eventName, GameObject gameObject)
		{
			if (string.IsNullOrEmpty(eventName))
			{
				return null;
			}
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError($"Posting event but gameObject is null: {gameObject}");
			}
			if (!gameObject.activeSelf)
			{
				UnityEngine.Debug.LogError($"Posting event but gameObject is not active: {gameObject}");
			}
			return Instance.MPost(eventName, gameObject);
		}

		public static FMOD.Studio.EventInstance? Post(string eventName)
		{
			if (string.IsNullOrEmpty(eventName))
			{
				return null;
			}
			return Instance.MPost(eventName);
		}

		public static FMOD.Studio.EventInstance? Post(string eventName, Vector3 position)
		{
			if (string.IsNullOrEmpty(eventName))
			{
				return null;
			}
			return Instance.MPost(eventName, position);
		}

		internal static FMOD.Studio.EventInstance? PostQuak(string soundKey, VoiceType voiceType, GameObject gameObject)
		{
			AudioObject orCreate = AudioObject.GetOrCreate(gameObject);
			orCreate.VoiceType = voiceType;
			return orCreate.PostQuak(soundKey);
		}

		public static void PostHitMarker(bool crit)
		{
			Post(crit ? "SFX/Combat/Marker/hitmarker_head" : "SFX/Combat/Marker/hitmarker");
		}

		public static void PostKillMarker(bool crit = false)
		{
			Post(crit ? "SFX/Combat/Marker/killmarker_head" : "SFX/Combat/Marker/killmarker");
		}

		private void Awake()
		{
			CharacterSoundMaker.OnFootStepSound = (Action<Vector3, CharacterSoundMaker.FootStepTypes, CharacterMainControl>)Delegate.Combine(CharacterSoundMaker.OnFootStepSound, new Action<Vector3, CharacterSoundMaker.FootStepTypes, CharacterMainControl>(OnFootStepSound));
			Projectile.OnBulletFlyByCharacter = (Action<Vector3>)Delegate.Combine(Projectile.OnBulletFlyByCharacter, new Action<Vector3>(OnBulletFlyby));
			MultiSceneCore.OnSubSceneLoaded += OnSubSceneLoaded;
			ItemUIUtilities.OnPutItem += OnPutItem;
			Health.OnDead += OnHealthDead;
			LevelManager.OnLevelInitialized += OnLevelInitialized;
			SceneLoader.onStartedLoadingScene += OnStartedLoadingScene;
			OptionsManager.OnOptionsChanged += OnOptionsChanged;
			foreach (Bus item in AllBueses())
			{
				item.LoadOptions();
			}
		}

		private void OnDestroy()
		{
			CharacterSoundMaker.OnFootStepSound = (Action<Vector3, CharacterSoundMaker.FootStepTypes, CharacterMainControl>)Delegate.Remove(CharacterSoundMaker.OnFootStepSound, new Action<Vector3, CharacterSoundMaker.FootStepTypes, CharacterMainControl>(OnFootStepSound));
			Projectile.OnBulletFlyByCharacter = (Action<Vector3>)Delegate.Remove(Projectile.OnBulletFlyByCharacter, new Action<Vector3>(OnBulletFlyby));
			MultiSceneCore.OnSubSceneLoaded -= OnSubSceneLoaded;
			ItemUIUtilities.OnPutItem -= OnPutItem;
			Health.OnDead -= OnHealthDead;
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
			SceneLoader.onStartedLoadingScene -= OnStartedLoadingScene;
			OptionsManager.OnOptionsChanged -= OnOptionsChanged;
		}

		private void OnOptionsChanged(string key)
		{
			foreach (Bus item in AllBueses())
			{
				item.NotifyOptionsChanged(key);
			}
		}

		public static Bus GetBus(string name)
		{
			if (Instance == null)
			{
				return null;
			}
			foreach (Bus item in Instance.AllBueses())
			{
				if (item.Name == name)
				{
					return item;
				}
			}
			return null;
		}

		private void OnStartedLoadingScene(SceneLoadingContext context)
		{
			if ((bool)ambientSource)
			{
				ambientSource.StopAll();
			}
		}

		private void OnLevelInitialized()
		{
		}

		private void Start()
		{
			UpdateBuses();
		}

		private void OnHealthDead(Health health, DamageInfo info)
		{
			if (health.TryGetCharacter() == CharacterMainControl.Main)
			{
				StopBGM();
				Post("Music/Stinger/stg_death");
			}
		}

		private void OnPutItem(Item item, bool pickup = false)
		{
			PlayPutItemSFX(item, pickup);
		}

		public static void PlayPutItemSFX(Item item, bool pickup = false)
		{
			if (!(item == null) && LevelManager.LevelInited)
			{
				Post((pickup ? "SFX/Item/pickup_{soundkey}" : "SFX/Item/put_{soundkey}").Format(new
				{
					soundkey = item.SoundKey.ToLower()
				}));
			}
		}

		private void OnSubSceneLoaded(MultiSceneCore core, Scene scene)
		{
			LevelManager.LevelInitializingComment = "Opening ears";
			SubSceneEntry subSceneInfo = core.GetSubSceneInfo(scene);
			if (subSceneInfo != null)
			{
				if ((bool)ambientSource)
				{
					LevelManager.LevelInitializingComment = "Hearing Ambient";
					ambientSource.StopAll();
					ambientSource.Post("Amb/amb_{soundkey}".Format(new
					{
						soundkey = subSceneInfo.AmbientSound.ToLower()
					}));
				}
				LevelManager.LevelInitializingComment = "Hearing Buses";
				ApplyBuses();
			}
		}

		public static bool TryCreateEventInstance(string eventPath, out FMOD.Studio.EventInstance eventInstance)
		{
			eventInstance = default(FMOD.Studio.EventInstance);
			if (Instance.useArchivedSound)
			{
				eventPath = "Archived/" + eventPath;
			}
			string text = "event:/" + eventPath;
			try
			{
				eventInstance = RuntimeManager.CreateInstance(text);
				return true;
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				if (LogEvent)
				{
					UnityEngine.Debug.LogError("[AudioEvent][Failed] " + text);
				}
			}
			return false;
		}

		public static void PlayBGM(string name)
		{
			StopBGM();
			if (Instance == null)
			{
				return;
			}
			playingBGM = true;
			if (!string.IsNullOrWhiteSpace(name))
			{
				string eventName = "Music/Loop/{soundkey}".Format(new
				{
					soundkey = name
				});
				if (!Instance.bgmSource.Post(eventName).HasValue)
				{
					currentBGMName = null;
				}
				else
				{
					currentBGMName = name;
				}
			}
		}

		public static void StopBGM()
		{
			if (!(Instance == null))
			{
				Instance.bgmSource.StopAll(FMOD.Studio.STOP_MODE.ALLOWFADEOUT);
				currentBGMName = null;
			}
		}

		public static void PlayStringer(string key)
		{
			string eventName = "Music/Stinger/{key}".Format(new { key });
			Instance.stingerSource.Post(eventName);
		}

		private void OnBulletFlyby(Vector3 vector)
		{
			Post("SFX/Combat/Bullet/flyby", vector);
		}

		public static void SetState(string stateGroup, string state)
		{
			globalStates[stateGroup] = state;
		}

		public static string GetState(string stateGroup)
		{
			if (globalStates.TryGetValue(stateGroup, out var value))
			{
				return value;
			}
			return null;
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Backslash))
			{
				useArchivedSound = !useArchivedSound;
				UnityEngine.Debug.Log($"USE ARCHIVED SOUND:{useArchivedSound}");
			}
			UpdateListener();
			UpdateBuses();
		}

		private void UpdateListener()
		{
			if (LevelManager.Instance == null)
			{
				Camera main = Camera.main;
				if (main != null)
				{
					listener.transform.position = main.transform.position;
					listener.transform.rotation = main.transform.rotation;
				}
				return;
			}
			GameCamera gameCamera = LevelManager.Instance.GameCamera;
			if (gameCamera != null)
			{
				if (CharacterMainControl.Main != null)
				{
					listener.transform.position = CharacterMainControl.Main.transform.position + Vector3.up * 2f;
				}
				else
				{
					listener.transform.position = gameCamera.renderCamera.transform.position;
				}
				listener.transform.rotation = gameCamera.renderCamera.transform.rotation;
			}
		}

		private void UpdateBuses()
		{
			foreach (Bus item in AllBueses())
			{
				if (item.Dirty)
				{
					item.Apply();
				}
			}
		}

		private void ApplyBuses()
		{
			foreach (Bus item in AllBueses())
			{
				item.Apply();
			}
		}

		private void OnFootStepSound(Vector3 position, CharacterSoundMaker.FootStepTypes type, CharacterMainControl character)
		{
			if (!(character == null))
			{
				GameObject gameObject = character.gameObject;
				string value = "floor";
				MSetParameter(gameObject, "terrain", value);
				string charaType = character.FootStepMaterialType.ToString();
				string strengthType = "light";
				switch (type)
				{
				case CharacterSoundMaker.FootStepTypes.walkLight:
				case CharacterSoundMaker.FootStepTypes.runLight:
					strengthType = "light";
					break;
				case CharacterSoundMaker.FootStepTypes.walkHeavy:
				case CharacterSoundMaker.FootStepTypes.runHeavy:
					strengthType = "heavy";
					break;
				}
				Post("Char/Footstep/footstep_{charaType}_{strengthType}".Format(new { charaType, strengthType }), character.gameObject);
			}
		}

		private void MSetParameter(GameObject gameObject, string parameterName, string value)
		{
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError("Game Object must exist");
			}
			else
			{
				AudioObject.GetOrCreate(gameObject).SetParameterByNameWithLabel(parameterName, value);
			}
		}

		private FMOD.Studio.EventInstance? MPost(string eventName, GameObject gameObject = null)
		{
			if (!Initialized)
			{
				return null;
			}
			if (string.IsNullOrWhiteSpace(eventName))
			{
				return null;
			}
			if (gameObject == null)
			{
				gameObject = Instance.gameObject;
			}
			else if (!gameObject.activeInHierarchy)
			{
				UnityEngine.Debug.LogWarning("Posting event on inactive object, canceled");
				return null;
			}
			return AudioObject.GetOrCreate(gameObject).Post(eventName ?? "");
		}

		private FMOD.Studio.EventInstance? MPost(string eventName, Vector3 position)
		{
			SoundSourcePool.Get().transform.position = position;
			if (!TryCreateEventInstance(eventName ?? "", out var eventInstance))
			{
				return null;
			}
			eventInstance.set3DAttributes(position.To3DAttributes());
			eventInstance.start();
			eventInstance.release();
			return eventInstance;
		}

		public static void StopAll(GameObject gameObject, FMOD.Studio.STOP_MODE mode = FMOD.Studio.STOP_MODE.IMMEDIATE)
		{
			AudioObject.GetOrCreate(gameObject).StopAll(mode);
		}

		internal void MSetRTPC(string key, float value, GameObject gameObject = null)
		{
			if (gameObject == null)
			{
				RuntimeManager.StudioSystem.setParameterByName("parameter:/" + key, value);
				if (LogEvent)
				{
					UnityEngine.Debug.Log($"[AudioEvent][Parameter][Global] {key} = {value}");
				}
			}
			else
			{
				AudioObject.GetOrCreate(gameObject).SetParameterByName("parameter:/" + key, value);
				if (LogEvent)
				{
					UnityEngine.Debug.Log($"[AudioEvent][Parameter][GameObject] {key} = {value}", gameObject);
				}
			}
		}

		internal static void SetRTPC(string key, float value, GameObject gameObject = null)
		{
			if (!(Instance == null))
			{
				Instance.MSetRTPC(key, value, gameObject);
			}
		}

		public static void SetVoiceType(GameObject gameObject, VoiceType voiceType)
		{
			if (!(gameObject == null))
			{
				AudioObject.GetOrCreate(gameObject).VoiceType = voiceType;
			}
		}
	}
	public class AudioObject : MonoBehaviour
	{
		private Dictionary<string, float> parameters = new Dictionary<string, float>();

		private Dictionary<string, string> strParameters = new Dictionary<string, string>();

		private AudioManager.VoiceType voiceType;

		public List<FMOD.Studio.EventInstance> events = new List<FMOD.Studio.EventInstance>();

		private bool needCleanup;

		public AudioManager.VoiceType VoiceType
		{
			get
			{
				return voiceType;
			}
			set
			{
				voiceType = value;
			}
		}

		internal static AudioObject GetOrCreate(GameObject from)
		{
			AudioObject component = from.GetComponent<AudioObject>();
			if (component != null)
			{
				return component;
			}
			return from.AddComponent<AudioObject>();
		}

		public FMOD.Studio.EventInstance? PostQuak(string soundKey)
		{
			string eventName = "Char/Voice/vo_" + voiceType.ToString().ToLower() + "_" + soundKey;
			return Post(eventName);
		}

		public FMOD.Studio.EventInstance? Post(string eventName, bool doRelease = true)
		{
			if (!AudioManager.TryCreateEventInstance(eventName ?? "", out var eventInstance))
			{
				return null;
			}
			eventInstance.setCallback(EventCallback);
			events.Add(eventInstance);
			eventInstance.set3DAttributes(base.gameObject.transform.position.To3DAttributes());
			ApplyParameters(eventInstance);
			eventInstance.start();
			if (doRelease)
			{
				eventInstance.release();
			}
			return eventInstance;
		}

		public void Stop(string eventName, FMOD.Studio.STOP_MODE mode)
		{
			foreach (FMOD.Studio.EventInstance @event in events)
			{
				if (@event.getDescription(out var description) == RESULT.OK && description.getPath(out var path) == RESULT.OK && !("event:/" + path != eventName))
				{
					@event.stop(mode);
					break;
				}
			}
		}

		private static RESULT EventCallback(EVENT_CALLBACK_TYPE type, IntPtr _event, IntPtr parameters)
		{
			if (type <= EVENT_CALLBACK_TYPE.PLUGIN_DESTROYED)
			{
				switch (type)
				{
				}
			}
			else if (type <= EVENT_CALLBACK_TYPE.SOUND_STOPPED)
			{
				switch (type)
				{
				}
			}
			else if (type <= EVENT_CALLBACK_TYPE.VIRTUAL_TO_REAL)
			{
				switch (type)
				{
				}
			}
			else if (type != EVENT_CALLBACK_TYPE.START_EVENT_COMMAND && type != EVENT_CALLBACK_TYPE.NESTED_TIMELINE_BEAT)
			{
				_ = -1;
			}
			return RESULT.OK;
		}

		private void FixedUpdate()
		{
			if (this == null || base.transform == null || events == null)
			{
				return;
			}
			foreach (FMOD.Studio.EventInstance @event in events)
			{
				if (!@event.isValid())
				{
					needCleanup = true;
				}
				else
				{
					@event.set3DAttributes(base.transform.position.To3DAttributes());
				}
			}
			if (needCleanup)
			{
				events.RemoveAll((FMOD.Studio.EventInstance e) => !e.isValid());
				needCleanup = false;
			}
		}

		internal void SetParameterByName(string parameter, float value)
		{
			parameters[parameter] = value;
			foreach (FMOD.Studio.EventInstance @event in events)
			{
				if (!@event.isValid())
				{
					needCleanup = true;
				}
				else
				{
					@event.setParameterByName(parameter, value);
				}
			}
		}

		internal void SetParameterByNameWithLabel(string parameter, string label)
		{
			strParameters[parameter] = label;
			foreach (FMOD.Studio.EventInstance @event in events)
			{
				if (!@event.isValid())
				{
					needCleanup = true;
				}
				else
				{
					@event.setParameterByNameWithLabel(parameter, label);
				}
			}
		}

		private void ApplyParameters(FMOD.Studio.EventInstance eventInstance)
		{
			foreach (KeyValuePair<string, float> parameter in parameters)
			{
				eventInstance.setParameterByName(parameter.Key, parameter.Value);
			}
			foreach (KeyValuePair<string, string> strParameter in strParameters)
			{
				eventInstance.setParameterByNameWithLabel(strParameter.Key, strParameter.Value);
			}
		}

		internal void StopAll(FMOD.Studio.STOP_MODE mode = FMOD.Studio.STOP_MODE.IMMEDIATE)
		{
			foreach (FMOD.Studio.EventInstance @event in events)
			{
				if (!@event.isValid())
				{
					needCleanup = true;
				}
				else
				{
					@event.stop(mode);
				}
			}
		}
	}
	public interface IProgress
	{
		Progress GetProgress();
	}
	public struct Progress
	{
		public bool inProgress;

		public float total;

		public float current;

		public string progressName;

		public float progress
		{
			get
			{
				if (!(total <= 0f))
				{
					return Mathf.Clamp01(current / total);
				}
				return 1f;
			}
		}
	}
	public class ItemShortcut : MonoBehaviour
	{
		[Serializable]
		private class SaveData
		{
			[SerializeField]
			internal List<int> inventoryIndexes = new List<int>();

			public int Count => inventoryIndexes.Count;

			public void Generate(ItemShortcut shortcut)
			{
				inventoryIndexes.Clear();
				Inventory mainInventory = MainInventory;
				if (!(mainInventory == null))
				{
					for (int i = 0; i < shortcut.items.Count; i++)
					{
						Item item = shortcut.items[i];
						int index = mainInventory.GetIndex(item);
						inventoryIndexes.Add(index);
					}
				}
			}

			public void ApplyTo(ItemShortcut shortcut)
			{
				Inventory mainInventory = MainInventory;
				if (mainInventory == null)
				{
					return;
				}
				for (int i = 0; i < inventoryIndexes.Count; i++)
				{
					int num = inventoryIndexes[i];
					if (num >= 0)
					{
						Item itemAt = mainInventory.GetItemAt(num);
						shortcut.Set_Local(i, itemAt);
					}
				}
			}
		}

		public static ItemShortcut Instance;

		[SerializeField]
		private int maxIndex = 3;

		[SerializeField]
		private List<Item> items = new List<Item>();

		[SerializeField]
		private List<int> itemTypes = new List<int>();

		private const string SaveKey = "ItemShortcut_Data";

		private HashSet<int> dirtyIndexes = new HashSet<int>();

		private static CharacterMainControl Master => CharacterMainControl.Main;

		private static Inventory MainInventory
		{
			get
			{
				if (Master == null)
				{
					return null;
				}
				if (!Master.CharacterItem)
				{
					return null;
				}
				return Master.CharacterItem.Inventory;
			}
		}

		public static int MaxIndex
		{
			get
			{
				if (Instance == null)
				{
					return 0;
				}
				return Instance.maxIndex;
			}
		}

		public static event Action<int> OnSetItem;

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			else
			{
				UnityEngine.Debug.LogError("检测到多个ItemShortcut");
			}
			SavesSystem.OnCollectSaveData += OnCollectSaveData;
			SavesSystem.OnSetFile += OnSetSaveFile;
			LevelManager.OnLevelInitialized += OnLevelInitialized;
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= OnCollectSaveData;
			SavesSystem.OnSetFile -= OnSetSaveFile;
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void Start()
		{
			Load();
		}

		private void OnLevelInitialized()
		{
			Load();
		}

		private void OnSetSaveFile()
		{
			Load();
		}

		private void OnCollectSaveData()
		{
			Save();
		}

		private void Load()
		{
			SavesSystem.Load<SaveData>("ItemShortcut_Data")?.ApplyTo(this);
		}

		private void Save()
		{
			SaveData saveData = new SaveData();
			saveData.Generate(this);
			SavesSystem.Save("ItemShortcut_Data", saveData);
		}

		public static bool IsItemValid(Item item)
		{
			if (item == null)
			{
				return false;
			}
			if (MainInventory == null)
			{
				return false;
			}
			if (MainInventory != item.InInventory)
			{
				return false;
			}
			if (item.Tags.Contains("Weapon"))
			{
				return false;
			}
			return true;
		}

		private bool Set_Local(int index, Item item)
		{
			if (Master == null)
			{
				return false;
			}
			if (index < 0 || index > maxIndex)
			{
				return false;
			}
			if (!IsItemValid(item))
			{
				return false;
			}
			while (items.Count <= index)
			{
				items.Add(null);
			}
			while (itemTypes.Count <= index)
			{
				itemTypes.Add(-1);
			}
			items[index] = item;
			itemTypes[index] = item.TypeID;
			ItemShortcut.OnSetItem?.Invoke(index);
			for (int i = 0; i < items.Count; i++)
			{
				if (i != index)
				{
					bool flag = false;
					if (items[i] == item)
					{
						items[i] = null;
						flag = true;
					}
					if (itemTypes[i] == item.TypeID)
					{
						itemTypes[i] = -1;
						items[i] = null;
						flag = true;
					}
					if (flag)
					{
						ItemShortcut.OnSetItem(i);
					}
				}
			}
			return true;
		}

		private Item Get_Local(int index)
		{
			if (index >= items.Count)
			{
				return null;
			}
			Item item = items[index];
			if (item == null)
			{
				item = MainInventory.Find(itemTypes[index]);
				if (item != null)
				{
					items[index] = item;
				}
			}
			if (!IsItemValid(item))
			{
				SetDirty(index);
				return null;
			}
			return item;
		}

		private void SetDirty(int index)
		{
			dirtyIndexes.Add(index);
		}

		private void Update()
		{
			if (dirtyIndexes.Count <= 0)
			{
				return;
			}
			int[] array = dirtyIndexes.ToArray();
			foreach (int num in array)
			{
				if (num < items.Count && !IsItemValid(items[num]))
				{
					items[num] = null;
					ItemShortcut.OnSetItem?.Invoke(num);
				}
			}
			dirtyIndexes.Clear();
		}

		public static Item Get(int index)
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.Get_Local(index);
		}

		public static bool Set(int index, Item item)
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.Set_Local(index, item);
		}
	}
	public class CursorManager : MonoBehaviour
	{
		[SerializeField]
		private CursorData defaultCursor;

		public CursorData currentCursor;

		private static List<ICursorDataProvider> cursorDataStack = new List<ICursorDataProvider>();

		private int frame;

		private float fpsBuffer;

		public static CursorManager Instance { get; private set; }

		public static void Register(ICursorDataProvider dataProvider)
		{
			cursorDataStack.Add(dataProvider);
			ApplyStackData();
		}

		public static bool Unregister(ICursorDataProvider dataProvider)
		{
			if (cursorDataStack.Count < 1)
			{
				return false;
			}
			if (!cursorDataStack.Contains(dataProvider))
			{
				return false;
			}
			bool result = cursorDataStack.Remove(dataProvider);
			ApplyStackData();
			return result;
		}

		private static void ApplyStackData()
		{
			if (Instance == null)
			{
				return;
			}
			if (cursorDataStack.Count <= 0)
			{
				Instance.MSetDefaultCursor();
				return;
			}
			ICursorDataProvider cursorDataProvider = cursorDataStack[cursorDataStack.Count - 1];
			if (cursorDataProvider == null)
			{
				Instance.MSetDefaultCursor();
			}
			Instance.MSetCursor(cursorDataProvider.GetCursorData());
		}

		private void Awake()
		{
			Instance = this;
			MSetCursor(defaultCursor);
		}

		private void Update()
		{
			if (currentCursor != null && currentCursor.textures.Length >= 2)
			{
				fpsBuffer += Time.unscaledDeltaTime * currentCursor.fps;
				if (fpsBuffer > 1f)
				{
					fpsBuffer = 0f;
					frame++;
					RefreshCursor();
				}
			}
		}

		private void RefreshCursor()
		{
			if (currentCursor != null)
			{
				currentCursor.Apply(frame);
			}
		}

		public void MSetDefaultCursor()
		{
			MSetCursor(defaultCursor);
		}

		public void MSetCursor(CursorData data)
		{
			currentCursor = data;
			frame = 12;
			RefreshCursor();
		}

		private void OnDestroy()
		{
			UnityEngine.Cursor.SetCursor(null, default(Vector2), CursorMode.Auto);
		}

		internal static void NotifyRefresh()
		{
			ApplyStackData();
		}
	}
	[Serializable]
	public class CursorData
	{
		public Texture2D[] textures;

		public Vector2 hotspot;

		public float fps;

		public Texture2D texture
		{
			get
			{
				if (textures.Length == 0)
				{
					return null;
				}
				return textures[0];
			}
		}

		internal void Apply(int frame)
		{
			if (textures == null || textures.Length < 1)
			{
				UnityEngine.Cursor.SetCursor(null, default(Vector2), CursorMode.Auto);
				return;
			}
			if (frame < 0)
			{
				int num = textures.Length;
				frame = (-frame / textures.Length + 1) * num + frame;
			}
			frame %= textures.Length;
			UnityEngine.Cursor.SetCursor(textures[frame], hotspot, CursorMode.Auto);
		}
	}
	public interface ICursorDataProvider
	{
		CursorData GetCursorData();
	}
	public class EXPManager : MonoBehaviour, ISaveDataProvider
	{
		private static EXPManager instance;

		[SerializeField]
		private string levelChangeNotificationFormatKey = "UI_LevelChangeNotification";

		[SerializeField]
		private List<long> levelExpDefinition;

		[SerializeField]
		private long point;

		public static Action<long> onExpChanged;

		public static Action<int, int> onLevelChanged;

		private long cachedExp;

		private const string prefixKey = "EXP";

		private const string key = "Value";

		public static EXPManager Instance => instance;

		private string LevelChangeNotificationFormat => levelChangeNotificationFormatKey.ToPlainText();

		public static long EXP
		{
			get
			{
				if (instance == null)
				{
					return 0L;
				}
				return instance.point;
			}
			private set
			{
				if (!(instance == null))
				{
					int level = Level;
					instance.point = value;
					onExpChanged?.Invoke(value);
					int level2 = Level;
					if (level != level2)
					{
						OnLevelChanged(level, level2);
					}
				}
			}
		}

		public static int Level
		{
			get
			{
				if (instance == null)
				{
					return 0;
				}
				return instance.LevelFromExp(EXP);
			}
		}

		public static long CachedExp
		{
			get
			{
				if (instance == null)
				{
					return 0L;
				}
				return instance.cachedExp;
			}
		}

		private string realKey => "EXP_Value";

		private static void OnLevelChanged(int oldLevel, int newLevel)
		{
			onLevelChanged?.Invoke(oldLevel, newLevel);
			if (!(Instance == null))
			{
				NotificationText.Push(Instance.LevelChangeNotificationFormat.Format(new
				{
					level = newLevel
				}));
			}
		}

		public static bool AddExp(int amount)
		{
			if (instance == null)
			{
				return false;
			}
			EXP += amount;
			return true;
		}

		private void CacheExp()
		{
			cachedExp = point;
		}

		public object GenerateSaveData()
		{
			return point;
		}

		public void SetupSaveData(object data)
		{
			if (data is long num)
			{
				point = num;
			}
		}

		private void Load()
		{
			if (SavesSystem.KeyExisits(realKey))
			{
				long num = SavesSystem.Load<long>(realKey);
				SetupSaveData(num);
			}
		}

		private void Save()
		{
			object obj = GenerateSaveData();
			SavesSystem.Save(realKey, (long)obj);
		}

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Debug.LogWarning("检测到多个ExpManager");
			}
			SavesSystem.OnSetFile += Load;
			SavesSystem.OnCollectSaveData += Save;
			LevelManager.OnLevelInitialized += CacheExp;
		}

		private void Start()
		{
			Load();
			CacheExp();
		}

		private void OnDestroy()
		{
			SavesSystem.OnSetFile -= Load;
			SavesSystem.OnCollectSaveData -= Save;
			LevelManager.OnLevelInitialized -= CacheExp;
		}

		public int LevelFromExp(long exp)
		{
			for (int i = 0; i < levelExpDefinition.Count; i++)
			{
				long num = levelExpDefinition[i];
				if (exp < num)
				{
					return i - 1;
				}
			}
			return levelExpDefinition.Count - 1;
		}

		public (long from, long to) GetLevelExpRange(int level)
		{
			int num = levelExpDefinition.Count - 1;
			if (level >= num)
			{
				List<long> list = levelExpDefinition;
				return (from: list[list.Count - 1], to: long.MaxValue);
			}
			long item = levelExpDefinition[level];
			long item2 = levelExpDefinition[level + 1];
			return (from: item, to: item2);
		}
	}
	public class RichPresenceManager : MonoBehaviour
	{
		public bool isMainMenu = true;

		public bool isInLevel;

		public string levelDisplayNameRaw;

		public static Action<RichPresenceManager> OnInstanceChanged;

		public bool isPlaying => !isMainMenu;

		private void InvokeChangeEvent()
		{
			OnInstanceChanged?.Invoke(this);
		}

		private void Awake()
		{
			MainMenu.OnMainMenuAwake = (Action)Delegate.Combine(MainMenu.OnMainMenuAwake, new Action(OnMainMenuAwake));
			MainMenu.OnMainMenuDestroy = (Action)Delegate.Combine(MainMenu.OnMainMenuDestroy, new Action(OnMainMenuDestroy));
			MultiSceneCore.OnInstanceAwake += OnMultiSceneCoreInstanceAwake;
			MultiSceneCore.OnInstanceDestroy += OnMultiSceneCoreInstanceDestroy;
		}

		private void OnDestroy()
		{
			MainMenu.OnMainMenuAwake = (Action)Delegate.Remove(MainMenu.OnMainMenuAwake, new Action(OnMainMenuAwake));
			MainMenu.OnMainMenuDestroy = (Action)Delegate.Remove(MainMenu.OnMainMenuDestroy, new Action(OnMainMenuDestroy));
			MultiSceneCore.OnInstanceAwake -= OnMultiSceneCoreInstanceAwake;
			MultiSceneCore.OnInstanceDestroy -= OnMultiSceneCoreInstanceDestroy;
		}

		private void OnMainMenuAwake()
		{
			isMainMenu = true;
			InvokeChangeEvent();
		}

		private void OnMainMenuDestroy()
		{
			isMainMenu = false;
			InvokeChangeEvent();
		}

		private void OnMultiSceneCoreInstanceAwake(MultiSceneCore core)
		{
			levelDisplayNameRaw = core.DisplaynameRaw;
			isInLevel = true;
			InvokeChangeEvent();
		}

		private void OnMultiSceneCoreInstanceDestroy(MultiSceneCore core)
		{
			isInLevel = false;
			InvokeChangeEvent();
		}

		internal string GetSteamDisplay()
		{
			if (Application.isEditor)
			{
				return "#Status_UnityEditor";
			}
			if (!isMainMenu)
			{
				return "#Status_Playing";
			}
			return "#Status_MainMenu";
		}
	}
	[CreateAssetMenu(menuName = "Settings/MetaData")]
	public class GameMetaData : ScriptableObject
	{
		[SerializeField]
		private GameVersionData versionData;

		[SerializeField]
		private bool isTestVersion;

		[SerializeField]
		private bool isDemo;

		[SerializeField]
		private Platform platform;

		[SerializeField]
		private bool bloodFxOn = true;

		private static GameMetaData _instance;

		public VersionData Version
		{
			get
			{
				if (Instance == null)
				{
					return default(VersionData);
				}
				return Instance.versionData.versionData;
			}
		}

		public bool IsDemo => isDemo;

		public bool IsTestVersion
		{
			get
			{
				if (isTestVersion)
				{
					return true;
				}
				return false;
			}
		}

		public static GameMetaData Instance
		{
			get
			{
				if (_instance == null)
				{
					_instance = Resources.Load<GameMetaData>("MetaData");
				}
				return _instance;
			}
		}

		public static bool BloodFxOn => Instance.bloodFxOn;

		public Platform Platform
		{
			get
			{
				return platform;
			}
			set
			{
				platform = value;
			}
		}
	}
	[Serializable]
	public struct VersionData
	{
		public int mainVersion;

		public int subVersion;

		public int buildVersion;

		public string suffix;

		public override string ToString()
		{
			return $"{mainVersion}.{subVersion}.{buildVersion}{suffix}";
		}
	}
	[CreateAssetMenu(menuName = "Settings/Version Data")]
	public class GameVersionData : ScriptableObject
	{
		public VersionData versionData;
	}
	public static class PlatformInfo
	{
		private static Func<string> _getIDFunc;

		private static Func<string> _getDisplayNameFunc;

		public static Platform Platform
		{
			get
			{
				if (Application.isEditor)
				{
					return Platform.UnityEditor;
				}
				return GameMetaData.Instance.Platform;
			}
			set
			{
				GameMetaData.Instance.Platform = value;
			}
		}

		public static Func<string> GetIDFunc
		{
			get
			{
				return _getIDFunc;
			}
			set
			{
				_getIDFunc = value;
			}
		}

		public static Func<string> GetDisplayNameFunc
		{
			get
			{
				return _getDisplayNameFunc;
			}
			set
			{
				_getDisplayNameFunc = value;
			}
		}

		public static string GetID()
		{
			string text = null;
			if (GetIDFunc != null)
			{
				text = GetIDFunc();
			}
			if (text == null)
			{
				text = Environment.MachineName;
			}
			return text;
		}

		public static string GetDisplayName()
		{
			if (GetDisplayNameFunc != null)
			{
				return GetDisplayNameFunc();
			}
			return "UNKOWN";
		}
	}
	public enum Platform
	{
		Unknown,
		Steam,
		Epic,
		WeGame,
		Apple,
		UnityEditor,
		bilibili
	}
	public class GameVersionDisplay : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI text;

		private void Start()
		{
			text.text = $"v{GameMetaData.Instance.Version}";
		}
	}
	public class SocialManager : MonoBehaviour
	{
		private bool initialized;

		private IAchievement[] _achievement_cache;

		private void Awake()
		{
			AchievementManager.OnAchievementUnlocked += UnlockAchievement;
		}

		private void Start()
		{
			Social.localUser.Authenticate(ProcessAuthentication);
		}

		private void ProcessAuthentication(bool success)
		{
			if (success)
			{
				initialized = true;
				Social.LoadAchievements(ProcessLoadedAchievements);
			}
		}

		private void ProcessLoadedAchievements(IAchievement[] loadedAchievements)
		{
			_achievement_cache = loadedAchievements;
		}

		private void UnlockAchievement(string id)
		{
			if (!initialized)
			{
				Social.ReportProgress(id, 100.0, OnReportProgressResult);
			}
		}

		private void OnReportProgressResult(bool success)
		{
			Social.LoadAchievements(ProcessLoadedAchievements);
		}
	}
	public class CheatMode
	{
		private static bool _acitive;

		public static bool Active
		{
			get
			{
				return _acitive;
			}
			private set
			{
				_acitive = value;
				CheatMode.OnCheatModeStatusChanged?.Invoke(value);
			}
		}

		private bool Cheated => SavesSystem.Load<bool>("Cheated");

		public static event Action<bool> OnCheatModeStatusChanged;

		public static void Activate()
		{
			if (CheatFileExists())
			{
				Active = true;
				SavesSystem.Save("Cheated", value: true);
			}
		}

		public static void Deactivate()
		{
			Active = false;
		}

		private static bool CheatFileExists()
		{
			return File.Exists(System.IO.Path.Join(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "WWSSADADBA"));
		}
	}
	public class DeadBodyManager : MonoBehaviour
	{
		[Serializable]
		public class DeathInfo
		{
			public bool valid;

			public uint raidID;

			public string subSceneID;

			public Vector3 worldPosition;

			public ItemTreeData itemTreeData;

			public bool spawned;

			public bool touched;
		}

		private List<DeathInfo> deaths = new List<DeathInfo>();

		public static DeadBodyManager Instance { get; private set; }

		private void AppendDeathInfo(DeathInfo deathInfo)
		{
			while (deaths.Count >= GameRulesManager.Current.SaveDeadbodyCount)
			{
				deaths.RemoveAt(0);
			}
			deaths.Add(deathInfo);
			Save();
		}

		private static List<DeathInfo> LoadDeathInfos()
		{
			return SavesSystem.Load<List<DeathInfo>>("DeathList");
		}

		internal static void RecordDeath(CharacterMainControl mainCharacter)
		{
			if (Instance == null)
			{
				UnityEngine.Debug.LogError("DeadBodyManager Instance is null");
				return;
			}
			DeathInfo deathInfo = new DeathInfo();
			deathInfo.valid = true;
			deathInfo.raidID = RaidUtilities.CurrentRaid.ID;
			deathInfo.subSceneID = MultiSceneCore.ActiveSubSceneID;
			deathInfo.worldPosition = mainCharacter.transform.position;
			deathInfo.itemTreeData = ItemTreeData.FromItem(mainCharacter.CharacterItem);
			Instance.AppendDeathInfo(deathInfo);
		}

		private void Awake()
		{
			Instance = this;
			MultiSceneCore.OnSubSceneLoaded += OnSubSceneLoaded;
			deaths.Clear();
			List<DeathInfo> list = LoadDeathInfos();
			if (list != null)
			{
				deaths.AddRange(list);
			}
			SavesSystem.OnCollectSaveData += Save;
		}

		private void OnDestroy()
		{
			MultiSceneCore.OnSubSceneLoaded -= OnSubSceneLoaded;
			SavesSystem.OnCollectSaveData -= Save;
		}

		private void Save()
		{
			SavesSystem.Save("DeathList", deaths);
		}

		private void OnSubSceneLoaded(MultiSceneCore core, Scene scene)
		{
			LevelManager.LevelInitializingComment = "Spawning bodies";
			if (!LevelConfig.SpawnTomb)
			{
				return;
			}
			foreach (DeathInfo death in deaths)
			{
				if (ShouldSpawnDeadBody(death))
				{
					SpawnDeadBody(death).Forget();
				}
			}
		}

		private async UniTask SpawnDeadBody(DeathInfo info)
		{
			Item item = await ItemTreeData.InstantiateAsync(info.itemTreeData);
			if (!(item == null))
			{
				Vector3 worldPosition = info.worldPosition;
				_ = info.subSceneID;
				InteractableLootbox.CreateFromItem(item, worldPosition, Quaternion.identity, moveToMainScene: true, GameplayDataSettings.Prefabs.LootBoxPrefab_Tomb, filterDontDropOnDead: true).OnInteractStartEvent.AddListener(delegate
				{
					NotifyDeadbodyTouched(info);
				});
				info.spawned = true;
			}
		}

		private static void NotifyDeadbodyTouched(DeathInfo info)
		{
			if (!(Instance == null))
			{
				Instance.OnDeadbodyTouched(info);
			}
		}

		private void OnDeadbodyTouched(DeathInfo info)
		{
			DeathInfo deathInfo = deaths.Find((DeathInfo e) => e.raidID == info.raidID);
			if (deathInfo != null)
			{
				deathInfo.touched = true;
			}
		}

		private bool ShouldSpawnDeadBody(DeathInfo info)
		{
			if (info == null)
			{
				return false;
			}
			if (!GameRulesManager.Current.SpawnDeadBody)
			{
				return false;
			}
			if (!LevelManager.Instance)
			{
				return false;
			}
			if (!LevelManager.Instance.IsRaidMap)
			{
				return false;
			}
			if (info == null)
			{
				return false;
			}
			if (!info.valid)
			{
				return false;
			}
			if (info.touched)
			{
				return false;
			}
			if (MultiSceneCore.ActiveSubSceneID != info.subSceneID)
			{
				return false;
			}
			return true;
		}
	}
	public class ItemUnlockNotification : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private FadeGroup mainFadeGroup;

		[SerializeField]
		private FadeGroup contentFadeGroup;

		[SerializeField]
		private UnityEngine.UI.Image image;

		[SerializeField]
		private TrueShadow shadow;

		[SerializeField]
		private TextMeshProUGUI textMain;

		[SerializeField]
		private TextMeshProUGUI textSub;

		[SerializeField]
		private float contentDelay = 0.5f;

		[SerializeField]
		[LocalizationKey("Default")]
		private string mainTextFormatKey = "UI_ItemUnlockNotification";

		[SerializeField]
		[LocalizationKey("Default")]
		private string subTextFormatKey = "UI_ItemUnlockNotification_Sub";

		private static List<int> pending = new List<int>();

		private UniTask showingTask;

		private bool pointerClicked;

		public string MainTextFormat => mainTextFormatKey.ToPlainText();

		private string SubTextFormat => subTextFormatKey.ToPlainText();

		public static ItemUnlockNotification Instance { get; private set; }

		private bool showing => showingTask.Status == UniTaskStatus.Pending;

		public static bool Showing
		{
			get
			{
				if (Instance == null)
				{
					return false;
				}
				return Instance.showing;
			}
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
		}

		private void Update()
		{
			if (!showing && pending.Count > 0)
			{
				BeginShow();
			}
		}

		private void BeginShow()
		{
			showingTask = ShowTask();
		}

		private async UniTask ShowTask()
		{
			await mainFadeGroup.ShowAndReturnTask();
			await UniTask.WaitForSeconds(contentDelay, ignoreTimeScale: true);
			while (pending.Count > 0)
			{
				int itemTypeID = pending[0];
				pending.RemoveAt(0);
				await DisplayContent(itemTypeID);
			}
			await mainFadeGroup.HideAndReturnTask();
		}

		private async UniTask DisplayContent(int itemTypeID)
		{
			Setup(itemTypeID);
			await contentFadeGroup.ShowAndReturnTask();
			pointerClicked = false;
			while (!pointerClicked)
			{
				await UniTask.NextFrame();
			}
			await contentFadeGroup.HideAndReturnTask();
		}

		private void Setup(int itemTypeID)
		{
			ItemMetaData metaData = ItemAssetsCollection.GetMetaData(itemTypeID);
			string displayName = metaData.DisplayName;
			Sprite icon = metaData.icon;
			image.sprite = icon;
			textMain.text = MainTextFormat.Format(new
			{
				itemDisplayName = displayName
			});
			textSub.text = SubTextFormat;
			DisplayQuality displayQuality = metaData.displayQuality;
			GameplayDataSettings.UIStyle.GetDisplayQualityLook(displayQuality).Apply(shadow);
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			pointerClicked = true;
		}

		public static void Push(int itemTypeID)
		{
			pending.Add(itemTypeID);
		}
	}
	public class StrongNotification : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private FadeGroup mainFadeGroup;

		[SerializeField]
		private FadeGroup contentFadeGroup;

		[SerializeField]
		private TextMeshProUGUI textMain;

		[SerializeField]
		private TextMeshProUGUI textSub;

		[SerializeField]
		private UnityEngine.UI.Image image;

		[SerializeField]
		private float contentDelay = 0.5f;

		private static List<StrongNotificationContent> pending = new List<StrongNotificationContent>();

		private UniTask showingTask;

		private bool confirmed;

		public static StrongNotification Instance { get; private set; }

		private bool showing => showingTask.Status == UniTaskStatus.Pending;

		public static bool Showing
		{
			get
			{
				if (Instance == null)
				{
					return false;
				}
				return Instance.showing;
			}
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			UIInputManager.OnConfirm += OnConfirm;
			UIInputManager.OnCancel += OnCancel;
			View.OnActiveViewChanged += View_OnActiveViewChanged;
		}

		private void OnDestroy()
		{
			UIInputManager.OnConfirm -= OnConfirm;
			UIInputManager.OnCancel -= OnCancel;
			View.OnActiveViewChanged -= View_OnActiveViewChanged;
		}

		private void View_OnActiveViewChanged()
		{
			confirmed = true;
		}

		private void OnCancel(UIInputEventData data)
		{
			confirmed = true;
		}

		private void OnConfirm(UIInputEventData data)
		{
			confirmed = true;
		}

		private void Update()
		{
			if (!showing && pending.Count > 0)
			{
				BeginShow();
			}
		}

		private void BeginShow()
		{
			showingTask = ShowTask();
		}

		private async UniTask ShowTask()
		{
			await mainFadeGroup.ShowAndReturnTask();
			await UniTask.WaitForSeconds(contentDelay, ignoreTimeScale: true);
			while (pending.Count > 0)
			{
				StrongNotificationContent cur = pending[0];
				pending.RemoveAt(0);
				await DisplayContent(cur);
			}
			await mainFadeGroup.HideAndReturnTask();
		}

		private async UniTask DisplayContent(StrongNotificationContent cur)
		{
			if (cur != null)
			{
				textMain.text = cur.mainText;
				textSub.text = cur.subText;
				if (cur.image != null)
				{
					image.sprite = cur.image;
					image.gameObject.SetActive(value: true);
				}
				else
				{
					image.gameObject.SetActive(value: false);
				}
				await contentFadeGroup.ShowAndReturnTask();
				confirmed = false;
				while (!confirmed)
				{
					await UniTask.NextFrame();
				}
				await contentFadeGroup.HideAndReturnTask();
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			confirmed = true;
		}

		public static void Push(StrongNotificationContent content)
		{
			pending.Add(content);
		}

		public static void Push(string mainText, string subText = "")
		{
			pending.Add(new StrongNotificationContent(mainText, subText));
		}
	}
	public class StrongNotificationContent
	{
		public string mainText;

		public string subText;

		public Sprite image;

		public StrongNotificationContent(string mainText, string subText = "", Sprite image = null)
		{
			this.mainText = mainText;
			this.subText = subText;
			this.image = image;
		}
	}
}
namespace Duckov.Weathers
{
	public class WeatherManager : MonoBehaviour
	{
		[Serializable]
		private struct SaveData
		{
			public bool valid;

			public int seed;

			public SaveData(WeatherManager weatherManager)
			{
				this = default(SaveData);
				seed = weatherManager.seed;
				valid = true;
			}

			internal void Setup(WeatherManager weatherManager)
			{
				weatherManager.seed = seed;
			}
		}

		private int seed = -1;

		[SerializeField]
		private Storm storm = new Storm();

		[SerializeField]
		private Precipitation precipitation = new Precipitation();

		private const string SaveKey = "WeatherManagerData";

		private Weather _cachedWeather;

		private TimeSpan _cachedDayAndTime;

		private bool _weatherDirty;

		public static WeatherManager Instance { get; private set; }

		public bool ForceWeather { get; set; }

		public Weather ForceWeatherValue { get; set; }

		public Storm Storm => storm;

		private void Awake()
		{
			Instance = this;
			SavesSystem.OnCollectSaveData += Save;
			Load();
			_weatherDirty = true;
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
		}

		private void Save()
		{
			SavesSystem.Save("WeatherManagerData", new SaveData(this));
		}

		private void Load()
		{
			SaveData saveData = SavesSystem.Load<SaveData>("WeatherManagerData");
			if (!saveData.valid)
			{
				SetRandomKey();
			}
			else
			{
				saveData.Setup(this);
			}
			SetupModules();
		}

		private void SetRandomKey()
		{
			seed = UnityEngine.Random.Range(0, 100000);
		}

		private void SetupModules()
		{
			precipitation.SetSeed(seed);
		}

		private Weather M_GetWeather(TimeSpan dayAndTime)
		{
			if (ForceWeather)
			{
				return ForceWeatherValue;
			}
			if (!_weatherDirty && dayAndTime == _cachedDayAndTime)
			{
				return _cachedWeather;
			}
			int stormLevel = storm.GetStormLevel(dayAndTime);
			Weather weather;
			if (stormLevel > 0)
			{
				weather = ((stormLevel != 1) ? Weather.Stormy_II : Weather.Stormy_I);
			}
			else
			{
				float num = precipitation.Get(dayAndTime);
				weather = ((num > precipitation.RainyThreshold) ? Weather.Rainy : ((num > precipitation.CloudyThreshold) ? Weather.Cloudy : Weather.Sunny));
			}
			_cachedDayAndTime = dayAndTime;
			_cachedWeather = weather;
			_weatherDirty = false;
			return weather;
		}

		private void M_SetForceWeather(bool forceWeather, Weather value = Weather.Sunny)
		{
			ForceWeather = forceWeather;
			ForceWeatherValue = value;
		}

		public static Weather GetWeather(TimeSpan dayAndTime)
		{
			if (Instance == null)
			{
				return Weather.Sunny;
			}
			return Instance.M_GetWeather(dayAndTime);
		}

		public static Weather GetWeather()
		{
			TimeSpan now = GameClock.Now;
			if ((bool)Instance && Instance.ForceWeather)
			{
				return Instance.ForceWeatherValue;
			}
			return GetWeather(now);
		}

		public static void SetForceWeather(bool forceWeather, Weather value = Weather.Sunny)
		{
			if (!(Instance == null))
			{
				Instance.M_SetForceWeather(forceWeather, value);
			}
		}
	}
	public enum Weather
	{
		Sunny,
		Cloudy,
		Rainy,
		Stormy_I,
		Stormy_II
	}
	[Serializable]
	public class Storm
	{
		[SerializeField]
		[TimeSpan]
		private long offset;

		[SerializeField]
		[TimeSpan]
		private long sleepTime;

		[SerializeField]
		[TimeSpan]
		private long stage1Time;

		[SerializeField]
		[TimeSpan]
		private long stage2Time;

		[TimeSpan]
		private long Period => sleepTime + stage1Time + stage2Time;

		public int GetStormLevel(TimeSpan dayAndTime)
		{
			long num = (dayAndTime.Ticks + offset) % Period;
			if (num < sleepTime)
			{
				return 0;
			}
			if (num < sleepTime + stage1Time)
			{
				return 1;
			}
			return 2;
		}

		public TimeSpan GetStormETA(TimeSpan dayAndTime)
		{
			long num = (dayAndTime.Ticks + offset) % Period;
			if (num < sleepTime)
			{
				return TimeSpan.FromTicks(sleepTime - num);
			}
			return TimeSpan.Zero;
		}

		public TimeSpan GetStormIOverETA(TimeSpan dayAndTime)
		{
			long num = (dayAndTime.Ticks + offset) % Period;
			return TimeSpan.FromTicks(sleepTime + stage1Time - num);
		}

		public TimeSpan GetStormIIOverETA(TimeSpan dayAndTime)
		{
			long num = (dayAndTime.Ticks + offset) % Period;
			return TimeSpan.FromTicks(Period - num);
		}

		public float GetSleepPercent(TimeSpan dayAndTime)
		{
			return (float)((dayAndTime.Ticks + offset) % Period) / (float)sleepTime;
		}

		public float GetStormRemainPercent(TimeSpan dayAndTime)
		{
			long num = (dayAndTime.Ticks + offset) % Period - sleepTime;
			return 1f - (float)num / ((float)stage1Time + (float)stage2Time);
		}
	}
	[Serializable]
	public class Precipitation
	{
		[SerializeField]
		private int seed;

		[SerializeField]
		[Range(0f, 1f)]
		private float cloudyThreshold;

		[SerializeField]
		[Range(0f, 1f)]
		private float rainyThreshold;

		[SerializeField]
		private float frequency = 1f;

		[SerializeField]
		private float offset;

		[SerializeField]
		private float contrast = 1f;

		public float CloudyThreshold => cloudyThreshold;

		public float RainyThreshold => rainyThreshold;

		public bool IsRainy(TimeSpan dayAndTime)
		{
			return Get(dayAndTime) > rainyThreshold;
		}

		public bool IsCloudy(TimeSpan dayAndTime)
		{
			return Get(dayAndTime) > cloudyThreshold;
		}

		public float Get(TimeSpan dayAndTime)
		{
			Vector2 perlinNoiseCoord = GetPerlinNoiseCoord(dayAndTime);
			return Mathf.Clamp01(((Mathf.PerlinNoise(perlinNoiseCoord.x, perlinNoiseCoord.y) + Mathf.PerlinNoise(perlinNoiseCoord.x + 0.5f + 123.4f, perlinNoiseCoord.y - 567.8f)) / 2f - 0.5f) * contrast + 0.5f + offset);
		}

		public Vector2 GetPerlinNoiseCoord(TimeSpan dayAndTime)
		{
			float num = (float)(dayAndTime.Days % 3650) * 24f + (float)dayAndTime.Hours + (float)dayAndTime.Minutes / 60f;
			int num2 = dayAndTime.Days / 3650;
			return new Vector2(num * frequency, seed + num2);
		}

		internal void SetSeed(int seed)
		{
			this.seed = seed;
		}

		public float Get()
		{
			TimeSpan now = GameClock.Now;
			return Get(now);
		}

		public bool IsRainy()
		{
			TimeSpan now = GameClock.Now;
			return IsRainy(now);
		}

		public bool IsCloudy()
		{
			TimeSpan now = GameClock.Now;
			return IsCloudy(now);
		}
	}
}
namespace Duckov.Tips
{
	public class TipsDisplay : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private TipEntry[] entries;

		[SerializeField]
		private UnityEngine.CanvasGroup canvasGroup;

		public void DisplayRandom()
		{
			if (entries.Length != 0)
			{
				TipEntry tipEntry = entries[UnityEngine.Random.Range(0, entries.Length)];
				text.text = tipEntry.Description;
			}
		}

		public void Display(string tipID)
		{
			TipEntry tipEntry = entries.FirstOrDefault((TipEntry e) => e.TipID == tipID);
			if (!(tipEntry.TipID != tipID))
			{
				text.text = tipEntry.Description;
			}
		}

		private void OnEnable()
		{
			canvasGroup.alpha = (SceneLoader.HideTips ? 0f : 1f);
			DisplayRandom();
		}
	}
	[Serializable]
	internal struct TipEntry
	{
		[SerializeField]
		private string tipID;

		public string TipID => tipID;

		[LocalizationKey("Default")]
		public string DescriptionKey
		{
			get
			{
				return "Tips_" + tipID;
			}
			set
			{
			}
		}

		public string Description => DescriptionKey.ToPlainText();
	}
}
namespace Duckov.Sounds
{
	public class SoundDisplay : MonoBehaviour
	{
		[SerializeField]
		private UnityEngine.UI.Image image;

		[SerializeField]
		private float removeRecordAfterTime = 1f;

		[SerializeField]
		private float triggerVelocity = 10f;

		[SerializeField]
		private float gravity = 1f;

		[SerializeField]
		private float untriggerVelocity = 100f;

		private float value;

		private float velocity;

		private AISound sound;

		public float Value => value;

		public AISound CurrentSount => sound;

		internal void Trigger(AISound sound)
		{
			this.sound = sound;
			base.gameObject.SetActive(value: true);
			velocity = triggerVelocity;
			value += velocity * Time.deltaTime;
		}

		private void Update()
		{
			velocity -= gravity * Time.deltaTime;
			value += velocity * Time.deltaTime;
			if (value > 1f || value < 0f)
			{
				velocity = 0f;
			}
			value = Mathf.Clamp01(value);
			image.color = new Color(1f, 1f, 1f, value);
		}
	}
	public class SoundVisualization : MonoBehaviour
	{
		[SerializeField]
		private RectTransform layoutCenter;

		[SerializeField]
		private SoundDisplay displayTemplate;

		[SerializeField]
		private float retriggerDistanceThreshold = 1f;

		[SerializeField]
		private float displayOffset = 400f;

		private PrefabPool<SoundDisplay> _displayPool;

		private Queue<SoundDisplay> releaseBuffer = new Queue<SoundDisplay>();

		private PrefabPool<SoundDisplay> DisplayPool
		{
			get
			{
				if (_displayPool == null)
				{
					_displayPool = new PrefabPool<SoundDisplay>(displayTemplate);
				}
				return _displayPool;
			}
		}

		private void Awake()
		{
			AIMainBrain.OnPlayerHearSound += OnHeardSound;
			if (layoutCenter == null)
			{
				layoutCenter = base.transform as RectTransform;
			}
		}

		private void OnDestroy()
		{
			AIMainBrain.OnPlayerHearSound -= OnHeardSound;
		}

		private void Update()
		{
			foreach (SoundDisplay activeEntry in DisplayPool.ActiveEntries)
			{
				if (activeEntry.Value <= 0f)
				{
					releaseBuffer.Enqueue(activeEntry);
				}
				else
				{
					RefreshEntryPosition(activeEntry);
				}
			}
			while (releaseBuffer.Count > 0)
			{
				SoundDisplay soundDisplay = releaseBuffer.Dequeue();
				if (!(soundDisplay == null))
				{
					DisplayPool.Release(soundDisplay);
				}
			}
		}

		private void OnHeardSound(AISound sound)
		{
			Trigger(sound);
		}

		private void Trigger(AISound sound)
		{
			if (GameCamera.Instance == null)
			{
				return;
			}
			SoundDisplay soundDisplay = null;
			if (sound.fromCharacter != null)
			{
				foreach (SoundDisplay activeEntry in DisplayPool.ActiveEntries)
				{
					AISound currentSount = activeEntry.CurrentSount;
					if (!(currentSount.fromCharacter != sound.fromCharacter) && currentSount.soundType == sound.soundType && Vector3.Distance(currentSount.pos, sound.pos) < retriggerDistanceThreshold)
					{
						soundDisplay = activeEntry;
					}
				}
			}
			if (soundDisplay == null)
			{
				soundDisplay = DisplayPool.Get();
			}
			RefreshEntryPosition(soundDisplay);
			soundDisplay.Trigger(sound);
		}

		private void RefreshEntryPosition(SoundDisplay e)
		{
			Vector3 pos = e.CurrentSount.pos;
			Vector2 screenPoint = RectTransformUtility.WorldToScreenPoint(GameCamera.Instance.renderCamera, pos);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(layoutCenter, screenPoint, null, out var localPoint);
			Vector2 normalized = localPoint.normalized;
			e.transform.localPosition = normalized * displayOffset;
			e.transform.rotation = Quaternion.FromToRotation(Vector2.up, normalized);
		}
	}
}
namespace Duckov.PerkTrees
{
	public class Perk : MonoBehaviour, ISelfValidator
	{
		[SerializeField]
		private PerkTree master;

		[SerializeField]
		private bool lockInDemo;

		[SerializeField]
		private Sprite icon;

		[SerializeField]
		private DisplayQuality quality;

		[LocalizationKey("Perks")]
		[SerializeField]
		private string displayName = "未命名技能";

		[SerializeField]
		private bool hasDescription;

		[SerializeField]
		private PerkRequirement requirement;

		[SerializeField]
		private bool defaultUnlocked;

		[SerializeField]
		internal bool unlocking;

		[DateTime]
		[SerializeField]
		internal long unlockingBeginTimeRaw;

		[SerializeField]
		private bool _unlocked;

		public bool LockInDemo => lockInDemo;

		public DisplayQuality DisplayQuality => quality;

		public Sprite Icon => icon;

		[LocalizationKey("Perks")]
		private string description
		{
			get
			{
				if (!hasDescription)
				{
					return string.Empty;
				}
				return displayName + "_Desc";
			}
			set
			{
			}
		}

		public string DisplayName => displayName.ToPlainText();

		public string Description
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				string value = description.ToPlainText();
				if (!string.IsNullOrEmpty(value))
				{
					stringBuilder.AppendLine(value);
				}
				PerkBehaviour[] components = GetComponents<PerkBehaviour>();
				for (int i = 0; i < components.Length; i++)
				{
					string value2 = components[i].Description;
					if (!string.IsNullOrEmpty(value2))
					{
						stringBuilder.AppendLine(value2);
					}
				}
				return stringBuilder.ToString();
			}
		}

		public PerkRequirement Requirement => requirement;

		public bool DefaultUnlocked => defaultUnlocked;

		private DateTime UnlockingBeginTime
		{
			get
			{
				DateTime dateTime = DateTime.FromBinary(unlockingBeginTimeRaw);
				if (dateTime > DateTime.UtcNow)
				{
					dateTime = DateTime.UtcNow;
					unlockingBeginTimeRaw = DateTime.UtcNow.ToBinary();
					GameManager.TimeTravelDetected();
				}
				return dateTime;
			}
		}

		public bool Unlocked
		{
			get
			{
				return _unlocked;
			}
			internal set
			{
				_unlocked = value;
				this.onUnlockStateChanged?.Invoke(this, value);
			}
		}

		public bool Unlocking => unlocking;

		public PerkTree Master
		{
			get
			{
				return master;
			}
			internal set
			{
				master = value;
			}
		}

		public string DisplayNameRaw => displayName;

		public string DescriptionRaw => description;

		public event Action<Perk, bool> onUnlockStateChanged;

		public static event Action<Perk> OnPerkUnlockConfirmed;

		public bool AreAllParentsUnlocked()
		{
			return master.AreAllParentsUnlocked(this);
		}

		private void OnValidate()
		{
			if (master == null)
			{
				master = GetComponentInParent<PerkTree>();
			}
		}

		private bool CheckAndPay()
		{
			if (requirement == null)
			{
				return true;
			}
			if (EXPManager.Level < requirement.level)
			{
				return false;
			}
			if (!requirement.cost.Pay())
			{
				return false;
			}
			return true;
		}

		public bool SubmitItemsAndBeginUnlocking()
		{
			if (Unlocked)
			{
				UnityEngine.Debug.LogError("Perk " + displayName + " already unlocked!");
				return false;
			}
			if (!CheckAndPay())
			{
				return false;
			}
			unlocking = true;
			unlockingBeginTimeRaw = DateTime.UtcNow.ToBinary();
			master.NotifyChildStateChanged(this);
			this.onUnlockStateChanged?.Invoke(this, _unlocked);
			return true;
		}

		public bool ConfirmUnlock()
		{
			if (Unlocked)
			{
				return false;
			}
			if (!unlocking)
			{
				return false;
			}
			if (DateTime.UtcNow - UnlockingBeginTime < requirement.RequireTime)
			{
				return false;
			}
			Unlocked = true;
			unlocking = false;
			master.NotifyChildStateChanged(this);
			Perk.OnPerkUnlockConfirmed?.Invoke(this);
			return true;
		}

		public bool ForceUnlock()
		{
			if (Unlocked)
			{
				return false;
			}
			UnityEngine.Debug.Log("Unlock default:" + displayName);
			Unlocked = true;
			unlocking = false;
			master.NotifyChildStateChanged(this);
			return true;
		}

		public TimeSpan GetRemainingTime()
		{
			if (Unlocked)
			{
				return TimeSpan.Zero;
			}
			if (!unlocking)
			{
				return TimeSpan.Zero;
			}
			TimeSpan timeSpan = DateTime.UtcNow - UnlockingBeginTime;
			TimeSpan timeSpan2 = requirement.RequireTime - timeSpan;
			if (timeSpan2 < TimeSpan.Zero)
			{
				return TimeSpan.Zero;
			}
			return timeSpan2;
		}

		public float GetProgress01()
		{
			TimeSpan remainingTime = GetRemainingTime();
			double totalSeconds = requirement.RequireTime.TotalSeconds;
			if (totalSeconds <= 0.0)
			{
				return 1f;
			}
			double totalSeconds2 = remainingTime.TotalSeconds;
			return 1f - (float)(totalSeconds2 / totalSeconds);
		}

		public void Validate(SelfValidationResult result)
		{
			if (master == null)
			{
				result.AddWarning("未指定PerkTree");
			}
			if (!master)
			{
				return;
			}
			if (!master.Perks.Contains(this))
			{
				result.AddError("PerkTree未包含此Perk").WithFix(delegate
				{
					master.perks.Add(this);
				});
			}
			if (master?.RelationGraphOwner?.GetRelatedNode(this) == null)
			{
				result.AddError("未在Graph中指定技能的关系");
			}
		}

		internal Vector2 GetLayoutPosition()
		{
			if (master == null)
			{
				return Vector2.zero;
			}
			return (master.RelationGraphOwner?.GetRelatedNode(this)).cachedPosition;
		}

		internal void NotifyParentStateChanged()
		{
			this.onUnlockStateChanged?.Invoke(this, Unlocked);
		}
	}
	[Serializable]
	public class PerkRequirement
	{
		[Serializable]
		public class RequireItemEntry
		{
			[ItemTypeID]
			public int id = 1;

			public int amount = 1;
		}

		public int level;

		public Cost cost;

		[TimeSpan]
		public long requireTime;

		public TimeSpan RequireTime => TimeSpan.FromTicks(requireTime);

		internal bool AreSatisfied()
		{
			if (level > EXPManager.Level)
			{
				return false;
			}
			if (!cost.Enough)
			{
				return false;
			}
			return true;
		}
	}
	[RequireComponent(typeof(Perk))]
	public abstract class PerkBehaviour : MonoBehaviour
	{
		private Perk master;

		protected Perk Master => master;

		private bool Unlocked
		{
			get
			{
				if (master == null)
				{
					return false;
				}
				return master.Unlocked;
			}
		}

		public virtual string Description => "";

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponent<Perk>();
			}
			master.onUnlockStateChanged += OnMasterUnlockStateChanged;
			LevelManager.OnLevelInitialized += OnLevelInitialized;
			if (LevelManager.LevelInited)
			{
				OnLevelInitialized();
			}
			OnAwake();
		}

		private void OnLevelInitialized()
		{
			NotifyUnlockStateChanged(Unlocked);
		}

		private void OnDestroy()
		{
			OnOnDestroy();
			if (!(master == null))
			{
				master.onUnlockStateChanged -= OnMasterUnlockStateChanged;
				LevelManager.OnLevelInitialized -= OnLevelInitialized;
			}
		}

		private void OnValidate()
		{
			if (master == null)
			{
				master = GetComponent<Perk>();
			}
		}

		private void OnMasterUnlockStateChanged(Perk perk, bool unlocked)
		{
			if (perk != master)
			{
				UnityEngine.Debug.LogError("Perk对象不匹配");
			}
			NotifyUnlockStateChanged(unlocked);
		}

		private void NotifyUnlockStateChanged(bool unlocked)
		{
			OnUnlockStateChanged(unlocked);
			if (unlocked)
			{
				OnUnlocked();
			}
			else
			{
				OnLocked();
			}
		}

		protected virtual void OnUnlockStateChanged(bool unlocked)
		{
		}

		protected virtual void OnUnlocked()
		{
		}

		protected virtual void OnLocked()
		{
		}

		protected virtual void OnAwake()
		{
		}

		protected virtual void OnOnDestroy()
		{
		}
	}
	public class AddGardenSize : PerkBehaviour, IGardenSizeAdder
	{
		[LocalizationKey("Default")]
		[SerializeField]
		private string descriptionFormatKey = "PerkBehaviour_AddGardenSize";

		[SerializeField]
		private string gardenID = "Default";

		[SerializeField]
		private Vector2Int add;

		public override string Description => descriptionFormatKey.ToPlainText().Format(new
		{
			addX = add.x,
			addY = add.y
		});

		protected override void OnUnlocked()
		{
			Garden.Register(this);
		}

		protected override void OnOnDestroy()
		{
			Garden.Unregister(this);
		}

		public Vector2Int GetValue(string gardenID)
		{
			if (gardenID != this.gardenID)
			{
				return default(Vector2Int);
			}
			return add;
		}
	}
	public class AddPlayerStorage : PerkBehaviour
	{
		[SerializeField]
		private int addCapacity;

		private string DescriptionFormat => "PerkBehaviour_AddPlayerStorage".ToPlainText();

		public override string Description => DescriptionFormat.Format(new { addCapacity });

		protected override void OnAwake()
		{
			PlayerStorage.OnRecalculateStorageCapacity += OnRecalculatePlayerStorage;
		}

		protected override void OnOnDestroy()
		{
			PlayerStorage.OnRecalculateStorageCapacity -= OnRecalculatePlayerStorage;
		}

		private void OnRecalculatePlayerStorage(PlayerStorage.StorageCapacityCalculationHolder holder)
		{
			if (base.Master.Unlocked)
			{
				holder.capacity += addCapacity;
			}
		}

		protected override void OnUnlocked()
		{
			base.OnUnlocked();
			PlayerStorage.NotifyCapacityDirty();
		}
	}
	public class GardenAutoWater : PerkBehaviour, IGardenAutoWaterProvider
	{
		[SerializeField]
		[LocalizationKey("Default")]
		private string descriptionKey = "PerkBehaviour_GardenAutoWater";

		[SerializeField]
		private string gardenID = "Default";

		public override string Description => descriptionKey.ToPlainText();

		protected override void OnUnlocked()
		{
			Garden.Register(this);
		}

		protected override void OnOnDestroy()
		{
			Garden.Unregister(this);
		}

		public bool TakeEffect(string gardenID)
		{
			return gardenID == this.gardenID;
		}
	}
	public class PerkTree : MonoBehaviour, ISaveDataProvider
	{
		[Serializable]
		private class SaveData
		{
			[Serializable]
			public class Entry
			{
				public string perkName;

				public bool unlocking;

				public long unlockingBeginTime;

				public bool unlocked;

				public Entry(Perk perk)
				{
					perkName = perk.name;
					unlocked = perk.Unlocked;
					unlocking = perk.Unlocking;
					unlockingBeginTime = perk.unlockingBeginTimeRaw;
				}
			}

			public List<Entry> entries;

			public SaveData(PerkTree perkTree)
			{
				entries = new List<Entry>();
				for (int i = 0; i < perkTree.perks.Count; i++)
				{
					Perk perk = perkTree.perks[i];
					if (!(perk == null))
					{
						entries.Add(new Entry(perk));
					}
				}
			}
		}

		[SerializeField]
		private string perkTreeID = "DefaultPerkTree";

		[SerializeField]
		private bool horizontal;

		[SerializeField]
		private PerkTreeRelationGraphOwner relationGraphOwner;

		[SerializeField]
		internal List<Perk> perks = new List<Perk>();

		private ReadOnlyCollection<Perk> perks_ReadOnly;

		private bool loaded;

		[LocalizationKey("Perks")]
		private string perkTreeName
		{
			get
			{
				return displayNameKey;
			}
			set
			{
			}
		}

		public string ID => perkTreeID;

		private string displayNameKey => "PerkTree_" + ID;

		public string DisplayName => displayNameKey.ToPlainText();

		public bool Horizontal => horizontal;

		public ReadOnlyCollection<Perk> Perks
		{
			get
			{
				if (perks_ReadOnly == null)
				{
					perks_ReadOnly = perks.AsReadOnly();
				}
				return perks_ReadOnly;
			}
		}

		public PerkTreeRelationGraphOwner RelationGraphOwner => relationGraphOwner;

		private string SaveKey => "PerkTree_" + perkTreeID;

		public event Action<PerkTree> onPerkTreeStatusChanged;

		private void Awake()
		{
			Load();
			SavesSystem.OnCollectSaveData += Save;
			SavesSystem.OnSetFile += Load;
		}

		private void Start()
		{
			foreach (Perk perk in perks)
			{
				if (!(perk == null) && perk.DefaultUnlocked)
				{
					perk.ForceUnlock();
				}
			}
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
			SavesSystem.OnSetFile -= Load;
		}

		public object GenerateSaveData()
		{
			return new SaveData(this);
		}

		public void SetupSaveData(object data)
		{
			foreach (Perk perk in perks)
			{
				perk.Unlocked = false;
			}
			if (!(data is SaveData saveData))
			{
				return;
			}
			foreach (Perk cur in perks)
			{
				if (!(cur == null))
				{
					SaveData.Entry entry = saveData.entries.Find((SaveData.Entry e) => e != null && e.perkName == cur.name);
					if (entry != null)
					{
						cur.Unlocked = entry.unlocked;
						cur.unlocking = entry.unlocking;
						cur.unlockingBeginTimeRaw = entry.unlockingBeginTime;
					}
				}
			}
		}

		public void Save()
		{
			SavesSystem.Save(SaveKey, GenerateSaveData() as SaveData);
		}

		public void Load()
		{
			if (SavesSystem.KeyExisits(SaveKey))
			{
				SaveData data = SavesSystem.Load<SaveData>(SaveKey);
				SetupSaveData(data);
				loaded = true;
			}
		}

		public void ReapplyPerks()
		{
			foreach (Perk perk in perks)
			{
				perk.Unlocked = false;
			}
			foreach (Perk perk2 in perks)
			{
				perk2.Unlocked = perk2.Unlocked;
			}
		}

		internal bool AreAllParentsUnlocked(Perk perk)
		{
			PerkRelationNode relatedNode = RelationGraphOwner.GetRelatedNode(perk);
			if (relatedNode == null)
			{
				return false;
			}
			foreach (PerkRelationNode incomingNode in relationGraphOwner.RelationGraph.GetIncomingNodes(relatedNode))
			{
				Perk relatedNode2 = incomingNode.relatedNode;
				if (!(relatedNode2 == null) && !relatedNode2.Unlocked)
				{
					return false;
				}
			}
			return true;
		}

		internal void NotifyChildStateChanged(Perk perk)
		{
			PerkRelationNode relatedNode = RelationGraphOwner.GetRelatedNode(perk);
			if (relatedNode == null)
			{
				return;
			}
			foreach (PerkRelationNode outgoingNode in relationGraphOwner.RelationGraph.GetOutgoingNodes(relatedNode))
			{
				outgoingNode.NotifyIncomingStateChanged();
			}
			this.onPerkTreeStatusChanged?.Invoke(this);
		}

		private void Collect()
		{
			perks.Clear();
			Perk[] componentsInChildren = base.transform.GetComponentsInChildren<Perk>();
			Perk[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Master = this;
			}
			perks.AddRange(componentsInChildren);
		}
	}
	public class PerkLevelLineNode : PerkRelationNodeBase
	{
		public Vector2 cachedPosition;

		public string DisplayName => name;

		public override int maxInConnections => 0;

		public override int maxOutConnections => 0;
	}
	public class PerkRelationConnection : NodeCanvas.Framework.Connection
	{
	}
	public class PerkRelationGraph : NodeCanvas.Framework.Graph
	{
		public override Type baseNodeType => typeof(PerkRelationNodeBase);

		public override bool requiresAgent => true;

		public override bool requiresPrimeNode => false;

		public override bool isTree => false;

		public override PlanarDirection flowDirection => PlanarDirection.Vertical;

		public override bool allowBlackboardOverrides => true;

		public override bool canAcceptVariableDrops => true;

		public PerkRelationNode GetRelatedNode(Perk perk)
		{
			return base.allNodes.Find(delegate(Node node)
			{
				if (node == null)
				{
					return false;
				}
				return node is PerkRelationNode perkRelationNode && perkRelationNode.relatedNode == perk;
			}) as PerkRelationNode;
		}

		public List<PerkRelationNode> GetIncomingNodes(PerkRelationNode skillTreeNode)
		{
			List<PerkRelationNode> list = new List<PerkRelationNode>();
			foreach (NodeCanvas.Framework.Connection inConnection in skillTreeNode.inConnections)
			{
				if (inConnection != null && inConnection.sourceNode is PerkRelationNode item)
				{
					list.Add(item);
				}
			}
			return list;
		}

		public List<PerkRelationNode> GetOutgoingNodes(PerkRelationNode skillTreeNode)
		{
			List<PerkRelationNode> list = new List<PerkRelationNode>();
			foreach (NodeCanvas.Framework.Connection outConnection in skillTreeNode.outConnections)
			{
				if (outConnection != null && outConnection.targetNode is PerkRelationNode item)
				{
					list.Add(item);
				}
			}
			return list;
		}
	}
	public class PerkRelationNode : PerkRelationNodeBase
	{
		public Perk relatedNode;

		public Vector2 cachedPosition;

		private bool dirty = true;

		internal bool isDuplicate;

		internal bool isInvalid;

		internal void SetDirty()
		{
			dirty = true;
		}

		public override void OnDestroy()
		{
			if (relatedNode == null)
			{
				return;
			}
			IEnumerable<Node> enumerable = base.graph.allNodes.Where((Node e) => (e as PerkRelationNode).relatedNode == relatedNode);
			if (enumerable.Count() > 2)
			{
				return;
			}
			foreach (Node item in enumerable)
			{
				if (item is PerkRelationNode perkRelationNode)
				{
					perkRelationNode.isDuplicate = false;
					perkRelationNode.SetDirty();
				}
			}
		}

		internal void NotifyIncomingStateChanged()
		{
			relatedNode.NotifyParentStateChanged();
		}
	}
	public class PerkRelationNodeBase : Node
	{
		public override int maxInConnections => 16;

		public override int maxOutConnections => 16;

		public override Type outConnectionType => typeof(PerkRelationConnection);

		public override bool allowAsPrime => true;

		public override bool canSelfConnect => false;

		public override Alignment2x2 commentsAlignment => Alignment2x2.Default;

		public override Alignment2x2 iconAlignment => Alignment2x2.Default;
	}
	public class PerkTreeRelationGraphOwner : GraphOwner<PerkRelationGraph>
	{
		private PerkRelationGraph _relationGraph;

		public PerkRelationGraph RelationGraph
		{
			get
			{
				if (_relationGraph == null)
				{
					_relationGraph = graph as PerkRelationGraph;
				}
				return _relationGraph;
			}
		}

		public List<Perk> GetRequiredNodes(Perk node)
		{
			PerkRelationNode relatedNode = RelationGraph.GetRelatedNode(node);
			if (relatedNode == null)
			{
				return null;
			}
			List<PerkRelationNode> incomingNodes = RelationGraph.GetIncomingNodes(relatedNode);
			if (incomingNodes == null)
			{
				return null;
			}
			if (incomingNodes.Count < 1)
			{
				return null;
			}
			List<Perk> list = new List<Perk>();
			foreach (PerkRelationNode item in incomingNodes)
			{
				Perk relatedNode2 = item.relatedNode;
				if (!(relatedNode2 == null))
				{
					list.Add(relatedNode2);
				}
			}
			return list;
		}

		internal PerkRelationNode GetRelatedNode(Perk perk)
		{
			if (RelationGraph == null)
			{
				return null;
			}
			return RelationGraph.GetRelatedNode(perk);
		}
	}
}
namespace Duckov.PerkTrees.Behaviours
{
	public class AddBlackMarketRefreshChance : PerkBehaviour
	{
		[SerializeField]
		private int addAmount = 1;

		protected override void OnAwake()
		{
			base.OnAwake();
			BlackMarket.onRequestMaxRefreshChance += HandleEvent;
		}

		protected override void OnOnDestroy()
		{
			base.OnOnDestroy();
			BlackMarket.onRequestMaxRefreshChance -= HandleEvent;
		}

		private void HandleEvent(BlackMarket.OnRequestMaxRefreshChanceEventContext context)
		{
			if (!(base.Master == null) && base.Master.Unlocked)
			{
				context.Add(addAmount);
			}
		}

		protected override void OnUnlocked()
		{
			BlackMarket.NotifyMaxRefreshChanceChanged();
		}
	}
	public class ChangeBlackMarketRefreshTimeFactor : PerkBehaviour
	{
		[SerializeField]
		private float amount = -0.1f;

		protected override void OnAwake()
		{
			base.OnAwake();
			BlackMarket.onRequestRefreshTime += HandleEvent;
		}

		protected override void OnOnDestroy()
		{
			base.OnOnDestroy();
			BlackMarket.onRequestRefreshTime -= HandleEvent;
		}

		private void HandleEvent(BlackMarket.OnRequestRefreshTimeFactorEventContext context)
		{
			if (!(base.Master == null) && base.Master.Unlocked)
			{
				context.Add(amount);
			}
		}
	}
	public class ModifyCharacterStatsBase : PerkBehaviour
	{
		[Serializable]
		public class Entry
		{
			public string key;

			public float value;

			public bool percentage;

			private StringList AvaliableKeys => StringLists.StatKeys;
		}

		private struct Record
		{
			public Stat stat;

			public float value;
		}

		[SerializeField]
		private List<Entry> entries = new List<Entry>();

		private Item targetItem;

		private List<Record> records = new List<Record>();

		private string DescriptionFormat => "PerkBehaviour_ModifyCharacterStatsBase".ToPlainText();

		public override string Description
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				foreach (Entry entry in entries)
				{
					if (entry != null && !string.IsNullOrEmpty(entry.key))
					{
						string statDisplayName = ("Stat_" + entry.key.Trim()).ToPlainText();
						bool num = entry.value > 0f;
						float value = entry.value;
						string value2 = string.Concat(str1: entry.percentage ? $"{value * 100f}%" : value.ToString(), str0: num ? "+" : "");
						string value3 = DescriptionFormat.Format(new
						{
							statDisplayName = statDisplayName,
							value = value2
						});
						stringBuilder.AppendLine(value3);
					}
				}
				return stringBuilder.ToString().Trim();
			}
		}

		protected override void OnUnlocked()
		{
			targetItem = LevelManager.Instance?.MainCharacter?.CharacterItem;
			if (targetItem == null)
			{
				return;
			}
			StatCollection stats = targetItem.Stats;
			if (stats == null)
			{
				return;
			}
			foreach (Entry entry in entries)
			{
				Stat stat = stats.GetStat(entry.key);
				if (stat == null)
				{
					break;
				}
				stat.BaseValue += entry.value;
				records.Add(new Record
				{
					stat = stat,
					value = entry.value
				});
			}
		}

		protected override void OnLocked()
		{
			if (targetItem == null || targetItem.Stats == null)
			{
				return;
			}
			foreach (Record record in records)
			{
				if (record.stat == null)
				{
					break;
				}
				record.stat.BaseValue -= record.value;
			}
		}
	}
	public class UnlockAchievement : PerkBehaviour
	{
		[SerializeField]
		private string achievementKey;

		protected override void OnUnlocked()
		{
			if (!(AchievementManager.Instance == null))
			{
				AchievementManager.Instance.Unlock(achievementKey.Trim());
			}
		}
	}
	public class UnlockFormula : PerkBehaviour
	{
		private IEnumerable<string> FormulasToUnlock
		{
			get
			{
				if (!CraftingFormulaCollection.Instance)
				{
					yield break;
				}
				string matchKey = base.Master.Master.ID + "/" + base.Master.name;
				foreach (CraftingFormula entry in CraftingFormulaCollection.Instance.Entries)
				{
					if (entry.requirePerk == matchKey)
					{
						yield return entry.id;
					}
				}
			}
		}

		protected override void OnUnlocked()
		{
			foreach (string item in FormulasToUnlock)
			{
				CraftingManager.UnlockFormula(item);
			}
		}
	}
}
namespace Duckov.PerkTrees.Interactable
{
	public class PerkTreeUIInvoker : InteractableBase
	{
		public string perkTreeID;

		protected override bool ShowUnityEvents => false;

		protected override void OnInteractStart(CharacterMainControl interactCharacter)
		{
			PerkTreeView.Show(PerkTreeManager.GetPerkTree(perkTreeID));
			StopInteract();
		}
	}
}
namespace Duckov.Options
{
	public class OptionsManager : MonoBehaviour
	{
		public const string FileName = "Options.ES3";

		private static ES3Settings _saveSettings;

		private static string Folder => SavesSystem.SavesFolder;

		public static string FilePath => System.IO.Path.Combine(Folder, "Options.ES3");

		private static ES3Settings SaveSettings
		{
			get
			{
				if (_saveSettings == null)
				{
					_saveSettings = new ES3Settings(applyDefaults: true);
					_saveSettings.path = FilePath;
					_saveSettings.location = ES3.Location.File;
				}
				return _saveSettings;
			}
		}

		public static float MouseSensitivity
		{
			get
			{
				return Load("MouseSensitivity", 10f);
			}
			set
			{
				Save("MouseSensitivity", value);
			}
		}

		public static event Action<string> OnOptionsChanged;

		public static void Save<T>(string key, T obj)
		{
			if (string.IsNullOrEmpty(key))
			{
				return;
			}
			try
			{
				ES3.Save(key, obj, SaveSettings);
				OptionsManager.OnOptionsChanged?.Invoke(key);
				ES3.CreateBackup(SaveSettings);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				UnityEngine.Debug.LogError("Error: Failed saving options: " + key);
			}
		}

		public static T Load<T>(string key, T defaultValue = default(T))
		{
			if (string.IsNullOrEmpty(key))
			{
				return default(T);
			}
			try
			{
				if (ES3.KeyExists(key, SaveSettings))
				{
					return ES3.Load<T>(key, SaveSettings);
				}
				ES3.Save(key, defaultValue, SaveSettings);
				return defaultValue;
			}
			catch
			{
				if (ES3.RestoreBackup(SaveSettings))
				{
					try
					{
						if (ES3.KeyExists(key, SaveSettings))
						{
							return ES3.Load<T>(key, SaveSettings);
						}
						ES3.Save(key, defaultValue, SaveSettings);
						return defaultValue;
					}
					catch
					{
						UnityEngine.Debug.LogError("[OPTIONS MANAGER] Failed restoring backup");
					}
				}
				ES3.DeleteFile(SaveSettings);
				return defaultValue;
			}
		}
	}
}
namespace Duckov.Options.UI
{
	public class OptionsPanel : UIPanel, ISingleSelectionMenu<OptionsPanel_TabButton>
	{
		[SerializeField]
		private List<OptionsPanel_TabButton> tabButtons;

		private OptionsPanel_TabButton selection;

		private void Start()
		{
			Setup();
		}

		private void Setup()
		{
			foreach (OptionsPanel_TabButton tabButton in tabButtons)
			{
				tabButton.onClicked = (Action<OptionsPanel_TabButton, PointerEventData>)Delegate.Combine(tabButton.onClicked, new Action<OptionsPanel_TabButton, PointerEventData>(OnTabButtonClicked));
			}
			if (selection == null)
			{
				selection = tabButtons[0];
			}
			SetSelection(selection);
		}

		private void OnTabButtonClicked(OptionsPanel_TabButton button, PointerEventData data)
		{
			data.Use();
			SetSelection(button);
		}

		protected override void OnOpen()
		{
			base.OnOpen();
		}

		public OptionsPanel_TabButton GetSelection()
		{
			return selection;
		}

		public bool SetSelection(OptionsPanel_TabButton selection)
		{
			this.selection = selection;
			foreach (OptionsPanel_TabButton tabButton in tabButtons)
			{
				tabButton.NotifySelectionChanged(this, selection);
			}
			return true;
		}
	}
	public class OptionsUIEntry_Dropdown : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler
	{
		[SerializeField]
		private TextMeshProUGUI label;

		[SerializeField]
		private OptionsProviderBase provider;

		[SerializeField]
		private TMP_Dropdown dropdown;

		private string optionKey
		{
			get
			{
				if (provider == null)
				{
					return "";
				}
				return provider.Key;
			}
		}

		[LocalizationKey("Options")]
		public string LabelKey
		{
			get
			{
				return "Options_" + optionKey;
			}
			set
			{
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			SetupDropdown();
		}

		private void SetupDropdown()
		{
			if ((bool)provider)
			{
				List<string> list = provider.GetOptions().ToList();
				string currentOption = provider.GetCurrentOption();
				int num = list.IndexOf(currentOption);
				if (num < 0)
				{
					list.Insert(0, currentOption);
					num = 0;
				}
				dropdown.ClearOptions();
				dropdown.AddOptions(list.ToList());
				dropdown.SetValueWithoutNotify(num);
			}
		}

		private void Awake()
		{
			LocalizationManager.OnSetLanguage += OnSetLanguage;
			dropdown.onValueChanged.AddListener(OnDropdownValueChanged);
			label.text = LabelKey.ToPlainText();
		}

		private void Start()
		{
			SetupDropdown();
		}

		private void OnDestroy()
		{
			LocalizationManager.OnSetLanguage -= OnSetLanguage;
		}

		private void OnSetLanguage(SystemLanguage language)
		{
			SetupDropdown();
			label.text = LabelKey.ToPlainText();
		}

		private void OnDropdownValueChanged(int index)
		{
			if ((bool)provider)
			{
				int num = provider.GetOptions().ToList().IndexOf(dropdown.options[index].text);
				if (num >= 0)
				{
					provider.Set(num);
				}
				SetupDropdown();
			}
		}

		private void OnValidate()
		{
			if ((bool)label)
			{
				label.text = LabelKey.ToPlainText();
			}
		}
	}
	public class OptionsUIEntry_Slider : MonoBehaviour
	{
		[SerializeField]
		private string key;

		[Space]
		[SerializeField]
		private float defaultValue;

		[SerializeField]
		private TextMeshProUGUI label;

		[SerializeField]
		private UnityEngine.UI.Slider slider;

		[SerializeField]
		private TMP_InputField valueField;

		[SerializeField]
		private string valueFormat = "0";

		[LocalizationKey("Options")]
		private string labelKey
		{
			get
			{
				return "Options_" + key;
			}
			set
			{
			}
		}

		public float Value
		{
			get
			{
				return OptionsManager.Load(key, defaultValue);
			}
			set
			{
				OptionsManager.Save(key, value);
			}
		}

		private void Awake()
		{
			slider.onValueChanged.AddListener(OnSliderValueChanged);
			valueField.onEndEdit.AddListener(OnFieldEndEdit);
			RefreshLable();
			LocalizationManager.OnSetLanguage += OnLanguageChanged;
		}

		private void OnDestroy()
		{
			LocalizationManager.OnSetLanguage -= OnLanguageChanged;
		}

		private void OnLanguageChanged(SystemLanguage language)
		{
			RefreshLable();
		}

		private void RefreshLable()
		{
			if ((bool)label)
			{
				label.text = labelKey.ToPlainText();
			}
		}

		private void OnFieldEndEdit(string arg0)
		{
			if (float.TryParse(arg0, out var result))
			{
				result = Mathf.Clamp(result, slider.minValue, slider.maxValue);
				Value = result;
			}
			RefreshValues();
		}

		private void OnEnable()
		{
			RefreshValues();
		}

		private void OnSliderValueChanged(float value)
		{
			Value = value;
			RefreshValues();
		}

		private void RefreshValues()
		{
			valueField.SetTextWithoutNotify(Value.ToString(valueFormat));
			slider.SetValueWithoutNotify(Value);
		}

		private void OnValidate()
		{
			RefreshLable();
		}
	}
	public class OptionsUIEntry_Toggle : MonoBehaviour
	{
		[SerializeField]
		private string key;

		[SerializeField]
		private bool defaultValue;

		[Space]
		[SerializeField]
		private TextMeshProUGUI label;

		[SerializeField]
		private UnityEngine.UI.Slider toggle;

		[LocalizationKey("Default")]
		private string labelKey
		{
			get
			{
				return "Options_" + key;
			}
			set
			{
			}
		}

		public bool Value
		{
			get
			{
				return OptionsManager.Load(key, defaultValue);
			}
			set
			{
				OptionsManager.Save(key, value);
			}
		}

		private int SliderValue
		{
			get
			{
				if (!Value)
				{
					return 0;
				}
				return 1;
			}
		}

		private void Awake()
		{
			toggle.wholeNumbers = true;
			toggle.minValue = 0f;
			toggle.maxValue = 1f;
			toggle.onValueChanged.AddListener(OnToggleValueChanged);
			label.text = labelKey.ToPlainText();
		}

		private void OnEnable()
		{
			toggle.SetValueWithoutNotify(SliderValue);
		}

		private void OnToggleValueChanged(float value)
		{
			Value = value > 0f;
		}
	}
	public class RuleEntry_Float : MonoBehaviour
	{
		[SerializeField]
		private SliderWithTextField slider;

		[SerializeField]
		private string fieldName = "damageFactor_ToPlayer";

		private FieldInfo field;

		private void Awake()
		{
			SliderWithTextField sliderWithTextField = slider;
			sliderWithTextField.onValueChanged = (Action<float>)Delegate.Combine(sliderWithTextField.onValueChanged, new Action<float>(OnValueChanged));
			GameRulesManager.OnRuleChanged += OnRuleChanged;
			Type typeFromHandle = typeof(Ruleset);
			field = typeFromHandle.GetField(fieldName, BindingFlags.Instance | BindingFlags.NonPublic);
			RefreshValue();
		}

		private void OnRuleChanged()
		{
			RefreshValue();
		}

		private void OnValueChanged(float value)
		{
			if (GameRulesManager.SelectedRuleIndex != RuleIndex.Custom)
			{
				RefreshValue();
				return;
			}
			Ruleset current = GameRulesManager.Current;
			SetValue(current, value);
			GameRulesManager.NotifyRuleChanged();
		}

		public void RefreshValue()
		{
			float value = GetValue(GameRulesManager.Current);
			slider.SetValueWithoutNotify(value);
		}

		protected void SetValue(Ruleset ruleset, float value)
		{
			field.SetValue(ruleset, value);
		}

		protected float GetValue(Ruleset ruleset)
		{
			return (float)field.GetValue(ruleset);
		}
	}
	public class RuleEntry_Int : MonoBehaviour
	{
		[SerializeField]
		private SliderWithTextField slider;

		[SerializeField]
		private string fieldName = "damageFactor_ToPlayer";

		private FieldInfo field;

		private void Awake()
		{
			SliderWithTextField sliderWithTextField = slider;
			sliderWithTextField.onValueChanged = (Action<float>)Delegate.Combine(sliderWithTextField.onValueChanged, new Action<float>(OnValueChanged));
			GameRulesManager.OnRuleChanged += OnRuleChanged;
			Type typeFromHandle = typeof(Ruleset);
			field = typeFromHandle.GetField(fieldName, BindingFlags.Instance | BindingFlags.NonPublic);
			RefreshValue();
		}

		private void OnRuleChanged()
		{
			RefreshValue();
		}

		private void OnValueChanged(float value)
		{
			if (GameRulesManager.SelectedRuleIndex != RuleIndex.Custom)
			{
				RefreshValue();
				return;
			}
			Ruleset current = GameRulesManager.Current;
			SetValue(current, (int)value);
			GameRulesManager.NotifyRuleChanged();
		}

		public void RefreshValue()
		{
			float valueWithoutNotify = GetValue(GameRulesManager.Current);
			slider.SetValueWithoutNotify(valueWithoutNotify);
		}

		protected void SetValue(Ruleset ruleset, int value)
		{
			field.SetValue(ruleset, value);
		}

		protected int GetValue(Ruleset ruleset)
		{
			return (int)field.GetValue(ruleset);
		}
	}
}
namespace Duckov.NoteIndexs
{
	public class NoteIndex : MonoBehaviour
	{
		[Serializable]
		private struct SaveData
		{
			public List<string> unlockedNotes;

			public List<string> readNotes;

			public SaveData(NoteIndex from)
			{
				unlockedNotes = from.unlockedNotes.ToList();
				readNotes = from.unlockedNotes.ToList();
			}

			public void Setup(NoteIndex to)
			{
				to.unlockedNotes.Clear();
				if (unlockedNotes != null)
				{
					to.unlockedNotes.AddRange(unlockedNotes);
				}
				to.readNotes.Clear();
				if (readNotes != null)
				{
					to.readNotes.AddRange(readNotes);
				}
			}
		}

		[SerializeField]
		private List<Note> notes = new List<Note>();

		private Dictionary<string, Note> _dic;

		private HashSet<string> unlockedNotes = new HashSet<string>();

		private HashSet<string> readNotes = new HashSet<string>();

		public static Action<string> onNoteStatusChanged;

		private const string SaveKey = "NoteIndexData";

		public static NoteIndex Instance => GameManager.NoteIndex;

		public List<Note> Notes => notes;

		private Dictionary<string, Note> MDic
		{
			get
			{
				if (_dic == null)
				{
					RebuildDic();
				}
				return _dic;
			}
		}

		public HashSet<string> UnlockedNotes => unlockedNotes;

		public HashSet<string> ReadNotes => unlockedNotes;

		private void RebuildDic()
		{
			if (_dic == null)
			{
				_dic = new Dictionary<string, Note>();
			}
			_dic.Clear();
			foreach (Note note in notes)
			{
				_dic[note.key] = note;
			}
		}

		public static IEnumerable<string> GetAllNotes(bool unlockedOnly = true)
		{
			if (Instance == null)
			{
				yield break;
			}
			foreach (Note note in Instance.notes)
			{
				string key = note.key;
				if (!unlockedOnly || GetNoteUnlocked(key))
				{
					yield return note.key;
				}
			}
		}

		private void Awake()
		{
			SavesSystem.OnCollectSaveData += Save;
			SavesSystem.OnSetFile += Load;
			Load();
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
			SavesSystem.OnSetFile -= Load;
		}

		private void Save()
		{
			SaveData value = new SaveData(this);
			SavesSystem.Save("NoteIndexData", value);
		}

		private void Load()
		{
			SavesSystem.Load<SaveData>("NoteIndexData").Setup(this);
		}

		public void MSetEntryDynamic(Note note)
		{
			MDic[note.key] = note;
		}

		public Note MGetNote(string key)
		{
			if (string.IsNullOrEmpty(key))
			{
				UnityEngine.Debug.LogError("Trying to get note with an empty key.");
				return null;
			}
			if (!MDic.TryGetValue(key, out var value))
			{
				UnityEngine.Debug.LogError("Cannot find note: " + key);
				return null;
			}
			return value;
		}

		public static Note GetNote(string key)
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.MGetNote(key);
		}

		public static bool SetNoteDynamic(Note note)
		{
			if (Instance == null)
			{
				return false;
			}
			Instance.MSetEntryDynamic(note);
			return true;
		}

		public static bool GetNoteUnlocked(string noteKey)
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.unlockedNotes.Contains(noteKey);
		}

		public static bool GetNoteRead(string noteKey)
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.readNotes.Contains(noteKey);
		}

		public static void SetNoteUnlocked(string noteKey)
		{
			if (!(Instance == null))
			{
				Instance.unlockedNotes.Add(noteKey);
				onNoteStatusChanged?.Invoke(noteKey);
			}
		}

		public static void SetNoteRead(string noteKey)
		{
			if (!(Instance == null))
			{
				Instance.readNotes.Add(noteKey);
				onNoteStatusChanged?.Invoke(noteKey);
			}
		}

		internal static int GetTotalNoteCount()
		{
			if (Instance == null)
			{
				return 0;
			}
			return Instance.Notes.Count();
		}

		internal static int GetUnlockedNoteCount()
		{
			if (Instance == null)
			{
				return 0;
			}
			return Instance.UnlockedNotes.Count;
		}
	}
	public enum NoteStatus
	{
		None = 0,
		Unlocked = 2
	}
	[Serializable]
	public class Note
	{
		[SerializeField]
		public string key;

		[SerializeField]
		public Sprite image;

		[LocalizationKey("Default")]
		public string titleKey
		{
			get
			{
				return "Note_" + key + "_Title";
			}
			set
			{
			}
		}

		[LocalizationKey("Default")]
		public string contentKey
		{
			get
			{
				return "Note_" + key + "_Content";
			}
			set
			{
			}
		}

		public string Title => titleKey.ToPlainText();

		private Sprite previewSprite => image;

		public string Content => contentKey.ToPlainText();
	}
	public class NoteIndexProxy : MonoBehaviour
	{
		public void UnlockNote(string key)
		{
			NoteIndex.SetNoteUnlocked(key);
		}

		public void UnlockAndShowNote(string key)
		{
			NoteIndexView.ShowNote(key);
		}
	}
	public class NoteInteract : InteractableBase
	{
		public string noteKey;

		[LocalizationKey("Default")]
		public string noteTitle;

		[LocalizationKey("Default")]
		public string noteContent;

		protected override void Start()
		{
			base.Start();
			if (NoteIndex.GetNoteUnlocked(noteKey))
			{
				base.gameObject.SetActive(value: false);
			}
			finishWhenTimeOut = true;
		}

		protected override void OnInteractFinished()
		{
			NoteIndex.SetNoteUnlocked(noteKey);
			NoteIndexView.ShowNote(noteKey);
			base.gameObject.SetActive(value: false);
		}

		private void OnValidate()
		{
			noteTitle = "Note_" + noteKey + "_Title";
			noteContent = "Note_" + noteKey + "_Content";
		}

		public void ReName()
		{
			base.gameObject.name = "Note_" + noteKey;
		}
	}
	public class RequireNoteIndexUnlocked : Condition
	{
		public string key;

		public override bool Evaluate()
		{
			return NoteIndex.GetNoteUnlocked(key);
		}
	}
}
namespace Duckov.Modding
{
	public abstract class ModBehaviour : MonoBehaviour
	{
		public ModManager master { get; private set; }

		public ModInfo info { get; private set; }

		public void Setup(ModManager master, ModInfo info)
		{
			this.master = master;
			this.info = info;
			OnAfterSetup();
		}

		public void NotifyBeforeDeactivate()
		{
			OnBeforeDeactivate();
		}

		protected virtual void OnAfterSetup()
		{
		}

		protected virtual void OnBeforeDeactivate()
		{
		}
	}
	public class ModManager : MonoBehaviour
	{
		[SerializeField]
		private Transform modParent;

		public static Action<string, string> OnModLoadingFailed;

		private static ES3Settings _settings;

		public static List<ModInfo> modInfos = new List<ModInfo>();

		private Dictionary<string, ModBehaviour> activeMods = new Dictionary<string, ModBehaviour>();

		public static bool AllowActivatingMod
		{
			get
			{
				return SavesSystem.LoadGlobal("AllowLoadingMod", defaultValue: false);
			}
			set
			{
				SavesSystem.SaveGlobal("AllowLoadingMod", value);
				if (Instance != null && value)
				{
					Instance.ScanAndActivateMods();
				}
			}
		}

		private static ES3Settings settings
		{
			get
			{
				if (_settings == null)
				{
					_settings = new ES3Settings
					{
						location = ES3.Location.File,
						path = "Saves/Mods.ES3"
					};
				}
				return _settings;
			}
		}

		private static string DefaultModFolderPath => System.IO.Path.Combine(Application.dataPath, "Mods");

		public static ModManager Instance => GameManager.ModManager;

		public static event Action OnReorder;

		public static event Action<List<ModInfo>> OnScan;

		public static event Action<ModInfo, ModBehaviour> OnModActivated;

		public static event Action<ModInfo, ModBehaviour> OnModWillBeDeactivated;

		public static event Action OnModStatusChanged;

		private void Awake()
		{
			if (modParent == null)
			{
				modParent = base.transform;
			}
		}

		private void Start()
		{
		}

		public void ScanAndActivateMods()
		{
			if (!AllowActivatingMod)
			{
				return;
			}
			Rescan();
			foreach (ModInfo modInfo in modInfos)
			{
				if (!activeMods.ContainsKey(modInfo.name))
				{
					bool flag = ShouldActivateMod(modInfo);
					UnityEngine.Debug.Log($"ModActive_{modInfo.name}: {flag}");
					if (flag && ActivateMod(modInfo) == null)
					{
						SetShouldActivateMod(modInfo, value: false);
					}
				}
			}
		}

		private static void SortModInfosByPriority()
		{
			modInfos.Sort(delegate(ModInfo a, ModInfo b)
			{
				int modPriority = GetModPriority(a.name);
				int modPriority2 = GetModPriority(b.name);
				return modPriority - modPriority2;
			});
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("Sorted mods:");
			foreach (ModInfo modInfo in modInfos)
			{
				stringBuilder.AppendLine(modInfo.name);
			}
			UnityEngine.Debug.Log(stringBuilder);
		}

		private static void Save<T>(string key, T value)
		{
			try
			{
				ES3.Save(key, value, settings);
				ES3.CreateBackup(settings);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogError("Failed saving mod info.");
				UnityEngine.Debug.LogException(exception);
			}
		}

		private static T Load<T>(string key, T defaultValue = default(T))
		{
			try
			{
				return ES3.Load(key, defaultValue, settings);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogError("Failed loading mod info.");
				ES3.RestoreBackup(settings);
				UnityEngine.Debug.LogException(exception);
				return defaultValue;
			}
		}

		public static void SetModPriority(string name, int priority)
		{
			Save("priority_" + name, priority);
		}

		public static int GetModPriority(string name)
		{
			return Load("priority_" + name, 0);
		}

		private void SetShouldActivateMod(ModInfo info, bool value)
		{
			SavesSystem.SaveGlobal("ModActive_" + info.name, value);
		}

		private bool ShouldActivateMod(ModInfo info)
		{
			return SavesSystem.LoadGlobal("ModActive_" + info.name, defaultValue: false);
		}

		public static void Rescan()
		{
			modInfos.Clear();
			if (Directory.Exists(DefaultModFolderPath))
			{
				string[] directories = Directory.GetDirectories(DefaultModFolderPath);
				for (int i = 0; i < directories.Length; i++)
				{
					if (TryProcessModFolder(directories[i], out var info, isSteamItem: false, 0uL))
					{
						modInfos.Add(info);
					}
				}
			}
			ModManager.OnScan?.Invoke(modInfos);
			SortModInfosByPriority();
		}

		private static void RegeneratePriorities()
		{
			for (int i = 0; i < modInfos.Count; i++)
			{
				string value = modInfos[i].name;
				if (!string.IsNullOrWhiteSpace(value))
				{
					SetModPriority(value, i);
				}
			}
		}

		public static bool Reorder(int fromIndex, int toIndex)
		{
			if (fromIndex == toIndex)
			{
				return false;
			}
			if (fromIndex < 0 || fromIndex >= modInfos.Count)
			{
				return false;
			}
			if (toIndex < 0 || toIndex >= modInfos.Count)
			{
				return false;
			}
			ModInfo item = modInfos[fromIndex];
			modInfos.RemoveAt(fromIndex);
			modInfos.Insert(toIndex, item);
			RegeneratePriorities();
			ModManager.OnReorder?.Invoke();
			return true;
		}

		public static bool TryProcessModFolder(string path, out ModInfo info, bool isSteamItem = false, ulong publishedFileId = 0uL)
		{
			info = default(ModInfo);
			info.path = path;
			string path2 = System.IO.Path.Combine(path, "info.ini");
			if (!File.Exists(path2))
			{
				return false;
			}
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			using (StreamReader streamReader = File.OpenText(path2))
			{
				while (!streamReader.EndOfStream)
				{
					string text = streamReader.ReadLine().Trim();
					if (!string.IsNullOrWhiteSpace(text) && !text.StartsWith('['))
					{
						string[] array = text.Split('=');
						if (array.Length == 2)
						{
							string key = array[0].Trim();
							string value = array[1].Trim();
							dictionary[key] = value;
						}
					}
				}
			}
			if (!dictionary.TryGetValue("name", out var value2))
			{
				UnityEngine.Debug.LogError("Failed to get name value in mod info.ini file. Aborting.\n" + path);
				return false;
			}
			if (!dictionary.TryGetValue("displayName", out var value3))
			{
				value3 = value2;
				UnityEngine.Debug.LogError("Failed to get displayName value in mod info.ini file.\n" + path);
			}
			if (!dictionary.TryGetValue("description", out var value4))
			{
				value4 = "?";
				UnityEngine.Debug.LogError("Failed to get description value in mod info.ini file.\n" + path);
			}
			ulong result = 0uL;
			if (dictionary.TryGetValue("publishedFileId", out var value5) && !ulong.TryParse(value5, out result))
			{
				UnityEngine.Debug.LogError("Invalid publishedFileId");
			}
			if (!isSteamItem)
			{
				publishedFileId = result;
			}
			else if (publishedFileId != result)
			{
				UnityEngine.Debug.LogError("PublishFileId not match.\npath:" + path);
			}
			info.name = value2;
			info.displayName = value3;
			info.description = value4;
			info.publishedFileId = publishedFileId;
			info.isSteamItem = isSteamItem;
			string dllPath = info.dllPath;
			info.dllFound = File.Exists(dllPath);
			if (!info.dllFound)
			{
				UnityEngine.Debug.LogError("Dll for mod " + value2 + " not found.\nExpecting: " + dllPath);
			}
			string path3 = System.IO.Path.Combine(path, "preview.png");
			if (File.Exists(path3))
			{
				using FileStream fileStream = File.OpenRead(path3);
				Texture2D texture2D = new Texture2D(256, 256);
				byte[] array2 = new byte[fileStream.Length];
				fileStream.Read(array2);
				if (texture2D.LoadImage(array2))
				{
					info.preview = texture2D;
				}
			}
			return true;
		}

		public static bool IsModActive(ModInfo info, out ModBehaviour instance)
		{
			instance = null;
			if (Instance == null)
			{
				return false;
			}
			if (Instance.activeMods.TryGetValue(info.name, out instance))
			{
				return instance != null;
			}
			return false;
		}

		public ModBehaviour GetActiveModBehaviour(ModInfo info)
		{
			if (activeMods.TryGetValue(info.name, out var value))
			{
				return value;
			}
			return null;
		}

		public void DeactivateMod(ModInfo info)
		{
			ModBehaviour activeModBehaviour = GetActiveModBehaviour(info);
			if (!(activeModBehaviour == null))
			{
				try
				{
					activeModBehaviour.NotifyBeforeDeactivate();
					ModManager.OnModWillBeDeactivated?.Invoke(info, activeModBehaviour);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				activeMods.Remove(info.name);
				try
				{
					UnityEngine.Object.Destroy(activeModBehaviour.gameObject);
					ModManager.OnModStatusChanged?.Invoke();
				}
				catch (Exception exception2)
				{
					UnityEngine.Debug.LogException(exception2);
				}
				SetShouldActivateMod(info, value: false);
			}
		}

		public ModBehaviour ActivateMod(ModInfo info)
		{
			if (!AllowActivatingMod)
			{
				UnityEngine.Debug.LogError("Activating mod not allowed! \nUser must first interact with the agreement UI in order to allow activating mods.");
				return null;
			}
			string dllPath = info.dllPath;
			string text = info.name;
			if (IsModActive(info, out var instance))
			{
				UnityEngine.Debug.LogError("Mod " + info.name + " instance already exists! Abort. Path: " + info.path, instance);
				return null;
			}
			UnityEngine.Debug.Log("Loading mod dll at path: " + dllPath);
			Type type;
			try
			{
				type = Assembly.LoadFrom(dllPath).GetType(text + ".ModBehaviour");
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogException(ex);
				string arg = "Mod loading failed: " + text + "\n" + ex.Message;
				OnModLoadingFailed?.Invoke(info.dllPath, arg);
				return null;
			}
			if (type == null || !type.InheritsFrom<ModBehaviour>())
			{
				UnityEngine.Debug.LogError("Cannot load mod.\nA type named " + text + ".Mod is expected, and it should inherit from Duckov.Modding.Mod.");
				return null;
			}
			GameObject gameObject = new GameObject(text);
			ModBehaviour modBehaviour;
			try
			{
				modBehaviour = gameObject.AddComponent(type) as ModBehaviour;
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
				UnityEngine.Debug.LogError("Failed to create component for mod " + text);
				return null;
			}
			if (modBehaviour == null)
			{
				UnityEngine.Object.Destroy(gameObject);
				UnityEngine.Debug.LogError("Failed to create component for mod " + text);
				return null;
			}
			gameObject.transform.SetParent(base.transform);
			UnityEngine.Debug.Log("Mod Loaded: " + info.name);
			modBehaviour.Setup(this, info);
			activeMods[info.name] = modBehaviour;
			try
			{
				ModManager.OnModActivated?.Invoke(info, modBehaviour);
				ModManager.OnModStatusChanged?.Invoke();
			}
			catch (Exception exception2)
			{
				UnityEngine.Debug.LogException(exception2);
			}
			SetShouldActivateMod(info, value: true);
			return modBehaviour;
		}

		internal static void WriteModInfoINI(ModInfo modInfo)
		{
			string path = System.IO.Path.Combine(modInfo.path, "info.ini");
			if (File.Exists(path))
			{
				File.Delete(path);
			}
			using FileStream stream = File.Create(path);
			StreamWriter streamWriter = new StreamWriter(stream);
			streamWriter.WriteLine("name = " + modInfo.name);
			streamWriter.WriteLine("displayName = " + modInfo.displayName);
			streamWriter.WriteLine("description = " + modInfo.description);
			streamWriter.WriteLine("");
			streamWriter.WriteLine($"publishedFileId = {modInfo.publishedFileId}");
			streamWriter.Close();
		}
	}
	[Serializable]
	public struct ModInfo
	{
		public string path;

		public string name;

		public string displayName;

		public string description;

		public Texture2D preview;

		public bool dllFound;

		public bool isSteamItem;

		public ulong publishedFileId;

		public string dllPath => System.IO.Path.Combine(path, name + ".dll");
	}
	public class SteamWorkshopManager : MonoBehaviour
	{
		private CallResult<SteamUGCQueryCompleted_t> CRSteamUGCQueryCompleted;

		private CallResult<CreateItemResult_t> CRCreateItemResult;

		private UGCQueryHandle_t activeQueryHandle;

		private static List<SteamUGCDetails_t> ugcDetailsCache = new List<SteamUGCDetails_t>();

		private bool createItemResultFired;

		private CreateItemResult_t createItemResult;

		public static SteamWorkshopManager Instance { get; private set; }

		public static ulong punBytesProcess { get; private set; }

		public static ulong punBytesTotal { get; private set; }

		public static float UploadingProgress => (float)((double)punBytesProcess / (double)punBytesTotal);

		public bool UploadSucceed { get; private set; }

		private void Awake()
		{
			Instance = this;
		}

		private void OnEnable()
		{
			ModManager.Rescan();
			SendQueryDetailsRequest();
			ModManager.OnScan += OnScanMods;
		}

		private void OnDisable()
		{
			ModManager.OnScan -= OnScanMods;
		}

		private void OnScanMods(List<ModInfo> list)
		{
			if (!SteamManager.Initialized)
			{
				return;
			}
			foreach (SteamUGCDetails_t item in ugcDetailsCache)
			{
				PublishedFileId_t nPublishedFileId = item.m_nPublishedFileId;
				EItemState itemState = (EItemState)SteamUGC.GetItemState(nPublishedFileId);
				if ((itemState | EItemState.k_EItemStateInstalled) == itemState && SteamUGC.GetItemInstallInfo(nPublishedFileId, out var _, out var pchFolder, 1024u, out var _))
				{
					if (!ModManager.TryProcessModFolder(pchFolder, out var info, isSteamItem: true, nPublishedFileId.m_PublishedFileId))
					{
						UnityEngine.Debug.LogError("Mod processing failed! \nPath:" + pchFolder);
					}
					else
					{
						list.Add(info);
					}
				}
			}
		}

		public void SendQueryDetailsRequest()
		{
			if (!SteamManager.Initialized)
			{
				return;
			}
			if (CRSteamUGCQueryCompleted == null)
			{
				CRSteamUGCQueryCompleted = CallResult<SteamUGCQueryCompleted_t>.Create(OnSteamUGCQueryCompleted);
			}
			HashSet<PublishedFileId_t> hashSet = new HashSet<PublishedFileId_t>();
			uint numSubscribedItems = SteamUGC.GetNumSubscribedItems();
			PublishedFileId_t[] array = new PublishedFileId_t[numSubscribedItems];
			SteamUGC.GetSubscribedItems(array, numSubscribedItems);
			hashSet.AddRange(array);
			foreach (ModInfo modInfo in ModManager.modInfos)
			{
				if (modInfo.publishedFileId != 0L)
				{
					hashSet.Add((PublishedFileId_t)modInfo.publishedFileId);
				}
			}
			SteamAPICall_t hAPICall = SteamUGC.SendQueryUGCRequest(SteamUGC.CreateQueryUGCDetailsRequest(hashSet.ToArray(), (uint)hashSet.Count));
			CRSteamUGCQueryCompleted.Set(hAPICall);
			new StringBuilder();
		}

		private void OnSteamUGCQueryCompleted(SteamUGCQueryCompleted_t completed, bool bIOFailure)
		{
			if (bIOFailure)
			{
				UnityEngine.Debug.LogError("Steam UGC Query failed", base.gameObject);
				ModManager.Instance.ScanAndActivateMods();
				return;
			}
			UGCQueryHandle_t handle = completed.m_handle;
			uint unNumResultsReturned = completed.m_unNumResultsReturned;
			for (uint num = 0u; num < unNumResultsReturned; num++)
			{
				SteamUGC.GetQueryUGCResult(handle, num, out var pDetails);
				ugcDetailsCache.Add(pDetails);
			}
			SteamUGC.ReleaseQueryUGCRequest(handle);
			ModManager.Instance.ScanAndActivateMods();
		}

		public async UniTask<PublishedFileId_t> RequestNewWorkshopItemID()
		{
			if (!SteamManager.Initialized)
			{
				return default(PublishedFileId_t);
			}
			if (CRCreateItemResult == null)
			{
				CRCreateItemResult = CallResult<CreateItemResult_t>.Create(OnCreateItemResult);
			}
			UnityEngine.Debug.Log("Requesting new PublishedFileId");
			createItemResultFired = false;
			SteamAPICall_t hAPICall = SteamUGC.CreateItem((AppId_t)3167020u, EWorkshopFileType.k_EWorkshopFileTypeFirst);
			CRCreateItemResult.Set(hAPICall, delegate(CreateItemResult_t result, bool failure)
			{
				UnityEngine.Debug.Log("Creat Item Result Fired B");
				createItemResultFired = true;
				createItemResult = result;
			});
			while (!createItemResultFired)
			{
				await UniTask.Yield();
			}
			if (createItemResult.m_eResult != EResult.k_EResultOK)
			{
				UnityEngine.Debug.LogError($"Failed to create workshop item.\nResult: {createItemResult.m_eResult}");
				return default(PublishedFileId_t);
			}
			return createItemResult.m_nPublishedFileId;
		}

		private void OnCreateItemResult(CreateItemResult_t result, bool bIOFailure)
		{
			UnityEngine.Debug.Log("Creat Item Result Fired A");
			createItemResultFired = true;
			createItemResult = result;
		}

		public async UniTask<bool> UploadWorkshopItem(string path, string changeNote = "Unknown")
		{
			if (!SteamManager.Initialized)
			{
				return false;
			}
			UnityEngine.Debug.Log("Begin uploading mod: \n" + path);
			if (!ModManager.TryProcessModFolder(path, out var modInfo, isSteamItem: false, 0uL))
			{
				UnityEngine.Debug.LogError("Failed to process mod folder:\n" + path);
				return false;
			}
			if (!modInfo.dllFound)
			{
				UnityEngine.Debug.LogError("Mod's dll file not found.\n" + modInfo.dllPath);
				return false;
			}
			if (modInfo.publishedFileId == 0L)
			{
				UnityEngine.Debug.Log("Requesting PublishedFileId for mod " + modInfo.name + " \n" + path);
				PublishedFileId_t publishedFileId_t = await RequestNewWorkshopItemID();
				if (publishedFileId_t.m_PublishedFileId == 0L)
				{
					UnityEngine.Debug.Log("Failed to request PublishedFileId.");
					return false;
				}
				modInfo.publishedFileId = publishedFileId_t.m_PublishedFileId;
				try
				{
					UnityEngine.Debug.Log($"MOD [{modInfo.name}] ({modInfo.publishedFileId}) Writing mod's info.ini  \n{path}");
					ModManager.WriteModInfoINI(modInfo);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					UnityEngine.Debug.LogError($"Successfully created steam workshop item (PublishedFileId:{publishedFileId_t}). But failed to write to info.ini.");
					return false;
				}
			}
			UGCUpdateHandle_t handle = SteamUGC.StartItemUpdate((AppId_t)3167020u, (PublishedFileId_t)modInfo.publishedFileId);
			SteamUGC.SetItemTitle(handle, modInfo.displayName);
			SteamUGC.SetItemDescription(handle, modInfo.description);
			SteamUGC.SetItemVisibility(handle, ERemoteStoragePublishedFileVisibility.k_ERemoteStoragePublishedFileVisibilityPublic);
			SteamUGC.SetItemTags(handle, new List<string> { "Mod" });
			string text = System.IO.Path.Combine(modInfo.path, "preview.png");
			text = text.Replace('\\', '/');
			SteamUGC.SetItemPreview(handle, text);
			string path2 = modInfo.path;
			path2 = path2.Replace('\\', '/');
			bool flag = SteamUGC.SetItemContent(handle, path2);
			UnityEngine.Debug.Log($"SetItemContent \n{path2}\n{flag}");
			bool submitCallDone = false;
			SubmitItemUpdateResult_t submitResult = default(SubmitItemUpdateResult_t);
			UnityEngine.Debug.Log($"MOD [{modInfo.name}] ({modInfo.publishedFileId}) Begin uploading to steam.  \n{path}");
			using (CallResult<SubmitItemUpdateResult_t> callHandler = CallResult<SubmitItemUpdateResult_t>.Create(delegate(SubmitItemUpdateResult_t result, bool failure)
			{
				submitCallDone = true;
				submitResult = result;
			}))
			{
				SteamAPICall_t hAPICall = SteamUGC.SubmitItemUpdate(handle, changeNote);
				callHandler.Set(hAPICall);
				while (!submitCallDone)
				{
					SteamUGC.GetItemUpdateProgress(handle, out var punBytesProcessed, out var num);
					punBytesProcess = punBytesProcessed;
					punBytesTotal = num;
					await UniTask.Yield();
				}
			}
			UnityEngine.Debug.Log($"MOD [{modInfo.name}] ({modInfo.publishedFileId}) Upload result returned.  \n{path}");
			if (submitResult.m_eResult != EResult.k_EResultOK)
			{
				UnityEngine.Debug.LogError($"Failed to upload mod.\nResult:{submitResult.m_eResult} \npath: {modInfo.path}");
				return false;
			}
			if (submitResult.m_bUserNeedsToAcceptWorkshopLegalAgreement)
			{
				SteamFriends.ActivateGameOverlayToWebPage($"steam://url/CommunityFilePage/{modInfo.publishedFileId}");
			}
			UploadSucceed = true;
			return true;
		}

		public static bool IsOwner(ModInfo info)
		{
			if (!SteamManager.Initialized)
			{
				return false;
			}
			if (info.publishedFileId == 0L)
			{
				return false;
			}
			foreach (SteamUGCDetails_t item in ugcDetailsCache)
			{
				if (item.m_nPublishedFileId.m_PublishedFileId == info.publishedFileId)
				{
					return item.m_ulSteamIDOwner == SteamUser.GetSteamID().m_SteamID;
				}
			}
			return false;
		}
	}
}
namespace Duckov.Modding.UI
{
	public class ModEntry : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI textTitle;

		[SerializeField]
		private TextMeshProUGUI textName;

		[SerializeField]
		private TextMeshProUGUI textDescription;

		[SerializeField]
		private RawImage preview;

		[SerializeField]
		private GameObject activeIndicator;

		[SerializeField]
		private GameObject nameCollisionIndicator;

		[SerializeField]
		private UnityEngine.UI.Button toggleButton;

		[SerializeField]
		private GameObject steamItemIndicator;

		[SerializeField]
		private GameObject steamItemOwnerIndicator;

		[SerializeField]
		private GameObject notSteamItemIndicator;

		[SerializeField]
		private UnityEngine.UI.Button uploadButton;

		[SerializeField]
		private GameObject failedIndicator;

		[SerializeField]
		private UnityEngine.UI.Button btnReorderUp;

		[SerializeField]
		private UnityEngine.UI.Button btnReorderDown;

		[SerializeField]
		private int index;

		private ModManagerUI master;

		private ModInfo info;

		private void Awake()
		{
			toggleButton.onClick.AddListener(OnToggleButtonClicked);
			uploadButton.onClick.AddListener(OnUploadButtonClicked);
			ModManager.OnModLoadingFailed = (Action<string, string>)Delegate.Combine(ModManager.OnModLoadingFailed, new Action<string, string>(OnModLoadingFailed));
			failedIndicator.SetActive(value: false);
			btnReorderDown.onClick.AddListener(OnButtonReorderDownClicked);
			btnReorderUp.onClick.AddListener(OnButtonReorderUpClicked);
		}

		private void OnButtonReorderUpClicked()
		{
			ModManager.Reorder(index, index - 1);
		}

		private void OnButtonReorderDownClicked()
		{
			ModManager.Reorder(index, index + 1);
		}

		private void OnDestroy()
		{
			ModManager.OnModLoadingFailed = (Action<string, string>)Delegate.Remove(ModManager.OnModLoadingFailed, new Action<string, string>(OnModLoadingFailed));
		}

		private void OnModLoadingFailed(string dllPath, string message)
		{
			if (!(dllPath != info.dllPath))
			{
				UnityEngine.Debug.LogError(message);
				failedIndicator.SetActive(value: true);
			}
		}

		private void OnUploadButtonClicked()
		{
			if (!(master == null))
			{
				master.BeginUpload(info).Forget();
			}
		}

		private void OnToggleButtonClicked()
		{
			if (ModManager.Instance == null)
			{
				UnityEngine.Debug.LogError("ModManager.Instance Not Found");
				return;
			}
			ModBehaviour instance;
			bool num = ModManager.IsModActive(info, out instance);
			bool flag = num && instance.info.path.Trim() == info.path.Trim();
			if (num && flag)
			{
				ModManager.Instance.DeactivateMod(info);
			}
			else
			{
				ModManager.Instance.ActivateMod(info);
			}
		}

		private void OnEnable()
		{
			ModManager.OnModStatusChanged += OnModStatusChanged;
		}

		private void OnDisable()
		{
			ModManager.OnModStatusChanged -= OnModStatusChanged;
		}

		private void OnModStatusChanged()
		{
			RefreshStatus();
		}

		private void RefreshStatus()
		{
			ModBehaviour instance;
			bool num = ModManager.IsModActive(info, out instance);
			bool flag = num && instance.info.path.Trim() == info.path.Trim();
			bool active = num && !flag;
			activeIndicator.SetActive(flag);
			nameCollisionIndicator.SetActive(active);
		}

		private void RefreshInfo()
		{
			textTitle.text = info.displayName;
			textName.text = info.name;
			textDescription.text = info.description;
			preview.texture = info.preview;
			steamItemIndicator.SetActive(info.isSteamItem);
			notSteamItemIndicator.SetActive(!info.isSteamItem);
			bool flag = SteamWorkshopManager.IsOwner(info);
			steamItemOwnerIndicator.SetActive(flag);
			bool active = flag || !info.isSteamItem;
			uploadButton.gameObject.SetActive(active);
		}

		public void Setup(ModManagerUI master, ModInfo modInfo, int index)
		{
			this.master = master;
			info = modInfo;
			this.index = index;
			RefreshInfo();
			RefreshStatus();
		}
	}
	public class ModManagerUI : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup mainFadeGroup;

		[SerializeField]
		private FadeGroup contentFadeGroup;

		[SerializeField]
		private FadeGroup agreementFadeGroup;

		[SerializeField]
		private FadeGroup uploaderFadeGroup;

		[SerializeField]
		private ModUploadPanel uploadPanel;

		[SerializeField]
		private UnityEngine.UI.Button rejectBtn;

		[SerializeField]
		private UnityEngine.UI.Button agreementBtn;

		[SerializeField]
		private ModEntry entryTemplate;

		[SerializeField]
		private UnityEngine.UI.Button quitBtn;

		[SerializeField]
		private GameObject needRebootIndicator;

		public UnityEvent onQuit;

		private PrefabPool<ModEntry> _pool;

		private bool uploading;

		private ModManager Master => ModManager.Instance;

		private PrefabPool<ModEntry> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<ModEntry>(entryTemplate);
				}
				return _pool;
			}
		}

		private void Awake()
		{
			agreementBtn.onClick.AddListener(OnAgreementBtnClicked);
			quitBtn.onClick.AddListener(Quit);
			rejectBtn.onClick.AddListener(OnRejectBtnClicked);
			needRebootIndicator.SetActive(value: false);
			ModManager.OnReorder += OnReorder;
		}

		private void OnDestroy()
		{
			ModManager.OnReorder -= OnReorder;
		}

		private void OnReorder()
		{
			Refresh();
			needRebootIndicator.SetActive(value: true);
		}

		private void OnRejectBtnClicked()
		{
			ModManager.AllowActivatingMod = false;
			Quit();
		}

		private void OnAgreementBtnClicked()
		{
			ModManager.AllowActivatingMod = true;
			agreementFadeGroup.Hide();
			contentFadeGroup.Show();
		}

		private void Show()
		{
			mainFadeGroup.Show();
		}

		private void OnEnable()
		{
			ModManager.Rescan();
			Refresh();
			uploaderFadeGroup.SkipHide();
			if (!ModManager.AllowActivatingMod)
			{
				contentFadeGroup.SkipHide();
				agreementFadeGroup.Show();
			}
			else
			{
				agreementFadeGroup.SkipHide();
				contentFadeGroup.Show();
			}
		}

		private void Refresh()
		{
			Pool.ReleaseAll();
			int num = 0;
			foreach (ModInfo modInfo in ModManager.modInfos)
			{
				Pool.Get().Setup(this, modInfo, num);
				num++;
			}
		}

		private void Hide()
		{
			mainFadeGroup.Hide();
		}

		private void Quit()
		{
			onQuit?.Invoke();
			Hide();
		}

		internal async UniTask BeginUpload(ModInfo info)
		{
			if (!uploading)
			{
				uploading = true;
				contentFadeGroup.Hide();
				await uploadPanel.Execute(info);
				contentFadeGroup.Show();
				uploading = false;
			}
		}
	}
}
namespace Duckov.MiniMaps
{
	public class MapMarkerManager : MonoBehaviour
	{
		[Serializable]
		private struct SaveData
		{
			public string mainSceneName;

			public List<MapMarkerPOI.RuntimeData> pois;
		}

		[SerializeField]
		private List<Sprite> icons = new List<Sprite>();

		[SerializeField]
		private MapMarkerPOI markerPrefab;

		[SerializeField]
		private int selectedIconIndex;

		[SerializeField]
		private Color selectedColor = Color.white;

		public static Action<int> OnIconChanged;

		public static Action<Color> OnColorChanged;

		private bool loaded;

		private List<MapMarkerPOI> pois = new List<MapMarkerPOI>();

		public static MapMarkerManager Instance { get; private set; }

		public static int SelectedIconIndex
		{
			get
			{
				if (Instance == null)
				{
					return 0;
				}
				return Instance.selectedIconIndex;
			}
		}

		public static Color SelectedColor
		{
			get
			{
				if (Instance == null)
				{
					return Color.white;
				}
				return Instance.selectedColor;
			}
		}

		public static Sprite SelectedIcon
		{
			get
			{
				if (Instance == null)
				{
					return null;
				}
				if (Instance.icons.Count <= SelectedIconIndex)
				{
					return null;
				}
				return Instance.icons[SelectedIconIndex];
			}
		}

		public static string SelectedIconName
		{
			get
			{
				if (Instance == null)
				{
					return null;
				}
				Sprite selectedIcon = SelectedIcon;
				if (selectedIcon == null)
				{
					return null;
				}
				return selectedIcon.name;
			}
		}

		public static List<Sprite> Icons
		{
			get
			{
				if (Instance == null)
				{
					return null;
				}
				return Instance.icons;
			}
		}

		private string SaveKey => "MapMarkerManager_" + MultiSceneCore.MainSceneID;

		private void Awake()
		{
			Instance = this;
			SavesSystem.OnCollectSaveData += OnCollectSaveData;
		}

		private void Start()
		{
			Load();
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= OnCollectSaveData;
		}

		private void Load()
		{
			loaded = true;
			SaveData saveData = SavesSystem.Load<SaveData>(SaveKey);
			if (saveData.pois == null)
			{
				return;
			}
			foreach (MapMarkerPOI.RuntimeData poi in saveData.pois)
			{
				Request(poi);
			}
		}

		private void OnCollectSaveData()
		{
			if (!loaded)
			{
				return;
			}
			SaveData value = new SaveData
			{
				pois = new List<MapMarkerPOI.RuntimeData>()
			};
			foreach (MapMarkerPOI poi in pois)
			{
				if (!(poi == null))
				{
					value.pois.Add(poi.Data);
				}
			}
			SavesSystem.Save(SaveKey, value);
		}

		public static void Request(MapMarkerPOI.RuntimeData data)
		{
			if (!(Instance == null))
			{
				MapMarkerPOI mapMarkerPOI = UnityEngine.Object.Instantiate(Instance.markerPrefab);
				mapMarkerPOI.Setup(data);
				Instance.pois.Add(mapMarkerPOI);
				MultiSceneCore.MoveToMainScene(mapMarkerPOI.gameObject);
			}
		}

		public static void Request(Vector3 worldPos)
		{
			if (!(Instance == null))
			{
				MapMarkerPOI mapMarkerPOI = UnityEngine.Object.Instantiate(Instance.markerPrefab);
				mapMarkerPOI.Setup(worldPos, SelectedIconName, MultiSceneCore.ActiveSubSceneID, SelectedColor);
				Instance.pois.Add(mapMarkerPOI);
				MultiSceneCore.MoveToMainScene(mapMarkerPOI.gameObject);
			}
		}

		public static void Release(MapMarkerPOI entry)
		{
			if (!(entry == null))
			{
				if (Instance != null)
				{
					Instance.pois.Remove(entry);
				}
				if (entry != null)
				{
					UnityEngine.Object.Destroy(entry.gameObject);
				}
			}
		}

		internal static Sprite GetIcon(string iconName)
		{
			if (Instance == null)
			{
				return null;
			}
			if (Instance.icons == null)
			{
				return null;
			}
			return Instance.icons.Find((Sprite e) => e != null && e.name == iconName);
		}

		internal static void SelectColor(Color color)
		{
			if (!(Instance == null))
			{
				Instance.selectedColor = color;
				OnColorChanged?.Invoke(color);
			}
		}

		internal static void SelectIcon(int index)
		{
			if (!(Instance == null))
			{
				Instance.selectedIconIndex = index;
				OnIconChanged?.Invoke(index);
			}
		}
	}
	public class MapMarkerPOI : MonoBehaviour, IPointOfInterest
	{
		[Serializable]
		public struct RuntimeData
		{
			public Vector3 worldPosition;

			public string iconName;

			public string overrideSceneKey;

			public Color color;
		}

		[SerializeField]
		private RuntimeData data;

		public RuntimeData Data => data;

		public Sprite Icon => MapMarkerManager.GetIcon(data.iconName);

		public int OverrideScene => SceneInfoCollection.GetBuildIndex(data.overrideSceneKey);

		public Color Color => data.color;

		public Color ShadowColor => Color.black;

		public float ScaleFactor => 0.8f;

		public void Setup(Vector3 worldPosition, string iconName = "", string overrideScene = "", Color? color = null)
		{
			data = new RuntimeData
			{
				worldPosition = worldPosition,
				iconName = iconName,
				overrideSceneKey = overrideScene,
				color = ((!color.HasValue) ? Color.white : color.Value)
			};
			base.transform.position = worldPosition;
			PointsOfInterests.Unregister(this);
			PointsOfInterests.Register(this);
		}

		public void Setup(RuntimeData data)
		{
			this.data = data;
			base.transform.position = data.worldPosition;
			PointsOfInterests.Unregister(this);
			PointsOfInterests.Register(this);
		}

		public void NotifyClicked(PointerEventData eventData)
		{
			MapMarkerManager.Release(this);
		}

		private void OnDestroy()
		{
			PointsOfInterests.Unregister(this);
		}
	}
	public class MiniMapCenter : MonoBehaviour
	{
		private static List<MiniMapCenter> activeMiniMapCenters = new List<MiniMapCenter>();

		[SerializeField]
		private float worldSize = -1f;

		public float WorldSize => worldSize;

		private void OnEnable()
		{
			activeMiniMapCenters.Add(this);
			if (activeMiniMapCenters.Count > 1)
			{
				if ((bool)activeMiniMapCenters.Find((MiniMapCenter e) => e != null && e != this && e.gameObject.scene.buildIndex == base.gameObject.scene.buildIndex))
				{
					UnityEngine.Debug.LogError("场景 " + base.gameObject.scene.name + " 似乎存在两个MiniMapCenter！");
				}
			}
			else
			{
				CacheThisCenter();
			}
		}

		private void CacheThisCenter()
		{
			MiniMapSettings instance = MiniMapSettings.Instance;
			if (!(instance == null))
			{
				_ = base.transform.position;
				instance.Cache(this);
			}
		}

		private void OnDisable()
		{
			activeMiniMapCenters.Remove(this);
		}

		internal static Vector3 GetCenterOfObjectScene(MonoBehaviour target)
		{
			int sceneBuildIndex = target.gameObject.scene.buildIndex;
			if (target is IPointOfInterest { OverrideScene: >=0 } pointOfInterest)
			{
				sceneBuildIndex = pointOfInterest.OverrideScene;
			}
			return GetCenter(sceneBuildIndex);
		}

		internal static string GetSceneID(MonoBehaviour target)
		{
			int sceneBuildIndex = target.gameObject.scene.buildIndex;
			if (target is IPointOfInterest { OverrideScene: >=0 } pointOfInterest)
			{
				sceneBuildIndex = pointOfInterest.OverrideScene;
			}
			MiniMapSettings instance = MiniMapSettings.Instance;
			if (instance == null)
			{
				return null;
			}
			return instance.maps.Find((MiniMapSettings.MapEntry e) => e.SceneReference.UnsafeReason == SceneReferenceUnsafeReason.None && e.SceneReference.BuildIndex == sceneBuildIndex)?.sceneID;
		}

		internal static Vector3 GetCenter(int sceneBuildIndex)
		{
			MiniMapSettings instance = MiniMapSettings.Instance;
			if (instance == null)
			{
				return Vector3.zero;
			}
			return instance.maps.FirstOrDefault((MiniMapSettings.MapEntry e) => e.SceneReference.UnsafeReason == SceneReferenceUnsafeReason.None && e.SceneReference.BuildIndex == sceneBuildIndex)?.mapWorldCenter ?? instance.combinedCenter;
		}

		internal static Vector3 GetCenter(string sceneID)
		{
			return GetCenter(SceneInfoCollection.GetBuildIndex(sceneID));
		}

		internal static Vector3 GetCombinedCenter()
		{
			MiniMapSettings instance = MiniMapSettings.Instance;
			if (instance == null)
			{
				return Vector3.zero;
			}
			return instance.combinedCenter;
		}

		private void OnDrawGizmosSelected()
		{
			if (!(WorldSize < 0f))
			{
				Gizmos.matrix = base.transform.localToWorldMatrix;
				Gizmos.DrawWireCube(Vector3.zero, new Vector3(WorldSize, 1f, WorldSize));
			}
		}
	}
	public class MiniMapSettings : MonoBehaviour, IMiniMapDataProvider
	{
		[Serializable]
		public class MapEntry : IMiniMapEntry
		{
			public float imageWorldSize;

			[SceneID]
			public string sceneID;

			public Sprite sprite;

			public SpriteRenderer offsetReference;

			public Vector3 mapWorldCenter;

			public bool hide;

			public bool noSignal;

			public SceneReference SceneReference => SceneInfoCollection.GetSceneInfo(sceneID)?.SceneReference;

			public string SceneID => sceneID;

			public Sprite Sprite => sprite;

			public bool Hide => hide;

			public bool NoSignal => noSignal;

			public float PixelSize
			{
				get
				{
					int width = sprite.texture.width;
					if (width > 0 && imageWorldSize > 0f)
					{
						return imageWorldSize / (float)width;
					}
					return -1f;
				}
			}

			public Vector2 Offset
			{
				get
				{
					if (offsetReference == null)
					{
						return Vector2.zero;
					}
					return offsetReference.transform.localPosition;
				}
			}

			public MapEntry()
			{
			}

			public MapEntry(MapEntry copyFrom)
			{
				imageWorldSize = copyFrom.imageWorldSize;
				sceneID = copyFrom.sceneID;
				sprite = copyFrom.sprite;
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		public struct Data
		{
		}

		public List<MapEntry> maps;

		public Vector3 combinedCenter;

		public float combinedSize;

		public Sprite combinedSprite;

		public Sprite CombinedSprite => combinedSprite;

		public Vector3 CombinedCenter => combinedCenter;

		public List<IMiniMapEntry> Maps => ((IEnumerable<IMiniMapEntry>)maps).ToList();

		public static MiniMapSettings Instance { get; private set; }

		public float PixelSize
		{
			get
			{
				int width = combinedSprite.texture.width;
				if (width > 0 && combinedSize > 0f)
				{
					return combinedSize / (float)width;
				}
				return -1f;
			}
		}

		private void Awake()
		{
			foreach (MapEntry map in maps)
			{
				SpriteRenderer offsetReference = map.offsetReference;
				if (offsetReference != null)
				{
					offsetReference.gameObject.SetActive(value: false);
				}
			}
			if (Instance == null)
			{
				Instance = this;
			}
		}

		public static bool TryGetMinimapPosition(Vector3 worldPosition, string sceneID, out Vector3 result)
		{
			result = worldPosition;
			if (Instance == null)
			{
				return false;
			}
			if (string.IsNullOrEmpty(sceneID))
			{
				return false;
			}
			MapEntry mapEntry = Instance.maps.FirstOrDefault((MapEntry e) => e != null && e.sceneID == sceneID);
			if (mapEntry == null)
			{
				return false;
			}
			Vector3 vector = worldPosition - mapEntry.mapWorldCenter;
			Vector3 vector2 = mapEntry.mapWorldCenter - Instance.combinedCenter;
			_ = vector + vector2;
			return true;
		}

		public static bool TryGetWorldPosition(Vector3 minimapPosition, string sceneID, out Vector3 result)
		{
			result = minimapPosition;
			if (Instance == null)
			{
				return false;
			}
			if (string.IsNullOrEmpty(sceneID))
			{
				return false;
			}
			MapEntry mapEntry = Instance.maps.FirstOrDefault((MapEntry e) => e != null && e.sceneID == sceneID);
			if (mapEntry == null)
			{
				return false;
			}
			result = mapEntry.mapWorldCenter + minimapPosition;
			return true;
		}

		public static bool TryGetMinimapPosition(Vector3 worldPosition, out Vector3 result)
		{
			result = worldPosition;
			Scene activeScene = SceneManager.GetActiveScene();
			if (!activeScene.isLoaded)
			{
				return false;
			}
			string sceneID = SceneInfoCollection.GetSceneID(activeScene.buildIndex);
			return TryGetMinimapPosition(worldPosition, sceneID, out result);
		}

		internal void Cache(MiniMapCenter miniMapCenter)
		{
			int scene = miniMapCenter.gameObject.scene.buildIndex;
			MapEntry mapEntry = maps.FirstOrDefault((MapEntry e) => e.SceneReference != null && e.SceneReference.UnsafeReason == SceneReferenceUnsafeReason.None && e.SceneReference.BuildIndex == scene);
			if (mapEntry != null)
			{
				mapEntry.mapWorldCenter = miniMapCenter.transform.position;
			}
		}
	}
	public static class PointsOfInterests
	{
		private static List<MonoBehaviour> points = new List<MonoBehaviour>();

		private static ReadOnlyCollection<MonoBehaviour> points_ReadOnly;

		public static ReadOnlyCollection<MonoBehaviour> Points
		{
			get
			{
				if (points_ReadOnly == null)
				{
					points_ReadOnly = new ReadOnlyCollection<MonoBehaviour>(points);
				}
				return points_ReadOnly;
			}
		}

		public static event Action<MonoBehaviour> OnPointRegistered;

		public static event Action<MonoBehaviour> OnPointUnregistered;

		public static void Register(MonoBehaviour point)
		{
			points.Add(point);
			PointsOfInterests.OnPointRegistered?.Invoke(point);
			CleanUp();
		}

		public static void Unregister(MonoBehaviour point)
		{
			if (points.Remove(point))
			{
				PointsOfInterests.OnPointUnregistered?.Invoke(point);
			}
			CleanUp();
		}

		private static void CleanUp()
		{
			points.RemoveAll((MonoBehaviour e) => e == null);
		}
	}
	public interface IPointOfInterest
	{
		int OverrideScene => -1;

		Sprite Icon => null;

		Color Color => Color.white;

		string DisplayName => null;

		Color ShadowColor => Color.white;

		float ShadowDistance => 0f;

		bool IsArea => false;

		float AreaRadius => 1f;

		bool HideIcon => false;

		float ScaleFactor => 1f;

		void NotifyClicked(PointerEventData eventData)
		{
		}
	}
	public class SimplePointOfInterest : MonoBehaviour, IPointOfInterest
	{
		[SerializeField]
		private Sprite icon;

		[SerializeField]
		private Color color = Color.white;

		[SerializeField]
		private Color shadowColor = Color.white;

		[SerializeField]
		private float shadowDistance;

		[LocalizationKey("Default")]
		[SerializeField]
		private string displayName = "";

		[SerializeField]
		private bool followActiveScene;

		[SceneID]
		[SerializeField]
		private string overrideSceneID;

		[SerializeField]
		private bool isArea;

		[SerializeField]
		private float areaRadius;

		[SerializeField]
		private float scaleFactor = 1f;

		[SerializeField]
		private bool hideIcon;

		public float ScaleFactor
		{
			get
			{
				return scaleFactor;
			}
			set
			{
				scaleFactor = value;
			}
		}

		public Color Color
		{
			get
			{
				return color;
			}
			set
			{
				color = value;
			}
		}

		public Color ShadowColor
		{
			get
			{
				return shadowColor;
			}
			set
			{
				shadowColor = value;
			}
		}

		public float ShadowDistance
		{
			get
			{
				return shadowDistance;
			}
			set
			{
				shadowDistance = value;
			}
		}

		public string DisplayName => displayName.ToPlainText();

		public Sprite Icon => icon;

		public int OverrideScene
		{
			get
			{
				if (followActiveScene && MultiSceneCore.ActiveSubScene.HasValue)
				{
					return MultiSceneCore.ActiveSubScene.Value.buildIndex;
				}
				if (!string.IsNullOrEmpty(overrideSceneID))
				{
					return SceneInfoCollection.GetBuildIndex(overrideSceneID);
				}
				return -1;
			}
		}

		public bool IsArea
		{
			get
			{
				return isArea;
			}
			set
			{
				isArea = value;
			}
		}

		public float AreaRadius
		{
			get
			{
				return areaRadius;
			}
			set
			{
				areaRadius = value;
			}
		}

		public bool HideIcon
		{
			get
			{
				return hideIcon;
			}
			set
			{
				hideIcon = value;
			}
		}

		public event Action<PointerEventData> OnClicked;

		private void OnEnable()
		{
			PointsOfInterests.Register(this);
		}

		private void OnDisable()
		{
			PointsOfInterests.Unregister(this);
		}

		public void Setup(Sprite icon = null, string displayName = null, bool followActiveScene = false, string overrideSceneID = null)
		{
			if (icon != null)
			{
				this.icon = icon;
			}
			this.displayName = displayName;
			this.followActiveScene = followActiveScene;
			this.overrideSceneID = overrideSceneID;
			PointsOfInterests.Unregister(this);
			PointsOfInterests.Register(this);
		}

		public void SetColor(Color color)
		{
			this.color = color;
		}

		public bool SetupMultiSceneLocation(MultiSceneLocation location, bool moveToMainScene = true)
		{
			if (!location.TryGetLocationPosition(out var result))
			{
				return false;
			}
			base.transform.position = result;
			overrideSceneID = location.SceneID;
			if (moveToMainScene && MultiSceneCore.MainScene.HasValue)
			{
				SceneManager.MoveGameObjectToScene(base.gameObject, MultiSceneCore.MainScene.Value);
			}
			return true;
		}

		public static SimplePointOfInterest Create(Vector3 position, string sceneID, string displayName, Sprite icon = null, bool hideIcon = false)
		{
			GameObject gameObject = new GameObject("POI_" + displayName);
			gameObject.transform.position = position;
			SimplePointOfInterest simplePointOfInterest = gameObject.AddComponent<SimplePointOfInterest>();
			simplePointOfInterest.overrideSceneID = sceneID;
			simplePointOfInterest.displayName = displayName;
			simplePointOfInterest.hideIcon = hideIcon;
			simplePointOfInterest.icon = icon;
			SceneManager.MoveGameObjectToScene(gameObject, MultiSceneCore.MainScene.Value);
			return simplePointOfInterest;
		}

		public void NotifyClicked(PointerEventData pointerEventData)
		{
			this.OnClicked?.Invoke(pointerEventData);
		}
	}
	public class MiniMapCompass : MonoBehaviour
	{
		[SerializeField]
		private Transform arrow;

		private void SetupRotation()
		{
			Vector3 vector = LevelManager.Instance.GameCamera.mainVCam.transform.up.ProjectOntoPlane(Vector3.up);
			Vector3 forward = Vector3.forward;
			float num = Vector3.SignedAngle(vector, forward, Vector3.up);
			arrow.localRotation = Quaternion.Euler(0f, 0f, 0f - num);
		}

		private void Update()
		{
			SetupRotation();
		}
	}
}
namespace Duckov.MiniMaps.UI
{
	public class MiniMapDisplay : MonoBehaviour, IScrollHandler, IEventSystemHandler
	{
		[SerializeField]
		private MiniMapView master;

		[SerializeField]
		private MiniMapDisplayEntry mapDisplayEntryPrefab;

		[SerializeField]
		private PointOfInterestEntry pointOfInterestEntryPrefab;

		[SerializeField]
		private UISplineRenderer teleporterSplines;

		[SerializeField]
		private bool autoSetupOnEnable;

		[SerializeField]
		private float padding = 25f;

		private PrefabPool<MiniMapDisplayEntry> _mapEntryPool;

		private PrefabPool<PointOfInterestEntry> _pointOfInterestEntryPool;

		private PrefabPool<MiniMapDisplayEntry> MapEntryPool
		{
			get
			{
				if (_mapEntryPool == null)
				{
					_mapEntryPool = new PrefabPool<MiniMapDisplayEntry>(mapDisplayEntryPrefab, base.transform, OnGetMapEntry);
				}
				return _mapEntryPool;
			}
		}

		private PrefabPool<PointOfInterestEntry> PointOfInterestEntryPool
		{
			get
			{
				if (_pointOfInterestEntryPool == null)
				{
					_pointOfInterestEntryPool = new PrefabPool<PointOfInterestEntry>(pointOfInterestEntryPrefab, base.transform, OnGetPointOfInterestEntry);
				}
				return _pointOfInterestEntryPool;
			}
		}

		public bool NoSignal()
		{
			foreach (MiniMapDisplayEntry activeEntry in MapEntryPool.ActiveEntries)
			{
				if (!(activeEntry == null) && !(activeEntry.SceneID != MultiSceneCore.ActiveSubSceneID) && activeEntry.NoSignal())
				{
					return true;
				}
			}
			return false;
		}

		private void OnGetPointOfInterestEntry(PointOfInterestEntry entry)
		{
			entry.gameObject.hideFlags |= HideFlags.DontSave;
		}

		private void OnGetMapEntry(MiniMapDisplayEntry entry)
		{
			entry.gameObject.hideFlags |= HideFlags.DontSave;
		}

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponentInParent<MiniMapView>();
			}
			mapDisplayEntryPrefab.gameObject.SetActive(value: false);
			pointOfInterestEntryPrefab.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			if (autoSetupOnEnable)
			{
				AutoSetup();
			}
			RegisterEvents();
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		private void RegisterEvents()
		{
			PointsOfInterests.OnPointRegistered += HandlePointOfInterest;
			PointsOfInterests.OnPointUnregistered += ReleasePointOfInterest;
		}

		private void UnregisterEvents()
		{
			PointsOfInterests.OnPointRegistered -= HandlePointOfInterest;
			PointsOfInterests.OnPointUnregistered -= ReleasePointOfInterest;
		}

		internal void AutoSetup()
		{
			MiniMapSettings miniMapSettings = UnityEngine.Object.FindAnyObjectByType<MiniMapSettings>();
			if ((bool)miniMapSettings)
			{
				Setup(miniMapSettings);
			}
		}

		public void Setup(IMiniMapDataProvider dataProvider)
		{
			if (dataProvider == null)
			{
				return;
			}
			MapEntryPool.ReleaseAll();
			bool flag = dataProvider.CombinedSprite != null;
			foreach (IMiniMapEntry map in dataProvider.Maps)
			{
				MiniMapDisplayEntry miniMapDisplayEntry = MapEntryPool.Get();
				miniMapDisplayEntry.Setup(this, map, !flag);
				miniMapDisplayEntry.gameObject.SetActive(value: true);
			}
			if (flag)
			{
				MiniMapDisplayEntry miniMapDisplayEntry2 = MapEntryPool.Get();
				miniMapDisplayEntry2.SetupCombined(this, dataProvider);
				miniMapDisplayEntry2.gameObject.SetActive(value: true);
				miniMapDisplayEntry2.transform.SetAsFirstSibling();
			}
			SetupRotation();
			FitContent();
			HandlePointsOfInterests();
			HandleTeleporters();
		}

		private void SetupRotation()
		{
			Vector3 to = LevelManager.Instance.GameCamera.mainVCam.transform.up.ProjectOntoPlane(Vector3.up);
			float z = Vector3.SignedAngle(Vector3.forward, to, Vector3.up);
			base.transform.localRotation = Quaternion.Euler(0f, 0f, z);
		}

		private void HandlePointsOfInterests()
		{
			PointOfInterestEntryPool.ReleaseAll();
			foreach (MonoBehaviour point in PointsOfInterests.Points)
			{
				if (!(point == null))
				{
					HandlePointOfInterest(point);
				}
			}
		}

		private void HandlePointOfInterest(MonoBehaviour poi)
		{
			int targetSceneIndex = poi.gameObject.scene.buildIndex;
			if (poi is IPointOfInterest { OverrideScene: >=0 } pointOfInterest)
			{
				targetSceneIndex = pointOfInterest.OverrideScene;
			}
			if (MultiSceneCore.ActiveSubScene.HasValue && targetSceneIndex == MultiSceneCore.ActiveSubScene.Value.buildIndex)
			{
				MiniMapDisplayEntry miniMapDisplayEntry = MapEntryPool.ActiveEntries.FirstOrDefault((MiniMapDisplayEntry e) => e.SceneReference != null && e.SceneReference.BuildIndex == targetSceneIndex);
				if (!(miniMapDisplayEntry == null) && !miniMapDisplayEntry.Hide)
				{
					PointOfInterestEntryPool.Get().Setup(this, poi, miniMapDisplayEntry);
				}
			}
		}

		private void ReleasePointOfInterest(MonoBehaviour poi)
		{
			PointOfInterestEntry pointOfInterestEntry = PointOfInterestEntryPool.ActiveEntries.FirstOrDefault((PointOfInterestEntry e) => e != null && e.Target == poi);
			if ((bool)pointOfInterestEntry)
			{
				PointOfInterestEntryPool.Release(pointOfInterestEntry);
			}
		}

		private void HandleTeleporters()
		{
			teleporterSplines.gameObject.SetActive(value: false);
		}

		private void FitContent()
		{
			ReadOnlyCollection<MiniMapDisplayEntry> activeEntries = MapEntryPool.ActiveEntries;
			Vector2 vector = new Vector2(float.MinValue, float.MinValue);
			Vector2 vector2 = new Vector2(float.MaxValue, float.MaxValue);
			foreach (MiniMapDisplayEntry item in activeEntries)
			{
				RectTransform rectTransform = item.transform as RectTransform;
				Vector2 vector3 = rectTransform.anchoredPosition + rectTransform.rect.min;
				Vector2 vector4 = rectTransform.anchoredPosition + rectTransform.rect.max;
				vector.x = MathF.Max(vector4.x, vector.x);
				vector.y = MathF.Max(vector4.y, vector.y);
				vector2.x = MathF.Min(vector3.x, vector2.x);
				vector2.y = MathF.Min(vector3.y, vector2.y);
			}
			Vector2 vector5 = (vector + vector2) / 2f;
			foreach (MiniMapDisplayEntry item2 in activeEntries)
			{
				item2.transform.localPosition -= (Vector3)vector5;
			}
			(base.transform as RectTransform).sizeDelta = new Vector2(vector.x - vector2.x + padding * 2f, vector.y - vector2.y + padding * 2f);
		}

		public bool TryConvertWorldToMinimap(Vector3 worldPosition, string sceneID, out Vector3 result)
		{
			result = worldPosition;
			MiniMapDisplayEntry miniMapDisplayEntry = MapEntryPool.ActiveEntries.FirstOrDefault((MiniMapDisplayEntry e) => e != null && e.SceneID == sceneID);
			if (miniMapDisplayEntry == null)
			{
				return false;
			}
			Vector3 center = MiniMapCenter.GetCenter(sceneID);
			Vector3 vector = worldPosition - center;
			Vector3 point = new Vector3(vector.x, vector.z);
			Vector3 point2 = miniMapDisplayEntry.transform.localToWorldMatrix.MultiplyPoint(point);
			result = base.transform.worldToLocalMatrix.MultiplyPoint(point2);
			return true;
		}

		public bool TryConvertToWorldPosition(Vector3 displayPosition, out Vector3 result)
		{
			result = default(Vector3);
			string activeSubsceneID = MultiSceneCore.ActiveSubSceneID;
			MiniMapDisplayEntry miniMapDisplayEntry = MapEntryPool.ActiveEntries.FirstOrDefault((MiniMapDisplayEntry e) => e != null && e.SceneID == activeSubsceneID);
			if (miniMapDisplayEntry == null)
			{
				return false;
			}
			Vector3 vector = miniMapDisplayEntry.transform.worldToLocalMatrix.MultiplyPoint(displayPosition);
			Vector3 vector2 = new Vector3(vector.x, 0f, vector.y);
			Vector3 center = MiniMapCenter.GetCenter(activeSubsceneID);
			result = center + vector2;
			return true;
		}

		internal void Center(Vector3 minimapPos)
		{
			RectTransform rectTransform = base.transform as RectTransform;
			if (!(rectTransform == null))
			{
				Vector3 vector = rectTransform.localToWorldMatrix.MultiplyPoint(minimapPos);
				Vector3 vector2 = (rectTransform.parent as RectTransform).position - vector;
				rectTransform.position += vector2;
			}
		}

		public void OnScroll(PointerEventData eventData)
		{
			master.OnScroll(eventData);
		}
	}
	public class MiniMapDisplayEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private UnityEngine.UI.Image image;

		private string sceneID;

		private RectTransform _rectTransform;

		private bool showGraphics;

		private bool isCombined;

		private IMiniMapEntry target;

		public SceneReference SceneReference => SceneInfoCollection.GetSceneInfo(SceneID)?.SceneReference;

		public string SceneID => sceneID;

		private RectTransform rectTransform
		{
			get
			{
				if (_rectTransform == null)
				{
					_rectTransform = base.transform as RectTransform;
				}
				return _rectTransform;
			}
		}

		public MiniMapDisplay Master { get; private set; }

		public bool Hide
		{
			get
			{
				if (target == null)
				{
					return false;
				}
				return target.Hide;
			}
		}

		private void Awake()
		{
			MultiSceneCore.OnSubSceneLoaded += OnSubSceneLoaded;
		}

		private void OnDestroy()
		{
			MultiSceneCore.OnSubSceneLoaded -= OnSubSceneLoaded;
		}

		private void OnSubSceneLoaded(MultiSceneCore core, Scene scene)
		{
			LevelManager.LevelInitializingComment = "Mapping entries";
			UnityEngine.Debug.Log("Mapping entries", this);
			RefreshGraphics();
		}

		public bool NoSignal()
		{
			if (target == null)
			{
				return false;
			}
			return target.NoSignal;
		}

		internal void Setup(MiniMapDisplay master, IMiniMapEntry cur, bool showGraphics = true)
		{
			Master = master;
			target = cur;
			if (cur.Sprite != null)
			{
				image.sprite = cur.Sprite;
				rectTransform.sizeDelta = Vector2.one * cur.Sprite.texture.width * cur.PixelSize;
				this.showGraphics = showGraphics;
			}
			else
			{
				this.showGraphics = false;
			}
			if (cur.Hide)
			{
				this.showGraphics = false;
			}
			rectTransform.anchoredPosition = cur.Offset;
			sceneID = cur.SceneID;
			isCombined = false;
			RefreshGraphics();
		}

		internal void SetupCombined(MiniMapDisplay master, IMiniMapDataProvider dataProvider)
		{
			target = null;
			Master = master;
			if (dataProvider != null && !(dataProvider.CombinedSprite == null))
			{
				image.sprite = dataProvider.CombinedSprite;
				rectTransform.sizeDelta = Vector2.one * dataProvider.CombinedSprite.texture.width * dataProvider.PixelSize;
				rectTransform.anchoredPosition = dataProvider.CombinedCenter;
				sceneID = "";
				image.enabled = true;
				showGraphics = true;
				isCombined = true;
				RefreshGraphics();
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Right && !string.IsNullOrEmpty(sceneID))
			{
				RectTransformUtility.ScreenPointToWorldPointInRectangle(base.transform as RectTransform, eventData.position, null, out var _);
				if (Master.TryConvertToWorldPosition(eventData.position, out var result))
				{
					MiniMapView.RequestMarkPOI(result);
					eventData.Use();
				}
			}
		}

		private void RefreshGraphics()
		{
			bool flag = ShouldShow();
			if (flag)
			{
				image.color = Color.white;
			}
			else
			{
				image.color = Color.clear;
			}
			image.enabled = flag;
		}

		public bool ShouldShow()
		{
			if (!showGraphics)
			{
				return false;
			}
			if (isCombined)
			{
				return showGraphics;
			}
			if (MultiSceneCore.ActiveSubSceneID == SceneID)
			{
				return true;
			}
			return false;
		}
	}
	public class MiniMapView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private MiniMapDisplay display;

		[SerializeField]
		private TextMeshProUGUI mapNameText;

		[SerializeField]
		private TextMeshProUGUI mapInfoText;

		[SerializeField]
		private UnityEngine.UI.Slider zoomSlider;

		[SerializeField]
		private float zoomMin = 5f;

		[SerializeField]
		private float zoomMax = 20f;

		[SerializeField]
		[HideInInspector]
		private float _zoom = 5f;

		[SerializeField]
		[Range(0f, 0.01f)]
		private float scrollSensitivity = 0.01f;

		[SerializeField]
		private SimplePointOfInterest markPoiTemplate;

		[SerializeField]
		private AnimationCurve zoomCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		[SerializeField]
		private GameObject noSignalIndicator;

		public static MiniMapView Instance => View.GetViewInstance<MiniMapView>();

		private float Zoom
		{
			get
			{
				return _zoom;
			}
			set
			{
				value = Mathf.Clamp01(value);
				_zoom = value;
				OnSetZoom(value);
			}
		}

		private void OnSetZoom(float scale)
		{
			RefreshZoom();
		}

		private void RefreshZoom()
		{
			if (!(display == null))
			{
				RectTransform rectTransform = base.transform as RectTransform;
				Transform obj = display.transform;
				Vector3 vector = rectTransform.localToWorldMatrix.MultiplyPoint(rectTransform.rect.center);
				Vector3 point = obj.worldToLocalMatrix.MultiplyPoint(vector);
				display.transform.localScale = Vector3.one * Mathf.Lerp(zoomMin, zoomMax, zoomCurve.Evaluate(Zoom));
				Vector3 vector2 = obj.localToWorldMatrix.MultiplyPoint(point) - vector;
				display.transform.position -= vector2;
				zoomSlider.SetValueWithoutNotify(Zoom);
			}
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
			display.AutoSetup();
			SceneInfoEntry sceneInfoEntry = MultiSceneCore.Instance?.SceneInfo;
			if (sceneInfoEntry != null)
			{
				mapNameText.text = sceneInfoEntry.DisplayName;
				mapInfoText.text = sceneInfoEntry.Description;
			}
			else
			{
				mapNameText.text = "";
				mapInfoText.text = "";
			}
			zoomSlider.SetValueWithoutNotify(Zoom);
			RefreshZoom();
			CeneterPlayer();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		protected override void Awake()
		{
			base.Awake();
			zoomSlider.onValueChanged.AddListener(OnZoomSliderValueChanged);
		}

		private void FixedUpdate()
		{
			RefreshNoSignalIndicator();
		}

		private void RefreshNoSignalIndicator()
		{
			noSignalIndicator.SetActive(display.NoSignal());
		}

		private void OnZoomSliderValueChanged(float value)
		{
			Zoom = value;
		}

		public static void Show()
		{
			if (!(Instance == null) && !(MiniMapSettings.Instance == null))
			{
				Instance.Open();
			}
		}

		public void CeneterPlayer()
		{
			CharacterMainControl main = CharacterMainControl.Main;
			if (!(main == null) && display.TryConvertWorldToMinimap(main.transform.position, SceneInfoCollection.GetSceneID(SceneManager.GetActiveScene().buildIndex), out var result))
			{
				display.Center(result);
			}
		}

		public static bool TryConvertWorldToMinimapPosition(Vector3 worldPosition, string sceneID, out Vector3 result)
		{
			result = default(Vector3);
			if (Instance == null)
			{
				return false;
			}
			return Instance.display.TryConvertWorldToMinimap(worldPosition, sceneID, out result);
		}

		public static bool TryConvertWorldToMinimapPosition(Vector3 worldPosition, out Vector3 result)
		{
			result = default(Vector3);
			if (Instance == null)
			{
				return false;
			}
			string sceneID = SceneInfoCollection.GetSceneID(SceneManager.GetActiveScene().buildIndex);
			return TryConvertWorldToMinimapPosition(worldPosition, sceneID, out result);
		}

		internal void OnScroll(PointerEventData eventData)
		{
			Zoom += eventData.scrollDelta.y * scrollSensitivity;
			eventData.Use();
		}

		internal static void RequestMarkPOI(Vector3 worldPos)
		{
			MapMarkerManager.Request(worldPos);
		}

		public void LoadData(PackedMapData mapData)
		{
			if (!(mapData == null))
			{
				display.Setup(mapData);
			}
		}

		public void LoadCurrent()
		{
			display.AutoSetup();
		}
	}
	public class PointOfInterestEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		private RectTransform rectTransform;

		private MiniMapDisplay master;

		private MonoBehaviour target;

		private IPointOfInterest pointOfInterest;

		private MiniMapDisplayEntry minimapEntry;

		[SerializeField]
		private Transform iconContainer;

		[SerializeField]
		private Sprite defaultIcon;

		[SerializeField]
		private Color defaultColor = Color.white;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TrueShadow shadow;

		[SerializeField]
		private TextMeshProUGUI displayName;

		[SerializeField]
		private ProceduralImage areaDisplay;

		[SerializeField]
		private UnityEngine.UI.Image areaFill;

		[SerializeField]
		private float areaLineThickness = 1f;

		[SerializeField]
		private string caption;

		private Vector3 cachedWorldPosition = Vector3.zero;

		public MonoBehaviour Target => target;

		private float ParentLocalScale => base.transform.parent.localScale.x;

		internal void Setup(MiniMapDisplay master, MonoBehaviour target, MiniMapDisplayEntry minimapEntry)
		{
			rectTransform = base.transform as RectTransform;
			this.master = master;
			this.target = target;
			this.minimapEntry = minimapEntry;
			this.pointOfInterest = null;
			icon.sprite = defaultIcon;
			icon.color = defaultColor;
			areaDisplay.color = defaultColor;
			Color color = defaultColor;
			color.a *= 0.1f;
			areaFill.color = color;
			caption = target.name;
			icon.gameObject.SetActive(value: true);
			if (target is IPointOfInterest pointOfInterest)
			{
				this.pointOfInterest = pointOfInterest;
				icon.gameObject.SetActive(!this.pointOfInterest.HideIcon);
				icon.sprite = ((pointOfInterest.Icon != null) ? pointOfInterest.Icon : defaultIcon);
				icon.color = pointOfInterest.Color;
				if ((bool)shadow)
				{
					shadow.Color = pointOfInterest.ShadowColor;
					shadow.OffsetDistance = pointOfInterest.ShadowDistance;
				}
				string value = this.pointOfInterest.DisplayName;
				caption = pointOfInterest.DisplayName;
				if (string.IsNullOrEmpty(value))
				{
					displayName.gameObject.SetActive(value: false);
				}
				else
				{
					displayName.gameObject.SetActive(value: true);
					displayName.text = this.pointOfInterest.DisplayName;
				}
				if (pointOfInterest.IsArea)
				{
					areaDisplay.gameObject.SetActive(value: true);
					rectTransform.sizeDelta = this.pointOfInterest.AreaRadius * Vector2.one * 2f;
					areaDisplay.color = pointOfInterest.Color;
					color = pointOfInterest.Color;
					color.a *= 0.1f;
					areaFill.color = color;
					areaDisplay.BorderWidth = areaLineThickness / ParentLocalScale;
				}
				else
				{
					icon.enabled = true;
					areaDisplay.gameObject.SetActive(value: false);
				}
				RefreshPosition();
				base.gameObject.SetActive(value: true);
			}
		}

		private void RefreshPosition()
		{
			cachedWorldPosition = target.transform.position;
			Vector3 centerOfObjectScene = MiniMapCenter.GetCenterOfObjectScene(target);
			Vector3 vector = target.transform.position - centerOfObjectScene;
			Vector3 point = new Vector2(vector.x, vector.z);
			Vector3 position = minimapEntry.transform.localToWorldMatrix.MultiplyPoint(point);
			base.transform.position = position;
			UpdateScale();
			UpdateRotation();
		}

		private void Update()
		{
			UpdateScale();
			UpdatePosition();
			UpdateRotation();
		}

		private void UpdateScale()
		{
			float num = ((pointOfInterest != null) ? pointOfInterest.ScaleFactor : 1f);
			iconContainer.localScale = Vector3.one * num / ParentLocalScale;
			if (pointOfInterest != null && pointOfInterest.IsArea)
			{
				areaDisplay.BorderWidth = areaLineThickness / ParentLocalScale;
				areaDisplay.FalloffDistance = 1f / ParentLocalScale;
			}
		}

		private void UpdatePosition()
		{
			if (cachedWorldPosition != target.transform.position)
			{
				RefreshPosition();
			}
		}

		private void UpdateRotation()
		{
			base.transform.rotation = Quaternion.identity;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			pointOfInterest.NotifyClicked(eventData);
			if (CheatMode.Active && UIInputManager.Ctrl && UIInputManager.Alt && UIInputManager.Shift && MiniMapCenter.GetSceneID(target) != null)
			{
				CharacterMainControl.Main.SetPosition(target.transform.position);
			}
		}
	}
}
namespace Duckov.MiniMaps.Editor
{
	public class MiniMapShooter : MonoBehaviour
	{
		private void Awake()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
namespace Duckov.MiniGames
{
	public class VirtualCursor : MiniGameBehaviour
	{
		[SerializeField]
		private RectTransform rectTransform;

		[SerializeField]
		private RectTransform moveArea;

		[SerializeField]
		private Canvas canvas;

		private RectTransform canvasRectTransform;

		[SerializeField]
		private GraphicRaycaster raycaster;

		[SerializeField]
		private float sensitivity = 0.5f;

		private static GameObject raycastGO;

		private static VirtualCursorTarget target;

		[NonSerialized]
		private List<Graphic> m_RaycastResults = new List<Graphic>();

		private Vector3 eventPositionWatch;

		[NonSerialized]
		private static List<Graphic> s_canvasGraphics = new List<Graphic>();

		[NonSerialized]
		private static readonly List<Graphic> s_SortedGraphics = new List<Graphic>();

		private void Awake()
		{
			if (rectTransform == null)
			{
				rectTransform = base.transform as RectTransform;
			}
			if (moveArea == null)
			{
				moveArea = rectTransform.parent as RectTransform;
			}
			if (canvas == null)
			{
				canvas = GetComponentInParent<Canvas>();
			}
			canvasRectTransform = canvas.transform as RectTransform;
			if (raycaster == null)
			{
				raycaster = GetComponentInParent<GraphicRaycaster>();
			}
		}

		private void Update()
		{
			if (base.Game == null || ((bool)base.Game.Console && !base.Game.Console.Interacting))
			{
				return;
			}
			Vector2 mouseDelta = UIInputManager.MouseDelta;
			Vector3 localPosition = rectTransform.localPosition + (Vector3)mouseDelta * sensitivity;
			Rect rect = moveArea.rect;
			localPosition.x = Mathf.Clamp(localPosition.x, rect.min.x, rect.max.x);
			localPosition.y = Mathf.Clamp(localPosition.y, rect.min.y, rect.max.y);
			rectTransform.localPosition = localPosition;
			List<RaycastResult> list = new List<RaycastResult>();
			Raycast(list);
			RaycastResult raycastResult = FindFirstRaycast(list);
			if (raycastResult.gameObject != raycastGO)
			{
				VirtualCursorTarget virtualCursorTarget = target;
				VirtualCursorTarget virtualCursorTarget2 = ((!(raycastResult.gameObject != null)) ? null : raycastResult.gameObject.GetComponent<VirtualCursorTarget>());
				if (virtualCursorTarget2 != virtualCursorTarget)
				{
					target = virtualCursorTarget2;
					OnChange(virtualCursorTarget2, virtualCursorTarget);
				}
			}
			if (UIInputManager.WasClickedThisFrame && target != null)
			{
				target.OnClick();
			}
		}

		private void OnChange(VirtualCursorTarget newTarget, VirtualCursorTarget oldTarget)
		{
			if (newTarget != null)
			{
				newTarget.OnCursorEnter();
			}
			if (oldTarget != null)
			{
				oldTarget.OnCursorExit();
			}
		}

		private void Raycast(List<RaycastResult> resultAppendList)
		{
			if (canvas == null)
			{
				return;
			}
			IList<Graphic> raycastableGraphicsForCanvas = GraphicRegistry.GetRaycastableGraphicsForCanvas(canvas);
			s_canvasGraphics.Clear();
			if (raycastableGraphicsForCanvas != null && raycastableGraphicsForCanvas.Count > 0)
			{
				for (int i = 0; i < raycastableGraphicsForCanvas.Count; i++)
				{
					s_canvasGraphics.Add(raycastableGraphicsForCanvas[i]);
				}
				Camera eventCamera = raycaster.eventCamera;
				Vector3 vector = eventCamera.WorldToScreenPoint(base.transform.position);
				vector.z = 0f;
				eventPositionWatch = vector;
				m_RaycastResults.Clear();
				Raycast(canvas, eventCamera, vector, raycastableGraphicsForCanvas, m_RaycastResults);
				int count = m_RaycastResults.Count;
				for (int j = 0; j < count; j++)
				{
					GameObject gameObject = m_RaycastResults[j].gameObject;
					float distance = 0f;
					Vector3 forward = gameObject.transform.forward;
					RaycastResult item = new RaycastResult
					{
						gameObject = gameObject,
						module = raycaster,
						distance = distance,
						screenPosition = vector,
						displayIndex = 0,
						index = resultAppendList.Count,
						depth = m_RaycastResults[j].depth,
						sortingLayer = canvas.sortingLayerID,
						sortingOrder = canvas.sortingOrder,
						worldPosition = vector,
						worldNormal = -forward
					};
					resultAppendList.Add(item);
				}
			}
		}

		private static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList<Graphic> foundGraphics, List<Graphic> results)
		{
			int count = foundGraphics.Count;
			for (int i = 0; i < count; i++)
			{
				Graphic graphic = foundGraphics[i];
				if (graphic.raycastTarget && !graphic.canvasRenderer.cull && graphic.depth != -1 && RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera, graphic.raycastPadding) && (!(eventCamera != null) || !(eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z > eventCamera.farClipPlane)) && graphic.Raycast(pointerPosition, eventCamera))
				{
					s_SortedGraphics.Add(graphic);
				}
			}
			s_SortedGraphics.Sort((Graphic g1, Graphic g2) => g2.depth.CompareTo(g1.depth));
			count = s_SortedGraphics.Count;
			for (int num = 0; num < count; num++)
			{
				results.Add(s_SortedGraphics[num]);
			}
			s_SortedGraphics.Clear();
		}

		private static RaycastResult FindFirstRaycast(List<RaycastResult> candidates)
		{
			int count = candidates.Count;
			for (int i = 0; i < count; i++)
			{
				if (!(candidates[i].gameObject == null))
				{
					return candidates[i];
				}
			}
			return default(RaycastResult);
		}

		internal static bool IsHovering(VirtualCursorTarget virtualCursorTarget)
		{
			return virtualCursorTarget == target;
		}
	}
	public class VirtualCursorTarget : MiniGameBehaviour
	{
		public UnityEvent onEnter;

		public UnityEvent onExit;

		public UnityEvent onClick;

		public bool IsHovering => VirtualCursor.IsHovering(this);

		public void OnCursorEnter()
		{
			onEnter?.Invoke();
		}

		public void OnCursorExit()
		{
			onExit?.Invoke();
		}

		public void OnClick()
		{
			onClick?.Invoke();
		}
	}
	public class GamingConsole : InteractableBase
	{
		[Serializable]
		private class SaveData
		{
			public ItemTreeData monitorData;

			public ItemTreeData consoleData;
		}

		[SerializeField]
		private List<MiniGame> possibleGames;

		[SerializeField]
		private RenderTexture rt;

		[SerializeField]
		private MiniGameInputHandler inputHandler;

		[SerializeField]
		private CinemachineVirtualCamera virtualCamera;

		[SerializeField]
		private float transitionTime = 1f;

		[SerializeField]
		private Transform vcamEndPosition;

		[SerializeField]
		private Transform vcamLookTarget;

		[SerializeField]
		private AnimationCurve posCurve;

		[SerializeField]
		private AnimationCurve rotCurve;

		[SerializeField]
		private AnimationCurve fovCurve;

		[SerializeField]
		private float activeFov = 45f;

		[SerializeField]
		private Transform teleportToPositionWhenBegin;

		[SerializeField]
		private Item mainItem;

		[SerializeField]
		[LocalizationKey("Default")]
		private string incompleteNotificationText = "GamingConsole_Incomplete";

		[SerializeField]
		[LocalizationKey("Default")]
		private string noGameNotificationText = "GamingConsole_NoGame";

		private MiniGame game;

		private string SaveKey = "GamingConsoleData";

		private bool loading;

		private bool loaded;

		private bool isBeingDestroyed;

		private int animateToken;

		public MiniGame SelectedGame
		{
			get
			{
				if (CatridgeGameID == null)
				{
					return null;
				}
				return possibleGames.Find((MiniGame e) => e != null && e.ID == CatridgeGameID);
			}
		}

		public MiniGame Game => game;

		public Slot MonitorSlot => mainItem.Slots["Monitor"];

		public Slot ConsoleSlot => mainItem.Slots["Console"];

		public bool controllerConnected
		{
			get
			{
				if (mainItem == null)
				{
					return false;
				}
				if (ConsoleSlot == null)
				{
					return false;
				}
				Item content = ConsoleSlot.Content;
				if (content == null)
				{
					return false;
				}
				Slot slot = content.Slots["FcController"];
				if (slot == null)
				{
					return false;
				}
				return slot.Content != null;
			}
		}

		public Item Monitor
		{
			get
			{
				if (MonitorSlot == null)
				{
					return null;
				}
				return MonitorSlot.Content;
			}
		}

		public Item Console
		{
			get
			{
				if (ConsoleSlot == null)
				{
					return null;
				}
				return ConsoleSlot.Content;
			}
		}

		public Item Cartridge
		{
			get
			{
				if (Console == null)
				{
					return null;
				}
				if (!Console.Slots)
				{
					UnityEngine.Debug.LogError(Console.DisplayName + " has no catridge slot");
					return null;
				}
				Slot slot = Console.Slots["Cartridge"];
				if (slot == null)
				{
					UnityEngine.Debug.LogError(Console.DisplayName + " has no catridge slot");
					return null;
				}
				return slot.Content;
			}
		}

		public string CatridgeGameID
		{
			get
			{
				if (Cartridge == null)
				{
					return null;
				}
				return Cartridge.Constants.GetString("GameID");
			}
		}

		public event Action<GamingConsole> onContentChanged;

		public event Action<GamingConsole> OnAfterAnimateIn;

		public event Action<GamingConsole> OnBeforeAnimateOut;

		public static event Action<bool> OnGamingConsoleInteractChanged;

		private async UniTask Load()
		{
			if (loading)
			{
				UnityEngine.Debug.LogError("Component is loading in progress, aborting.");
				return;
			}
			while (!LevelManager.LevelInited)
			{
				await UniTask.Yield();
			}
			SaveData data = SavesSystem.Load<SaveData>(SaveKey);
			if (data == null)
			{
				loaded = true;
				return;
			}
			if (data.monitorData != null)
			{
				Item item = await ItemTreeData.InstantiateAsync(data.monitorData);
				if (item != null)
				{
					if (!MonitorSlot.Plug(item, out var unpluggedItem))
					{
						ItemUtilities.SendToPlayer(item);
					}
					if (unpluggedItem != null)
					{
						unpluggedItem.DestroyTree();
					}
				}
			}
			if (data.consoleData != null)
			{
				Item item2 = await ItemTreeData.InstantiateAsync(data.consoleData);
				if (item2 != null)
				{
					if (!ConsoleSlot.Plug(item2, out var unpluggedItem2))
					{
						ItemUtilities.SendToPlayer(item2);
					}
					if (unpluggedItem2 != null)
					{
						unpluggedItem2.DestroyTree();
					}
				}
			}
			loading = false;
			loaded = true;
			this.onContentChanged?.Invoke(this);
		}

		private void Save()
		{
			if (!loading && loaded)
			{
				SaveData saveData = new SaveData();
				if (Console != null)
				{
					saveData.consoleData = ItemTreeData.FromItem(Console);
				}
				if (Monitor != null)
				{
					saveData.monitorData = ItemTreeData.FromItem(Monitor);
				}
				SavesSystem.Save(SaveKey, saveData);
			}
		}

		protected override void Awake()
		{
			base.Awake();
			UIInputManager.OnCancel += OnUICancel;
			SavesSystem.OnCollectSaveData += Save;
			inputHandler.enabled = false;
			mainItem.onItemTreeChanged += OnContentChanged;
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			GamingConsole.OnGamingConsoleInteractChanged?.Invoke(obj: false);
			UIInputManager.OnCancel -= OnUICancel;
			SavesSystem.OnCollectSaveData -= Save;
			isBeingDestroyed = true;
		}

		private void OnDisable()
		{
			GamingConsole.OnGamingConsoleInteractChanged?.Invoke(obj: false);
		}

		protected override void Start()
		{
			base.Start();
			Load().Forget();
		}

		private void OnContentChanged(Item item)
		{
			this.onContentChanged?.Invoke(this);
			RefreshGame();
		}

		private void OnUICancel(UIInputEventData data)
		{
			if (!data.Used && base.Interacting)
			{
				StopInteract();
				data.Use();
			}
		}

		protected override void OnInteractStart(CharacterMainControl interactCharacter)
		{
			base.OnInteractStart(interactCharacter);
			GamingConsole.OnGamingConsoleInteractChanged?.Invoke(this);
			if (Console == null || Monitor == null || Cartridge == null)
			{
				NotificationText.Push(incompleteNotificationText.ToPlainText());
				StopInteract();
				return;
			}
			if (SelectedGame == null)
			{
				NotificationText.Push(noGameNotificationText.ToPlainText());
				StopInteract();
				return;
			}
			RefreshGame();
			inputHandler.enabled = controllerConnected;
			AnimateCameraIn().Forget();
			HUDManager.RegisterHideToken(this);
			CharacterMainControl.Main.SetPosition(teleportToPositionWhenBegin.position);
			GamingConsoleHUD.Show();
		}

		private async UniTask AnimateCameraIn()
		{
			int token = (animateToken = UnityEngine.Random.Range(0, int.MaxValue));
			Vector3 toPos = vcamEndPosition.position;
			Quaternion rotation = vcamEndPosition.rotation;
			float toFov = activeFov;
			if (!(GameCamera.Instance == null) && !(GameCamera.Instance.mainVCam == null))
			{
				CinemachineVirtualCamera mainVCam = GameCamera.Instance.mainVCam;
				Vector3 fromPos = mainVCam.transform.position;
				Quaternion fromRot = mainVCam.transform.rotation;
				float fromFov = mainVCam.m_Lens.FieldOfView;
				virtualCamera.transform.position = fromPos;
				virtualCamera.transform.rotation = fromRot;
				virtualCamera.Priority = 10;
				float time = 0f;
				while (time < transitionTime)
				{
					time += Time.deltaTime;
					float time2 = time / transitionTime;
					float t = posCurve.Evaluate(time2);
					float t2 = rotCurve.Evaluate(time2);
					float t3 = fovCurve.Evaluate(time2);
					Vector3 vector = Vector3.Lerp(fromPos, toPos, t);
					rotation = Quaternion.LookRotation(vcamLookTarget.position - vector, Vector3.up);
					Quaternion rotation2 = Quaternion.Lerp(fromRot, rotation, t2);
					float fieldOfView = Mathf.Lerp(fromFov, toFov, t3);
					virtualCamera.transform.SetPositionAndRotation(vector, rotation2);
					virtualCamera.m_Lens.FieldOfView = fieldOfView;
					await UniTask.Yield();
					if (animateToken != token)
					{
						return;
					}
				}
				rotation = Quaternion.LookRotation(vcamLookTarget.position - toPos, Vector3.up);
			}
			virtualCamera.transform.SetPositionAndRotation(toPos, rotation);
			virtualCamera.m_Lens.FieldOfView = toFov;
			this.OnAfterAnimateIn?.Invoke(this);
		}

		private async UniTask AnimateCameraOut()
		{
			this.OnBeforeAnimateOut?.Invoke(this);
			int token = (animateToken = UnityEngine.Random.Range(0, int.MaxValue));
			GameCamera instance = GameCamera.Instance;
			if (!(instance == null))
			{
				CinemachineVirtualCamera mainVCam = instance.mainVCam;
				if (!(mainVCam == null))
				{
					Vector3 fromPos = virtualCamera.transform.position;
					float fromFov = activeFov;
					float time = 0f;
					while (time < transitionTime)
					{
						if (mainVCam == null)
						{
							return;
						}
						time += Time.deltaTime;
						float time2 = 1f - time / transitionTime;
						float t = 1f - posCurve.Evaluate(time2);
						float t2 = 1f - rotCurve.Evaluate(time2);
						float t3 = 1f - fovCurve.Evaluate(time2);
						Vector3 position = mainVCam.transform.position;
						Quaternion rotation = mainVCam.transform.rotation;
						float fieldOfView = mainVCam.m_Lens.FieldOfView;
						Vector3 vector = Vector3.Lerp(fromPos, position, t);
						Quaternion rotation2 = Quaternion.Lerp(Quaternion.LookRotation(vcamLookTarget.position - vector, Vector3.up), rotation, t2);
						float fieldOfView2 = Mathf.Lerp(fromFov, fieldOfView, t3);
						virtualCamera.transform.SetPositionAndRotation(vector, rotation2);
						virtualCamera.m_Lens.FieldOfView = fieldOfView2;
						await UniTask.Yield();
						if (animateToken != token)
						{
							return;
						}
					}
				}
			}
			virtualCamera.Priority = -1;
		}

		protected override void OnInteractStop()
		{
			base.OnInteractStop();
			GamingConsole.OnGamingConsoleInteractChanged?.Invoke(obj: false);
			inputHandler.enabled = false;
			AnimateCameraOut().Forget();
			HUDManager.UnregisterHideToken(this);
			GamingConsoleHUD.Hide();
		}

		private void RefreshGame()
		{
			if (game == null)
			{
				CreateGame(SelectedGame);
			}
			else if (SelectedGame == null || SelectedGame.ID != game.ID)
			{
				CreateGame(SelectedGame);
			}
		}

		private void CreateGame(MiniGame prefab)
		{
			if (!isBeingDestroyed)
			{
				if (game != null)
				{
					UnityEngine.Object.Destroy(game.gameObject);
				}
				if (!(prefab == null))
				{
					game = UnityEngine.Object.Instantiate(prefab);
					game.transform.SetParent(base.transform, worldPositionStays: true);
					game.SetRenderTexture(rt);
					game.SetConsole(this);
					inputHandler.SetGame(game);
				}
			}
		}
	}
	public class GamingConsoleAnimator : MonoBehaviour
	{
		[SerializeField]
		private Animator animator;

		[SerializeField]
		private GamingConsole console;

		private Vector2 joyStick_Current;

		private Vector2 joyStick_Target;

		[SerializeField]
		private MiniGame Game
		{
			get
			{
				if (console == null)
				{
					return null;
				}
				return console.Game;
			}
		}

		private void Update()
		{
			Tick();
		}

		private void Tick()
		{
			if (Game == null)
			{
				Clear();
			}
			else if (!CameraMode.Active)
			{
				joyStick_Target = Game.GetAxis();
				joyStick_Current = Vector2.Lerp(joyStick_Current, joyStick_Target, 0.25f);
				Vector2 vector = joyStick_Current;
				animator.SetFloat("AxisX", vector.x);
				animator.SetFloat("AxisY", vector.y);
				animator.SetBool("ButtonA", Game.GetButton(MiniGame.Button.A));
				animator.SetBool("ButtonB", Game.GetButton(MiniGame.Button.B));
			}
		}

		private void Clear()
		{
			animator.SetBool("ButtonA", value: false);
			animator.SetBool("ButtonB", value: false);
			animator.SetFloat("AxisX", 0f);
			animator.SetFloat("AxisY", 0f);
		}
	}
	public class GamingConsoleHUD : View
	{
		[SerializeField]
		private FadeGroup contentFadeGroup;

		private static GamingConsoleHUD _instance_cache;

		private static GamingConsoleHUD Instance
		{
			get
			{
				if (_instance_cache == null)
				{
					_instance_cache = View.GetViewInstance<GamingConsoleHUD>();
				}
				return _instance_cache;
			}
		}

		public static void Show()
		{
			if (!(Instance == null))
			{
				Instance.LocalShow();
			}
		}

		public static void Hide()
		{
			if (!(Instance == null))
			{
				Instance.LocalHide();
			}
		}

		private void LocalShow()
		{
			contentFadeGroup.Show();
		}

		private void LocalHide()
		{
			contentFadeGroup.Hide();
		}
	}
	public class MiniGame : MonoBehaviour
	{
		public enum TickTiming
		{
			Manual,
			Update,
			FixedUpdate,
			LateUpdate
		}

		public enum Button
		{
			None,
			A,
			B,
			Start,
			Select,
			Left,
			Right,
			Up,
			Down
		}

		public class ButtonStatus
		{
			public bool pressed;

			public bool justPressed;

			public bool justReleased;
		}

		public struct MiniGameInputEventContext
		{
			public bool isButtonEvent;

			public Button button;

			public bool pressing;

			public bool buttonDown;

			public bool buttonUp;

			public bool isAxisEvent;

			public int axisIndex;

			public Vector2 axisValue;
		}

		[SerializeField]
		private string id;

		public TickTiming tickTiming;

		[SerializeField]
		private Camera camera;

		[SerializeField]
		private Camera uiCamera;

		[SerializeField]
		private RenderTexture renderTexture;

		public static Action<MiniGame, float> onUpdateLogic;

		private GamingConsole console;

		private Vector2 inputAxis_0;

		private Vector2 inputAxis_1;

		private Dictionary<Button, ButtonStatus> buttons = new Dictionary<Button, ButtonStatus>();

		public string ID => id;

		public Camera Camera => camera;

		public Camera UICamera => uiCamera;

		public RenderTexture RenderTexture => renderTexture;

		public GamingConsole Console => console;

		public static event Action<MiniGame, MiniGameInputEventContext> OnInput;

		public void SetRenderTexture(RenderTexture texture)
		{
			camera.targetTexture = texture;
			if ((bool)uiCamera)
			{
				uiCamera.targetTexture = texture;
			}
		}

		public RenderTexture CreateAndSetRenderTexture(int width, int height)
		{
			RenderTexture result = new RenderTexture(width, height, 32);
			SetRenderTexture(result);
			return result;
		}

		private void Awake()
		{
			if (renderTexture != null)
			{
				SetRenderTexture(renderTexture);
			}
		}

		public void SetInputAxis(Vector2 axis, int index = 0)
		{
			Vector2 vector = inputAxis_0;
			if (index == 0)
			{
				inputAxis_0 = axis;
			}
			if (index == 1)
			{
				inputAxis_1 = axis;
			}
			if (index == 0)
			{
				bool flag = axis.x < -0.1f;
				bool flag2 = axis.x > 0.1f;
				bool flag3 = axis.y > 0.1f;
				bool flag4 = axis.y < -0.1f;
				bool flag5 = vector.x < -0.1f;
				bool flag6 = vector.x > 0.1f;
				bool flag7 = vector.y > 0.1f;
				bool flag8 = vector.y < -0.1f;
				if (flag != flag5)
				{
					SetButton(Button.Left, flag);
				}
				if (flag2 != flag6)
				{
					SetButton(Button.Right, flag2);
				}
				if (flag3 != flag7)
				{
					SetButton(Button.Up, flag3);
				}
				if (flag4 != flag8)
				{
					SetButton(Button.Down, flag4);
				}
			}
			MiniGame.OnInput?.Invoke(this, new MiniGameInputEventContext
			{
				isAxisEvent = true,
				axisIndex = index,
				axisValue = axis
			});
		}

		public void SetButton(Button button, bool down)
		{
			if (!buttons.TryGetValue(button, out var value))
			{
				value = new ButtonStatus();
				buttons[button] = value;
			}
			if (down)
			{
				value.justPressed = true;
				value.pressed = true;
			}
			else
			{
				value.pressed = false;
				value.justReleased = true;
			}
			buttons[button] = value;
			MiniGame.OnInput?.Invoke(this, new MiniGameInputEventContext
			{
				isButtonEvent = true,
				button = button,
				pressing = value.pressed,
				buttonDown = value.justPressed,
				buttonUp = value.justReleased
			});
		}

		public bool GetButton(Button button)
		{
			if (!buttons.TryGetValue(button, out var value))
			{
				return false;
			}
			return value.pressed;
		}

		public bool GetButtonDown(Button button)
		{
			if (!buttons.TryGetValue(button, out var value))
			{
				return false;
			}
			return value.justPressed;
		}

		public bool GetButtonUp(Button button)
		{
			if (!buttons.TryGetValue(button, out var value))
			{
				return false;
			}
			return value.justReleased;
		}

		public Vector2 GetAxis(int index = 0)
		{
			return index switch
			{
				0 => inputAxis_0, 
				1 => inputAxis_1, 
				_ => default(Vector2), 
			};
		}

		private void Tick(float deltaTime)
		{
			UpdateLogic(deltaTime);
			Cleanup();
		}

		private void UpdateLogic(float deltaTime)
		{
			onUpdateLogic?.Invoke(this, deltaTime);
		}

		private void Cleanup()
		{
			foreach (ButtonStatus value in buttons.Values)
			{
				value.justPressed = false;
				value.justReleased = false;
			}
		}

		private void Update()
		{
			if (tickTiming == TickTiming.Update)
			{
				Tick(Time.deltaTime);
			}
		}

		private void FixedUpdate()
		{
			if (tickTiming == TickTiming.FixedUpdate)
			{
				Tick(Time.fixedDeltaTime);
			}
		}

		private void LateUpdate()
		{
			if (tickTiming == TickTiming.FixedUpdate)
			{
				Tick(Time.deltaTime);
			}
		}

		public void ClearInput()
		{
			foreach (ButtonStatus value in buttons.Values)
			{
				if (value.pressed)
				{
					value.justReleased = true;
				}
				value.pressed = false;
			}
			SetInputAxis(default(Vector2));
			SetInputAxis(default(Vector2), 1);
		}

		internal void SetConsole(GamingConsole console)
		{
			this.console = console;
		}
	}
	public class MiniGameBehaviour : MonoBehaviour
	{
		[SerializeField]
		private MiniGame game;

		public MiniGame Game => game;

		public void SetGame(MiniGame game = null)
		{
			if (game == null)
			{
				this.game = GetComponentInParent<MiniGame>();
			}
			else
			{
				this.game = game;
			}
		}

		private void OnUpdateLogic(MiniGame game, float deltaTime)
		{
			if (!(this == null) && base.enabled && !(game == null) && !(game != this.game))
			{
				OnUpdate(deltaTime);
			}
		}

		protected virtual void OnEnable()
		{
			MiniGame.onUpdateLogic = (Action<MiniGame, float>)Delegate.Combine(MiniGame.onUpdateLogic, new Action<MiniGame, float>(OnUpdateLogic));
		}

		protected virtual void OnDisable()
		{
			MiniGame.onUpdateLogic = (Action<MiniGame, float>)Delegate.Remove(MiniGame.onUpdateLogic, new Action<MiniGame, float>(OnUpdateLogic));
		}

		private void OnDestroy()
		{
			MiniGame.onUpdateLogic = (Action<MiniGame, float>)Delegate.Remove(MiniGame.onUpdateLogic, new Action<MiniGame, float>(OnUpdateLogic));
		}

		protected virtual void Start()
		{
			if (game == null)
			{
				SetGame();
			}
		}

		protected virtual void OnUpdate(float deltaTime)
		{
		}
	}
	public class MiniGameInputHandler : MonoBehaviour
	{
		[SerializeField]
		private MiniGame game;

		private InputAction inputActionMove;

		private InputAction inputActionButtonA;

		private InputAction inputActionButtonB;

		private InputAction inputActionSelect;

		private InputAction inputActionStart;

		private InputAction inputActionMouseDelta;

		private List<Action> unbindCommands = new List<Action>();

		private void Awake()
		{
			InputActionAsset actions = GameManager.MainPlayerInput.actions;
			inputActionMove = actions["MoveAxis"];
			inputActionButtonA = actions["MiniGameA"];
			inputActionButtonB = actions["MiniGameB"];
			inputActionSelect = actions["MiniGameSelect"];
			inputActionStart = actions["MiniGameStart"];
			inputActionMouseDelta = actions["MouseDelta"];
			inputActionButtonA.actionMap.Enable();
			Bind(inputActionMove, OnMove);
			Bind(inputActionButtonA, OnButtonA);
			Bind(inputActionButtonB, OnButtonB);
			Bind(inputActionSelect, OnSelect);
			Bind(inputActionStart, OnStart);
			Bind(inputActionMouseDelta, OnMouseDelta);
		}

		private void OnMouseDelta(InputAction.CallbackContext context)
		{
			if (base.isActiveAndEnabled && !(game == null))
			{
				game.SetInputAxis(context.ReadValue<Vector2>(), 1);
			}
		}

		public void ClearInput()
		{
			game?.ClearInput();
		}

		private void OnDisable()
		{
			ClearInput();
		}

		private void SetGameButtonByContext(MiniGame.Button button, InputAction.CallbackContext context)
		{
			if (context.started)
			{
				game.SetButton(button, down: true);
			}
			else if (context.canceled)
			{
				game.SetButton(button, down: false);
			}
		}

		private void OnStart(InputAction.CallbackContext context)
		{
			if (base.isActiveAndEnabled && !(game == null))
			{
				SetGameButtonByContext(MiniGame.Button.Start, context);
			}
		}

		private void OnSelect(InputAction.CallbackContext context)
		{
			if (base.isActiveAndEnabled && !(game == null))
			{
				SetGameButtonByContext(MiniGame.Button.Select, context);
			}
		}

		private void OnButtonB(InputAction.CallbackContext context)
		{
			if (base.isActiveAndEnabled && !(game == null))
			{
				SetGameButtonByContext(MiniGame.Button.B, context);
			}
		}

		private void OnButtonA(InputAction.CallbackContext context)
		{
			if (base.isActiveAndEnabled && !(game == null))
			{
				SetGameButtonByContext(MiniGame.Button.A, context);
			}
		}

		private void OnMove(InputAction.CallbackContext context)
		{
			if (base.isActiveAndEnabled && !(game == null))
			{
				game.SetInputAxis(context.ReadValue<Vector2>());
			}
		}

		private void OnDestroy()
		{
			foreach (Action unbindCommand in unbindCommands)
			{
				unbindCommand?.Invoke();
			}
		}

		private void Bind(InputAction inputAction, Action<InputAction.CallbackContext> action)
		{
			inputAction.Enable();
			inputAction.started += action;
			inputAction.performed += action;
			inputAction.canceled += action;
			unbindCommands.Add(delegate
			{
				inputAction.started -= action;
				inputAction.performed -= action;
				inputAction.canceled -= action;
			});
		}

		internal void SetGame(MiniGame game)
		{
			this.game = game;
		}
	}
}
namespace Duckov.MiniGames.Utilities
{
	public class ControllerAnimator : MonoBehaviour
	{
		private GamingConsole master;

		public Transform mainTransform;

		public Transform btn_A;

		public Transform btn_B;

		public Transform btn_Start;

		public Transform btn_Select;

		public Transform btn_Axis;

		public Transform fxPos_Up;

		public Transform fxPos_Right;

		public Transform fxPos_Down;

		public Transform fxPos_Left;

		[SerializeField]
		private float transitionDuration = 0.2f;

		[SerializeField]
		private float axisAmp = 10f;

		[SerializeField]
		private float btnDepth = 0.003f;

		[SerializeField]
		private float torqueStrength = 5f;

		[SerializeField]
		private float torqueDuration = 0.5f;

		[SerializeField]
		private int torqueVibrato = 1;

		[SerializeField]
		private float torqueElasticity = 1f;

		[SerializeField]
		private ParticleSystem buttonPressFX;

		[SerializeField]
		private ParticleSystem buttonRestFX;

		private void OnEnable()
		{
			MiniGame.OnInput += OnMiniGameInput;
		}

		private void OnDisable()
		{
			MiniGame.OnInput -= OnMiniGameInput;
		}

		private void OnMiniGameInput(MiniGame game, MiniGame.MiniGameInputEventContext context)
		{
			if (!(master == null) && !(master.Game != game))
			{
				HandleInput(context);
			}
		}

		private void HandleInput(MiniGame.MiniGameInputEventContext context)
		{
			if (context.isButtonEvent)
			{
				HandleButtonEvent(context);
			}
			else if (context.isAxisEvent)
			{
				HandleAxisEvent(context);
			}
		}

		private void HandleAxisEvent(MiniGame.MiniGameInputEventContext context)
		{
			if (context.axisIndex == 0)
			{
				SetAxis(context.axisValue);
			}
		}

		private void HandleButtonEvent(MiniGame.MiniGameInputEventContext context)
		{
			switch (context.button)
			{
			case MiniGame.Button.A:
				HandleBtnPushRest(btn_A, context.pressing);
				break;
			case MiniGame.Button.B:
				HandleBtnPushRest(btn_B, context.pressing);
				break;
			case MiniGame.Button.Start:
				HandleBtnPushRest(btn_Start, context.pressing);
				break;
			case MiniGame.Button.Select:
				HandleBtnPushRest(btn_Select, context.pressing);
				break;
			case MiniGame.Button.Left:
			case MiniGame.Button.Right:
			case MiniGame.Button.Up:
			case MiniGame.Button.Down:
				PlayAxisPressReleaseFX(context.button, context.pressing);
				break;
			}
			if (context.pressing)
			{
				switch (context.button)
				{
				case MiniGame.Button.A:
					ApplyTorque(1f, -0.5f);
					break;
				case MiniGame.Button.B:
					ApplyTorque(1f, -0f);
					break;
				case MiniGame.Button.Start:
					ApplyTorque(0.5f, -0.5f);
					break;
				case MiniGame.Button.Select:
					ApplyTorque(-0.5f, -0.5f);
					break;
				case MiniGame.Button.Up:
					ApplyTorque(-1f, 0.5f);
					break;
				case MiniGame.Button.Right:
					ApplyTorque(-0.5f, 0f);
					break;
				case MiniGame.Button.Down:
					ApplyTorque(-1f, -0.5f);
					break;
				case MiniGame.Button.Left:
					ApplyTorque(-1f, 0f);
					break;
				case MiniGame.Button.None:
					break;
				}
			}
			else
			{
				ApplyTorque(UnityEngine.Random.insideUnitCircle * 0.25f);
			}
		}

		private void PlayAxisPressReleaseFX(MiniGame.Button button, bool pressing)
		{
			Transform transform = null;
			switch (button)
			{
			case MiniGame.Button.Up:
				transform = fxPos_Up;
				break;
			case MiniGame.Button.Right:
				transform = fxPos_Right;
				break;
			case MiniGame.Button.Down:
				transform = fxPos_Down;
				break;
			case MiniGame.Button.Left:
				transform = fxPos_Left;
				break;
			}
			if (!(transform == null))
			{
				if (pressing)
				{
					FXPool.Play(buttonPressFX, transform.position, transform.rotation);
				}
				else
				{
					FXPool.Play(buttonRestFX, transform.position, transform.rotation);
				}
			}
		}

		private void ApplyTorque(float x, float y)
		{
			if (!(mainTransform == null))
			{
				mainTransform.DOKill();
				Vector3 punch = new Vector3(0f - y, 0f - x, 0f) * torqueStrength;
				mainTransform.localRotation = Quaternion.identity;
				mainTransform.DOPunchRotation(punch, torqueDuration, torqueVibrato, torqueElasticity);
			}
		}

		private void ApplyTorque(Vector2 torque)
		{
			ApplyTorque(torque.x, torque.y);
		}

		private void HandleBtnPushRest(Transform btnTrans, bool pressed)
		{
			if (pressed)
			{
				Push(btnTrans);
			}
			else
			{
				Rest(btnTrans);
			}
		}

		internal void SetConsole(GamingConsole master)
		{
			this.master = master;
			RefreshAll();
		}

		private void RefreshAll()
		{
			RestAll();
			if (master == null)
			{
				return;
			}
			MiniGame game = master.Game;
			if (!(game == null))
			{
				if (game.GetButton(MiniGame.Button.A))
				{
					Push(btn_A);
				}
				if (game.GetButton(MiniGame.Button.B))
				{
					Push(btn_B);
				}
				if (game.GetButton(MiniGame.Button.Select))
				{
					Push(btn_Select);
				}
				if (game.GetButton(MiniGame.Button.Start))
				{
					Push(btn_Start);
				}
				SetAxis(game.GetAxis());
			}
		}

		private void RestAll()
		{
			Rest(btn_A);
			Rest(btn_B);
			Rest(btn_Start);
			Rest(btn_Select);
			Rest(btn_Axis);
			SetAxis(Vector2.zero);
		}

		private void SetAxis(Vector2 axis)
		{
			if (!(btn_Axis == null))
			{
				axis = axis.normalized;
				Vector3 euler = new Vector3(0f, (0f - axis.x) * axisAmp, axis.y * axisAmp);
				Quaternion localRotation = btn_Axis.localRotation;
				Quaternion quaternion = Quaternion.Euler(euler);
				_ = quaternion * Quaternion.Inverse(localRotation);
				btn_Axis.localRotation = quaternion;
			}
		}

		private void Push(Transform btnTransform)
		{
			if (!(btnTransform == null))
			{
				btnTransform.DOKill();
				btnTransform.DOLocalMoveX(0f - btnDepth, transitionDuration).SetEase(Ease.OutElastic);
				if ((bool)buttonPressFX)
				{
					FXPool.Play(buttonPressFX, btnTransform.position, btnTransform.rotation);
				}
			}
		}

		private void Rest(Transform btnTransform)
		{
			if (!(btnTransform == null))
			{
				btnTransform.DOKill();
				btnTransform.DOLocalMoveX(0f, transitionDuration).SetEase(Ease.OutElastic);
				if ((bool)buttonRestFX)
				{
					FXPool.Play(buttonRestFX, btnTransform.position, btnTransform.rotation);
				}
			}
		}
	}
	public class ControllerPickupAnimation : MonoBehaviour
	{
		[SerializeField]
		private Transform restTransform;

		[SerializeField]
		private Transform controllerTransform;

		[SerializeField]
		private float transitionTime = 1f;

		[SerializeField]
		private AnimationCurve pickupCurve;

		private int activeToken;

		private AnimationCurve pickupRotCurve => pickupCurve;

		private AnimationCurve pickupPosCurve => pickupCurve;

		private AnimationCurve putDownCurve => pickupCurve;

		public async UniTask PickUp(Transform endTransform)
		{
			if (controllerTransform == null)
			{
				return;
			}
			int token = ++activeToken;
			controllerTransform.DOKill();
			Vector3 fromPos = controllerTransform.position;
			Quaternion fromRot = controllerTransform.rotation;
			Vector3 toPos = endTransform.position;
			Quaternion toRot = endTransform.rotation;
			float time = 0f;
			while (time < transitionTime)
			{
				time += Time.deltaTime;
				float time2 = time / transitionTime;
				Vector3 position = Vector3.LerpUnclamped(fromPos, toPos, pickupPosCurve.Evaluate(time2));
				Quaternion rotation = Quaternion.SlerpUnclamped(fromRot, toRot, pickupRotCurve.Evaluate(time2));
				controllerTransform.SetPositionAndRotation(position, rotation);
				await UniTask.Yield();
				if (token != activeToken)
				{
					return;
				}
			}
			await controllerTransform.DOShakeRotation(0.4f, 10f);
			controllerTransform.SetPositionAndRotation(toPos, toRot);
		}

		public async UniTask PutDown()
		{
			if (controllerTransform == null)
			{
				return;
			}
			int token = ++activeToken;
			controllerTransform.DOKill();
			Vector3 fromPos = controllerTransform.position;
			Quaternion fromRot = controllerTransform.rotation;
			Vector3 toPos = restTransform.position;
			Quaternion toRot = restTransform.rotation;
			float time = 0f;
			while (time < transitionTime)
			{
				if (controllerTransform == null)
				{
					return;
				}
				time += Time.deltaTime;
				float time2 = time / transitionTime;
				Vector3 position = Vector3.LerpUnclamped(fromPos, toPos, pickupPosCurve.Evaluate(time2));
				Quaternion rotation = Quaternion.LerpUnclamped(fromRot, toRot, pickupRotCurve.Evaluate(time2));
				controllerTransform.SetPositionAndRotation(position, rotation);
				await UniTask.Yield();
				if (token != activeToken || controllerTransform == null)
				{
					return;
				}
			}
			controllerTransform.SetPositionAndRotation(toPos, toRot);
		}
	}
	public class GamingConsoleGraphics : MonoBehaviour
	{
		[SerializeField]
		private GamingConsole master;

		[SerializeField]
		private Transform monitorRoot;

		[SerializeField]
		private Transform consoleRoot;

		[SerializeField]
		private Transform playingControllerPosition;

		private Transform cartridgeRoot;

		private Item _cachedMonitor;

		private Item _cachedConsole;

		private Item _cachedCartridge;

		private ItemGraphicInfo monitorGraphic;

		private ItemGraphicInfo consoleGraphic;

		private ControllerPickupAnimation pickupAnimation;

		private ControllerAnimator controllerAnimator;

		private bool dirty;

		private bool isBeingDestroyed;

		private void Awake()
		{
			master.onContentChanged += OnContentChanged;
			master.OnAfterAnimateIn += OnAfterAnimateIn;
			master.OnBeforeAnimateOut += OnBeforeAnimateOut;
		}

		private void Start()
		{
			dirty = true;
		}

		private void OnContentChanged(GamingConsole console)
		{
			if (console.Monitor != _cachedMonitor)
			{
				OnMonitorChanged();
			}
			if (console.Console != _cachedConsole)
			{
				OnConsoleChanged();
			}
			if (console.Cartridge != _cachedCartridge)
			{
				OnCatridgeChanged();
			}
			dirty = true;
		}

		private void Update()
		{
			if (dirty)
			{
				RefreshDisplays();
				dirty = false;
			}
		}

		private void RefreshDisplays()
		{
			if (isBeingDestroyed)
			{
				return;
			}
			_cachedMonitor = master.Monitor;
			_cachedConsole = master.Console;
			_cachedCartridge = master.Cartridge;
			if ((bool)monitorGraphic)
			{
				UnityEngine.Object.Destroy(monitorGraphic.gameObject);
			}
			if ((bool)consoleGraphic)
			{
				UnityEngine.Object.Destroy(consoleGraphic.gameObject);
			}
			if ((bool)_cachedMonitor && !_cachedMonitor.IsBeingDestroyed)
			{
				monitorGraphic = ItemGraphicInfo.CreateAGraphic(_cachedMonitor, monitorRoot);
			}
			if ((bool)_cachedConsole && !_cachedConsole.IsBeingDestroyed)
			{
				consoleGraphic = ItemGraphicInfo.CreateAGraphic(_cachedConsole, consoleRoot);
				if (consoleGraphic != null)
				{
					pickupAnimation = consoleGraphic.GetComponent<ControllerPickupAnimation>();
					controllerAnimator = consoleGraphic.GetComponentInChildren<ControllerAnimator>();
				}
				else
				{
					pickupAnimation = null;
					controllerAnimator = null;
				}
				if (controllerAnimator != null)
				{
					controllerAnimator.SetConsole(master);
				}
			}
		}

		private void OnCatridgeChanged()
		{
		}

		private void OnConsoleChanged()
		{
		}

		private void OnMonitorChanged()
		{
		}

		private void OnDestroy()
		{
			isBeingDestroyed = true;
		}

		private void OnBeforeAnimateOut(GamingConsole console)
		{
			if (!(pickupAnimation == null))
			{
				pickupAnimation.PutDown().Forget();
			}
		}

		private void OnAfterAnimateIn(GamingConsole console)
		{
			if (!(pickupAnimation == null))
			{
				pickupAnimation.PickUp(playingControllerPosition).Forget();
			}
		}
	}
}
namespace Duckov.MiniGames.SnakeForces
{
	public class SnakeDisplay : MiniGameBehaviour
	{
		[SerializeField]
		private SnakeForce master;

		[SerializeField]
		private SnakePartDisplay partDisplayTemplate;

		[SerializeField]
		private Transform foodDisplayTemplate;

		[SerializeField]
		private Transform exitDisplayTemplte;

		[SerializeField]
		private ParticleSystem eatFXPrefab;

		[SerializeField]
		private int gridSize = 8;

		private PrefabPool<SnakePartDisplay> _partPool;

		private PrefabPool<Transform> _foodPool;

		private bool punchingColor;

		private int punchColorIndex;

		private PrefabPool<SnakePartDisplay> PartPool
		{
			get
			{
				if (_partPool == null)
				{
					_partPool = new PrefabPool<SnakePartDisplay>(partDisplayTemplate);
				}
				return _partPool;
			}
		}

		private PrefabPool<Transform> FoodPool
		{
			get
			{
				if (_foodPool == null)
				{
					_foodPool = new PrefabPool<Transform>(foodDisplayTemplate);
				}
				return _foodPool;
			}
		}

		private void Awake()
		{
			master.OnAddPart += OnAddPart;
			master.OnGameStart += OnGameStart;
			master.OnRemovePart += OnRemovePart;
			master.OnAfterTick += OnAfterTick;
			master.OnFoodEaten += OnFoodEaten;
			partDisplayTemplate.gameObject.SetActive(value: false);
		}

		protected override void OnUpdate(float deltaTime)
		{
			base.OnUpdate(deltaTime);
			HandlePunchColor();
		}

		private void HandlePunchColor()
		{
			if (!punchingColor)
			{
				return;
			}
			if (punchColorIndex >= master.Snake.Count)
			{
				punchingColor = false;
				return;
			}
			SnakePartDisplay snakePartDisplay = PartPool.ActiveEntries.First((SnakePartDisplay e) => e.Target == master.Snake[punchColorIndex]);
			if ((bool)snakePartDisplay)
			{
				snakePartDisplay.PunchColor(Color.HSVToRGB((float)punchColorIndex % 12f / 12f, 1f, 1f));
			}
			punchColorIndex++;
		}

		private void OnGameStart(SnakeForce force)
		{
			RefreshFood();
		}

		private void OnFoodEaten(SnakeForce force, Vector2Int coord)
		{
			FXPool.Play(eatFXPrefab, GetWorldPosition(coord), Quaternion.LookRotation((Vector3Int)master.Head.direction, Vector3.forward));
			foreach (SnakePartDisplay activeEntry in PartPool.ActiveEntries)
			{
				activeEntry.Punch();
			}
			StartPunchingColor();
		}

		private void StartPunchingColor()
		{
			punchingColor = true;
			punchColorIndex = 0;
		}

		private void OnAfterTick(SnakeForce force)
		{
			RefreshFood();
		}

		private void RefreshFood()
		{
			FoodPool.ReleaseAll();
			foreach (Vector2Int food in master.Foods)
			{
				FoodPool.Get().localPosition = GetPosition(food);
			}
		}

		private void OnRemovePart(SnakeForce.Part part)
		{
			PartPool.ReleaseAll((SnakePartDisplay e) => e.Target == part);
		}

		private void OnAddPart(SnakeForce.Part part)
		{
			PartPool.Get().Setup(this, part);
		}

		internal Vector3 GetPosition(Vector2Int coord)
		{
			return (Vector2)(coord * gridSize);
		}

		internal Vector3 GetWorldPosition(Vector2Int coord)
		{
			Vector3 position = GetPosition(coord);
			return base.transform.TransformPoint(position);
		}
	}
	public class SnakeForce : MiniGameBehaviour
	{
		public class Part
		{
			public Vector2Int coord;

			public Vector2Int direction;

			public readonly SnakeForce Master;

			public bool IsHead => this == Master.Head;

			public bool IsTail => this == Master.Tail;

			public event Action<Part> OnMove;

			public Part(SnakeForce master, Vector2Int coord, Vector2Int direction)
			{
				Master = master;
				this.coord = coord;
				this.direction = direction;
			}

			internal void MoveTo(Vector2Int coord)
			{
				this.coord = coord;
				this.OnMove?.Invoke(this);
			}
		}

		[SerializeField]
		private GameObject gameOverScreen;

		[SerializeField]
		private GameObject titleScreen;

		[SerializeField]
		private GameObject winIndicator;

		[SerializeField]
		private TextMeshProUGUI scoreText;

		[SerializeField]
		private TextMeshProUGUI highScoreText;

		[SerializeField]
		private GameObject highScoreIndicator;

		[SerializeField]
		private TextMeshProUGUI scoreTextGameOver;

		[SerializeField]
		private Transform cameraParent;

		[SerializeField]
		private float tickIntervalFrom = 0.5f;

		[SerializeField]
		private float tickIntervalTo = 0.01f;

		[SerializeField]
		private int maxSpeedTick = 4096;

		[SerializeField]
		private AnimationCurve speedCurve;

		[SerializeField]
		private int borderXMin = -10;

		[SerializeField]
		private int borderXMax = 10;

		[SerializeField]
		private int borderYMin = -10;

		[SerializeField]
		private int borderYMax = 10;

		private bool playing;

		private bool dead;

		private bool won;

		private List<Part> snake = new List<Part>();

		private List<Vector2Int> foods = new List<Vector2Int>();

		private int _score;

		public const string HighScoreKey = "MiniGame/Snake/HighScore";

		private float tickETA;

		private List<Vector2Int> allCoords = new List<Vector2Int>();

		private ulong playTick;

		private Vector2Int lastFrameAxis;

		private double freezeCountDown;

		private bool axisInput;

		public List<Part> Snake => snake;

		public List<Vector2Int> Foods => foods;

		public int Score
		{
			get
			{
				return _score;
			}
			private set
			{
				_score = value;
				this.OnScoreChanged?.Invoke(this);
			}
		}

		public static int HighScore
		{
			get
			{
				return SavesSystem.Load<int>("MiniGame/Snake/HighScore");
			}
			private set
			{
				SavesSystem.Save("MiniGame/Snake/HighScore", value);
			}
		}

		public Part Head
		{
			get
			{
				if (snake.Count <= 0)
				{
					return null;
				}
				return snake[0];
			}
		}

		public Part Tail
		{
			get
			{
				if (snake.Count <= 0)
				{
					return null;
				}
				List<Part> list = snake;
				return list[list.Count - 1];
			}
		}

		public event Action<Part> OnAddPart;

		public event Action<Part> OnRemovePart;

		public event Action<SnakeForce> OnAfterTick;

		public event Action<SnakeForce> OnScoreChanged;

		public event Action<SnakeForce> OnGameStart;

		public event Action<SnakeForce> OnGameOver;

		public event Action<SnakeForce, Vector2Int> OnFoodEaten;

		protected override void Start()
		{
			base.Start();
			titleScreen.SetActive(value: true);
		}

		private void Restart()
		{
			Clear();
			gameOverScreen.SetActive(value: false);
			for (int i = borderXMin; i <= borderXMax; i++)
			{
				for (int j = borderYMin; j <= borderYMax; j++)
				{
					allCoords.Add(new Vector2Int(i, j));
				}
			}
			AddPart(new Vector2Int((borderXMax + borderXMin) / 2, (borderYMax + borderYMin) / 2), Vector2Int.up);
			Grow();
			Grow();
			AddFood();
			PunchCamera();
			playing = true;
			RefreshScoreText();
			highScoreText.text = $"{HighScore}";
			this.OnGameStart?.Invoke(this);
		}

		private void AddFood(int count = 3)
		{
			List<Vector2Int> list = new List<Vector2Int>(allCoords);
			foreach (Part item2 in snake)
			{
				list.Remove(item2.coord);
			}
			if (list.Count <= 0)
			{
				Win();
				return;
			}
			Vector2Int[] randomSubSet = list.GetRandomSubSet(count);
			foreach (Vector2Int item in randomSubSet)
			{
				foods.Add(item);
			}
		}

		private void GameOver()
		{
			this.OnGameOver?.Invoke(this);
			bool active = Score > HighScore;
			if (Score > HighScore)
			{
				HighScore = Score;
			}
			highScoreIndicator.SetActive(active);
			winIndicator.SetActive(won);
			scoreTextGameOver.text = $"{Score}";
			gameOverScreen.SetActive(value: true);
			PunchCamera();
		}

		private void Win()
		{
			won = true;
			GameOver();
		}

		protected override void OnUpdate(float deltaTime)
		{
			Vector2 axis = base.Game.GetAxis();
			if (axis.sqrMagnitude > 0.1f)
			{
				Vector2Int vector2Int = default(Vector2Int);
				if (axis.x > 0f)
				{
					vector2Int = Vector2Int.right;
				}
				else if (axis.x < 0f)
				{
					vector2Int = Vector2Int.left;
				}
				else if (axis.y > 0f)
				{
					vector2Int = Vector2Int.up;
				}
				else if (axis.y < 0f)
				{
					vector2Int = Vector2Int.down;
				}
				if (lastFrameAxis != vector2Int)
				{
					axisInput = true;
				}
				lastFrameAxis = vector2Int;
			}
			else
			{
				lastFrameAxis = Vector2Int.zero;
			}
			if (freezeCountDown > 0.0)
			{
				freezeCountDown -= Time.unscaledDeltaTime;
				return;
			}
			if (dead || won || !playing)
			{
				if (base.Game.GetButtonDown(MiniGame.Button.Start))
				{
					Restart();
				}
				return;
			}
			RefreshScoreText();
			bool flag = base.Game.GetButton(MiniGame.Button.B) || base.Game.GetButton(MiniGame.Button.A);
			tickETA -= deltaTime * (flag ? 10f : 1f);
			float time = ((playTick < (ulong)maxSpeedTick) ? ((float)playTick / (float)maxSpeedTick) : 1f);
			float num = Mathf.Lerp(tickIntervalFrom, tickIntervalTo, speedCurve.Evaluate(time));
			if (tickETA <= 0f || axisInput)
			{
				Tick();
				tickETA = num;
				axisInput = false;
			}
		}

		private void RefreshScoreText()
		{
			scoreText.text = $"{Score}";
		}

		private void Tick()
		{
			playTick++;
			if (Head != null)
			{
				HandleMovement();
				DetectDeath();
				HandleEatAndGrow();
				this.OnAfterTick?.Invoke(this);
			}
		}

		private void HandleMovement()
		{
			Vector2Int vector2Int = lastFrameAxis;
			if ((!(vector2Int == -Head.direction) || snake.Count <= 1) && vector2Int != Vector2Int.zero)
			{
				Head.direction = vector2Int;
			}
			for (int num = snake.Count - 1; num >= 0; num--)
			{
				Part part = snake[num];
				Vector2Int coord = ((num > 0) ? snake[num - 1].coord : (part.coord + part.direction));
				if (num > 0)
				{
					part.direction = snake[num - 1].direction;
				}
				if (coord.x > borderXMax)
				{
					coord.x = borderXMin;
				}
				if (coord.y > borderYMax)
				{
					coord.y = borderYMin;
				}
				if (coord.x < borderXMin)
				{
					coord.x = borderXMax;
				}
				if (coord.y < borderYMin)
				{
					coord.y = borderYMax;
				}
				part.MoveTo(coord);
			}
		}

		private void HandleEatAndGrow()
		{
			Vector2Int coord = Head.coord;
			if (foods.Remove(coord))
			{
				Grow();
				Score++;
				int num = 3 + Mathf.FloorToInt(Mathf.Log(Score, 2f));
				int count = Mathf.Max(0, num - foods.Count);
				AddFood(count);
				this.OnFoodEaten?.Invoke(this, coord);
				PunchCamera();
			}
		}

		private void DetectDeath()
		{
			Vector2Int coord = Head.coord;
			int num = 1;
			while (true)
			{
				if (num < snake.Count)
				{
					if (snake[num].coord == coord)
					{
						break;
					}
					num++;
					continue;
				}
				return;
			}
			dead = true;
			GameOver();
		}

		private Part Grow()
		{
			if (snake.Count == 0)
			{
				UnityEngine.Debug.LogError("Cannot grow the snake! It haven't been created yet.");
				return null;
			}
			Part tail = Tail;
			Vector2Int coord = tail.coord - tail.direction;
			return AddPart(coord, tail.direction);
		}

		private Part AddPart(Vector2Int coord, Vector2Int direction)
		{
			Part part = new Part(this, coord, direction);
			snake.Add(part);
			this.OnAddPart?.Invoke(part);
			return part;
		}

		private bool RemovePart(Part part)
		{
			if (!snake.Remove(part))
			{
				return false;
			}
			this.OnRemovePart?.Invoke(part);
			return true;
		}

		private void Clear()
		{
			titleScreen.SetActive(value: false);
			won = false;
			dead = false;
			Score = 0;
			playTick = 0uL;
			allCoords.Clear();
			foods.Clear();
			for (int num = snake.Count - 1; num >= 0; num--)
			{
				Part part = snake[num];
				if (part == null)
				{
					snake.RemoveAt(num);
				}
				else
				{
					RemovePart(part);
				}
			}
		}

		private void PunchCamera()
		{
			freezeCountDown = 0.10000000149011612;
			cameraParent.DOKill(complete: true);
			cameraParent.DOShakePosition(0.4f);
			cameraParent.DOShakeRotation(0.4f, Vector3.forward);
		}
	}
	public class SnakePartDisplay : MiniGameBehaviour
	{
		[SerializeField]
		private UnityEngine.UI.Image image;

		private Vector2Int cachedCoord;

		public SnakeDisplay Master { get; private set; }

		public SnakeForce.Part Target { get; private set; }

		internal void Setup(SnakeDisplay master, SnakeForce.Part part)
		{
			if (Target != null)
			{
				Target.OnMove -= OnTargetMove;
			}
			Master = master;
			Target = part;
			cachedCoord = Target.coord;
			base.transform.localPosition = Master.GetPosition(cachedCoord);
			Target.OnMove += OnTargetMove;
		}

		private void OnTargetMove(SnakeForce.Part part)
		{
			if (base.enabled)
			{
				_ = (Target.coord - cachedCoord).sqrMagnitude;
				cachedCoord = Target.coord;
				Vector3 position = Master.GetPosition(cachedCoord);
				DoMove(position);
			}
		}

		private void DoMove(Vector3 vector3)
		{
			base.transform.localPosition = vector3;
		}

		internal void Punch()
		{
			base.transform.DOKill(complete: true);
			base.transform.localScale = Vector3.one;
			base.transform.DOPunchScale(Vector3.one * 1.1f, 0.2f, 4);
		}

		internal void PunchColor(Color color)
		{
			image.DOKill();
			image.color = color;
			image.DOColor(Color.white, 0.4f);
		}
	}
}
namespace Duckov.MiniGames.GoldMiner
{
	public class GoldMinerArtifact : MiniGameBehaviour
	{
		[SerializeField]
		private string id;

		[SerializeField]
		private Sprite icon;

		[SerializeField]
		private bool allowMultiple;

		[SerializeField]
		private int basePrice;

		[SerializeField]
		private int quality;

		private GoldMiner master;

		public Action<GoldMinerArtifact> OnAttached;

		public Action<GoldMinerArtifact> OnDetached;

		[LocalizationKey("Default")]
		private string displayNameKey
		{
			get
			{
				return "GoldMiner_" + id;
			}
			set
			{
			}
		}

		[LocalizationKey("Default")]
		private string descriptionKey
		{
			get
			{
				return "GoldMiner_" + id + "_Desc";
			}
			set
			{
			}
		}

		public bool AllowMultiple => allowMultiple;

		public string DisplayName => displayNameKey.ToPlainText();

		public string Description => descriptionKey.ToPlainText();

		public int Quality => quality;

		public int BasePrice => basePrice;

		public string ID => id;

		public Sprite Icon => icon;

		public GoldMiner Master => master;

		public void Attach(GoldMiner master)
		{
			this.master = master;
			base.transform.SetParent(master.transform);
			OnAttached?.Invoke(this);
		}

		public void Detatch(GoldMiner master)
		{
			OnDetached?.Invoke(this);
			if (master != this.master)
			{
				UnityEngine.Debug.LogError("Artifact is being notified detach by a different GoldMiner instance.", master.gameObject);
			}
			this.master = null;
		}

		private void OnDestroy()
		{
			Detatch(master);
		}
	}
	public abstract class GoldMinerArtifactBehaviour : MiniGameBehaviour
	{
		[SerializeField]
		protected GoldMinerArtifact master;

		protected GoldMinerRunData Run
		{
			get
			{
				if (master == null)
				{
					return null;
				}
				if (master.Master == null)
				{
					return null;
				}
				return master.Master.run;
			}
		}

		protected GoldMiner GoldMiner
		{
			get
			{
				if (master == null)
				{
					return null;
				}
				return master.Master;
			}
		}

		private void Awake()
		{
			if (!master)
			{
				master = GetComponent<GoldMinerArtifact>();
			}
			GoldMinerArtifact goldMinerArtifact = master;
			goldMinerArtifact.OnAttached = (Action<GoldMinerArtifact>)Delegate.Combine(goldMinerArtifact.OnAttached, new Action<GoldMinerArtifact>(OnAttached));
			GoldMinerArtifact goldMinerArtifact2 = master;
			goldMinerArtifact2.OnDetached = (Action<GoldMinerArtifact>)Delegate.Combine(goldMinerArtifact2.OnDetached, new Action<GoldMinerArtifact>(OnDetached));
		}

		protected virtual void OnAttached(GoldMinerArtifact artifact)
		{
		}

		protected virtual void OnDetached(GoldMinerArtifact artifact)
		{
		}
	}
	public class Bomb : MiniGameBehaviour
	{
		[SerializeField]
		private float moveSpeed;

		[SerializeField]
		private float maxLifeTime = 10f;

		[SerializeField]
		private ParticleSystem explodeFX;

		private float lifeTime;

		private List<GoldMinerEntity> hoveringTargets = new List<GoldMinerEntity>();

		protected override void OnUpdate(float deltaTime)
		{
			base.transform.position += base.transform.up * moveSpeed * deltaTime;
			hoveringTargets.RemoveAll((GoldMinerEntity e) => e == null);
			if (hoveringTargets.Count > 0)
			{
				Explode(hoveringTargets[0]);
			}
			lifeTime += deltaTime;
			if (lifeTime > maxLifeTime)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Explode(GoldMinerEntity goldMinerTarget)
		{
			goldMinerTarget.Explode(base.transform.position);
			FXPool.Play(explodeFX, base.transform.position, base.transform.rotation);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private void OnCollisionEnter2D(Collision2D collision)
		{
			GoldMinerEntity component = collision.gameObject.GetComponent<GoldMinerEntity>();
			if (component != null)
			{
				hoveringTargets.Add(component);
			}
		}

		private void OnCollisionExit2D(Collision2D collision)
		{
			GoldMinerEntity component = collision.gameObject.GetComponent<GoldMinerEntity>();
			if (component != null)
			{
				hoveringTargets.Remove(component);
			}
		}
	}
	[Serializable]
	public class GoldMinerRunData
	{
		public readonly GoldMiner master;

		public int money;

		public int bomb;

		public int strengthPotion;

		public int eagleEyePotion;

		public int shopTicket;

		public const int shopDefaultItemAmount = 3;

		public const int shopMaxItemAmount = 3;

		public int shopCapacity = 3;

		public float levelScoreFactor;

		public Stat maxStamina = new Stat("maxStamina", 15f);

		public Stat extraStamina = new Stat("extraStamina", 2f);

		public Stat staminaDrain = new Stat("staminaDrain", 1f);

		public Stat gameSpeedFactor = new Stat("gameSpeedFactor", 1f);

		public Stat emptySpeed = new Stat("emptySpeed", 300f);

		public Stat strength = new Stat("strength", 0f);

		public Stat scoreFactorBase = new Stat("scoreFactor", 1f);

		public Stat rockValueFactor = new Stat("rockValueFactor", 1f);

		public Stat goldValueFactor = new Stat("goldValueFactor", 1f);

		public Stat charm = new Stat("charm", 1f);

		public Stat shopRefreshPrice = new Stat("shopRefreshPrice", 100f);

		public Stat shopRefreshPriceIncrement = new Stat("shopRefreshPriceIncrement", 50f);

		public Stat shopRefreshChances = new Stat("shopRefreshChances", 2f);

		public Stat shopPriceCut = new Stat("shopPriceCut", 0.7f);

		public Stat defuse = new Stat("defuse", 0f);

		public float extraRocks;

		public float extraGold;

		public float extraDiamond;

		public List<GoldMinerArtifact> artifacts = new List<GoldMinerArtifact>();

		private Dictionary<string, int> artifactCount = new Dictionary<string, int>();

		private Modifier strengthPotionModifier;

		private Modifier eagleEyeModifier;

		internal int targetScore = 100;

		public List<Func<GoldMinerEntity, bool>> isGoldPredicators = new List<Func<GoldMinerEntity, bool>>();

		public List<Func<GoldMinerEntity, bool>> isRockPredicators = new List<Func<GoldMinerEntity, bool>>();

		public List<Func<float>> additionalFactorFuncs = new List<Func<float>>();

		public List<Func<int, int>> settleValueProcessor = new List<Func<int, int>>();

		public List<Func<bool>> forceLevelSuccessFuncs = new List<Func<bool>>();

		internal int minMoneySum;

		public int seed { get; private set; }

		public System.Random shopRandom { get; set; }

		public System.Random levelRandom { get; private set; }

		public float GameSpeedFactor => gameSpeedFactor.Value;

		public float stamina { get; set; }

		public bool gameOver { get; set; }

		public int level { get; set; }

		public bool StrengthPotionActivated { get; private set; }

		public bool EagleEyeActivated { get; private set; }

		public GoldMinerArtifact AttachArtifactFromPrefab(GoldMinerArtifact prefab)
		{
			if (prefab == null)
			{
				return null;
			}
			GoldMinerArtifact goldMinerArtifact = UnityEngine.Object.Instantiate(prefab, master.transform);
			AttachArtifact(goldMinerArtifact);
			return goldMinerArtifact;
		}

		private void AttachArtifact(GoldMinerArtifact artifact)
		{
			if (artifactCount.ContainsKey(artifact.ID))
			{
				artifactCount[artifact.ID]++;
			}
			else
			{
				artifactCount[artifact.ID] = 1;
			}
			artifacts.Add(artifact);
			artifact.Attach(master);
			master.NotifyArtifactChange();
		}

		public bool DetachArtifact(GoldMinerArtifact artifact)
		{
			bool result = artifacts.Remove(artifact);
			artifact.Detatch(master);
			if (artifactCount.ContainsKey(artifact.ID))
			{
				artifactCount[artifact.ID]--;
			}
			else
			{
				UnityEngine.Debug.LogError("Artifact counter error.", master);
			}
			master.NotifyArtifactChange();
			return result;
		}

		public int GetArtifactCount(string id)
		{
			if (artifactCount.TryGetValue(id, out var value))
			{
				return value;
			}
			return 0;
		}

		public GoldMinerRunData(GoldMiner master, int seed = 0)
		{
			this.master = master;
			if (seed == 0)
			{
				seed = UnityEngine.Random.Range(int.MinValue, int.MaxValue);
			}
			this.seed = seed;
			levelRandom = new System.Random(seed);
			strengthPotionModifier = new Modifier(ModifierType.Add, 100f, this);
			eagleEyeModifier = new Modifier(ModifierType.PercentageMultiply, -0.5f, this);
		}

		public void ActivateStrengthPotion()
		{
			if (!StrengthPotionActivated)
			{
				strength.AddModifier(strengthPotionModifier);
				StrengthPotionActivated = true;
			}
		}

		public void DeactivateStrengthPotion()
		{
			strength.RemoveModifier(strengthPotionModifier);
			StrengthPotionActivated = false;
		}

		public void ActivateEagleEye()
		{
			if (!EagleEyeActivated)
			{
				gameSpeedFactor.AddModifier(eagleEyeModifier);
				EagleEyeActivated = true;
			}
		}

		public void DeactivateEagleEye()
		{
			gameSpeedFactor.RemoveModifier(eagleEyeModifier);
			EagleEyeActivated = false;
		}

		internal void Cleanup()
		{
			foreach (GoldMinerArtifact artifact in artifacts)
			{
				if (!(artifact == null))
				{
					if (Application.isPlaying)
					{
						UnityEngine.Object.Destroy(artifact.gameObject);
					}
					else
					{
						UnityEngine.Object.Destroy(artifact.gameObject);
					}
				}
			}
		}

		public bool IsGold(GoldMinerEntity entity)
		{
			if (entity == null)
			{
				return false;
			}
			foreach (Func<GoldMinerEntity, bool> isGoldPredicator in isGoldPredicators)
			{
				if (isGoldPredicator(entity))
				{
					return true;
				}
			}
			return entity.tags.Contains(GoldMinerEntity.Tag.Gold);
		}

		public bool IsRock(GoldMinerEntity entity)
		{
			if (entity == null)
			{
				return false;
			}
			foreach (Func<GoldMinerEntity, bool> isGoldPredicator in isGoldPredicators)
			{
				if (isGoldPredicator(entity))
				{
					return true;
				}
			}
			return entity.tags.Contains(GoldMinerEntity.Tag.Rock);
		}

		internal bool IsPig(GoldMinerEntity entity)
		{
			return entity.tags.Contains(GoldMinerEntity.Tag.Pig);
		}
	}
	public class GoldMiner : MiniGameBehaviour
	{
		[SerializeField]
		private Hook hook;

		[SerializeField]
		private GoldMinerShop shop;

		[SerializeField]
		private LevelSettlementUI settlementUI;

		[SerializeField]
		private GameObject titleScreen;

		[SerializeField]
		private GameObject gameoverScreen;

		[SerializeField]
		private GoldMiner_PopText popText;

		[SerializeField]
		private Transform levelLayout;

		[SerializeField]
		private Bounds bounds;

		[SerializeField]
		private Bomb bombPrefab;

		[SerializeField]
		private RandomContainer<GoldMinerEntity> entities;

		[SerializeField]
		private List<GoldMinerArtifact> artifactPrefabs = new List<GoldMinerArtifact>();

		private ReadOnlyCollection<GoldMinerArtifact> artifactPrefabs_ReadOnly;

		public Action<GoldMiner> onLevelBegin;

		public Action<GoldMiner> onLevelEnd;

		public Action<GoldMiner> onShopBegin;

		public Action<GoldMiner> onShopEnd;

		public Action<GoldMiner> onEarlyLevelPlayTick;

		public Action<GoldMiner> onLateLevelPlayTick;

		public Action<GoldMiner, Hook> onHookLaunch;

		public Action<GoldMiner, Hook> onHookBeginRetrieve;

		public Action<GoldMiner, Hook> onHookEndRetrieve;

		public Action<GoldMiner, Hook, GoldMinerEntity> onHookAttach;

		public Action<GoldMiner, GoldMinerEntity> onResolveEntity;

		public Action<GoldMiner, GoldMinerEntity> onAfterResolveEntity;

		public Action<GoldMiner> onArtifactChange;

		private const string HighLevelSaveKey = "MiniGame/GoldMiner/HighLevel";

		private bool titleConfirmed;

		private bool gameOverConfirmed;

		public List<GoldMinerEntity> activeEntities = new List<GoldMinerEntity>();

		private bool levelPlaying;

		public List<GoldMinerEntity> resolvedEntities = new List<GoldMinerEntity>();

		private bool launchHook;

		public Hook Hook => hook;

		public Bounds Bounds => bounds;

		public int Money
		{
			get
			{
				if (run == null)
				{
					return 0;
				}
				return run.money;
			}
		}

		public ReadOnlyCollection<GoldMinerArtifact> ArtifactPrefabs
		{
			get
			{
				if (artifactPrefabs_ReadOnly == null)
				{
					artifactPrefabs_ReadOnly = new ReadOnlyCollection<GoldMinerArtifact>(artifactPrefabs);
				}
				return artifactPrefabs_ReadOnly;
			}
		}

		public static int HighLevel
		{
			get
			{
				return SavesSystem.Load<int>("MiniGame/GoldMiner/HighLevel");
			}
			set
			{
				SavesSystem.Save("MiniGame/GoldMiner/HighLevel", value);
			}
		}

		public GoldMinerRunData run { get; private set; }

		private bool ShouldQuit
		{
			get
			{
				if (base.gameObject == null)
				{
					return true;
				}
				return false;
			}
		}

		public float GlobalPriceFactor => 1f;

		public static event Action<int> OnLevelClear;

		private void Awake()
		{
			Hook.OnBeginRetrieve += OnHookBeginRetrieve;
			Hook.OnEndRetrieve += OnHookEndRetrieve;
			Hook.OnLaunch += OnHookLaunch;
			Hook.OnResolveTarget += OnHookResolveEntity;
			Hook.OnAttach += OnHookAttach;
		}

		protected override void Start()
		{
			base.Start();
			hook.BeginSwing();
			Main().Forget();
		}

		internal bool PayMoney(int price)
		{
			if (run.money < price)
			{
				return false;
			}
			run.money -= price;
			return true;
		}

		private async UniTask Main()
		{
			await DoTitleScreen();
			while (!ShouldQuit)
			{
				Cleanup();
				int seed = UnityEngine.Random.Range(int.MinValue, int.MaxValue);
				await Run(seed);
			}
		}

		private async UniTask DoTitleScreen()
		{
			titleConfirmed = false;
			if ((bool)titleScreen)
			{
				titleScreen.SetActive(value: true);
			}
			while (!titleConfirmed)
			{
				await UniTask.Yield();
				if (base.Game.GetButtonDown(MiniGame.Button.A) || base.Game.GetButtonDown(MiniGame.Button.Start))
				{
					titleConfirmed = true;
				}
			}
			if ((bool)titleScreen)
			{
				titleScreen.SetActive(value: false);
			}
		}

		private async UniTask DoGameOver()
		{
			UnityEngine.Debug.Log("Game Over");
		}

		public void Cleanup()
		{
			if (run != null)
			{
				run.Cleanup();
			}
		}

		private void GenerateLevel()
		{
			for (int i = 0; i < activeEntities.Count; i++)
			{
				GoldMinerEntity goldMinerEntity = activeEntities[i];
				if (!(goldMinerEntity == null))
				{
					if (Application.isPlaying)
					{
						UnityEngine.Object.Destroy(goldMinerEntity.gameObject);
					}
					else
					{
						UnityEngine.Object.DestroyImmediate(goldMinerEntity.gameObject);
					}
				}
			}
			activeEntities.Clear();
			for (int j = 0; j < resolvedEntities.Count; j++)
			{
				GoldMinerEntity goldMinerEntity2 = activeEntities[j];
				if (!(goldMinerEntity2 == null))
				{
					if (Application.isPlaying)
					{
						UnityEngine.Object.Destroy(goldMinerEntity2.gameObject);
					}
					else
					{
						UnityEngine.Object.DestroyImmediate(goldMinerEntity2.gameObject);
					}
				}
			}
			resolvedEntities.Clear();
			int seed = run.levelRandom.Next();
			System.Random levelGenRandom = new System.Random(seed);
			int minValue = 10;
			int maxValue = 20;
			int num = levelGenRandom.Next(minValue, maxValue);
			for (int k = 0; k < num; k++)
			{
				GoldMinerEntity random = entities.GetRandom(levelGenRandom);
				Generate(random);
			}
			for (float num2 = run.extraRocks; num2 > 0f; num2 -= 1f)
			{
				if (num2 > 1f || levelGenRandom.NextDouble() < (double)num2)
				{
					GoldMinerEntity random2 = entities.GetRandom(levelGenRandom, (GoldMinerEntity e) => e.tags.Contains(GoldMinerEntity.Tag.Rock));
					Generate(random2);
				}
			}
			for (float num3 = run.extraGold; num3 > 0f; num3 -= 1f)
			{
				if (num3 > 1f || levelGenRandom.NextDouble() < (double)num3)
				{
					GoldMinerEntity random3 = entities.GetRandom(levelGenRandom, (GoldMinerEntity e) => e.tags.Contains(GoldMinerEntity.Tag.Gold));
					Generate(random3);
				}
			}
			for (float num4 = run.extraDiamond; num4 > 0f; num4 -= 1f)
			{
				if (num4 > 1f || levelGenRandom.NextDouble() < (double)num4)
				{
					GoldMinerEntity random4 = entities.GetRandom(levelGenRandom, (GoldMinerEntity e) => e.tags.Contains(GoldMinerEntity.Tag.Diamond));
					Generate(random4);
				}
			}
			run.shopRandom = new System.Random(run.seed + levelGenRandom.Next());
			void Generate(GoldMinerEntity entityPrefab)
			{
				if (!(entityPrefab == null))
				{
					Vector2 posNormalized = new Vector2((float)levelGenRandom.NextDouble(), (float)levelGenRandom.NextDouble());
					GoldMinerEntity goldMinerEntity3 = UnityEngine.Object.Instantiate(entityPrefab, levelLayout);
					Vector3 localPosition = NormalizedPosToLocalPos(posNormalized);
					Quaternion localRotation = Quaternion.AngleAxis((float)levelGenRandom.NextDouble() * 360f, Vector3.forward);
					goldMinerEntity3.transform.localPosition = localPosition;
					goldMinerEntity3.transform.localRotation = localRotation;
					goldMinerEntity3.SetMaster(this);
					activeEntities.Add(goldMinerEntity3);
				}
			}
		}

		private Vector3 NormalizedPosToLocalPos(Vector2 posNormalized)
		{
			float x = Mathf.Lerp(bounds.min.x, bounds.max.x, posNormalized.x);
			float y = Mathf.Lerp(bounds.min.y, bounds.max.y, posNormalized.y);
			return new Vector3(x, y, 0f);
		}

		private void OnDrawGizmosSelected()
		{
			Gizmos.matrix = levelLayout.localToWorldMatrix;
			Gizmos.DrawWireCube(bounds.center, bounds.extents * 2f);
		}

		private async UniTask Run(int seed = 0)
		{
			run = new GoldMinerRunData(this, seed);
			while (true)
			{
				await DoLevel();
				if (!(await SettleLevel()))
				{
					break;
				}
				if (run.level > HighLevel)
				{
					HighLevel = run.level;
				}
				await DoShop();
				run.level++;
			}
			await DoGameOver();
		}

		private async UniTask<bool> SettleLevel()
		{
			int moneySum = 0;
			float factor = run.scoreFactorBase.Value + run.levelScoreFactor;
			int targetScore = run.targetScore;
			settlementUI.Reset();
			settlementUI.SetTargetScore(targetScore);
			settlementUI.Show();
			await UniTask.WaitForSeconds(0.5f);
			foreach (GoldMinerEntity resolvedEntity in resolvedEntities)
			{
				int value = resolvedEntity.Value;
				value = Mathf.CeilToInt((float)value * run.charm.Value);
				foreach (Func<int, int> item in run.settleValueProcessor)
				{
					value = item(value);
				}
				if (value != 0)
				{
					moneySum += value;
					int score = Mathf.CeilToInt((float)moneySum * factor);
					settlementUI.StepResolveEntity(resolvedEntity);
					settlementUI.Step(moneySum, factor, score);
					await UniTask.WaitForSeconds(0.2f);
				}
			}
			foreach (Func<float> additionalFactorFunc in run.additionalFactorFuncs)
			{
				float num = additionalFactorFunc();
				if (num != 0f)
				{
					factor += num;
					int score2 = Mathf.CeilToInt((float)moneySum * factor);
					settlementUI.Step(moneySum, factor, score2);
					await UniTask.WaitForSeconds(0.2f);
				}
			}
			if (moneySum < run.minMoneySum)
			{
				moneySum = run.minMoneySum;
			}
			int num2 = Mathf.CeilToInt((float)moneySum * factor);
			settlementUI.Step(moneySum, factor, num2);
			bool result = num2 >= targetScore;
			settlementUI.StepResult(result);
			if (!result)
			{
				for (int i = 0; i < run.forceLevelSuccessFuncs.Count; i++)
				{
					Func<bool> func = run.forceLevelSuccessFuncs[i];
					if (func != null && func())
					{
						result = true;
						settlementUI.StepResult(result);
						break;
					}
				}
			}
			run.money += moneySum;
			while (!base.Game.GetButton(MiniGame.Button.A))
			{
				await UniTask.Yield();
			}
			settlementUI.Hide();
			if (result)
			{
				GoldMiner.OnLevelClear?.Invoke(run.level);
			}
			return result;
		}

		private async UniTask DoLevel()
		{
			Hook.Reset();
			resolvedEntities.Clear();
			GenerateLevel();
			run.levelScoreFactor = 0f;
			run.stamina = run.maxStamina.Value;
			int level = run.level;
			run.targetScore = Mathf.CeilToInt(40.564f * Mathf.Exp(0.2118f * (float)(level + 1))) * 10;
			onLevelBegin?.Invoke(this);
			popText.Pop($"LEVEL {run.level + 1}", hook.Axis.position);
			await UniTask.WaitForSeconds(0.5f);
			popText.Pop("Begin!", hook.Axis.position);
			levelPlaying = true;
			launchHook = false;
			while (!IsLevelOver())
			{
				await UniTask.Yield(PlayerLoopTiming.FixedUpdate);
			}
			onLevelEnd?.Invoke(this);
			levelPlaying = false;
			if ((bool)Hook.GrabbingTarget)
			{
				Hook.ReleaseClaw();
			}
		}

		protected override void OnUpdate(float deltaTime)
		{
			if (levelPlaying)
			{
				UpdateLevelPlaying(deltaTime);
			}
		}

		private void UpdateLevelPlaying(float deltaTime)
		{
			onEarlyLevelPlayTick?.Invoke(this);
			Hook.SetParameters(run.GameSpeedFactor, run.emptySpeed.Value, run.strength.Value);
			Hook.Tick(deltaTime);
			switch (Hook.Status)
			{
			case Hook.HookStatus.Swinging:
				if (launchHook)
				{
					Hook.Launch();
				}
				break;
			case Hook.HookStatus.Retrieving:
				run.stamina -= deltaTime * run.staminaDrain.Value;
				break;
			}
			onLateLevelPlayTick?.Invoke(this);
			launchHook = false;
		}

		public void LaunchHook()
		{
			launchHook = true;
		}

		private bool IsLevelOver()
		{
			activeEntities.RemoveAll((GoldMinerEntity e) => e == null);
			if (activeEntities.Count <= 0)
			{
				return true;
			}
			if (hook.Status == Hook.HookStatus.Swinging && run.stamina <= 0f)
			{
				return true;
			}
			if (Hook.Status == Hook.HookStatus.Retrieving && run.stamina < 0f - run.extraStamina.Value)
			{
				return true;
			}
			return false;
		}

		private async UniTask DoShop()
		{
			onShopBegin?.Invoke(this);
			await shop.Execute();
			onShopEnd?.Invoke(this);
		}

		private void OnHookResolveEntity(Hook hook, GoldMinerEntity entity)
		{
			entity.NotifyResolved(this);
			entity.gameObject.SetActive(value: false);
			activeEntities.Remove(entity);
			resolvedEntities.Add(entity);
			if (run.IsRock(entity))
			{
				entity.Value = Mathf.CeilToInt((float)entity.Value * run.rockValueFactor.Value);
			}
			if (run.IsGold(entity))
			{
				entity.Value = Mathf.CeilToInt((float)entity.Value * run.goldValueFactor.Value);
			}
			popText.Pop($"${entity.Value}", hook.Axis.position);
			onResolveEntity?.Invoke(this, entity);
			onAfterResolveEntity?.Invoke(this, entity);
		}

		private void OnHookBeginRetrieve(Hook hook)
		{
			onHookBeginRetrieve?.Invoke(this, hook);
		}

		private void OnHookEndRetrieve(Hook hook)
		{
			onHookEndRetrieve?.Invoke(this, hook);
			if (run.StrengthPotionActivated)
			{
				run.DeactivateStrengthPotion();
			}
		}

		private void OnHookLaunch(Hook hook)
		{
			onHookLaunch?.Invoke(this, hook);
			if (run.EagleEyeActivated)
			{
				run.DeactivateEagleEye();
			}
		}

		private void OnHookAttach(Hook hook, GoldMinerEntity entity)
		{
			onHookAttach?.Invoke(this, hook, entity);
		}

		public bool UseStrengthPotion()
		{
			if (run.strengthPotion <= 0)
			{
				return false;
			}
			if (run.StrengthPotionActivated)
			{
				return false;
			}
			run.strengthPotion--;
			run.ActivateStrengthPotion();
			return true;
		}

		public bool UseEagleEyePotion()
		{
			if (run.eagleEyePotion <= 0)
			{
				return false;
			}
			if (run.EagleEyeActivated)
			{
				return false;
			}
			run.eagleEyePotion--;
			run.ActivateEagleEye();
			return true;
		}

		public GoldMinerArtifact GetArtifactPrefab(string id)
		{
			return artifactPrefabs.Find((GoldMinerArtifact e) => e != null && e.ID == id);
		}

		internal bool UseBomb()
		{
			if (run.bomb <= 0)
			{
				return false;
			}
			run.bomb--;
			UnityEngine.Object.Instantiate(bombPrefab, hook.Axis.transform.position, Quaternion.FromToRotation(Vector3.up, -hook.Axis.transform.up), base.transform);
			return true;
		}

		internal void NotifyArtifactChange()
		{
			onArtifactChange?.Invoke(this);
		}
	}
	public class GoldMinerEntity : MiniGameBehaviour
	{
		public enum Size
		{
			XS = -2,
			S,
			M,
			L,
			XL
		}

		public enum Tag
		{
			None,
			Rock,
			Gold,
			Diamond,
			Mine,
			Chest,
			Pig,
			Cable
		}

		[SerializeField]
		private string typeID;

		[SerializeField]
		public Size size;

		[SerializeField]
		public Tag[] tags;

		[SerializeField]
		private int value;

		[SerializeField]
		private float speed = 1f;

		[SerializeField]
		private ParticleSystem contactFX;

		[SerializeField]
		private ParticleSystem beginMoveFX;

		[SerializeField]
		private ParticleSystem resolveFX;

		[SerializeField]
		private ParticleSystem explodeFX;

		public Action<GoldMinerEntity, Hook> OnAttached;

		public Action<GoldMinerEntity, GoldMiner> OnResolved;

		public GoldMiner master { get; private set; }

		public string TypeID => typeID;

		public float Speed => speed;

		public int Value
		{
			get
			{
				return value;
			}
			set
			{
				this.value = value;
			}
		}

		public void SetMaster(GoldMiner master)
		{
			this.master = master;
		}

		public void NotifyAttached(Hook hook)
		{
			OnAttached?.Invoke(this, hook);
			FXPool.Play(contactFX, base.transform.position, base.transform.rotation);
		}

		public void NotifyBeginRetrieving()
		{
			FXPool.Play(beginMoveFX, base.transform.position, base.transform.rotation);
		}

		internal void Explode(Vector3 origin)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			FXPool.Play(explodeFX, base.transform.position, base.transform.rotation);
		}

		internal void NotifyResolved(GoldMiner game)
		{
			OnResolved?.Invoke(this, game);
			FXPool.Play(resolveFX, base.transform.position, base.transform.rotation);
		}
	}
	public class GoldMinerShop : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private GoldMinerShopUI ui;

		[SerializeField]
		private RandomContainer<int> qualityDistribute;

		public List<ShopEntity> stock = new List<ShopEntity>();

		public Action onAfterOperation;

		private int capacity;

		private List<GoldMinerArtifact>[] validCandidateLists = new List<GoldMinerArtifact>[5];

		private bool complete;

		private int refreshPrice = 100;

		public int refreshChance { get; private set; }

		private void Clear()
		{
			capacity = master.run.shopCapacity;
			for (int i = 0; i < stock.Count; i++)
			{
				ShopEntity shopEntity = stock[i];
				if (shopEntity != null && (shopEntity.sold || !shopEntity.locked))
				{
					stock[i] = null;
				}
			}
			for (int j = capacity; j < stock.Count; j++)
			{
				if (stock[j] == null)
				{
					stock.RemoveAt(j);
				}
			}
		}

		private void Refill()
		{
			capacity = master.run.shopCapacity;
			for (int i = 0; i < capacity; i++)
			{
				if (stock.Count <= i)
				{
					stock.Add(null);
				}
				ShopEntity shopEntity = stock[i];
				if (shopEntity == null || shopEntity.sold)
				{
					stock[i] = GenerateNewShopItem();
				}
			}
		}

		private void RefreshStock()
		{
			Clear();
			CacheValidCandiateLists();
			Refill();
			onAfterOperation?.Invoke();
		}

		private void CacheValidCandiateLists()
		{
			for (int i = 0; i < 5; i++)
			{
				int quality = i + 1;
				List<GoldMinerArtifact> list = SearchValidCandidateArtifactIDs(quality).ToList();
				validCandidateLists[i] = list;
			}
			foreach (ShopEntity item in stock)
			{
				if (item != null && !(item.artifact == null) && !item.artifact.AllowMultiple)
				{
					List<GoldMinerArtifact>[] array = validCandidateLists;
					for (int j = 0; j < array.Length; j++)
					{
						array[j]?.Remove(item.artifact);
					}
				}
			}
		}

		private IEnumerable<GoldMinerArtifact> SearchValidCandidateArtifactIDs(int quality)
		{
			foreach (GoldMinerArtifact artifact in master.ArtifactPrefabs)
			{
				if (artifact.Quality == quality && (artifact.AllowMultiple || (master.run.GetArtifactCount(artifact.ID) <= 0 && !stock.Any((ShopEntity e) => e != null && !e.sold && e.ID == artifact.ID))))
				{
					yield return artifact;
				}
			}
		}

		private List<GoldMinerArtifact> GetValidCandidateArtifactIDs(int q)
		{
			return validCandidateLists[q - 1];
		}

		private ShopEntity GenerateNewShopItem()
		{
			int num = qualityDistribute.GetRandom();
			List<GoldMinerArtifact> list = null;
			for (int num2 = num; num2 >= 1; num2--)
			{
				list = GetValidCandidateArtifactIDs(num2);
				if (list.Count > 0)
				{
					num = num2;
					break;
				}
			}
			GoldMinerArtifact random = list.GetRandom(master.run.shopRandom);
			if (random != null && !random.AllowMultiple)
			{
				GetValidCandidateArtifactIDs(num)?.Remove(random);
			}
			if (random == null)
			{
				UnityEngine.Debug.Log($"{num} failed to generate");
			}
			return new ShopEntity
			{
				artifact = random
			};
		}

		public bool Buy(ShopEntity entity)
		{
			if (!stock.Contains(entity))
			{
				UnityEngine.Debug.LogError("Buying entity that doesn't exist in shop stock");
				return false;
			}
			if (entity.sold)
			{
				return false;
			}
			bool useTicket;
			int price = CalculateDealPrice(entity, out useTicket);
			if (master.run.shopTicket > 0)
			{
				master.run.shopTicket--;
			}
			else if (!master.PayMoney(price))
			{
				return false;
			}
			master.run.AttachArtifactFromPrefab(entity.artifact);
			entity.sold = true;
			onAfterOperation?.Invoke();
			return true;
		}

		public int CalculateDealPrice(ShopEntity entity, out bool useTicket)
		{
			useTicket = false;
			if (entity == null)
			{
				return 0;
			}
			if (master.run.shopTicket > 0)
			{
				useTicket = true;
				return 0;
			}
			GoldMinerArtifact artifact = entity.artifact;
			if (artifact == null)
			{
				return 0;
			}
			return Mathf.CeilToInt((float)artifact.BasePrice * entity.priceFactor * master.GlobalPriceFactor);
		}

		public async UniTask Execute()
		{
			RefreshStock();
			if (stock.Count > 0)
			{
				stock[0].priceFactor = master.run.shopPriceCut.Value;
			}
			refreshPrice = Mathf.RoundToInt(master.run.shopRefreshPrice.Value);
			refreshChance = Mathf.RoundToInt(master.run.shopRefreshChances.Value);
			complete = false;
			ui.gameObject.SetActive(value: true);
			ui.enableInput = false;
			ui.Setup(this);
			await UniTask.WaitForSeconds(0.1f);
			ui.enableInput = true;
			while (!complete)
			{
				await UniTask.Yield();
			}
			ui.gameObject.SetActive(value: false);
		}

		internal void Continue()
		{
			complete = true;
		}

		internal bool TryRefresh()
		{
			if (refreshChance <= 0)
			{
				return false;
			}
			int refreshCost = GetRefreshCost();
			if (!master.PayMoney(refreshCost))
			{
				return false;
			}
			refreshChance--;
			refreshPrice += Mathf.RoundToInt(master.run.shopRefreshPriceIncrement.Value);
			RefreshStock();
			return true;
		}

		internal int GetRefreshCost()
		{
			return refreshPrice;
		}
	}
	[Serializable]
	public class ShopEntity
	{
		public GoldMinerArtifact artifact;

		public bool locked;

		public bool sold;

		public float priceFactor = 1f;

		public string ID
		{
			get
			{
				if (!artifact)
				{
					return null;
				}
				return artifact.ID;
			}
		}
	}
	public class Hook : MiniGameBehaviour
	{
		public enum HookStatus
		{
			Idle,
			Swinging,
			Launching,
			Attaching,
			Retrieving,
			Retrieved
		}

		public float emptySpeed = 1000f;

		public float strength;

		public float swingFreqFactor = 1f;

		[SerializeField]
		private Transform hookAxis;

		[SerializeField]
		private HookHead hookHead;

		[SerializeField]
		private Transform claw;

		[SerializeField]
		private float clawOffset = 4f;

		[SerializeField]
		private Animator clawAnimator;

		[SerializeField]
		private LineRenderer ropeLineRenderer;

		[SerializeField]
		private Bounds bounds;

		[SerializeField]
		private float grabAnimationTime = 0.5f;

		[SerializeField]
		private Ease grabAnimationEase = Ease.OutBounce;

		[SerializeField]
		private float maxAngle;

		[SerializeField]
		private float minDist;

		[SerializeField]
		private float maxDist;

		[Range(0f, 1f)]
		private float ropeControl;

		[Range(-1f, 1f)]
		private float axisControl;

		private HookStatus status;

		private float t;

		private GoldMinerEntity _grabbingTarget;

		private Vector2 relativePos;

		private Quaternion targetRelativeRotation;

		private float targetDist;

		private float retrieveETA;

		public float forceModification;

		private float maxDeltaWatch;

		public Transform Axis => hookAxis;

		public HookStatus Status => status;

		private float RopeDistance => Mathf.Lerp(minDist, maxDist, ropeControl);

		private float AxisAngle => Mathf.Lerp(0f - maxAngle, maxAngle, (axisControl + 1f) / 2f);

		private bool RopeOutOfBound
		{
			get
			{
				Vector3 point = Quaternion.Euler(0f, 0f, AxisAngle) * Vector2.down * RopeDistance;
				return !bounds.Contains(point);
			}
		}

		public GoldMinerEntity GrabbingTarget
		{
			get
			{
				return _grabbingTarget;
			}
			private set
			{
				_grabbingTarget = value;
			}
		}

		internal Vector3 Direction => -hookAxis.transform.up;

		public event Action<Hook, GoldMinerEntity> OnResolveTarget;

		public event Action<Hook> OnLaunch;

		public event Action<Hook> OnBeginRetrieve;

		public event Action<Hook, GoldMinerEntity> OnAttach;

		public event Action<Hook> OnEndRetrieve;

		public void SetParameters(float swingFreqFactor, float emptySpeed, float strength)
		{
			this.swingFreqFactor = swingFreqFactor;
			this.emptySpeed = emptySpeed;
			this.strength = strength;
		}

		public void Tick(float deltaTime)
		{
			UpdateStatus(deltaTime);
			UpdateHookHeadPosition();
			UpdateAxis();
			ropeLineRenderer.SetPositions(new Vector3[2]
			{
				hookAxis.transform.position,
				hookHead.transform.position
			});
		}

		private void UpdateHookHeadPosition()
		{
			hookHead.transform.localPosition = GetHookHeadPosition(RopeDistance);
		}

		private Vector3 GetHookHeadPosition(float ropeDistance)
		{
			return -Vector3.up * RopeDistance;
		}

		private void UpdateAxis()
		{
			hookAxis.transform.localRotation = Quaternion.Euler(0f, 0f, AxisAngle);
		}

		private void OnValidate()
		{
			UpdateHookHeadPosition();
			UpdateAxis();
		}

		private void UpdateStatus(float deltaTime)
		{
			switch (status)
			{
			case HookStatus.Swinging:
				UpdateSwinging(deltaTime);
				UpdateClaw();
				break;
			case HookStatus.Launching:
				UpdateClaw();
				UpdateLaunching(deltaTime);
				break;
			case HookStatus.Attaching:
				UpdateAttaching(deltaTime);
				break;
			case HookStatus.Retrieving:
				UpdateRetreving(deltaTime);
				UpdateClaw();
				break;
			case HookStatus.Retrieved:
				UpdateRetrieved();
				break;
			case HookStatus.Idle:
				break;
			}
		}

		public void Launch()
		{
			if (status == HookStatus.Swinging)
			{
				EnterStatus(HookStatus.Launching);
				this.OnLaunch?.Invoke(this);
			}
		}

		public void Reset()
		{
			ropeControl = 0f;
		}

		private void UpdateClaw()
		{
			clawAnimator.SetBool("Grabbing", GrabbingTarget);
			if (!GrabbingTarget)
			{
				claw.localRotation = Quaternion.Euler(0f, 0f, -180f);
				claw.localPosition = Vector3.zero;
			}
			else
			{
				Vector2 to = GrabbingTarget.transform.position - hookHead.transform.position;
				claw.rotation = Quaternion.Euler(0f, 0f, Vector2.SignedAngle(Vector2.up, to));
				claw.position = hookHead.transform.position + (Vector3)to.normalized * clawOffset;
			}
		}

		private void UpdateSwinging(float deltaTime)
		{
			t += deltaTime * 90f * swingFreqFactor * (MathF.PI / 180f);
			axisControl = Mathf.Sin(t);
		}

		private void UpdateLaunching(float deltaTime)
		{
			float speed = emptySpeed;
			if (GrabbingTarget != null)
			{
				speed = GrabbingTarget.Speed;
			}
			float num = (100f + strength) / 100f;
			speed *= num;
			float maxDelta = speed * deltaTime / (maxDist - minDist);
			Vector3 hookHeadPosition = GetHookHeadPosition(RopeDistance);
			ropeControl = Mathf.MoveTowards(ropeControl, 1f, maxDelta);
			GetHookHeadPosition(RopeDistance);
			Vector3 oldWorldPos = hookAxis.localToWorldMatrix.MultiplyPoint(hookHeadPosition);
			Vector3 newWorldPos = hookAxis.localToWorldMatrix.MultiplyPoint(hookHeadPosition);
			if (RopeOutOfBound || ropeControl >= 1f)
			{
				EnterStatus(HookStatus.Retrieving);
			}
			CheckGrab(oldWorldPos, newWorldPos);
		}

		private void CheckGrab(Vector3 oldWorldPos, Vector3 newWorldPos)
		{
			if ((bool)GrabbingTarget)
			{
				return;
			}
			Vector3 vector = newWorldPos - oldWorldPos;
			RaycastHit2D[] array = Physics2D.CircleCastAll(oldWorldPos, 8f, vector.normalized, vector.magnitude);
			for (int i = 0; i < array.Length; i++)
			{
				RaycastHit2D raycastHit2D = array[i];
				if (!(raycastHit2D.collider == null))
				{
					GoldMinerEntity component = raycastHit2D.collider.gameObject.GetComponent<GoldMinerEntity>();
					if (!(component == null))
					{
						Grab(component);
						break;
					}
				}
			}
		}

		private void Grab(GoldMinerEntity target)
		{
			GrabbingTarget = target;
			EnterStatus(HookStatus.Attaching);
			relativePos = target.transform.position - hookHead.transform.position;
			targetDist = relativePos.magnitude;
			targetRelativeRotation = Quaternion.FromToRotation(relativePos, GrabbingTarget.transform.up);
			retrieveETA = grabAnimationTime;
			Vector2 to = GrabbingTarget.transform.position - hookHead.transform.position;
			Vector3 endValue = new Vector3(0f, 0f, Vector2.SignedAngle(Vector2.up, to));
			Vector3 endValue2 = hookHead.transform.position + (Vector3)to.normalized * clawOffset;
			claw.DORotate(endValue, retrieveETA).SetEase(grabAnimationEase);
			claw.DOMove(endValue2, retrieveETA).SetEase(grabAnimationEase);
			clawAnimator.SetBool("Grabbing", GrabbingTarget);
			GrabbingTarget.NotifyAttached(this);
			this.OnAttach?.Invoke(this, target);
		}

		private void UpdateAttaching(float deltaTime)
		{
			if (GrabbingTarget == null)
			{
				EnterStatus(HookStatus.Retrieving);
				return;
			}
			retrieveETA -= deltaTime;
			if (retrieveETA <= 0f)
			{
				EnterStatus(HookStatus.Retrieving);
			}
		}

		private void UpdateRetreving(float deltaTime)
		{
			float speed = emptySpeed;
			if (GrabbingTarget != null)
			{
				speed = GrabbingTarget.Speed;
			}
			float num = (100f + strength) / 100f;
			speed *= num;
			float maxDelta = (maxDeltaWatch = speed * deltaTime / (maxDist - minDist));
			Vector3 hookHeadPosition = GetHookHeadPosition(RopeDistance);
			ropeControl = Mathf.MoveTowards(ropeControl, 0f, maxDelta);
			GetHookHeadPosition(RopeDistance);
			Vector3 oldWorldPos = hookAxis.localToWorldMatrix.MultiplyPoint(hookHeadPosition);
			Vector3 newWorldPos = hookAxis.localToWorldMatrix.MultiplyPoint(hookHeadPosition);
			if (ropeControl <= 0f)
			{
				ropeControl = 0f;
				EnterStatus(HookStatus.Retrieved);
			}
			if ((bool)GrabbingTarget)
			{
				Vector3 vector = GrabbingTarget.transform.position - hookHead.transform.position;
				if (vector.magnitude > targetDist)
				{
					GrabbingTarget.transform.position = hookHead.transform.position + vector.normalized * targetDist;
					Vector3 toDirection = targetRelativeRotation * vector;
					GrabbingTarget.transform.rotation = Quaternion.FromToRotation(Vector3.up, toDirection);
				}
			}
			else
			{
				CheckGrab(oldWorldPos, newWorldPos);
			}
		}

		private void UpdateRetrieved()
		{
			if ((bool)GrabbingTarget)
			{
				ResolveRetrievedObject(GrabbingTarget);
				GrabbingTarget = null;
			}
			EnterStatus(HookStatus.Swinging);
		}

		private void ResolveRetrievedObject(GoldMinerEntity grabingTarget)
		{
			this.OnResolveTarget?.Invoke(this, grabingTarget);
		}

		private void OnExitStatus(HookStatus status)
		{
			switch (status)
			{
			case HookStatus.Retrieving:
				this.OnEndRetrieve?.Invoke(this);
				break;
			case HookStatus.Idle:
			case HookStatus.Swinging:
			case HookStatus.Launching:
			case HookStatus.Attaching:
			case HookStatus.Retrieved:
				break;
			}
		}

		private void EnterStatus(HookStatus status)
		{
			OnExitStatus(this.status);
			this.status = status;
			OnEnterStatus(this.status);
		}

		private void OnEnterStatus(HookStatus status)
		{
			switch (status)
			{
			case HookStatus.Swinging:
				ropeControl = 0f;
				break;
			case HookStatus.Retrieving:
				if ((bool)GrabbingTarget)
				{
					GrabbingTarget.NotifyBeginRetrieving();
				}
				this.OnBeginRetrieve?.Invoke(this);
				break;
			case HookStatus.Idle:
			case HookStatus.Launching:
			case HookStatus.Attaching:
			case HookStatus.Retrieved:
				break;
			}
		}

		internal void ReleaseClaw()
		{
			GrabbingTarget = null;
		}

		internal void BeginSwing()
		{
			EnterStatus(HookStatus.Swinging);
		}
	}
	public class HookHead : MonoBehaviour
	{
		public Action<HookHead, Collision2D> onCollisionEnter;

		public Action<HookHead, Collision2D> onCollisionExit;

		public Action<HookHead, Collision2D> onCollisionStay;

		private void OnCollisionEnter2D(Collision2D collision)
		{
			onCollisionEnter?.Invoke(this, collision);
		}

		private void OnCollisionExit2D(Collision2D collision)
		{
			onCollisionExit?.Invoke(this, collision);
		}

		private void OnCollisionStay2D(Collision2D collision)
		{
			onCollisionStay?.Invoke(this, collision);
		}
	}
	public class GoldMiner_ShopItem : MonoBehaviour
	{
		[SerializeField]
		private Sprite icon;

		[LocalizationKey("Default")]
		[SerializeField]
		private string displayNameKey;

		[SerializeField]
		private int basePrice;

		public UnityEvent<GoldMiner> onBought;

		public Sprite Icon => icon;

		public string DisplayNameKey => displayNameKey;

		public string DisplayName => displayNameKey.ToPlainText();

		public int BasePrice => basePrice;

		public void OnBought(GoldMiner target)
		{
			onBought?.Invoke(target);
		}
	}
	public class AddBombOnRetrieve : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMinerEntity master;

		[SerializeField]
		private int amount = 1;

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponent<GoldMinerEntity>();
			}
			GoldMinerEntity goldMinerEntity = master;
			goldMinerEntity.OnResolved = (Action<GoldMinerEntity, GoldMiner>)Delegate.Combine(goldMinerEntity.OnResolved, new Action<GoldMinerEntity, GoldMiner>(OnResolved));
		}

		private void OnResolved(GoldMinerEntity entity, GoldMiner game)
		{
			game.run.bomb += amount;
		}
	}
	public class AddEagleEyePotionOnRetrieve : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMinerEntity master;

		[SerializeField]
		private int amount = 1;

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponent<GoldMinerEntity>();
			}
			GoldMinerEntity goldMinerEntity = master;
			goldMinerEntity.OnResolved = (Action<GoldMinerEntity, GoldMiner>)Delegate.Combine(goldMinerEntity.OnResolved, new Action<GoldMinerEntity, GoldMiner>(OnResolved));
		}

		private void OnResolved(GoldMinerEntity entity, GoldMiner game)
		{
			game.run.eagleEyePotion += amount;
		}
	}
	public class AddStrengthPotionOnRetrieve : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMinerEntity master;

		[SerializeField]
		private int amount = 1;

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponent<GoldMinerEntity>();
			}
			GoldMinerEntity goldMinerEntity = master;
			goldMinerEntity.OnResolved = (Action<GoldMinerEntity, GoldMiner>)Delegate.Combine(goldMinerEntity.OnResolved, new Action<GoldMinerEntity, GoldMiner>(OnResolved));
		}

		private void OnResolved(GoldMinerEntity entity, GoldMiner game)
		{
			game.run.strengthPotion += amount;
		}
	}
	public class ExplodeOnAttach : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMiner goldMiner;

		[SerializeField]
		private GoldMinerEntity master;

		[SerializeField]
		private float explodeRange;

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponent<GoldMinerEntity>();
			}
			if (goldMiner == null)
			{
				goldMiner = GetComponentInParent<GoldMiner>();
			}
			GoldMinerEntity goldMinerEntity = master;
			goldMinerEntity.OnAttached = (Action<GoldMinerEntity, Hook>)Delegate.Combine(goldMinerEntity.OnAttached, new Action<GoldMinerEntity, Hook>(OnAttached));
		}

		private void OnAttached(GoldMinerEntity target, Hook hook)
		{
			if (goldMiner == null || goldMiner.run == null || goldMiner.run.defuse.Value > 0.1f)
			{
				return;
			}
			Collider2D[] array = Physics2D.OverlapCircleAll(base.transform.position, explodeRange);
			for (int i = 0; i < array.Length; i++)
			{
				GoldMinerEntity component = array[i].GetComponent<GoldMinerEntity>();
				if (!(component == null))
				{
					component.Explode(base.transform.position);
				}
			}
			master.Explode(base.transform.position);
		}

		private void OnDrawGizmosSelected()
		{
			Gizmos.color = Color.red;
			Gizmos.DrawWireSphere(base.transform.position, explodeRange);
		}
	}
	public class PigBehaviour : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMinerEntity entity;

		[SerializeField]
		private float moveSpeed = 50f;

		private bool attached;

		private bool movingRight;

		private void Awake()
		{
			if (entity == null)
			{
				entity = GetComponent<GoldMinerEntity>();
			}
			GoldMinerEntity goldMinerEntity = entity;
			goldMinerEntity.OnAttached = (Action<GoldMinerEntity, Hook>)Delegate.Combine(goldMinerEntity.OnAttached, new Action<GoldMinerEntity, Hook>(OnAttached));
		}

		protected override void OnUpdate(float deltaTime)
		{
			Quaternion localRotation = Quaternion.AngleAxis((!movingRight) ? 180 : 0, Vector3.up);
			base.transform.localRotation = localRotation;
			base.transform.localPosition += (movingRight ? Vector3.right : Vector3.left) * moveSpeed * entity.master.run.GameSpeedFactor * deltaTime;
			if (base.transform.localPosition.x > entity.master.Bounds.max.x)
			{
				movingRight = false;
			}
			else if (base.transform.localPosition.x < entity.master.Bounds.min.x)
			{
				movingRight = true;
			}
		}

		private void OnAttached(GoldMinerEntity entity, Hook hook)
		{
		}
	}
	public class BombDisplay : MonoBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private TextMeshProUGUI amountText;

		[SerializeField]
		private NavEntry navEntry;

		private void Awake()
		{
			NavEntry obj = navEntry;
			obj.onInteract = (Action<NavEntry>)Delegate.Combine(obj.onInteract, new Action<NavEntry>(OnInteract));
			GoldMiner goldMiner = master;
			goldMiner.onEarlyLevelPlayTick = (Action<GoldMiner>)Delegate.Combine(goldMiner.onEarlyLevelPlayTick, new Action<GoldMiner>(OnEarlyLevelPlayTick));
		}

		private void OnEarlyLevelPlayTick(GoldMiner miner)
		{
			if (!(master == null) && master.run != null)
			{
				amountText.text = $"{master.run.bomb}";
			}
		}

		private void OnInteract(NavEntry entry)
		{
			master.UseBomb();
		}
	}
	public class EagleEyePotionDisplay : MonoBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private TextMeshProUGUI amountText;

		[SerializeField]
		private NavEntry navEntry;

		private void Awake()
		{
			NavEntry obj = navEntry;
			obj.onInteract = (Action<NavEntry>)Delegate.Combine(obj.onInteract, new Action<NavEntry>(OnInteract));
			GoldMiner goldMiner = master;
			goldMiner.onEarlyLevelPlayTick = (Action<GoldMiner>)Delegate.Combine(goldMiner.onEarlyLevelPlayTick, new Action<GoldMiner>(OnEarlyLevelPlayTick));
		}

		private void OnEarlyLevelPlayTick(GoldMiner miner)
		{
			if (!(master == null) && master.run != null)
			{
				amountText.text = $"{master.run.eagleEyePotion}";
			}
		}

		private void OnInteract(NavEntry entry)
		{
			master.UseEagleEyePotion();
		}
	}
	public class GoldMinerMoneyDisplay : MonoBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private string format = "$0";

		private void Update()
		{
			text.text = master.Money.ToString(format);
		}
	}
	public class GoldMinerShopUI : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private TextMeshProUGUI descriptionText;

		[SerializeField]
		private GoldMinerShopUIEntry[] entries;

		public int navIndex;

		public bool enableInput;

		public GoldMinerShopUIEntry hoveringEntry;

		public GoldMinerShop target { get; private set; }

		private void UnregisterEvent()
		{
			if (!(target == null))
			{
				GoldMinerShop goldMinerShop = target;
				goldMinerShop.onAfterOperation = (Action)Delegate.Remove(goldMinerShop.onAfterOperation, new Action(OnAfterOperation));
			}
		}

		private void RegisterEvent()
		{
			if (!(target == null))
			{
				GoldMinerShop goldMinerShop = target;
				goldMinerShop.onAfterOperation = (Action)Delegate.Combine(goldMinerShop.onAfterOperation, new Action(OnAfterOperation));
			}
		}

		private void OnAfterOperation()
		{
			RefreshEntries();
		}

		private void RefreshEntries()
		{
			for (int i = 0; i < entries.Length; i++)
			{
				GoldMinerShopUIEntry goldMinerShopUIEntry = entries[i];
				if (i >= target.stock.Count)
				{
					goldMinerShopUIEntry.gameObject.SetActive(value: false);
					continue;
				}
				goldMinerShopUIEntry.gameObject.SetActive(value: true);
				ShopEntity shopEntity = target.stock[i];
				goldMinerShopUIEntry.Setup(this, shopEntity);
			}
		}

		public void Setup(GoldMinerShop shop)
		{
			UnregisterEvent();
			target = shop;
			RegisterEvent();
			RefreshEntries();
		}

		protected override void OnUpdate(float deltaTime)
		{
			base.OnUpdate(deltaTime);
			RefreshDescriptionText();
		}

		private void RefreshDescriptionText()
		{
			string text = "";
			if (hoveringEntry != null && hoveringEntry.target != null && hoveringEntry.target.artifact != null)
			{
				text = hoveringEntry.target.artifact.Description;
			}
			descriptionText.text = text;
		}
	}
	public class GoldMinerShopUIContinueBtn : MonoBehaviour
	{
		[SerializeField]
		private GoldMinerShop shop;

		[SerializeField]
		private NavEntry navEntry;

		private void Awake()
		{
			if (!navEntry)
			{
				navEntry = GetComponent<NavEntry>();
			}
			NavEntry obj = navEntry;
			obj.onInteract = (Action<NavEntry>)Delegate.Combine(obj.onInteract, new Action<NavEntry>(OnInteract));
		}

		private void OnInteract(NavEntry entry)
		{
			shop.Continue();
		}
	}
	public class GoldMinerShopUIEntry : MonoBehaviour
	{
		[SerializeField]
		private NavEntry navEntry;

		[SerializeField]
		private VirtualCursorTarget VCT;

		[SerializeField]
		private GameObject mainLayout;

		[SerializeField]
		private TextMeshProUGUI nameText;

		[SerializeField]
		private TextMeshProUGUI priceText;

		[SerializeField]
		private string priceFormat = "0";

		[SerializeField]
		private GameObject priceIndicator;

		[SerializeField]
		private GameObject freeIndicator;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private GameObject soldIndicator;

		private GoldMinerShopUI master;

		public ShopEntity target;

		private void Awake()
		{
			if (!navEntry)
			{
				navEntry = GetComponent<NavEntry>();
			}
			NavEntry obj = navEntry;
			obj.onInteract = (Action<NavEntry>)Delegate.Combine(obj.onInteract, new Action<NavEntry>(OnInteract));
			VCT = GetComponent<VirtualCursorTarget>();
			if ((bool)VCT)
			{
				VCT.onEnter.AddListener(OnVCTEnter);
			}
		}

		private void OnVCTEnter()
		{
			master.hoveringEntry = this;
		}

		private void OnInteract(NavEntry entry)
		{
			master.target.Buy(target);
		}

		internal void Setup(GoldMinerShopUI master, ShopEntity target)
		{
			this.master = master;
			this.target = target;
			if (target == null || target.artifact == null)
			{
				SetupEmpty();
				return;
			}
			mainLayout.SetActive(value: true);
			nameText.text = target.artifact.DisplayName;
			icon.sprite = target.artifact.Icon;
			Refresh();
		}

		private void Refresh()
		{
			bool useTicket;
			int num = master.target.CalculateDealPrice(target, out useTicket);
			priceText.text = num.ToString(priceFormat);
			priceIndicator.SetActive(num > 0);
			freeIndicator.SetActive(num <= 0);
			soldIndicator.SetActive(target.sold);
		}

		private void SetupEmpty()
		{
			mainLayout.SetActive(value: false);
		}
	}
	public class GoldMinerShopUIRefreshBtn : MonoBehaviour
	{
		[SerializeField]
		private GoldMinerShop shop;

		[SerializeField]
		private NavEntry navEntry;

		[SerializeField]
		private TextMeshProUGUI costText;

		[SerializeField]
		private TextMeshProUGUI refreshChanceText;

		[SerializeField]
		private GameObject noChanceIndicator;

		private void Awake()
		{
			if (!navEntry)
			{
				navEntry = GetComponent<NavEntry>();
			}
			NavEntry obj = navEntry;
			obj.onInteract = (Action<NavEntry>)Delegate.Combine(obj.onInteract, new Action<NavEntry>(OnInteract));
			GoldMinerShop goldMinerShop = shop;
			goldMinerShop.onAfterOperation = (Action)Delegate.Combine(goldMinerShop.onAfterOperation, new Action(OnAfterOperation));
		}

		private void OnEnable()
		{
			RefreshCostText();
		}

		private void OnAfterOperation()
		{
			RefreshCostText();
		}

		private void RefreshCostText()
		{
			costText.text = $"${shop.GetRefreshCost()}";
			refreshChanceText.text = $"{shop.refreshChance}";
			noChanceIndicator.SetActive(shop.refreshChance < 1);
		}

		private void OnInteract(NavEntry entry)
		{
			shop.TryRefresh();
		}
	}
	public class GoldMiner_PopText : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMiner_PopTextEntry textTemplate;

		private PrefabPool<GoldMiner_PopTextEntry> _textPool;

		private PrefabPool<GoldMiner_PopTextEntry> TextPool
		{
			get
			{
				if (_textPool == null)
				{
					_textPool = new PrefabPool<GoldMiner_PopTextEntry>(textTemplate);
				}
				return _textPool;
			}
		}

		public void Pop(string content, Vector3 position)
		{
			TextPool.Get().Setup(position, content, ReleaseEntry);
		}

		private void ReleaseEntry(GoldMiner_PopTextEntry entry)
		{
			TextPool.Release(entry);
		}
	}
	public class GoldMiner_PopTextEntry : MonoBehaviour
	{
		public TextMeshProUGUI tmp;

		public float lifeTime;

		public float moveSpeed = 1f;

		private bool initialized;

		private float life;

		private Action<GoldMiner_PopTextEntry> releaseAction;

		public void Setup(Vector3 pos, string text, Action<GoldMiner_PopTextEntry> releaseAction)
		{
			initialized = true;
			tmp.text = text;
			life = 0f;
			base.transform.position = pos;
			this.releaseAction = releaseAction;
		}

		private void Update()
		{
			if (initialized)
			{
				life += Time.deltaTime;
				base.transform.position += Vector3.up * moveSpeed * Time.deltaTime;
				if (life >= lifeTime)
				{
					Release();
				}
			}
		}

		private void Release()
		{
			if (releaseAction != null)
			{
				releaseAction(this);
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class LevelSettlementUI : MonoBehaviour
	{
		[SerializeField]
		private GoldMiner goldMiner;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private PunchReceiver moneyPunch;

		[SerializeField]
		private PunchReceiver factorPunch;

		[SerializeField]
		private PunchReceiver scorePunch;

		[SerializeField]
		private TextMeshProUGUI moneyText;

		[SerializeField]
		private TextMeshProUGUI factorText;

		[SerializeField]
		private TextMeshProUGUI scoreText;

		[SerializeField]
		private TextMeshProUGUI levelText;

		[SerializeField]
		private TextMeshProUGUI targetScoreText;

		[SerializeField]
		private GameObject clearIndicator;

		[SerializeField]
		private GameObject failIndicator;

		private int targetScore;

		private int money;

		private int score;

		private float factor;

		internal void Reset()
		{
			clearIndicator.SetActive(value: false);
			failIndicator.SetActive(value: false);
			money = 0;
			score = 0;
			factor = 0f;
			RefreshTexts();
		}

		public void SetTargetScore(int targetScore)
		{
			this.targetScore = targetScore;
			RefreshTexts();
		}

		public void StepResolveEntity(GoldMinerEntity entity)
		{
		}

		public void StepResult(bool clear)
		{
			clearIndicator.SetActive(clear);
			failIndicator.SetActive(!clear);
		}

		public void Step(int money, float factor, int score)
		{
			bool num = money > this.money;
			bool flag = factor > this.factor;
			bool flag2 = score > this.score;
			this.money = money;
			this.factor = factor;
			this.score = score;
			RefreshTexts();
			if (num)
			{
				moneyPunch.Punch();
			}
			if (flag)
			{
				factorPunch.Punch();
			}
			if (flag2)
			{
				scorePunch.Punch();
			}
		}

		private void RefreshTexts()
		{
			levelText.text = $"LEVEL {goldMiner.run.level + 1}";
			targetScoreText.text = $"{targetScore}";
			moneyText.text = $"${money}";
			factorText.text = $"{factor}";
			scoreText.text = $"{score}";
		}

		public void Show()
		{
			fadeGroup.Show();
		}

		public void Hide()
		{
			fadeGroup.Hide();
		}
	}
	public class NavGroup : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		public List<NavEntry> entries;

		public static Action OnNavGroupChanged;

		private int _navIndex;

		public static NavGroup ActiveNavGroup { get; private set; }

		public bool active => ActiveNavGroup == this;

		public int NavIndex
		{
			get
			{
				return _navIndex;
			}
			set
			{
				int navIndex = _navIndex;
				_navIndex = value;
				CleanupIndex();
				int navIndex2 = _navIndex;
				RefreshEntry(navIndex);
				RefreshEntry(navIndex2);
			}
		}

		public void SetAsActiveNavGroup()
		{
			NavGroup activeNavGroup = ActiveNavGroup;
			ActiveNavGroup = this;
			RefreshAll();
			if (activeNavGroup != null)
			{
				activeNavGroup.RefreshAll();
			}
			OnNavGroupChanged?.Invoke();
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			RefreshAll();
		}

		private void CleanupIndex()
		{
			if (_navIndex < 0)
			{
				_navIndex = entries.Count - 1;
			}
			if (_navIndex >= entries.Count)
			{
				_navIndex = 0;
			}
		}

		private void RefreshAll()
		{
			for (int i = 0; i < entries.Count; i++)
			{
				RefreshEntry(i);
			}
		}

		private void RefreshEntry(int index)
		{
			if (index >= 0 && index < entries.Count)
			{
				entries[index].NotifySelectionState(active && NavIndex == index);
			}
		}

		public NavEntry GetSelectedEntry()
		{
			if (NavIndex < 0 || NavIndex >= entries.Count)
			{
				return null;
			}
			return entries[NavIndex];
		}

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponentInParent<GoldMiner>();
			}
			GoldMiner goldMiner = master;
			goldMiner.onLevelBegin = (Action<GoldMiner>)Delegate.Combine(goldMiner.onLevelBegin, new Action<GoldMiner>(OnLevelBegin));
		}

		private void OnLevelBegin(GoldMiner miner)
		{
			RefreshAll();
		}

		internal void Remove(NavEntry navEntry)
		{
			entries.Remove(navEntry);
			CleanupIndex();
			RefreshAll();
		}

		internal void Add(NavEntry navEntry)
		{
			entries.Add(navEntry);
			CleanupIndex();
			RefreshAll();
		}

		internal void TrySelect(NavEntry navEntry)
		{
			if (entries.Contains(navEntry))
			{
				int navIndex = entries.IndexOf(navEntry);
				SetAsActiveNavGroup();
				NavIndex = navIndex;
			}
		}
	}
	public class NavGroupLinearController : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private NavGroup navGroup;

		[SerializeField]
		private NavGroup otherNavGroup;

		[SerializeField]
		private bool setActiveWhenLevelBegin;

		private bool changeLock;

		private void Awake()
		{
			GoldMiner goldMiner = master;
			goldMiner.onLevelBegin = (Action<GoldMiner>)Delegate.Combine(goldMiner.onLevelBegin, new Action<GoldMiner>(OnLevelBegin));
			NavGroup.OnNavGroupChanged = (Action)Delegate.Combine(NavGroup.OnNavGroupChanged, new Action(OnNavGroupChanged));
		}

		private void OnLevelBegin(GoldMiner miner)
		{
			if (setActiveWhenLevelBegin)
			{
				navGroup.SetAsActiveNavGroup();
			}
		}

		private void OnNavGroupChanged()
		{
			changeLock = true;
		}
	}
	public class PassivePropDisplay : MonoBehaviour
	{
		[SerializeField]
		private NavEntry navEntry;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TextMeshProUGUI amounText;

		public RectTransform rectTransform { get; private set; }

		public NavEntry NavEntry => navEntry;

		public GoldMinerArtifact Target { get; private set; }

		internal void Setup(GoldMinerArtifact target, int amount)
		{
			Target = target;
			icon.sprite = target.Icon;
			rectTransform = base.transform as RectTransform;
			amounText.text = ((amount > 1) ? $"{amount}" : "");
		}
	}
	public class PassivePropsUI : MiniGameBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private RectTransform descriptionContainer;

		[SerializeField]
		private TextMeshProUGUI descriptionText;

		[SerializeField]
		private PassivePropDisplay entryTemplate;

		[SerializeField]
		private NavGroup navGroup;

		[SerializeField]
		private NavGroup upNavGroup;

		[SerializeField]
		private GridLayoutGroup gridLayout;

		private PrefabPool<PassivePropDisplay> _pool;

		private bool changeLock;

		private PrefabPool<PassivePropDisplay> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<PassivePropDisplay>(entryTemplate, null, OnGetEntry, OnReleaseEntry);
				}
				return _pool;
			}
		}

		private void OnReleaseEntry(PassivePropDisplay display)
		{
			navGroup.Remove(display.NavEntry);
		}

		private void OnGetEntry(PassivePropDisplay display)
		{
			navGroup.Add(display.NavEntry);
		}

		private void Awake()
		{
			GoldMiner goldMiner = master;
			goldMiner.onLevelBegin = (Action<GoldMiner>)Delegate.Combine(goldMiner.onLevelBegin, new Action<GoldMiner>(OnLevelBegin));
			GoldMiner goldMiner2 = master;
			goldMiner2.onArtifactChange = (Action<GoldMiner>)Delegate.Combine(goldMiner2.onArtifactChange, new Action<GoldMiner>(OnArtifactChanged));
			GoldMiner goldMiner3 = master;
			goldMiner3.onEarlyLevelPlayTick = (Action<GoldMiner>)Delegate.Combine(goldMiner3.onEarlyLevelPlayTick, new Action<GoldMiner>(OnEarlyTick));
			NavGroup.OnNavGroupChanged = (Action)Delegate.Combine(NavGroup.OnNavGroupChanged, new Action(OnNavGroupChanged));
		}

		private void OnDestroy()
		{
			NavGroup.OnNavGroupChanged = (Action)Delegate.Remove(NavGroup.OnNavGroupChanged, new Action(OnNavGroupChanged));
		}

		private void OnNavGroupChanged()
		{
			changeLock = true;
			if (navGroup.active && Pool.ActiveEntries.Count <= 0)
			{
				upNavGroup.SetAsActiveNavGroup();
			}
			RefreshDescription();
		}

		private void OnEarlyTick(GoldMiner miner)
		{
			RefreshDescription();
		}

		private void SetCoord((int x, int y) coord)
		{
			int navIndex = CoordToIndex(coord);
			navGroup.NavIndex = navIndex;
			RefreshDescription();
		}

		private void RefreshDescription()
		{
			if (!navGroup.active)
			{
				HideDescription();
				return;
			}
			if (Pool.ActiveEntries.Count <= 0)
			{
				HideDescription();
				return;
			}
			NavEntry selectedEntry = navGroup.GetSelectedEntry();
			if (selectedEntry == null)
			{
				HideDescription();
				return;
			}
			if (!selectedEntry.VCT.IsHovering)
			{
				HideDescription();
				return;
			}
			PassivePropDisplay component = selectedEntry.GetComponent<PassivePropDisplay>();
			if (component == null)
			{
				HideDescription();
			}
			else
			{
				SetupAndShowDescription(component);
			}
		}

		private void HideDescription()
		{
			descriptionContainer.gameObject.SetActive(value: false);
		}

		private void SetupAndShowDescription(PassivePropDisplay ppd)
		{
			descriptionContainer.gameObject.SetActive(value: true);
			string description = ppd.Target.Description;
			descriptionText.text = description;
			descriptionContainer.position = ppd.rectTransform.TransformPoint(ppd.rectTransform.rect.max);
		}

		private int CoordToIndex((int x, int y) coord)
		{
			int count = navGroup.entries.Count;
			if (count <= 0)
			{
				return 0;
			}
			int constraintCount = gridLayout.constraintCount;
			int num = count / constraintCount;
			if (coord.y > num)
			{
				coord.y = num;
			}
			int num2 = constraintCount;
			if (coord.y == num)
			{
				num2 = count % constraintCount;
			}
			if (coord.x < 0)
			{
				coord.x = num2 - 1;
			}
			coord.x %= num2;
			if (coord.y < 0)
			{
				coord.y = num;
			}
			coord.y %= num + 1;
			return constraintCount * coord.y + coord.x;
		}

		private (int x, int y) IndexToCoord(int index)
		{
			int constraintCount = gridLayout.constraintCount;
			int item = index / constraintCount;
			return (x: index % constraintCount, y: item);
		}

		private void OnLevelBegin(GoldMiner miner)
		{
			Refresh();
			RefreshDescription();
		}

		private void OnArtifactChanged(GoldMiner miner)
		{
			Refresh();
		}

		private void Refresh()
		{
			Pool.ReleaseAll();
			if (master == null)
			{
				return;
			}
			GoldMinerRunData run = master.run;
			if (run == null)
			{
				return;
			}
			foreach (IGrouping<string, GoldMinerArtifact> item in from e in run.artifacts
				where e != null
				group e by e.ID)
			{
				GoldMinerArtifact target = item.ElementAt(0);
				Pool.Get().Setup(target, item.Count());
			}
		}
	}
	public class ScoreDisplay : MonoBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private TextMeshProUGUI moneyText;

		[SerializeField]
		private TextMeshProUGUI factorText;

		[SerializeField]
		private TextMeshProUGUI scoreText;

		[SerializeField]
		private TextMeshProUGUI targetScoreText;

		private void Awake()
		{
			GoldMiner goldMiner = master;
			goldMiner.onLevelBegin = (Action<GoldMiner>)Delegate.Combine(goldMiner.onLevelBegin, new Action<GoldMiner>(OnLevelBegin));
			GoldMiner goldMiner2 = master;
			goldMiner2.onAfterResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner2.onAfterResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnAfterResolveEntity));
		}

		private void OnAfterResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			Refresh();
		}

		private void OnLevelBegin(GoldMiner miner)
		{
			Refresh();
		}

		private void Refresh()
		{
			GoldMinerRunData run = master.run;
			if (run == null)
			{
				return;
			}
			int num = 0;
			float num2 = run.scoreFactorBase.Value + run.levelScoreFactor;
			int targetScore = run.targetScore;
			foreach (GoldMinerEntity resolvedEntity in master.resolvedEntities)
			{
				int num3 = Mathf.CeilToInt((float)resolvedEntity.Value * run.charm.Value);
				if (num3 != 0)
				{
					num += num3;
				}
			}
			moneyText.text = $"${num}";
			factorText.text = $"{num2}";
			scoreText.text = $"{Mathf.CeilToInt((float)num * num2)}";
			targetScoreText.text = $"{targetScore}";
		}
	}
	public class StaminaDisplay : MonoBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private UnityEngine.UI.Image fill;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private Gradient normalColor;

		[SerializeField]
		private Color extraColor = Color.red;

		private void FixedUpdate()
		{
			Refresh();
		}

		private void Refresh()
		{
			if (master == null)
			{
				return;
			}
			GoldMinerRunData run = master.run;
			if (run == null)
			{
				return;
			}
			float stamina = run.stamina;
			float value = run.maxStamina.Value;
			float value2 = run.extraStamina.Value;
			if (stamina > 0f)
			{
				float num = stamina / value;
				fill.fillAmount = num;
				fill.color = normalColor.Evaluate(num);
				text.text = $"{stamina:0.0}";
				return;
			}
			float num2 = value2 + stamina;
			if (num2 < 0f)
			{
				num2 = 0f;
			}
			float fillAmount = num2 / value2;
			fill.fillAmount = fillAmount;
			fill.color = extraColor;
			text.text = $"{num2:0.00}";
		}
	}
	public class StrengthPotionDisplay : MonoBehaviour
	{
		[SerializeField]
		private GoldMiner master;

		[SerializeField]
		private TextMeshProUGUI amountText;

		[SerializeField]
		private NavEntry navEntry;

		private void Awake()
		{
			NavEntry obj = navEntry;
			obj.onInteract = (Action<NavEntry>)Delegate.Combine(obj.onInteract, new Action<NavEntry>(OnInteract));
			GoldMiner goldMiner = master;
			goldMiner.onEarlyLevelPlayTick = (Action<GoldMiner>)Delegate.Combine(goldMiner.onEarlyLevelPlayTick, new Action<GoldMiner>(OnEarlyLevelPlayTick));
		}

		private void OnEarlyLevelPlayTick(GoldMiner miner)
		{
			if (!(master == null) && master.run != null)
			{
				amountText.text = $"{master.run.strengthPotion}";
			}
		}

		private void OnInteract(NavEntry entry)
		{
			master.UseStrengthPotion();
		}
	}
}
namespace Duckov.MiniGames.GoldMiner.UI
{
	public class NavEntry : MonoBehaviour
	{
		public GameObject selectedIndicator;

		public Action<NavEntry> onInteract;

		public Action<NavEntry> onTrySelectThis;

		public NavGroup masterGroup;

		public VirtualCursorTarget VCT;

		public bool selectionState { get; private set; }

		private void Awake()
		{
			if (masterGroup == null)
			{
				masterGroup = GetComponentInParent<NavGroup>();
			}
			VCT = GetComponent<VirtualCursorTarget>();
			if ((bool)VCT)
			{
				VCT.onEnter.AddListener(TrySelectThis);
				VCT.onClick.AddListener(Interact);
			}
		}

		private void Interact()
		{
			NotifyInteract();
		}

		public void NotifySelectionState(bool value)
		{
			selectionState = value;
			selectedIndicator.SetActive(selectionState);
		}

		internal void NotifyInteract()
		{
			onInteract?.Invoke(this);
		}

		public void TrySelectThis()
		{
			if (!(masterGroup == null))
			{
				masterGroup.TrySelect(this);
			}
		}
	}
}
namespace Duckov.MiniGames.GoldMiner.Artifacts
{
	public class GMA_001 : GoldMinerArtifactBehaviour
	{
		private Modifier staminaModifier;

		private Modifier scoreFactorModifier;

		private GoldMinerRunData cachedRun;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				cachedRun = base.Run;
				staminaModifier = new Modifier(ModifierType.Add, 1f, this);
				scoreFactorModifier = new Modifier(ModifierType.Add, 1f, this);
				cachedRun.staminaDrain.AddModifier(staminaModifier);
				cachedRun.scoreFactorBase.AddModifier(scoreFactorModifier);
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (cachedRun != null)
			{
				cachedRun.staminaDrain.RemoveModifier(staminaModifier);
				cachedRun.scoreFactorBase.RemoveModifier(scoreFactorModifier);
			}
		}
	}
	public class GMA_002 : GoldMinerArtifactBehaviour
	{
		private Modifier modifer;

		private bool effectActive;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(master == null) && !(base.GoldMiner == null))
			{
				modifer = new Modifier(ModifierType.PercentageMultiply, -0.5f, this);
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
				GoldMiner goldMiner2 = base.GoldMiner;
				goldMiner2.onHookBeginRetrieve = (Action<GoldMiner, Hook>)Delegate.Combine(goldMiner2.onHookBeginRetrieve, new Action<GoldMiner, Hook>(OnBeginRetrieve));
				GoldMiner goldMiner3 = base.GoldMiner;
				goldMiner3.onHookEndRetrieve = (Action<GoldMiner, Hook>)Delegate.Combine(goldMiner3.onHookEndRetrieve, new Action<GoldMiner, Hook>(OnEndRetrieve));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
				GoldMiner goldMiner2 = base.GoldMiner;
				goldMiner2.onHookBeginRetrieve = (Action<GoldMiner, Hook>)Delegate.Remove(goldMiner2.onHookBeginRetrieve, new Action<GoldMiner, Hook>(OnBeginRetrieve));
				GoldMiner goldMiner3 = base.GoldMiner;
				goldMiner3.onHookEndRetrieve = (Action<GoldMiner, Hook>)Delegate.Remove(goldMiner3.onHookEndRetrieve, new Action<GoldMiner, Hook>(OnEndRetrieve));
				if (base.Run != null)
				{
					base.Run.staminaDrain.RemoveModifier(modifer);
				}
			}
		}

		private void OnBeginRetrieve(GoldMiner miner, Hook hook)
		{
			if (effectActive)
			{
				base.Run.staminaDrain.AddModifier(modifer);
			}
		}

		private void OnEndRetrieve(GoldMiner miner, Hook hook)
		{
			base.Run.staminaDrain.RemoveModifier(modifer);
			effectActive = false;
		}

		private void OnResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			effectActive = true;
		}
	}
	public class GMA_003 : GoldMinerArtifactBehaviour
	{
		private int streak;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		private void OnResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			if (!(entity == null))
			{
				if (base.Run.IsRock(entity))
				{
					UnityEngine.Debug.Log("Enity is Rock ", entity);
					streak++;
				}
				else
				{
					streak = 0;
				}
				if (streak > 1)
				{
					base.Run.levelScoreFactor += 0.1f;
				}
			}
		}
	}
	public class GMA_004 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		private void OnResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			if (!(entity == null) && base.Run.IsRock(entity) && entity.size > GoldMinerEntity.Size.M)
			{
				base.Run.levelScoreFactor += 0.3f;
			}
		}
	}
	public class GMA_005 : GoldMinerArtifactBehaviour
	{
		private int remaining = 3;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		private void OnResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			if (remaining >= 1 && !(entity == null) && base.Run.IsRock(entity) && entity.size < GoldMinerEntity.Size.M)
			{
				entity.Value += 500;
				remaining--;
			}
		}
	}
	public class GMA_006 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.isGoldPredicators.Add(SmallRockIsGold);
			}
		}

		private bool SmallRockIsGold(GoldMinerEntity entity)
		{
			if (entity.tags.Contains(GoldMinerEntity.Tag.Rock) && entity.size < GoldMinerEntity.Size.M)
			{
				return true;
			}
			return false;
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.isGoldPredicators.Remove(SmallRockIsGold);
			}
		}
	}
	public class GMA_007 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.additionalFactorFuncs.Add(AddFactorIfResolved3DifferentKindsOfGold);
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.additionalFactorFuncs.Remove(AddFactorIfResolved3DifferentKindsOfGold);
			}
		}

		private float AddFactorIfResolved3DifferentKindsOfGold()
		{
			if ((from e in base.GoldMiner.resolvedEntities
				where e != null && e.tags.Contains(GoldMinerEntity.Tag.Gold)
				group e by e.size).Count() >= 3)
			{
				return 0.5f;
			}
			return 0f;
		}
	}
	public class GMA_008 : GoldMinerArtifactBehaviour
	{
		private bool triggered;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onLevelBegin = (Action<GoldMiner>)Delegate.Combine(goldMiner.onLevelBegin, new Action<GoldMiner>(OnLevelBegin));
				GoldMiner goldMiner2 = base.GoldMiner;
				goldMiner2.onAfterResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner2.onAfterResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnAfterResolveEntity));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onLevelBegin = (Action<GoldMiner>)Delegate.Remove(goldMiner.onLevelBegin, new Action<GoldMiner>(OnLevelBegin));
				GoldMiner goldMiner2 = base.GoldMiner;
				goldMiner2.onAfterResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner2.onAfterResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnAfterResolveEntity));
			}
		}

		private void OnLevelBegin(GoldMiner miner)
		{
			triggered = false;
		}

		private void OnAfterResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			if (!triggered && base.GoldMiner.activeEntities.Count <= 0)
			{
				triggered = true;
				base.Run.charm.BaseValue += 0.5f;
			}
		}
	}
	public class GMA_009 : GoldMinerArtifactBehaviour
	{
		private bool effectActive;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		private void OnResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			if (!(entity == null))
			{
				if (base.Run.IsRock(entity))
				{
					effectActive = true;
				}
				if (effectActive && base.Run.IsGold(entity))
				{
					effectActive = false;
					entity.Value *= 2;
				}
			}
		}
	}
	public class GMA_010 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.minMoneySum = 1000;
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.minMoneySum = 0;
			}
		}
	}
	public class GMA_011 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.forceLevelSuccessFuncs.Add(ForceAndDetach);
			}
		}

		private bool ForceAndDetach()
		{
			base.Run.DetachArtifact(master);
			return true;
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.forceLevelSuccessFuncs.Remove(ForceAndDetach);
			}
		}
	}
	public class GMA_012 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.defuse.AddModifier(new Modifier(ModifierType.Add, 1f, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.defuse.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_013 : GoldMinerArtifactBehaviour
	{
	}
	public class GMA_014 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onAfterResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner.onAfterResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnAfterResolveEntity));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onAfterResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner.onAfterResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnAfterResolveEntity));
			}
		}

		private void OnAfterResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			if (!(entity == null) && base.Run != null && base.Run.IsPig(entity))
			{
				base.Run.stamina += 2f;
			}
		}
	}
	public class GMA_015 : GoldMinerArtifactBehaviour
	{
		[SerializeField]
		private int amount = 20;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		private void OnResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			if (base.Run != null && base.Run.IsPig(entity))
			{
				entity.Value += amount;
			}
		}
	}
	public class GMA_016 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.rockValueFactor.AddModifier(new Modifier(ModifierType.Add, 1f, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.rockValueFactor.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_017 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.goldValueFactor.AddModifier(new Modifier(ModifierType.Add, 0.2f, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.goldValueFactor.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_018 : GoldMinerArtifactBehaviour
	{
		private int remaining;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onLevelBegin = (Action<GoldMiner>)Delegate.Combine(goldMiner.onLevelBegin, new Action<GoldMiner>(OnLevelBegin));
				GoldMiner goldMiner2 = base.GoldMiner;
				goldMiner2.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Combine(goldMiner2.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (!(base.GoldMiner == null))
			{
				GoldMiner goldMiner = base.GoldMiner;
				goldMiner.onLevelBegin = (Action<GoldMiner>)Delegate.Remove(goldMiner.onLevelBegin, new Action<GoldMiner>(OnLevelBegin));
				GoldMiner goldMiner2 = base.GoldMiner;
				goldMiner2.onResolveEntity = (Action<GoldMiner, GoldMinerEntity>)Delegate.Remove(goldMiner2.onResolveEntity, new Action<GoldMiner, GoldMinerEntity>(OnResolveEntity));
			}
		}

		private void OnLevelBegin(GoldMiner miner)
		{
			remaining = 5;
		}

		private void OnResolveEntity(GoldMiner miner, GoldMinerEntity entity)
		{
			if ((bool)entity && remaining >= 1)
			{
				remaining--;
				entity.Value = 200;
			}
		}
	}
	public class GMA_019 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.bomb += 3;
			}
		}
	}
	public class GMA_020 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.strengthPotion += 3;
			}
		}
	}
	public class GMA_021 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.eagleEyePotion += 3;
			}
		}
	}
	public class GMA_022 : GoldMinerArtifactBehaviour
	{
		[SerializeField]
		private float amount = 0.1f;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.charm.AddModifier(new Modifier(ModifierType.Add, amount, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.charm.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_023 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.strength.AddModifier(new Modifier(ModifierType.Add, 10f, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.strength.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_024 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.maxStamina.AddModifier(new Modifier(ModifierType.Add, 1.5f, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.maxStamina.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_025 : GoldMinerArtifactBehaviour
	{
		[SerializeField]
		private float addAmount = 1f;

		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.emptySpeed.AddModifier(new Modifier(ModifierType.PercentageAdd, addAmount, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.emptySpeed.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_026 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.shopRefreshPrice.AddModifier(new Modifier(ModifierType.PercentageMultiply, -1f, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.shopRefreshPrice.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_027 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.shopRefreshChances.AddModifier(new Modifier(ModifierType.Add, 1f, this));
			}
		}

		protected override void OnDetached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.shopRefreshChances.RemoveAllModifiersFromSource(this);
			}
		}
	}
	public class GMA_028 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.shopTicket++;
			}
		}
	}
	public class GMA_029 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null && base.Run.shopCapacity < 6)
			{
				base.Run.shopCapacity++;
			}
		}
	}
	public class GMA_030 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.extraRocks = Mathf.MoveTowards(base.Run.extraRocks, 5f, 1f);
			}
		}
	}
	public class GMA_031 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.extraGold = Mathf.MoveTowards(base.Run.extraGold, 5f, 1f);
			}
		}
	}
	public class GMA_032 : GoldMinerArtifactBehaviour
	{
		protected override void OnAttached(GoldMinerArtifact artifact)
		{
			if (base.Run != null)
			{
				base.Run.extraDiamond = Mathf.MoveTowards(base.Run.extraDiamond, 5f, 0.5f);
			}
		}
	}
}
namespace Duckov.MiniGames.Debugging
{
	public class HideAndLockCursor : MonoBehaviour
	{
		private void OnEnable()
		{
			UnityEngine.Cursor.visible = false;
			UnityEngine.Cursor.lockState = CursorLockMode.Locked;
		}

		private void OnDisable()
		{
			UnityEngine.Cursor.visible = true;
			UnityEngine.Cursor.lockState = CursorLockMode.None;
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				base.enabled = false;
			}
		}
	}
}
namespace Duckov.MiniGames.Examples.HelloWorld
{
	public class FakeMouse : MiniGameBehaviour
	{
		[SerializeField]
		private float sensitivity = 1f;

		private RectTransform rectTransform;

		private RectTransform parentRectTransform;

		private void Awake()
		{
			rectTransform = base.transform as RectTransform;
			parentRectTransform = base.transform.parent as RectTransform;
		}

		protected override void OnUpdate(float deltaTime)
		{
			Vector3 localPosition = rectTransform.localPosition;
			localPosition += (Vector3)base.Game.GetAxis(1) * sensitivity;
			Rect rect = parentRectTransform.rect;
			localPosition.x = Mathf.Clamp(localPosition.x, rect.xMin, rect.xMax);
			localPosition.y = Mathf.Clamp(localPosition.y, rect.yMin, rect.yMax);
			rectTransform.localPosition = localPosition;
		}
	}
	public class Move : MiniGameBehaviour
	{
		[SerializeField]
		private Rigidbody rigidbody;

		[SerializeField]
		private float speed = 10f;

		[SerializeField]
		private float jumpSpeed = 5f;

		private List<Collider> touchingColliders = new List<Collider>();

		private void Awake()
		{
			if (rigidbody == null)
			{
				rigidbody = GetComponent<Rigidbody>();
			}
		}

		protected override void OnUpdate(float deltaTime)
		{
			bool flag = CanJump();
			Vector2 vector = base.Game.GetAxis() * speed;
			float y = rigidbody.velocity.y;
			if (base.Game.GetButtonDown(MiniGame.Button.A) && flag)
			{
				y = jumpSpeed;
			}
			rigidbody.velocity = new Vector3(vector.x, y, vector.y);
		}

		private bool CanJump()
		{
			if (touchingColliders.Count > 0)
			{
				return true;
			}
			return false;
		}

		private void OnCollisionEnter(Collision collision)
		{
			touchingColliders.Add(collision.collider);
		}

		private void OnCollisionExit(Collision collision)
		{
			touchingColliders.Remove(collision.collider);
		}
	}
}
namespace Duckov.MiniGames.Examples.FPS
{
	public class UICrossHair : MiniGameBehaviour
	{
		[SerializeField]
		private RectTransform rectTransform;

		[SerializeField]
		private RectTransform canvasRectTransform;

		[SerializeField]
		private FPSGunControl gunControl;

		private float ScatterAngle
		{
			get
			{
				if ((bool)gunControl)
				{
					return gunControl.ScatterAngle;
				}
				return 0f;
			}
		}

		private void Awake()
		{
			if (rectTransform == null)
			{
				rectTransform = GetComponent<RectTransform>();
			}
		}

		protected override void OnUpdate(float deltaTime)
		{
			float scatterAngle = ScatterAngle;
			float fieldOfView = base.Game.Camera.fieldOfView;
			float y = canvasRectTransform.sizeDelta.y;
			float num = scatterAngle / fieldOfView;
			float num2 = Mathf.FloorToInt(y * num / 2f) * 2 + 1;
			rectTransform.sizeDelta = num2 * Vector2.one;
		}
	}
	public class FPS_Enemy_HomingFly : MiniGameBehaviour
	{
		[SerializeField]
		private Rigidbody rigidbody;

		[SerializeField]
		private FPSHealth health;

		private bool CanSeeTarget => false;

		private bool Dead => health.Dead;

		private void Awake()
		{
			if (rigidbody == null)
			{
				rigidbody = GetComponent<Rigidbody>();
			}
			health.onDead += OnDead;
		}

		private void OnDead(FPSHealth health)
		{
			rigidbody.useGravity = true;
		}

		protected override void OnUpdate(float deltaTime)
		{
			if (Dead)
			{
				UpdateDead(deltaTime);
			}
			else if (CanSeeTarget)
			{
				UpdateHoming(deltaTime);
			}
			else
			{
				UpdateIdle(deltaTime);
			}
		}

		private void UpdateIdle(float deltaTime)
		{
		}

		private void UpdateDead(float deltaTime)
		{
		}

		private void UpdateHoming(float deltaTime)
		{
		}
	}
	public class FPSCharacter : MonoBehaviour
	{
		[SerializeField]
		private FPSMovement movement;

		[SerializeField]
		private FPSGunControl gunControl;
	}
	public class FPSDamageReceiver : MonoBehaviour
	{
		[SerializeField]
		private ParticleSystem damageEffectPrefab;

		[SerializeField]
		private ParticleSystem damageEffectPrefab_Censored;

		public ParticleSystem DamageFX
		{
			get
			{
				if (GameManager.BloodFxOn)
				{
					return damageEffectPrefab;
				}
				return damageEffectPrefab_Censored;
			}
		}

		public event Action<FPSDamageReceiver, FPSDamageInfo> onReceiveDamage;

		internal void CastDamage(FPSDamageInfo damage)
		{
			if (!(DamageFX == null))
			{
				FXPool.Play(DamageFX, damage.point, Quaternion.FromToRotation(Vector3.forward, damage.normal));
				this.onReceiveDamage?.Invoke(this, damage);
			}
		}
	}
	public struct FPSDamageInfo
	{
		public object source;

		public float amount;

		public Vector3 point;

		public Vector3 normal;
	}
	public class FPSGun : MiniGameBehaviour
	{
		[Serializable]
		public struct Pose
		{
			[SerializeField]
			private Vector3 localPosition;

			[SerializeField]
			private Quaternion localRotation;

			public static Pose Extraterpolate(Pose poseA, Pose poseB, float t)
			{
				return new Pose
				{
					localPosition = Vector3.LerpUnclamped(poseA.localPosition, poseB.localPosition, t),
					localRotation = Quaternion.LerpUnclamped(poseA.localRotation, poseB.localRotation, t)
				};
			}

			public Pose(Transform fromTransform)
			{
				localPosition = fromTransform.localPosition;
				localRotation = fromTransform.localRotation;
			}
		}

		[SerializeField]
		private float fireRate = 1f;

		[SerializeField]
		private bool auto;

		[SerializeField]
		private Transform muzzle;

		[SerializeField]
		private ParticleSystem muzzleFlash;

		[SerializeField]
		private ParticleSystem bulletTracer;

		[SerializeField]
		private LayerMask castLayers = -1;

		[SerializeField]
		private ParticleSystem normalHitFXPrefab;

		[SerializeField]
		private float minScatterAngle;

		[SerializeField]
		private float maxScatterAngle;

		[SerializeField]
		private float scatterIncrementPerShot;

		[SerializeField]
		private float scatterDecayRate;

		[SerializeField]
		private Transform graphicsTransform;

		[SerializeField]
		private Pose idlePose;

		[SerializeField]
		private Pose recoilPose;

		private float scatterStatus;

		private float coolDown;

		private Camera mainCamera;

		private bool trigger;

		private bool justPressedTrigger;

		public float ScatterAngle => Mathf.Lerp(minScatterAngle, maxScatterAngle, scatterStatus);

		private void Fire()
		{
			coolDown = 1f / fireRate;
			DoCast();
			muzzleFlash.Play();
			DoFireAnimation();
			scatterStatus = Mathf.MoveTowards(scatterStatus, 1f, scatterIncrementPerShot);
		}

		private void DoFireAnimation()
		{
			graphicsTransform.DOKill(complete: true);
			graphicsTransform.localPosition = Vector3.zero;
			graphicsTransform.localRotation = Quaternion.identity;
			graphicsTransform.DOPunchPosition(Vector3.back * 0.2f, 0.2f);
			graphicsTransform.DOShakeRotation(0.5f, -Vector3.right * 10f);
		}

		private void DoCast()
		{
			Ray ray = mainCamera.ViewportPointToRay(Vector3.one * 0.5f);
			Vector2 vector = UnityEngine.Random.insideUnitCircle * ScatterAngle / 2f;
			Vector3 vector2 = Quaternion.Euler(vector.y, vector.x, 0f) * Vector3.forward;
			Vector3 direction = mainCamera.transform.localToWorldMatrix.MultiplyVector(vector2);
			ray.direction = direction;
			Physics.Raycast(ray, out var hitInfo, 100f, castLayers);
			HandleBulletTracer(hitInfo);
			if (!(hitInfo.collider == null))
			{
				FPSDamageInfo fPSDamageInfo = new FPSDamageInfo
				{
					source = this,
					amount = 1f,
					point = hitInfo.point,
					normal = hitInfo.normal
				};
				FPSDamageReceiver component = hitInfo.collider.GetComponent<FPSDamageReceiver>();
				if ((bool)component)
				{
					component.CastDamage(fPSDamageInfo);
				}
				else
				{
					HandleNormalHit(fPSDamageInfo);
				}
			}
		}

		private void HandleBulletTracer(RaycastHit castInfo)
		{
			if (bulletTracer == null)
			{
				return;
			}
			Vector3 position = muzzle.transform.position;
			Vector3 forward = muzzle.transform.forward;
			if (castInfo.collider != null)
			{
				forward = castInfo.point - position;
				if ((castInfo.point - position).magnitude < 5f)
				{
					bulletTracer.transform.rotation = Quaternion.FromToRotation(Vector3.forward, -forward);
					bulletTracer.transform.position = castInfo.point;
				}
				else
				{
					bulletTracer.transform.rotation = Quaternion.FromToRotation(Vector3.forward, forward);
					bulletTracer.transform.position = muzzle.position;
				}
			}
			else
			{
				bulletTracer.transform.rotation = Quaternion.FromToRotation(Vector3.forward, forward);
				bulletTracer.transform.position = muzzle.position;
			}
			bulletTracer.Emit(1);
		}

		private void HandleNormalHit(FPSDamageInfo info)
		{
			FXPool.Play(normalHitFXPrefab, info.point, Quaternion.FromToRotation(Vector3.forward, info.normal));
		}

		internal void SetTrigger(bool value)
		{
			trigger = value;
			if (value)
			{
				justPressedTrigger = true;
			}
		}

		internal void Setup(Camera mainCamera, Transform gunParent)
		{
			base.transform.SetParent(gunParent, worldPositionStays: false);
			base.transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
			this.mainCamera = mainCamera;
		}

		protected override void OnUpdate(float deltaTime)
		{
			if (coolDown > 0f)
			{
				coolDown -= deltaTime;
				coolDown = Mathf.Max(0f, coolDown);
			}
			if (coolDown <= 0f && trigger && (auto || justPressedTrigger))
			{
				Fire();
			}
			justPressedTrigger = false;
			scatterStatus = Mathf.MoveTowards(scatterStatus, 0f, scatterDecayRate * deltaTime);
			UpdateGunPhysicsStatus(deltaTime);
		}

		private void UpdateGunPhysicsStatus(float deltaTime)
		{
		}
	}
	public class FPSGunControl : MiniGameBehaviour
	{
		[SerializeField]
		private Camera mainCamera;

		[SerializeField]
		private Transform gunParent;

		[SerializeField]
		private FPSGun gun;

		public FPSGun Gun => gun;

		public float ScatterAngle
		{
			get
			{
				if ((bool)Gun)
				{
					return Gun.ScatterAngle;
				}
				return 0f;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (gun != null)
			{
				SetGun(gun);
			}
		}

		protected override void OnUpdate(float deltaTime)
		{
			bool buttonDown = base.Game.GetButtonDown(MiniGame.Button.A);
			bool buttonUp = base.Game.GetButtonUp(MiniGame.Button.A);
			if (buttonDown)
			{
				gun.SetTrigger(value: true);
			}
			if (buttonUp)
			{
				gun.SetTrigger(value: false);
			}
			UpdateGunPhysicsStatus(deltaTime);
		}

		private void UpdateGunPhysicsStatus(float deltaTime)
		{
		}

		private void SetGun(FPSGun gunInstance)
		{
			if (gunInstance != gun)
			{
				UnityEngine.Object.Destroy(gun);
			}
			gun = gunInstance;
			SetupGunData();
		}

		private void SetupGunData()
		{
			gun.Setup(mainCamera, gunParent);
		}
	}
	public class FPSHealth : MiniGameBehaviour
	{
		[SerializeField]
		private int maxHp;

		[SerializeField]
		private List<FPSDamageReceiver> damageReceivers;

		[SerializeField]
		private MeshRenderer meshRenderer;

		[SerializeField]
		private float hurtValueDropRate = 1f;

		private int hp;

		private bool dead;

		private float hurtValue;

		private MaterialPropertyBlock materialPropertyBlock;

		public int HP => hp;

		public bool Dead => dead;

		public event Action<FPSHealth> onDead;

		protected override void Start()
		{
			base.Start();
			hp = maxHp;
			materialPropertyBlock = new MaterialPropertyBlock();
			foreach (FPSDamageReceiver damageReceiver in damageReceivers)
			{
				damageReceiver.onReceiveDamage += OnReceiverReceiveDamage;
			}
		}

		protected override void OnUpdate(float deltaTime)
		{
			if (hurtValue > 0f)
			{
				hurtValue = Mathf.MoveTowards(hurtValue, 0f, deltaTime * hurtValueDropRate);
			}
			materialPropertyBlock.SetFloat("_HurtValue", hurtValue);
			meshRenderer.SetPropertyBlock(materialPropertyBlock, 0);
		}

		private void OnReceiverReceiveDamage(FPSDamageReceiver receiver, FPSDamageInfo info)
		{
			ReceiveDamage(info);
		}

		private void ReceiveDamage(FPSDamageInfo info)
		{
			if (!dead)
			{
				hurtValue = 1f;
				hp -= Mathf.FloorToInt(info.amount);
				if (hp <= 0)
				{
					hp = 0;
					Die();
				}
			}
		}

		private void Die()
		{
			dead = true;
			this.onDead?.Invoke(this);
		}
	}
	public class FPSMovement : Character
	{
		[SerializeField]
		private MiniGame game;

		[SerializeField]
		private Vector2 lookSensitivity;

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void Start()
		{
			base.Start();
			if (game == null)
			{
				game.GetComponentInParent<MiniGame>();
			}
		}

		public void SetGame(MiniGame game)
		{
			this.game = game;
		}

		private void Update()
		{
			UpdateRotation();
			UpdateMovement();
			if (game.GetButtonDown(MiniGame.Button.B))
			{
				Jump();
			}
			else if (game.GetButtonUp(MiniGame.Button.B))
			{
				StopJumping();
			}
		}

		private void UpdateMovement()
		{
			Vector2 axis = game.GetAxis();
			Vector3 vector = Vector3.zero;
			vector += Vector3.right * axis.x;
			vector += Vector3.forward * axis.y;
			if ((bool)base.camera)
			{
				vector = vector.relativeTo(base.cameraTransform);
			}
			SetMovementDirection(vector);
		}

		private void UpdateRotation()
		{
			Vector2 axis = game.GetAxis(1);
			AddYawInput(axis.x * lookSensitivity.x);
			if (axis.y != 0f)
			{
				float num = MathLib.ClampAngle(0f - base.cameraTransform.localRotation.eulerAngles.x + axis.y * lookSensitivity.y, -80f, 80f);
				base.cameraTransform.localRotation = Quaternion.Euler(0f - num, 0f, 0f);
			}
		}

		public void AddControlYawInput(float value)
		{
			AddYawInput(value);
		}
	}
}
namespace Duckov.MiniGames.BubblePoppers
{
	public class Bubble : MiniGameBehaviour
	{
		public enum Status
		{
			Idle,
			Moving,
			Attached,
			Detached,
			Explode
		}

		[SerializeField]
		private float radius;

		[SerializeField]
		private int colorIndex;

		[SerializeField]
		private float gravity;

		[SerializeField]
		private float explodeAfterDetachedFor = 1f;

		[SerializeField]
		private ParticleSystem explodeFXrefab;

		[SerializeField]
		private UnityEngine.UI.Image image;

		[SerializeField]
		private RectTransform graphicsRoot;

		[SerializeField]
		private float gSpring = 1f;

		[SerializeField]
		private float gDamping = 10f;

		[SerializeField]
		private float vibrationFrequency = 10f;

		[SerializeField]
		private float vibrationAmp = 4f;

		private float explodeETA;

		private float explodeCountDown;

		private Vector2 gVelocity;

		public BubblePopper Master { get; private set; }

		public float Radius => radius;

		public int ColorIndex => colorIndex;

		public Color DisplayColor
		{
			get
			{
				if (Master == null)
				{
					return Color.white;
				}
				return Master.GetDisplayColor(ColorIndex);
			}
		}

		public Vector2Int Coord { get; internal set; }

		public Vector2 MoveDirection { get; internal set; }

		public Vector2 Velocity { get; internal set; }

		public Status status { get; private set; }

		private Vector2 gPos
		{
			get
			{
				return graphicsRoot.localPosition;
			}
			set
			{
				graphicsRoot.localPosition = value;
			}
		}

		private Vector2 gForce => (new Vector2(Mathf.PerlinNoise(7.3f, Time.time * vibrationFrequency) * 2f - 1f, Mathf.PerlinNoise(0.3f, Time.time * vibrationFrequency) * 2f - 1f) * vibrationAmp - gPos) * gSpring;

		internal void Setup(BubblePopper master, int colorIndex)
		{
			Master = master;
			this.colorIndex = colorIndex;
			image.color = DisplayColor;
		}

		internal void Launch(Vector2 direction)
		{
			MoveDirection = direction;
			status = Status.Moving;
		}

		internal void NotifyExplode(Vector2Int origin)
		{
			status = Status.Explode;
			Vector2Int vector2Int = Coord - origin;
			float magnitude = vector2Int.magnitude;
			explodeETA = magnitude * 0.025f;
			Impact(((Vector2)vector2Int).normalized * 5f);
		}

		internal void NotifyAttached(Vector2Int coord)
		{
			Vector2 vector = Master.Layout.CoordToLocalPosition(coord);
			base.transform.position = Master.Layout.transform.localToWorldMatrix.MultiplyPoint(vector);
			status = Status.Attached;
			Coord = coord;
		}

		public void NotifyDetached()
		{
			status = Status.Detached;
			Velocity = Vector2.zero;
			explodeCountDown = explodeAfterDetachedFor;
		}

		protected override void OnUpdate(float deltaTime)
		{
			UpdateLogic(deltaTime);
			UpdateGraphics(deltaTime);
		}

		private void UpdateLogic(float deltaTime)
		{
			if (!(Master == null) && !Master.Busy && status == Status.Moving)
			{
				Master.MoveBubble(this, deltaTime);
			}
		}

		private void UpdateGraphics(float deltaTime)
		{
			if (status == Status.Explode)
			{
				explodeETA -= deltaTime;
				if (explodeETA <= 0f)
				{
					FXPool.Play(explodeFXrefab, base.transform.position, base.transform.rotation, DisplayColor);
					Master.Release(this);
				}
			}
			if (status == Status.Detached)
			{
				base.transform.localPosition += (Vector3)Velocity * deltaTime;
				Velocity += -Vector2.up * gravity;
				explodeCountDown -= deltaTime;
				if (explodeCountDown <= 0f)
				{
					NotifyExplode(Coord);
				}
			}
			UpdateElasticMovement(deltaTime);
		}

		private void UpdateElasticMovement(float deltaTime)
		{
			float num = ((Vector2.Dot(gVelocity, gForce.normalized) < 0f) ? gDamping : 1f);
			gVelocity += gForce * deltaTime;
			gVelocity = Vector2.MoveTowards(gVelocity, Vector2.zero, num * gVelocity.magnitude * deltaTime);
			gPos += gVelocity;
		}

		public void Impact(Vector2 velocity)
		{
			gVelocity = velocity;
		}

		internal void Rest()
		{
			gPos = Vector2.zero;
			gVelocity = Vector2.zero;
		}
	}
	public class BubblePopper : MiniGameBehaviour
	{
		public enum Status
		{
			Idle,
			Loaded,
			Launched,
			Settled,
			GameOver
		}

		public struct CastResult
		{
			public Vector2 origin;

			public Vector2 castDirection;

			public float castDistance;

			public bool clipWall;

			public bool touchWall;

			public int touchWallDirection;

			public bool collide;

			public Bubble touchingBubble;

			public Vector2Int touchBubbleCoord;

			public bool touchCeiling;

			public Vector2 endPosition;

			public Vector2Int endCoord;

			public bool Collide
			{
				get
				{
					if (!collide && !clipWall && !touchWall)
					{
						return touchingBubble;
					}
					return true;
				}
			}
		}

		[SerializeField]
		private Bubble bubbleTemplate;

		[SerializeField]
		private BubblePopperLayout layout;

		[SerializeField]
		private UnityEngine.UI.Image waitingColorIndicator;

		[SerializeField]
		private UnityEngine.UI.Image loadedColorIndicator;

		[SerializeField]
		private Transform cannon;

		[SerializeField]
		private LineRenderer aimingLine;

		[SerializeField]
		private Transform cameraParent;

		[SerializeField]
		private Animator duckAnimator;

		[SerializeField]
		private Transform gear;

		[SerializeField]
		private TextMeshProUGUI scoreText;

		[SerializeField]
		private TextMeshProUGUI levelText;

		[SerializeField]
		private TextMeshProUGUI highScoreText;

		[SerializeField]
		private GameObject startScreen;

		[SerializeField]
		private GameObject endScreen;

		[SerializeField]
		private GameObject failIndicator;

		[SerializeField]
		private GameObject clearIndicator;

		[SerializeField]
		private GameObject newRecordIndicator;

		[SerializeField]
		private GameObject allLevelsClearIndicator;

		[SerializeField]
		private TextMeshProUGUI endScreenLevelText;

		[SerializeField]
		private TextMeshProUGUI endScreenScoreText;

		[SerializeField]
		private BubblePopperLevelDataProvider levelDataProvider;

		[SerializeField]
		private Color[] colorPallette;

		[SerializeField]
		private float aimingDistance = 100f;

		[SerializeField]
		private Vector2 cannonAngleRange = new Vector2(-45f, 45f);

		[SerializeField]
		private float cannonRotateSpeed = 20f;

		[SerializeField]
		private int ceilingYCoord;

		[SerializeField]
		private int initialFloorYCoord = -18;

		[SerializeField]
		private int floorStepAfterShots = 4;

		[SerializeField]
		private float bubbleMoveSpeed = 100f;

		private float shockwaveStrength = 2f;

		[SerializeField]
		private float moveCeilingTime = 1f;

		[SerializeField]
		private AnimationCurve moveCeilingCurve;

		private PrefabPool<Bubble> _bubblePool;

		private Dictionary<Vector2Int, Bubble> attachedBubbles = new Dictionary<Vector2Int, Bubble>();

		private float cannonAngle;

		private int waitingColor;

		private int loadedColor;

		private Bubble activeBubble;

		private bool clear;

		private bool fail;

		private bool allLevelsClear;

		private bool playing;

		[SerializeField]
		private int floorYCoord;

		private int levelIndex;

		private int _score;

		private bool isHighScore;

		private const string HighScoreSaveKey = "MiniGame/BubblePopper/HighScore";

		private const string HighLevelSaveKey = "MiniGame/BubblePopper/HighLevel";

		private const int CriticalCount = 3;

		private bool movingCeiling;

		private float moveCeilingT;

		private Vector2 originalCeilingPos;

		private Vector3[] aimlinePoints = new Vector3[3];

		[SerializeField]
		private bool drawGizmos = true;

		[SerializeField]
		private float distance;

		public int AvaliableColorCount => colorPallette.Length;

		public BubblePopperLayout Layout => layout;

		public float BubbleRadius
		{
			get
			{
				if (bubbleTemplate == null)
				{
					return 8f;
				}
				return bubbleTemplate.Radius;
			}
		}

		public Bubble BubbleTemplate => bubbleTemplate;

		private PrefabPool<Bubble> BubblePool
		{
			get
			{
				if (_bubblePool == null)
				{
					_bubblePool = new PrefabPool<Bubble>(bubbleTemplate, null, OnGetBubble);
				}
				return _bubblePool;
			}
		}

		public Status status { get; private set; }

		public int FloorStepETA { get; private set; }

		public int Score
		{
			get
			{
				return _score;
			}
			private set
			{
				_score = value;
				RefreshScoreText();
			}
		}

		public static int HighScore
		{
			get
			{
				return SavesSystem.Load<int>("MiniGame/BubblePopper/HighScore");
			}
			set
			{
				SavesSystem.Save("MiniGame/BubblePopper/HighScore", value);
			}
		}

		public static int HighLevel
		{
			get
			{
				return SavesSystem.Load<int>("MiniGame/BubblePopper/HighLevel");
			}
			set
			{
				SavesSystem.Save("MiniGame/BubblePopper/HighLevel", value);
			}
		}

		public bool Busy { get; private set; }

		public static event Action<int> OnLevelClear;

		private void OnGetBubble(Bubble bubble)
		{
			bubble.Rest();
		}

		protected override void Start()
		{
			base.Start();
			RefreshScoreText();
			RefreshLevelText();
			HideEndScreen();
			ShowStartScreen();
		}

		private void RefreshScoreText()
		{
			scoreText.text = $"{Score}";
			highScoreText.text = $"{HighScore}";
		}

		private void RefreshLevelText()
		{
			levelText.text = $"{levelIndex}";
		}

		protected override void OnUpdate(float deltaTime)
		{
			UpdateStatus(deltaTime);
			HandleInput(deltaTime);
			UpdateAimingLine();
		}

		private void ShowStartScreen()
		{
			startScreen.SetActive(value: true);
		}

		private void HideStartScreen()
		{
			startScreen.SetActive(value: false);
		}

		private void ShowEndScreen()
		{
			endScreen.SetActive(value: true);
			endScreenLevelText.text = $"LEVEL {levelIndex}";
			endScreenScoreText.text = $"{Score}";
			failIndicator.SetActive(fail);
			clearIndicator.SetActive(clear);
			newRecordIndicator.SetActive(isHighScore);
			allLevelsClearIndicator.SetActive(allLevelsClear);
		}

		private void HideEndScreen()
		{
			endScreen.SetActive(value: false);
		}

		private void NewGame()
		{
			playing = true;
			levelIndex = 0;
			Score = 0;
			isHighScore = false;
			HideStartScreen();
			HideEndScreen();
			int[] levelData = LoadLevelData(levelIndex);
			StartNewLevel(levelData);
			RefreshLevelText();
		}

		private void NextLevel()
		{
			levelIndex++;
			HideStartScreen();
			HideEndScreen();
			int[] levelData = LoadLevelData(levelIndex);
			StartNewLevel(levelData);
			RefreshLevelText();
		}

		private int[] LoadLevelData(int levelIndex)
		{
			return levelDataProvider.GetData(levelIndex);
		}

		private Vector2Int LevelDataIndexToCoord(int index)
		{
			int num = layout.XCoordBorder.y - layout.XCoordBorder.x + 1;
			int num2 = index / num;
			return new Vector2Int(index % num, -num2);
		}

		private void StartNewLevel(int[] levelData)
		{
			clear = false;
			fail = false;
			FloorStepETA = floorStepAfterShots;
			BubblePool.ReleaseAll();
			attachedBubbles.Clear();
			ResetFloor();
			for (int i = 0; i < levelData.Length; i++)
			{
				int num = levelData[i];
				if (num >= 0)
				{
					Vector2Int coord = LevelDataIndexToCoord(i);
					Bubble bubble = BubblePool.Get();
					bubble.Setup(this, num);
					Set(bubble, coord);
				}
			}
			PushRandomColor();
			PushRandomColor();
			SetStatus(Status.Loaded);
		}

		private void ResetFloor()
		{
			floorYCoord = initialFloorYCoord;
			RefreshLayoutPosition();
		}

		private void StepFloor()
		{
			floorYCoord++;
			BeginMovingCeiling();
		}

		private void RefreshLayoutPosition()
		{
			Vector3 localPosition = layout.transform.localPosition;
			localPosition.y = (float)(-(floorYCoord - initialFloorYCoord)) * BubbleRadius * BubblePopperLayout.YOffsetFactor;
			layout.transform.localPosition = localPosition;
		}

		private void UpdateStatus(float deltaTime)
		{
			switch (status)
			{
			case Status.Idle:
			case Status.GameOver:
				if (base.Game.GetButtonDown(MiniGame.Button.Start))
				{
					if (!playing || fail || allLevelsClear)
					{
						NewGame();
					}
					else
					{
						NextLevel();
					}
				}
				break;
			case Status.Launched:
				UpdateLaunched(deltaTime);
				break;
			case Status.Settled:
				UpdateSettled(deltaTime);
				break;
			case Status.Loaded:
				break;
			}
		}

		private void BeginMovingCeiling()
		{
			movingCeiling = true;
			moveCeilingT = 0f;
			originalCeilingPos = layout.transform.localPosition;
		}

		private void UpdateMoveCeiling(float deltaTime)
		{
			moveCeilingT += deltaTime;
			if (moveCeilingT >= moveCeilingTime)
			{
				movingCeiling = false;
				RefreshLayoutPosition();
				return;
			}
			Vector2 b = new Vector2(layout.transform.localPosition.x, (float)(-(floorYCoord - initialFloorYCoord)) * BubbleRadius * BubblePopperLayout.YOffsetFactor);
			float t = moveCeilingCurve.Evaluate(moveCeilingT / moveCeilingTime);
			Vector3 localPosition = Vector2.LerpUnclamped(originalCeilingPos, b, t);
			layout.transform.localPosition = localPosition;
		}

		private void UpdateSettled(float deltaTime)
		{
			if (movingCeiling)
			{
				UpdateMoveCeiling(deltaTime);
			}
			else if (CheckGameOver())
			{
				SetStatus(Status.GameOver);
			}
			else
			{
				SetStatus(Status.Loaded);
			}
		}

		private void HandleFloorStep()
		{
			FloorStepETA--;
			if (FloorStepETA <= 0)
			{
				StepFloor();
				FloorStepETA = floorStepAfterShots;
			}
		}

		private bool CheckGameOver()
		{
			if (attachedBubbles.Count == 0)
			{
				clear = true;
				allLevelsClear = levelIndex >= levelDataProvider.TotalLevels;
				if (clear)
				{
					if (levelIndex > HighLevel)
					{
						HighLevel = levelIndex;
					}
					BubblePopper.OnLevelClear?.Invoke(levelIndex);
				}
				return true;
			}
			if (attachedBubbles.Keys.Any((Vector2Int e) => e.y <= floorYCoord))
			{
				fail = true;
				return true;
			}
			return false;
		}

		private void SetStatus(Status newStatus)
		{
			OnExitStatus(status);
			status = newStatus;
			switch (status)
			{
			case Status.Settled:
				PushRandomColor();
				HandleFloorStep();
				break;
			case Status.GameOver:
				if (Score > HighScore)
				{
					HighScore = Score;
					isHighScore = true;
				}
				ShowGameOverScreen();
				break;
			case Status.Idle:
			case Status.Loaded:
			case Status.Launched:
				break;
			}
		}

		private void ShowGameOverScreen()
		{
			ShowEndScreen();
		}

		private void OnExitStatus(Status status)
		{
			switch (status)
			{
			}
		}

		private void Set(Bubble bubble, Vector2Int coord)
		{
			attachedBubbles[coord] = bubble;
			bubble.NotifyAttached(coord);
		}

		private void Attach(Bubble bubble, Vector2Int coord)
		{
			if (attachedBubbles.TryGetValue(coord, out var _))
			{
				UnityEngine.Debug.LogError("Target coord is occupied!");
				return;
			}
			Set(bubble, coord);
			List<Vector2Int> continousCoords = GetContinousCoords(coord);
			if (continousCoords.Count >= 3)
			{
				HashSet<Vector2Int> hashSet = new HashSet<Vector2Int>();
				int num = 0;
				foreach (Vector2Int item in continousCoords)
				{
					hashSet.AddRange(layout.GetAllNeighbourCoords(item, includeCenter: false));
					Explode(item, coord);
					num++;
				}
				PunchCamera();
				HashSet<Vector2Int> looseCoords = GetLooseCoords(hashSet);
				foreach (Vector2Int item2 in looseCoords)
				{
					Detach(item2);
				}
				CalculateAndAddScore(looseCoords, continousCoords);
			}
			Shockwave(coord, shockwaveStrength).Forget();
		}

		private void CalculateAndAddScore(HashSet<Vector2Int> detached, List<Vector2Int> exploded)
		{
			int count = exploded.Count;
			int count2 = detached.Count;
			int num = Mathf.FloorToInt(Mathf.Pow(count, 2f)) * (1 + count2);
			Score += num;
		}

		private void Explode(Vector2Int coord, Vector2Int origin)
		{
			if (attachedBubbles.TryGetValue(coord, out var value))
			{
				attachedBubbles.Remove(coord);
				if (!(value == null))
				{
					value.NotifyExplode(origin);
				}
			}
		}

		private List<Vector2Int> GetContinousCoords(Vector2Int root)
		{
			List<Vector2Int> list = new List<Vector2Int>();
			if (!attachedBubbles.TryGetValue(root, out var value))
			{
				return list;
			}
			if (value == null)
			{
				return list;
			}
			int colorIndex = value.ColorIndex;
			HashSet<Vector2Int> visitedCoords = new HashSet<Vector2Int>();
			Stack<Vector2Int> coords = new Stack<Vector2Int>();
			Push(root);
			while (coords.Count > 0)
			{
				Vector2Int vector2Int = coords.Pop();
				if (!attachedBubbles.TryGetValue(vector2Int, out var value2) || value2 == null || value2.ColorIndex != colorIndex)
				{
					continue;
				}
				list.Add(vector2Int);
				Vector2Int[] allNeighbourCoords = layout.GetAllNeighbourCoords(vector2Int, includeCenter: false);
				foreach (Vector2Int vector2Int2 in allNeighbourCoords)
				{
					if (!visitedCoords.Contains(vector2Int2))
					{
						Push(vector2Int2);
					}
				}
			}
			return list;
			void Push(Vector2Int coord)
			{
				coords.Push(coord);
				visitedCoords.Add(coord);
			}
		}

		private HashSet<Vector2Int> GetLooseCoords(HashSet<Vector2Int> roots)
		{
			List<Vector2Int> pendingRoots = roots.ToList();
			HashSet<Vector2Int> hashSet = new HashSet<Vector2Int>();
			while (pendingRoots.Count > 0)
			{
				Vector2Int root = PopRoot();
				if (CheckConnectedLoose(root, out var connected))
				{
					hashSet.AddRange(connected);
				}
			}
			return hashSet;
			bool CheckConnectedLoose(Vector2Int item, out List<Vector2Int> reference)
			{
				reference = new List<Vector2Int>();
				bool result = true;
				Stack<Vector2Int> stack = new Stack<Vector2Int>();
				HashSet<Vector2Int> hashSet2 = new HashSet<Vector2Int>();
				stack.Push(item);
				hashSet2.Add(item);
				while (stack.Count > 0)
				{
					Vector2Int vector2Int = stack.Pop();
					pendingRoots.Remove(vector2Int);
					if (attachedBubbles.ContainsKey(vector2Int))
					{
						if (vector2Int.y >= ceilingYCoord)
						{
							result = false;
						}
						reference.Add(vector2Int);
						Vector2Int[] allNeighbourCoords = layout.GetAllNeighbourCoords(vector2Int, includeCenter: false);
						foreach (Vector2Int item2 in allNeighbourCoords)
						{
							if (!hashSet2.Contains(item2))
							{
								stack.Push(item2);
								hashSet2.Add(item2);
							}
						}
					}
				}
				return result;
			}
			Vector2Int PopRoot()
			{
				Vector2Int result = pendingRoots[0];
				pendingRoots.RemoveAt(0);
				return result;
			}
		}

		private void Detach(Vector2Int coord)
		{
			if (attachedBubbles.TryGetValue(coord, out var value))
			{
				attachedBubbles.Remove(coord);
				value.NotifyDetached();
			}
		}

		private void UpdateAimingLine()
		{
			aimingLine.gameObject.SetActive(status == Status.Loaded);
			Matrix4x4 worldToLocalMatrix = layout.transform.worldToLocalMatrix;
			Vector3 vector = worldToLocalMatrix.MultiplyPoint(cannon.position);
			Vector3 vector2 = worldToLocalMatrix.MultiplyVector(cannon.up);
			Vector3 vector3 = vector2 * aimingDistance;
			CastResult castResult = SlideCast(vector, vector3);
			vector.z = 0f;
			aimlinePoints[0] = vector;
			aimlinePoints[1] = castResult.endPosition;
			if (castResult.touchWall)
			{
				float num = Mathf.Max(aimingDistance - (castResult.endPosition - (Vector2)vector).magnitude, 0f);
				Vector2 vector4 = vector2;
				vector4.x *= -1f;
				aimlinePoints[2] = castResult.endPosition + vector4 * num;
			}
			else
			{
				aimlinePoints[2] = castResult.endPosition;
			}
			aimingLine.SetPositions(aimlinePoints);
		}

		private void UpdateLaunched(float deltaTime)
		{
			if (activeBubble == null || activeBubble.status != Bubble.Status.Moving)
			{
				activeBubble = null;
				SetStatus(Status.Settled);
			}
		}

		private void HandleInput(float deltaTime)
		{
			float x = base.Game.GetAxis().x;
			cannonAngle = Mathf.Clamp(cannonAngle - x * cannonRotateSpeed * deltaTime, cannonAngleRange.x, cannonAngleRange.y);
			cannon.rotation = Quaternion.Euler(0f, 0f, cannonAngle);
			duckAnimator.SetInteger("MovementDirection", (x > 0.01f) ? 1 : ((x < -0.01f) ? (-1) : 0));
			gear.Rotate(0f, 0f, x * cannonRotateSpeed * deltaTime);
			if (base.Game.GetButtonDown(MiniGame.Button.A))
			{
				LaunchBubble();
			}
		}

		public void MoveBubble(Bubble bubble, float deltaTime)
		{
			if (bubble == null)
			{
				return;
			}
			Vector2 moveDirection = bubble.MoveDirection;
			float num = deltaTime * bubbleMoveSpeed;
			Matrix4x4 worldToLocalMatrix = layout.transform.worldToLocalMatrix;
			Matrix4x4 localToWorldMatrix = layout.transform.localToWorldMatrix;
			Vector2 normalized = moveDirection.normalized;
			Vector2 origin = worldToLocalMatrix.MultiplyPoint(bubble.transform.position);
			Vector2 delta = (Vector2)worldToLocalMatrix.MultiplyVector(moveDirection.normalized) * num;
			CastResult castResult = SlideCast(origin, delta);
			bubble.transform.position = localToWorldMatrix.MultiplyPoint(castResult.endPosition);
			if (castResult.Collide)
			{
				if (castResult.touchWall && (float)castResult.touchWallDirection * normalized.x > 0f)
				{
					moveDirection.x *= -1f;
					bubble.MoveDirection = moveDirection;
				}
				if ((bool)castResult.touchingBubble || castResult.touchCeiling)
				{
					Attach(bubble, castResult.endCoord);
				}
			}
		}

		private Bubble LaunchBubble(Vector2 origin, Vector2 direction, int colorIndex)
		{
			Bubble bubble = BubblePool.Get();
			bubble.transform.position = layout.transform.localToWorldMatrix.MultiplyPoint(origin);
			bubble.MoveDirection = direction;
			bubble.Setup(this, colorIndex);
			bubble.Launch(direction);
			return bubble;
		}

		private void LaunchBubble()
		{
			if (status == Status.Loaded)
			{
				activeBubble = LaunchBubble(layout.transform.worldToLocalMatrix.MultiplyPoint(cannon.transform.position), layout.transform.worldToLocalMatrix.MultiplyVector(cannon.transform.up), loadedColor);
				loadedColor = -1;
				RefreshColorIndicators();
				SetStatus(Status.Launched);
			}
		}

		private void PunchLoadedIndicator()
		{
			loadedColorIndicator.transform.DOKill(complete: true);
			loadedColorIndicator.transform.localPosition = Vector2.left * 15f;
			loadedColorIndicator.transform.DOLocalMove(Vector3.zero, 0.1f, snapping: true);
		}

		private void PunchWaitingIndicator()
		{
			waitingColorIndicator.transform.localPosition = Vector2.zero;
			waitingColorIndicator.transform.DOKill(complete: true);
			waitingColorIndicator.transform.DOPunchPosition(Vector3.down * 5f, 0.5f, 10, 1f, snapping: true);
		}

		private void PushRandomColor()
		{
			loadedColor = waitingColor;
			waitingColor = UnityEngine.Random.Range(0, AvaliableColorCount);
			if (attachedBubbles.Count <= 0)
			{
				waitingColor = UnityEngine.Random.Range(0, AvaliableColorCount);
			}
			List<int> list = (from e in attachedBubbles.Values
				group e by e.ColorIndex into g
				select g.Key).ToList();
			waitingColor = list.GetRandom();
			RefreshColorIndicators();
			PunchLoadedIndicator();
			PunchWaitingIndicator();
		}

		private void RefreshColorIndicators()
		{
			loadedColorIndicator.color = GetDisplayColor(loadedColor);
			waitingColorIndicator.color = GetDisplayColor(waitingColor);
		}

		private bool IsCoordOccupied(Vector2Int coord, out Bubble touchingBubble, out bool ceiling)
		{
			ceiling = false;
			if (attachedBubbles.TryGetValue(coord, out touchingBubble))
			{
				return true;
			}
			if (coord.y > ceilingYCoord)
			{
				ceiling = true;
				return true;
			}
			return false;
		}

		public CastResult SlideCast(Vector2 origin, Vector2 delta)
		{
			float magnitude = delta.magnitude;
			Vector2 normalized = delta.normalized;
			float bubbleRadius = BubbleRadius;
			CastResult result = new CastResult
			{
				origin = origin,
				castDirection = normalized,
				castDistance = magnitude
			};
			Vector2 vector = origin + delta;
			float num = 1f;
			float num2 = layout.XPositionBorder.x + bubbleRadius;
			float num3 = layout.XPositionBorder.y - bubbleRadius;
			if (origin.x < num2 || origin.x > num3)
			{
				Vector2 endPosition = origin;
				endPosition.x = Mathf.Clamp(endPosition.x, num2 + 0.001f, num3 - 0.001f);
				result.endPosition = endPosition;
				result.clipWall = true;
				result.collide = true;
			}
			else
			{
				if (vector.x < num2)
				{
					result.touchWall = true;
					num = Mathf.Abs(origin.x - num2) / Mathf.Abs(delta.x);
					result.touchWallDirection = -1;
				}
				else if (vector.x > num3)
				{
					result.touchWall = true;
					num = Mathf.Abs(num3 - origin.x) / Mathf.Abs(delta.x);
					result.touchWallDirection = 1;
				}
				delta *= num;
				magnitude = delta.magnitude;
				result.endPosition = origin + delta;
				List<Vector2Int> allPassingCoords = layout.GetAllPassingCoords(origin, normalized, delta.magnitude);
				float num4 = magnitude;
				foreach (Vector2Int item in allPassingCoords)
				{
					if (IsCoordOccupied(item, out var touchingBubble, out var ceiling) && BubbleCast(layout.CoordToLocalPosition(item), origin, normalized, magnitude, out var hitCircleCenter))
					{
						float magnitude2 = (hitCircleCenter - origin).magnitude;
						if (magnitude2 < num4)
						{
							result.collide = true;
							result.touchingBubble = touchingBubble;
							result.touchBubbleCoord = item;
							result.endPosition = hitCircleCenter;
							result.touchCeiling = ceiling;
							num4 = magnitude2;
							result.touchWall = false;
						}
					}
				}
			}
			result.endCoord = layout.LocalPositionToCoord(result.endPosition);
			return result;
		}

		private bool BubbleCast(Vector2 pos, Vector2 origin, Vector2 direction, float distance, out Vector2 hitCircleCenter)
		{
			float bubbleRadius = BubbleRadius;
			hitCircleCenter = origin;
			Vector2 vector = pos - origin;
			float sqrMagnitude = vector.sqrMagnitude;
			float magnitude = vector.magnitude;
			if (magnitude > distance + 2f * bubbleRadius)
			{
				return false;
			}
			if (magnitude <= bubbleRadius * 2f)
			{
				hitCircleCenter = pos - 2f * vector.normalized * bubbleRadius;
				return true;
			}
			if (Vector2.Dot(vector, direction) < 0f)
			{
				return false;
			}
			float f = MathF.PI / 180f * Vector2.Angle(vector, direction);
			float num = vector.magnitude * Mathf.Sin(f);
			if (num > 2f * bubbleRadius)
			{
				return false;
			}
			float num2 = num * num;
			float num3 = bubbleRadius * bubbleRadius * 2f * 2f;
			float num4 = Mathf.Sqrt(sqrMagnitude - num2) - Mathf.Sqrt(num3 - num2);
			if (num4 > distance)
			{
				return false;
			}
			hitCircleCenter = origin + direction * num4;
			return true;
		}

		private void OnDrawGizmos()
		{
			if (!drawGizmos)
			{
				return;
			}
			float bubbleRadius = BubbleRadius;
			Matrix4x4 worldToLocalMatrix = layout.transform.worldToLocalMatrix;
			Vector3 vector = worldToLocalMatrix.MultiplyPoint(cannon.position);
			Vector3 vector2 = worldToLocalMatrix.MultiplyVector(cannon.up);
			CastResult castResult = SlideCast(vector, vector2 * distance);
			Gizmos.matrix = layout.transform.localToWorldMatrix;
			Gizmos.color = new Color(1f, 1f, 1f, 0.1f);
			for (int i = layout.XCoordBorder.x; i <= layout.XCoordBorder.y; i++)
			{
				for (int j = floorYCoord; j <= ceilingYCoord; j++)
				{
					new Vector2Int(i, j);
					layout.GizmosDrawCoord(new Vector2Int(i, j), 0.25f);
				}
			}
			Gizmos.color = (castResult.Collide ? Color.red : Color.green);
			Gizmos.DrawWireSphere(vector, bubbleRadius);
			Gizmos.DrawWireSphere(castResult.endPosition, bubbleRadius);
			Gizmos.DrawLine(vector, castResult.endPosition);
			Gizmos.color = Color.cyan;
			Gizmos.DrawWireSphere(layout.CoordToLocalPosition(castResult.endCoord), bubbleRadius * 0.8f);
			if (castResult.collide)
			{
				Gizmos.color = Color.white;
				Gizmos.DrawWireSphere(layout.CoordToLocalPosition(castResult.touchBubbleCoord), bubbleRadius * 0.5f);
			}
		}

		internal void Release(Bubble bubble)
		{
			BubblePool.Release(bubble);
		}

		internal Color GetDisplayColor(int colorIndex)
		{
			if (colorIndex < 0)
			{
				return Color.clear;
			}
			if (colorIndex >= colorPallette.Length)
			{
				return Color.white;
			}
			return colorPallette[colorIndex];
		}

		private async UniTask Shockwave(Vector2Int origin, float amplitude)
		{
			HashSet<Vector2Int> visited = new HashSet<Vector2Int>();
			List<Vector2Int> next = new List<Vector2Int>();
			visited.Add(origin);
			next.Add(origin);
			List<Vector2Int> buffer = new List<Vector2Int>();
			while (next.Count > 0)
			{
				buffer.Clear();
				foreach (Vector2Int item2 in next)
				{
					attachedBubbles.TryGetValue(item2, out var value);
					if (value != null)
					{
						value.Impact(((Vector2)(item2 - origin)).normalized * amplitude);
					}
					Vector2Int[] allNeighbourCoords = layout.GetAllNeighbourCoords(item2, includeCenter: false);
					for (int i = 0; i < allNeighbourCoords.Length; i++)
					{
						Vector2Int item = allNeighbourCoords[i];
						if (!visited.Contains(item) && item.x >= layout.XCoordBorder.x && item.x <= layout.XCoordBorder.y && item.y <= ceilingYCoord && item.y >= floorYCoord)
						{
							buffer.Add(item);
						}
					}
				}
				next.Clear();
				visited.AddRange(buffer);
				next.AddRange(buffer);
				await UniTask.WaitForSeconds(0.025f);
				amplitude *= 0.5f;
				if (base.gameObject == null)
				{
					break;
				}
			}
		}

		private void PunchCamera()
		{
			cameraParent.DOKill(complete: true);
			cameraParent.DOShakePosition(0.4f);
			cameraParent.DOShakeRotation(0.4f, Vector3.forward);
		}
	}
	public class BubblePopperLayout : MiniGameBehaviour
	{
		[SerializeField]
		private Vector2Int xBorder;

		public Vector2Int XCoordBorder;

		public float BubbleRadius = 8f;

		public static readonly float YOffsetFactor = Mathf.Tan(MathF.PI / 3f);

		[SerializeField]
		private Transform tester;

		[SerializeField]
		private float distance = 10f;

		[SerializeField]
		private Vector2Int min;

		[SerializeField]
		private Vector2Int max;

		public Vector2 XPositionBorder => new Vector2((float)xBorder.x * BubbleRadius * 2f - BubbleRadius, (float)xBorder.y * BubbleRadius * 2f);

		public Vector2 CoordToLocalPosition(Vector2Int coord)
		{
			float bubbleRadius = BubbleRadius;
			return new Vector2(((coord.y % 2 != 0) ? bubbleRadius : 0f) + (float)coord.x * bubbleRadius * 2f, (float)coord.y * bubbleRadius * YOffsetFactor);
		}

		public Vector2Int LocalPositionToCoord(Vector2 localPosition)
		{
			float bubbleRadius = BubbleRadius;
			int num = Mathf.RoundToInt(localPosition.y / bubbleRadius / YOffsetFactor);
			float num2 = ((num % 2 != 0) ? bubbleRadius : 0f);
			return new Vector2Int(Mathf.RoundToInt((localPosition.x - num2) / bubbleRadius / 2f), num);
		}

		public Vector2Int WorldPositionToCoord(Vector2 position)
		{
			Vector3 vector = base.transform.worldToLocalMatrix.MultiplyPoint(position);
			return LocalPositionToCoord(vector);
		}

		public Vector2Int[] GetAllNeighbourCoords(Vector2Int center, bool includeCenter)
		{
			int num = ((center.y % 2 == 0) ? (-1) : 0);
			if (includeCenter)
			{
				return new Vector2Int[7]
				{
					new Vector2Int(center.x + num, center.y + 1),
					new Vector2Int(center.x + num + 1, center.y + 1),
					new Vector2Int(center.x - 1, center.y),
					center,
					new Vector2Int(center.x + 1, center.y),
					new Vector2Int(center.x + num, center.y - 1),
					new Vector2Int(center.x + num + 1, center.y - 1)
				};
			}
			return new Vector2Int[6]
			{
				new Vector2Int(center.x + num, center.y + 1),
				new Vector2Int(center.x + num + 1, center.y + 1),
				new Vector2Int(center.x - 1, center.y),
				new Vector2Int(center.x + 1, center.y),
				new Vector2Int(center.x + num, center.y - 1),
				new Vector2Int(center.x + num + 1, center.y - 1)
			};
		}

		public List<Vector2Int> GetAllPassingCoords(Vector2 localOrigin, Vector2 direction, float length)
		{
			float num = BubbleRadius * 2f;
			List<Vector2Int> list = new List<Vector2Int> { LocalPositionToCoord(localOrigin) };
			if (num > 0f)
			{
				float num2 = 0f - num;
				while (num2 < length)
				{
					num2 += num;
					Vector2 localPosition = localOrigin + num2 * direction;
					Vector2Int center = LocalPositionToCoord(localPosition);
					list.AddRange(GetAllNeighbourCoords(center, includeCenter: true));
				}
			}
			return list;
		}

		private void OnDrawGizmos()
		{
			_ = BubbleRadius;
			Gizmos.matrix = base.transform.localToWorldMatrix;
			Gizmos.color = Color.cyan;
			Gizmos.DrawLine(new Vector3(XPositionBorder.x, 0f), new Vector3(XPositionBorder.x, -100f));
			Gizmos.DrawLine(new Vector3(XPositionBorder.y, 0f), new Vector3(XPositionBorder.y, -100f));
		}

		public void GizmosDrawCoord(Vector2Int coord, float ratio)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = base.transform.localToWorldMatrix;
			Gizmos.DrawSphere(CoordToLocalPosition(coord), BubbleRadius * ratio);
			Gizmos.matrix = matrix;
		}
	}
	public class BubblePopperLevelDataProvider : MonoBehaviour
	{
		[SerializeField]
		private BubblePopper master;

		[SerializeField]
		private int totalLevels = 10;

		[SerializeField]
		public int seed;

		public int TotalLevels => totalLevels;

		internal int[] GetData(int levelIndex)
		{
			int num = seed + levelIndex;
			int[] array = new int[60 + 10 * (levelIndex / 2)];
			System.Random random = new System.Random(num);
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = random.Next(0, master.AvaliableColorCount);
			}
			return array;
		}
	}
}
namespace Duckov.MasterKeys
{
	public class MasterKeyRegisterViewInvoker : InteractableBase
	{
		protected override void Awake()
		{
			base.Awake();
			finishWhenTimeOut = true;
		}

		protected override void OnInteractFinished()
		{
			MasterKeysRegisterView.Show();
		}
	}
	public class MasterKeysManager : MonoBehaviour
	{
		[Serializable]
		public class Status
		{
			[ItemTypeID]
			public int id;

			public bool active;
		}

		[SerializeField]
		private List<Status> keysStatus = new List<Status>();

		private static List<int> _cachedKeyItemIds;

		private static string[] excludeTags = new string[1] { "SpecialKey" };

		private const string SaveKey = "MasterKeys";

		public static MasterKeysManager Instance { get; private set; }

		public int Count => keysStatus.Count;

		public static List<int> AllPossibleKeys
		{
			get
			{
				if (_cachedKeyItemIds == null)
				{
					_cachedKeyItemIds = new List<int>();
					foreach (ItemAssetsCollection.Entry entry in ItemAssetsCollection.Instance.entries)
					{
						Tag[] tags = entry.metaData.tags;
						if (tags.Any((Tag e) => Tag.Match(e, "Key")) && (!GameMetaData.Instance.IsDemo || !tags.Any((Tag e) => e.name == GameplayDataSettings.Tags.LockInDemoTag.name)) && !tags.Any((Tag e) => excludeTags.Contains(e.name)))
						{
							_cachedKeyItemIds.Add(entry.typeID);
						}
					}
				}
				return _cachedKeyItemIds;
			}
		}

		public static event Action<int> OnMasterKeyUnlocked;

		public static bool SubmitAndActivate(Item item)
		{
			if (Instance == null)
			{
				return false;
			}
			if (item == null)
			{
				return false;
			}
			int typeID = item.TypeID;
			if (IsActive(typeID))
			{
				return false;
			}
			if (item.StackCount > 1)
			{
				item.StackCount--;
			}
			else
			{
				item.Detach();
				item.DestroyTree();
			}
			Activate(typeID);
			return true;
		}

		public static bool IsActive(int id)
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.IsActive_Local(id);
		}

		internal static void Activate(int id)
		{
			if (!(Instance == null))
			{
				Instance.Activate_Local(id);
			}
		}

		internal static Status GetStatus(int id)
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.GetStatus_Local(id);
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			SavesSystem.OnCollectSaveData += OnCollectSaveData;
			Load();
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= OnCollectSaveData;
		}

		private void OnCollectSaveData()
		{
			Save();
		}

		public bool IsActive_Local(int id)
		{
			return GetStatus(id)?.active ?? false;
		}

		private void Activate_Local(int id)
		{
			if (id >= 0 && AllPossibleKeys.Contains(id))
			{
				GetOrCreateStatus(id).active = true;
				MasterKeysManager.OnMasterKeyUnlocked?.Invoke(id);
			}
		}

		public Status GetStatus_Local(int id)
		{
			return keysStatus.Find((Status e) => e.id == id);
		}

		public Status GetOrCreateStatus(int id)
		{
			Status status_Local = GetStatus_Local(id);
			if (status_Local != null)
			{
				return status_Local;
			}
			Status status = new Status();
			status.id = id;
			keysStatus.Add(status);
			return status;
		}

		private void Save()
		{
			SavesSystem.Save("MasterKeys", keysStatus);
		}

		private void Load()
		{
			if (SavesSystem.KeyExisits("MasterKeys"))
			{
				keysStatus = SavesSystem.Load<List<Status>>("MasterKeys");
			}
			else
			{
				keysStatus = new List<Status>();
			}
		}
	}
}
namespace Duckov.MasterKeys.UI
{
	public class MasterKeysIndexEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[Serializable]
		public struct Look
		{
			public Color color;

			public Material material;

			public void ApplyTo(Graphic graphic)
			{
				graphic.material = material;
				graphic.color = color;
			}
		}

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TextMeshProUGUI nameText;

		[SerializeField]
		private Look notDiscoveredLook;

		[SerializeField]
		private Look activeLook;

		[SerializeField]
		private Sprite undiscoveredIcon;

		[ItemTypeID]
		private int itemID;

		private ItemMetaData metaData;

		private MasterKeysManager.Status status;

		private ISingleSelectionMenu<MasterKeysIndexEntry> menu;

		public int ItemID => itemID;

		public string DisplayName
		{
			get
			{
				if (status == null)
				{
					return "???";
				}
				if (!status.active)
				{
					return "???";
				}
				return metaData.DisplayName;
			}
		}

		public Sprite Icon
		{
			get
			{
				if (status == null)
				{
					return undiscoveredIcon;
				}
				if (!status.active)
				{
					return undiscoveredIcon;
				}
				return metaData.icon;
			}
		}

		public string Description
		{
			get
			{
				if (status == null)
				{
					return "???";
				}
				if (!status.active)
				{
					return "???";
				}
				return metaData.Description;
			}
		}

		public bool Active
		{
			get
			{
				if (status == null)
				{
					return false;
				}
				return status.active;
			}
		}

		internal event Action<MasterKeysIndexEntry> onPointerClicked;

		public void Setup(int itemID, ISingleSelectionMenu<MasterKeysIndexEntry> menu)
		{
			this.itemID = itemID;
			metaData = ItemAssetsCollection.GetMetaData(itemID);
			this.menu = menu;
			Refresh();
		}

		private void SetupNotDiscovered()
		{
			icon.sprite = (undiscoveredIcon ? undiscoveredIcon : metaData.icon);
			notDiscoveredLook.ApplyTo(icon);
			nameText.text = "???";
		}

		private void SetupActive()
		{
			icon.sprite = metaData.icon;
			activeLook.ApplyTo(icon);
			nameText.text = metaData.DisplayName;
		}

		private void Refresh()
		{
			status = MasterKeysManager.GetStatus(itemID);
			if (status != null)
			{
				if (status.active)
				{
					SetupActive();
				}
			}
			else
			{
				SetupNotDiscovered();
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Refresh();
			menu?.SetSelection(this);
			this.onPointerClicked?.Invoke(this);
		}
	}
	public class MasterKeysIndexInspector : MonoBehaviour
	{
		[SerializeField]
		private int targetItemID;

		[SerializeField]
		private TextMeshProUGUI nameText;

		[SerializeField]
		private TextMeshProUGUI descriptionText;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private GameObject content;

		[SerializeField]
		private GameObject placeHolder;

		internal void Setup(MasterKeysIndexEntry target)
		{
			if (target == null)
			{
				SetupEmpty();
			}
			else
			{
				SetupNormal(target);
			}
		}

		private void SetupNormal(MasterKeysIndexEntry target)
		{
			targetItemID = target.ItemID;
			placeHolder.SetActive(value: false);
			content.SetActive(value: true);
			nameText.text = target.DisplayName;
			descriptionText.text = target.Description;
			icon.sprite = target.Icon;
		}

		private void SetupEmpty()
		{
			content.gameObject.SetActive(value: false);
			placeHolder.SetActive(value: true);
		}
	}
	public class MasterKeysIndexList : MonoBehaviour, ISingleSelectionMenu<MasterKeysIndexEntry>
	{
		[SerializeField]
		private MasterKeysIndexEntry entryPrefab;

		[SerializeField]
		private RectTransform entryContainer;

		private PrefabPool<MasterKeysIndexEntry> _pool;

		private MasterKeysIndexEntry selection;

		private PrefabPool<MasterKeysIndexEntry> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<MasterKeysIndexEntry>(entryPrefab, entryContainer, OnGetEntry, OnReleaseEntry);
				}
				return _pool;
			}
		}

		internal event Action<MasterKeysIndexEntry> onEntryPointerClicked;

		private void OnGetEntry(MasterKeysIndexEntry entry)
		{
			entry.onPointerClicked += OnEntryPointerClicked;
		}

		private void OnReleaseEntry(MasterKeysIndexEntry entry)
		{
			entry.onPointerClicked -= OnEntryPointerClicked;
		}

		private void OnEntryPointerClicked(MasterKeysIndexEntry entry)
		{
			this.onEntryPointerClicked?.Invoke(entry);
		}

		private void Awake()
		{
			entryPrefab.gameObject.SetActive(value: false);
		}

		internal void Refresh()
		{
			Pool.ReleaseAll();
			foreach (int allPossibleKey in MasterKeysManager.AllPossibleKeys)
			{
				Populate(allPossibleKey);
			}
		}

		private void Populate(int itemID)
		{
			MasterKeysIndexEntry masterKeysIndexEntry = Pool.Get(entryContainer);
			masterKeysIndexEntry.gameObject.SetActive(value: true);
			masterKeysIndexEntry.Setup(itemID, this);
		}

		public MasterKeysIndexEntry GetSelection()
		{
			return selection;
		}

		public bool SetSelection(MasterKeysIndexEntry selection)
		{
			this.selection = selection;
			return true;
		}
	}
	public class MasterKeysRegisterView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private InventoryDisplay inventoryDisplay;

		[SerializeField]
		private InventoryDisplay playerStorageInventoryDisplay;

		[SerializeField]
		private ItemDetailsDisplay detailsDisplay;

		[SerializeField]
		private FadeGroup detailsFadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button submitButton;

		[SerializeField]
		private Item keySlotItem;

		[SerializeField]
		private string keySlotKey = "Key";

		[SerializeField]
		private SlotDisplay registerSlotDisplay;

		[SerializeField]
		private GameObject recordExistsIndicator;

		[SerializeField]
		private FadeGroup succeedIndicator;

		[SerializeField]
		private float successIndicationTime = 1.5f;

		private string sfx_Register = "UI/register";

		public static MasterKeysRegisterView Instance => View.GetViewInstance<MasterKeysRegisterView>();

		private Item CharacterItem => LevelManager.Instance?.MainCharacter?.CharacterItem;

		private Slot KeySlot
		{
			get
			{
				if (keySlotItem == null)
				{
					return null;
				}
				if (keySlotItem.Slots == null)
				{
					return null;
				}
				return keySlotItem.Slots[keySlotKey];
			}
		}

		protected override void Awake()
		{
			base.Awake();
			submitButton.onClick.AddListener(OnSubmitButtonClicked);
			succeedIndicator.SkipHide();
			detailsFadeGroup.SkipHide();
			registerSlotDisplay.onSlotDisplayDoubleClicked += OnSlotDoubleClicked;
			inventoryDisplay.onDisplayDoubleClicked += OnInventoryItemDoubleClicked;
			playerStorageInventoryDisplay.onDisplayDoubleClicked += OnInventoryItemDoubleClicked;
		}

		private void OnInventoryItemDoubleClicked(InventoryDisplay display, InventoryEntry entry, PointerEventData data)
		{
			if (!entry.Editable)
			{
				return;
			}
			Item item = entry.Item;
			if (!(item == null) && KeySlot.CanPlug(item))
			{
				item.Detach();
				KeySlot.Plug(item, out var unpluggedItem);
				if (unpluggedItem != null)
				{
					ItemUtilities.SendToPlayer(unpluggedItem);
				}
			}
		}

		private void OnSlotDoubleClicked(SlotDisplay display)
		{
			Item item = display.GetItem();
			if (!(item == null))
			{
				item.Detach();
				ItemUtilities.SendToPlayer(item);
			}
		}

		private void OnSubmitButtonClicked()
		{
			if (KeySlot != null && KeySlot.Content != null && MasterKeysManager.SubmitAndActivate(KeySlot.Content))
			{
				IndicateSuccess();
			}
		}

		private void IndicateSuccess()
		{
			SuccessIndicationTask().Forget();
		}

		private async UniTask SuccessIndicationTask()
		{
			succeedIndicator.Show();
			AudioManager.Post(sfx_Register);
			await UniTask.WaitForSeconds(successIndicationTime, ignoreTimeScale: true);
			succeedIndicator.Hide();
		}

		private void HideSuccessIndication()
		{
			succeedIndicator.Hide();
		}

		private bool EntryFunc_ShouldHighligh(Item e)
		{
			if (e == null)
			{
				return false;
			}
			if (!KeySlot.CanPlug(e))
			{
				return false;
			}
			if (MasterKeysManager.IsActive(e.TypeID))
			{
				return false;
			}
			return true;
		}

		private bool EntryFunc_CanOperate(Item e)
		{
			if (e == null)
			{
				return true;
			}
			return KeySlot.CanPlug(e);
		}

		protected override void OnOpen()
		{
			UnregisterEvents();
			base.OnOpen();
			Item characterItem = CharacterItem;
			if (characterItem == null)
			{
				UnityEngine.Debug.LogError("物品栏开启失败，角色物体不存在");
				Close();
				return;
			}
			base.gameObject.SetActive(value: true);
			inventoryDisplay.ShowOperationButtons = false;
			inventoryDisplay.Setup(characterItem.Inventory, EntryFunc_ShouldHighligh, EntryFunc_CanOperate);
			if (PlayerStorage.Inventory != null)
			{
				playerStorageInventoryDisplay.ShowOperationButtons = false;
				playerStorageInventoryDisplay.gameObject.SetActive(value: true);
				playerStorageInventoryDisplay.Setup(PlayerStorage.Inventory, EntryFunc_ShouldHighligh, EntryFunc_CanOperate);
			}
			else
			{
				playerStorageInventoryDisplay.gameObject.SetActive(value: false);
			}
			registerSlotDisplay.Setup(KeySlot);
			RefreshRecordExistsIndicator();
			RegisterEvents();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			UnregisterEvents();
			base.OnClose();
			fadeGroup.Hide();
			detailsFadeGroup.Hide();
			if (KeySlot != null && KeySlot.Content != null)
			{
				Item content = KeySlot.Content;
				content.Detach();
				ItemUtilities.SendToPlayerCharacterInventory(content);
			}
		}

		private void RegisterEvents()
		{
			KeySlot.onSlotContentChanged += OnSlotContentChanged;
			ItemUIUtilities.OnSelectionChanged += OnItemSelectionChanged;
		}

		private void UnregisterEvents()
		{
			KeySlot.onSlotContentChanged -= OnSlotContentChanged;
			ItemUIUtilities.OnSelectionChanged -= OnItemSelectionChanged;
		}

		private void OnSlotContentChanged(Slot slot)
		{
			RefreshRecordExistsIndicator();
			HideSuccessIndication();
			if (slot?.Content != null)
			{
				AudioManager.PlayPutItemSFX(slot.Content);
			}
		}

		private void RefreshRecordExistsIndicator()
		{
			Item content = KeySlot.Content;
			if (content == null)
			{
				recordExistsIndicator.SetActive(value: false);
				return;
			}
			bool active = MasterKeysManager.IsActive(content.TypeID);
			recordExistsIndicator.SetActive(active);
		}

		private void OnItemSelectionChanged()
		{
			if (ItemUIUtilities.SelectedItem != null)
			{
				detailsDisplay.Setup(ItemUIUtilities.SelectedItem);
				detailsFadeGroup.Show();
			}
			else
			{
				detailsFadeGroup.Hide();
			}
		}

		public static void Show()
		{
			if (!(Instance == null))
			{
				Instance.Open();
			}
		}
	}
	public class MasterKeysView : View, ISingleSelectionMenu<MasterKeysIndexEntry>
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private MasterKeysIndexList listDisplay;

		[SerializeField]
		private MasterKeysIndexInspector inspector;

		public static MasterKeysView Instance => View.GetViewInstance<MasterKeysView>();

		protected override void Awake()
		{
			base.Awake();
			listDisplay.onEntryPointerClicked += OnEntryClicked;
		}

		private void OnEntryClicked(MasterKeysIndexEntry entry)
		{
			RefreshInspectorDisplay();
		}

		public MasterKeysIndexEntry GetSelection()
		{
			return listDisplay.GetSelection();
		}

		public bool SetSelection(MasterKeysIndexEntry selection)
		{
			listDisplay.GetSelection();
			return true;
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
			SetSelection(null);
			RefreshListDisplay();
			RefreshInspectorDisplay();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		private void RefreshListDisplay()
		{
			listDisplay.Refresh();
		}

		private void RefreshInspectorDisplay()
		{
			MasterKeysIndexEntry selection = GetSelection();
			inspector.Setup(selection);
		}

		internal static void Show()
		{
			if (Instance == null)
			{
				UnityEngine.Debug.Log(" Master keys view Instance is null");
			}
			else
			{
				Instance.Open();
			}
		}
	}
}
namespace Duckov.Crops
{
	public class CellDisplay : MonoBehaviour
	{
		[Serializable]
		private struct GraphicsStyle
		{
			public Color color;

			public float smoothness;
		}

		[SerializeField]
		private Renderer renderer;

		[SerializeField]
		private GraphicsStyle styleDry;

		[SerializeField]
		private GraphicsStyle styleWatered;

		private Garden garden;

		private Vector2Int coord;

		private MaterialPropertyBlock propertyBlock;

		internal void Setup(Garden garden, int coordx, int coordy)
		{
			this.garden = garden;
			coord = new Vector2Int(coordx, coordy);
			bool watered = false;
			Crop crop = garden[coord];
			if (crop != null)
			{
				watered = crop.Watered;
			}
			RefreshGraphics(watered);
		}

		private void OnEnable()
		{
			Crop.onCropStatusChange += HandleCropEvent;
		}

		private void OnDisable()
		{
			Crop.onCropStatusChange -= HandleCropEvent;
		}

		private void HandleCropEvent(Crop crop, Crop.CropEvent e)
		{
			if (!(crop == null) && !(garden == null))
			{
				CropData data = crop.Data;
				if (!(data.gardenID != garden.GardenID) && !(data.coord != coord))
				{
					RefreshGraphics(crop.Watered && e != Crop.CropEvent.BeforeDestroy && e != Crop.CropEvent.Harvest);
				}
			}
		}

		private void RefreshGraphics(bool watered)
		{
			if (watered)
			{
				ApplyGraphicsStype(styleWatered);
			}
			else
			{
				ApplyGraphicsStype(styleDry);
			}
		}

		private void ApplyGraphicsStype(GraphicsStyle style)
		{
			if (propertyBlock == null)
			{
				propertyBlock = new MaterialPropertyBlock();
			}
			propertyBlock.Clear();
			string text = "_TintColor";
			string text2 = "_Smoothness";
			propertyBlock.SetColor(text, style.color);
			propertyBlock.SetFloat(text2, style.smoothness);
			renderer.SetPropertyBlock(propertyBlock);
		}
	}
	public class Crop : MonoBehaviour
	{
		public enum CropEvent
		{
			Plant,
			Water,
			Ripen,
			Harvest,
			BeforeDestroy
		}

		[SerializeField]
		private Transform displayParent;

		private Garden garden;

		private bool initialized;

		private CropData data;

		private CropInfo info;

		private GameObject displayInstance;

		public Action<Crop> onPlant;

		public Action<Crop> onWater;

		public Action<Crop> onRipen;

		public Action<Crop> onHarvest;

		public Action<Crop> onBeforeDestroy;

		public CropData Data => data;

		public CropInfo Info => info;

		public float Progress => (float)data.growTicks / (float)info.totalGrowTicks;

		public bool Ripen
		{
			get
			{
				if (!initialized)
				{
					return false;
				}
				return data.growTicks >= info.totalGrowTicks;
			}
		}

		public bool Watered => data.watered;

		public string DisplayName => Info.DisplayName;

		public TimeSpan RemainingTime
		{
			get
			{
				if (!initialized)
				{
					return TimeSpan.Zero;
				}
				long num = info.totalGrowTicks - data.growTicks;
				if (num < 0)
				{
					return TimeSpan.Zero;
				}
				return TimeSpan.FromTicks(num);
			}
		}

		public static event Action<Crop, CropEvent> onCropStatusChange;

		public bool Harvest()
		{
			if (!Ripen)
			{
				return false;
			}
			if (Watered)
			{
				data.score += 50;
			}
			int product = info.GetProduct(data.Ranking);
			if (product <= 0)
			{
				UnityEngine.Debug.LogError("Crop product is invalid:\ncrop:" + info.id);
				return false;
			}
			Cost cost = new Cost((product, info.resultAmount));
			cost.Return().Forget();
			DestroyCrop();
			onHarvest?.Invoke(this);
			Crop.onCropStatusChange?.Invoke(this, CropEvent.Harvest);
			return true;
		}

		public void DestroyCrop()
		{
			onBeforeDestroy?.Invoke(this);
			Crop.onCropStatusChange?.Invoke(this, CropEvent.BeforeDestroy);
			garden.Release(this);
		}

		public void InitializeNew(Garden garden, string id, Vector2Int coord)
		{
			CropData cropData = new CropData
			{
				gardenID = garden.GardenID,
				cropID = id,
				coord = coord,
				LastUpdateDateTime = DateTime.Now
			};
			Initialize(garden, cropData);
			onPlant?.Invoke(this);
			Crop.onCropStatusChange?.Invoke(this, CropEvent.Plant);
		}

		public void Initialize(Garden garden, CropData data)
		{
			this.garden = garden;
			string cropID = data.cropID;
			CropInfo? cropInfo = CropDatabase.GetCropInfo(cropID);
			if (!cropInfo.HasValue)
			{
				UnityEngine.Debug.LogError("找不到 corpInfo id: " + cropID);
				return;
			}
			info = cropInfo.Value;
			this.data = data;
			RefreshDisplayInstance();
			initialized = true;
			Vector3 localPosition = garden.CoordToLocalPosition(data.coord);
			base.transform.localPosition = localPosition;
		}

		private void RefreshDisplayInstance()
		{
			if (displayInstance != null)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(displayInstance.gameObject);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(displayInstance.gameObject);
				}
			}
			if (info.displayPrefab == null)
			{
				UnityEngine.Debug.LogError("找不到Display Prefab: " + info.DisplayName);
				return;
			}
			displayInstance = UnityEngine.Object.Instantiate(info.displayPrefab, displayParent);
			displayInstance.transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
		}

		public void Water()
		{
			if (!data.watered)
			{
				data.watered = true;
				onWater?.Invoke(this);
				Crop.onCropStatusChange?.Invoke(this, CropEvent.Water);
			}
		}

		private void FixedUpdate()
		{
			Tick();
		}

		private void Tick()
		{
			if (!initialized)
			{
				return;
			}
			TimeSpan timeSpan = DateTime.Now - data.LastUpdateDateTime;
			data.LastUpdateDateTime = DateTime.Now;
			if (data.watered && !Ripen)
			{
				long ticks = timeSpan.Ticks;
				data.growTicks += ticks;
				if (Ripen)
				{
					OnRipen();
				}
			}
		}

		private void OnRipen()
		{
			onRipen?.Invoke(this);
			Crop.onCropStatusChange?.Invoke(this, CropEvent.Ripen);
		}
	}
	public class CropAnimator : MonoBehaviour
	{
		[Serializable]
		private struct Stage
		{
			public float progress;

			public float position;

			public Stage(float progress, float position)
			{
				this.progress = progress;
				this.position = position;
			}
		}

		[SerializeField]
		private Crop crop;

		[SerializeField]
		private Transform displayParent;

		[SerializeField]
		private ParticleSystem plantFX;

		[SerializeField]
		private ParticleSystem stageChangeFX;

		[SerializeField]
		private ParticleSystem ripenFX;

		[SerializeField]
		private ParticleSystem waterFX;

		[SerializeField]
		private ParticleSystem harvestFX;

		[SerializeField]
		private ParticleSystem destroyFX;

		[SerializeField]
		private Stage[] stages = new Stage[3]
		{
			new Stage(0.333f, -0.4f),
			new Stage(0.666f, -0.2f),
			new Stage(0.999f, -0.1f)
		};

		private int? cachedStage;

		private ParticleSystem PlantFX => plantFX;

		private ParticleSystem StageChangeFX => stageChangeFX;

		private ParticleSystem RipenFX => ripenFX;

		private ParticleSystem WaterFX => waterFX;

		private ParticleSystem HarvestFX => harvestFX;

		private ParticleSystem DestroyFX => destroyFX;

		private void Awake()
		{
			if (crop == null)
			{
				crop = GetComponent<Crop>();
			}
			Crop obj = crop;
			obj.onPlant = (Action<Crop>)Delegate.Combine(obj.onPlant, new Action<Crop>(OnPlant));
			Crop obj2 = crop;
			obj2.onRipen = (Action<Crop>)Delegate.Combine(obj2.onRipen, new Action<Crop>(OnRipen));
			Crop obj3 = crop;
			obj3.onWater = (Action<Crop>)Delegate.Combine(obj3.onWater, new Action<Crop>(OnWater));
			Crop obj4 = crop;
			obj4.onHarvest = (Action<Crop>)Delegate.Combine(obj4.onHarvest, new Action<Crop>(OnHarvest));
			Crop obj5 = crop;
			obj5.onBeforeDestroy = (Action<Crop>)Delegate.Combine(obj5.onBeforeDestroy, new Action<Crop>(OnBeforeDestroy));
		}

		private void Update()
		{
			RefreshPosition();
		}

		private void RefreshPosition(bool notifyStageChange = true)
		{
			float progress = crop.Progress;
			Stage stage = default(Stage);
			int? num = cachedStage;
			for (int i = 0; i < stages.Length; i++)
			{
				Stage stage2 = stages[i];
				if (progress < stages[i].progress)
				{
					stage = stage2;
					cachedStage = i;
					break;
				}
			}
			displayParent.localPosition = Vector3.up * stage.position;
			if (notifyStageChange && num.HasValue && num.Value != cachedStage)
			{
				OnStageChange();
			}
		}

		private void OnStageChange()
		{
			FXPool.Play(StageChangeFX, base.transform.position, base.transform.rotation);
		}

		private void OnWater(Crop crop)
		{
			FXPool.Play(WaterFX, base.transform.position, base.transform.rotation);
		}

		private void OnRipen(Crop crop)
		{
			FXPool.Play(RipenFX, base.transform.position, base.transform.rotation);
		}

		private void OnHarvest(Crop crop)
		{
			FXPool.Play(HarvestFX, base.transform.position, base.transform.rotation);
		}

		private void OnPlant(Crop crop)
		{
			FXPool.Play(PlantFX, base.transform.position, base.transform.rotation);
		}

		private void OnBeforeDestroy(Crop crop)
		{
			FXPool.Play(DestroyFX, base.transform.position, base.transform.rotation);
		}
	}
	[CreateAssetMenu]
	public class CropDatabase : ScriptableObject
	{
		[SerializeField]
		public List<CropInfo> entries = new List<CropInfo>();

		[SerializeField]
		public List<SeedInfo> seedInfos = new List<SeedInfo>();

		public static CropDatabase Instance => GameplayDataSettings.CropDatabase;

		public static CropInfo? GetCropInfo(string id)
		{
			CropDatabase instance = Instance;
			for (int i = 0; i < instance.entries.Count; i++)
			{
				CropInfo value = instance.entries[i];
				if (value.id == id)
				{
					return value;
				}
			}
			return null;
		}

		internal static bool IsIdValid(string id)
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.entries.Any((CropInfo e) => e.id == id);
		}

		internal static bool IsSeed(int itemTypeID)
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.seedInfos.Any((SeedInfo e) => e.itemTypeID == itemTypeID);
		}

		internal static SeedInfo GetSeedInfo(int seedItemTypeID)
		{
			if (Instance == null)
			{
				return default(SeedInfo);
			}
			return Instance.seedInfos.FirstOrDefault((SeedInfo e) => e.itemTypeID == seedItemTypeID);
		}
	}
	[Serializable]
	public struct SeedInfo
	{
		[ItemTypeID]
		public int itemTypeID;

		public RandomContainer<string> cropIDs;

		public string GetRandomCropID()
		{
			return cropIDs.GetRandom();
		}
	}
	[Serializable]
	public struct CropInfo
	{
		public string id;

		public GameObject displayPrefab;

		[ItemTypeID]
		public int resultPoor;

		[ItemTypeID]
		public int resultNormal;

		[ItemTypeID]
		public int resultGood;

		private ItemMetaData? _normalMetaData;

		public int resultAmount;

		[TimeSpan]
		public long totalGrowTicks;

		public string DisplayName
		{
			get
			{
				if (!_normalMetaData.HasValue)
				{
					_normalMetaData = ItemAssetsCollection.GetMetaData(resultNormal);
				}
				return _normalMetaData.Value.DisplayName;
			}
		}

		public TimeSpan GrowTime => TimeSpan.FromTicks(totalGrowTicks);

		public int GetProduct(ProductRanking ranking)
		{
			int num = 0;
			switch (ranking)
			{
			case ProductRanking.Poor:
				num = resultPoor;
				break;
			case ProductRanking.Normal:
				num = resultNormal;
				break;
			case ProductRanking.Good:
				num = resultGood;
				break;
			}
			if (num == 0)
			{
				if (resultNormal != 0)
				{
					return resultNormal;
				}
				if (resultPoor != 0)
				{
					return resultPoor;
				}
			}
			return num;
		}
	}
	public enum ProductRanking
	{
		Poor,
		Normal,
		Good
	}
	[Serializable]
	public struct CropData
	{
		public string gardenID;

		public Vector2Int coord;

		public string cropID;

		public int score;

		public bool watered;

		[TimeSpan]
		public long growTicks;

		[DateTime]
		public long lastUpdateDateTimeRaw;

		public ProductRanking Ranking
		{
			get
			{
				if (score < 33)
				{
					return ProductRanking.Poor;
				}
				if (score < 66)
				{
					return ProductRanking.Normal;
				}
				return ProductRanking.Good;
			}
		}

		public TimeSpan GrowTime => TimeSpan.FromTicks(growTicks);

		public DateTime LastUpdateDateTime
		{
			get
			{
				return DateTime.FromBinary(lastUpdateDateTimeRaw);
			}
			set
			{
				lastUpdateDateTimeRaw = value.ToBinary();
			}
		}
	}
	public class Garden : MonoBehaviour
	{
		[Serializable]
		private class SaveData
		{
			[SerializeField]
			public List<CropData> crops;

			public SaveData(Garden garden)
			{
				crops = new List<CropData>();
				foreach (Crop value in garden.dictioanry.Values)
				{
					if (!(value == null))
					{
						crops.Add(value.Data);
					}
				}
			}
		}

		[SerializeField]
		private string gardenID = "Default";

		public static List<IGardenSizeAdder> sizeAdders = new List<IGardenSizeAdder>();

		public static List<IGardenAutoWaterProvider> autoWaters = new List<IGardenAutoWaterProvider>();

		public static Dictionary<string, Garden> gardens = new Dictionary<string, Garden>();

		[SerializeField]
		private Grid grid;

		[SerializeField]
		private Crop cropTemplate;

		[SerializeField]
		private Transform border00;

		[SerializeField]
		private Transform border01;

		[SerializeField]
		private Transform border11;

		[SerializeField]
		private Transform border10;

		[SerializeField]
		private Transform corner00;

		[SerializeField]
		private Transform corner01;

		[SerializeField]
		private Transform corner11;

		[SerializeField]
		private Transform corner10;

		[SerializeField]
		private BoxCollider interactBox;

		[SerializeField]
		private Vector2Int size;

		[SerializeField]
		private bool autoWater;

		public Vector3 cameraRigCenter = new Vector3(3f, 0f, 3f);

		private bool sizeDirty;

		[SerializeField]
		private CellDisplay cellDisplayTemplate;

		private PrefabPool<CellDisplay> _cellPool;

		private Dictionary<Vector2Int, Crop> dictioanry = new Dictionary<Vector2Int, Crop>();

		public string GardenID => gardenID;

		public string SaveKey => "Garden_" + gardenID;

		public bool AutoWater
		{
			get
			{
				return autoWater;
			}
			set
			{
				autoWater = value;
				if (value)
				{
					WaterAll();
				}
			}
		}

		public Vector2Int Size
		{
			get
			{
				return size;
			}
			set
			{
				size = value;
				sizeDirty = true;
			}
		}

		public PrefabPool<CellDisplay> CellPool
		{
			get
			{
				if (_cellPool == null)
				{
					_cellPool = new PrefabPool<CellDisplay>(cellDisplayTemplate);
				}
				return _cellPool;
			}
		}

		public Crop this[Vector2Int coord]
		{
			get
			{
				if (dictioanry.TryGetValue(coord, out var value))
				{
					return value;
				}
				return null;
			}
			private set
			{
				dictioanry[coord] = value;
			}
		}

		public static event Action OnSizeAddersChanged;

		public static event Action OnAutoWatersChanged;

		private void WaterAll()
		{
			foreach (Crop value in dictioanry.Values)
			{
				if (!(value == null) && !value.Watered)
				{
					value.Water();
				}
			}
		}

		private void Awake()
		{
			gardens[gardenID] = this;
			SavesSystem.OnCollectSaveData += Save;
			OnSizeAddersChanged += RefreshSize;
			OnAutoWatersChanged += RefreshAutowater;
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
			OnSizeAddersChanged -= RefreshSize;
			OnAutoWatersChanged -= RefreshAutowater;
		}

		private void Start()
		{
			RegenerateCellDisplays();
			Load();
			RefreshSize();
			RefreshAutowater();
		}

		private void FixedUpdate()
		{
			if (sizeDirty)
			{
				RegenerateCellDisplays();
			}
		}

		private void RefreshAutowater()
		{
			bool flag = false;
			foreach (IGardenAutoWaterProvider autoWater in autoWaters)
			{
				if (autoWater.TakeEffect(gardenID))
				{
					flag = true;
					break;
				}
			}
			if (flag != AutoWater)
			{
				AutoWater = flag;
			}
		}

		private void RefreshSize()
		{
			Vector2Int zero = Vector2Int.zero;
			foreach (IGardenSizeAdder sizeAdder in sizeAdders)
			{
				if (sizeAdder != null)
				{
					zero += sizeAdder.GetValue(gardenID);
				}
			}
			Size = new Vector2Int(3 + zero.x, 3 + zero.y);
		}

		public void SetSize(int x, int y)
		{
			RegenerateCellDisplays();
		}

		private void RegenerateCellDisplays()
		{
			sizeDirty = false;
			CellPool.ReleaseAll();
			Vector2Int vector2Int = Size;
			for (int i = 0; i < vector2Int.y; i++)
			{
				for (int j = 0; j < vector2Int.x; j++)
				{
					Vector3 localPosition = CoordToLocalPosition(new Vector2Int(j, i));
					CellDisplay cellDisplay = CellPool.Get();
					cellDisplay.transform.localPosition = localPosition;
					cellDisplay.Setup(this, j, i);
				}
			}
			Vector3 vector = CoordToLocalPosition(new Vector2Int(0, 0)) - new Vector3(grid.cellSize.x, 0f, grid.cellSize.y) / 2f;
			Vector3 vector2 = CoordToLocalPosition(new Vector2Int(vector2Int.x, vector2Int.y)) - new Vector3(grid.cellSize.x, 0f, grid.cellSize.y) / 2f;
			float num = vector2.x - vector.x;
			float num2 = vector2.z - vector.z;
			Vector3 localPosition2 = vector;
			Vector3 localPosition3 = new Vector3(vector.x, 0f, vector2.z);
			Vector3 localPosition4 = vector2;
			Vector3 localPosition5 = new Vector3(vector2.x, 0f, vector.z);
			Vector3 localScale = new Vector3(1f, 1f, num2);
			Vector3 localScale2 = new Vector3(1f, 1f, num);
			Vector3 localScale3 = new Vector3(1f, 1f, num2);
			Vector3 localScale4 = new Vector3(1f, 1f, num);
			border00.localPosition = localPosition2;
			border01.localPosition = localPosition3;
			border11.localPosition = localPosition4;
			border10.localPosition = localPosition5;
			corner00.localPosition = localPosition2;
			corner01.localPosition = localPosition3;
			corner11.localPosition = localPosition4;
			corner10.localPosition = localPosition5;
			border00.localScale = localScale;
			border01.localScale = localScale2;
			border11.localScale = localScale3;
			border10.localScale = localScale4;
			border00.localRotation = Quaternion.Euler(0f, 0f, 0f);
			border01.localRotation = Quaternion.Euler(0f, 90f, 0f);
			border11.localRotation = Quaternion.Euler(0f, 180f, 0f);
			border10.localRotation = Quaternion.Euler(0f, 270f, 0f);
			Vector3 localPosition6 = (vector + vector2) / 2f;
			interactBox.transform.localPosition = localPosition6;
			interactBox.center = Vector3.zero;
			interactBox.size = new Vector3(num + 0.5f, 1f, num2 + 0.5f);
		}

		private Crop CreateCropInstance(string id)
		{
			return UnityEngine.Object.Instantiate(cropTemplate, base.transform);
		}

		public void Save()
		{
			if (LevelManager.LevelInited)
			{
				SaveData value = new SaveData(this);
				SavesSystem.Save(SaveKey, value);
			}
		}

		public void Load()
		{
			Clear();
			dictioanry.Clear();
			SaveData saveData = SavesSystem.Load<SaveData>(SaveKey);
			if (saveData == null)
			{
				return;
			}
			foreach (CropData crop2 in saveData.crops)
			{
				Crop crop = CreateCropInstance(crop2.cropID);
				crop.Initialize(this, crop2);
				this[crop2.coord] = crop;
			}
		}

		private void Clear()
		{
			foreach (Crop item in dictioanry.Values.ToList())
			{
				if (!(item == null))
				{
					UnityEngine.Object.Destroy(item.gameObject);
				}
			}
		}

		public bool IsCoordValid(Vector2Int coord)
		{
			Vector2Int vector2Int = Size;
			if (vector2Int.x <= 0 || vector2Int.y <= 0)
			{
				return true;
			}
			if (coord.x < vector2Int.x && coord.y < vector2Int.y && coord.x >= 0)
			{
				return coord.y >= 0;
			}
			return false;
		}

		public bool IsCoordOccupied(Vector2Int coord)
		{
			return this[coord] != null;
		}

		public bool Plant(Vector2Int coord, string cropID)
		{
			if (!IsCoordValid(coord))
			{
				return false;
			}
			if (IsCoordOccupied(coord))
			{
				return false;
			}
			if (!CropDatabase.IsIdValid(cropID))
			{
				UnityEngine.Debug.Log("[Garden] Invalid crop id " + cropID, this);
				return false;
			}
			Crop crop = CreateCropInstance(cropID);
			crop.InitializeNew(this, cropID, coord);
			this[coord] = crop;
			if (autoWater)
			{
				crop.Water();
			}
			return true;
		}

		public void Water(Vector2Int coord)
		{
			Crop crop = this[coord];
			if (!(crop == null))
			{
				crop.Water();
			}
		}

		public Vector3 CoordToWorldPosition(Vector2Int coord)
		{
			Vector3 position = CoordToLocalPosition(coord);
			return base.transform.TransformPoint(position);
		}

		public Vector3 CoordToLocalPosition(Vector2Int coord)
		{
			Vector3 cellCenterLocal = grid.GetCellCenterLocal((Vector3Int)coord);
			float z = grid.cellSize.z;
			float y = cellCenterLocal.y - z / 2f;
			Vector3 result = cellCenterLocal;
			result.y = y;
			return result;
		}

		public Vector2Int WorldPositionToCoord(Vector3 wPos)
		{
			Vector3 worldPosition = wPos + Vector3.up * 0.1f * grid.cellSize.z;
			return (Vector2Int)grid.WorldToCell(worldPosition);
		}

		internal void Release(Crop crop)
		{
			UnityEngine.Object.Destroy(crop.gameObject);
		}

		private void OnDrawGizmosSelected()
		{
			Gizmos.matrix = base.transform.localToWorldMatrix;
			float x = grid.cellSize.x;
			float y = grid.cellSize.y;
			Vector2Int vector2Int = Size;
			for (int i = 0; i <= vector2Int.x; i++)
			{
				Vector3 vector = Vector3.right * i * x;
				Vector3 to = vector + Vector3.forward * vector2Int.y * y;
				Gizmos.DrawLine(vector, to);
			}
			for (int j = 0; j <= vector2Int.y; j++)
			{
				Vector3 vector2 = Vector3.forward * j * y;
				Vector3 to2 = vector2 + Vector3.right * vector2Int.x * x;
				Gizmos.DrawLine(vector2, to2);
			}
		}

		internal static void Register(IGardenSizeAdder obj)
		{
			sizeAdders.Add(obj);
			Garden.OnSizeAddersChanged?.Invoke();
		}

		internal static void Register(IGardenAutoWaterProvider obj)
		{
			autoWaters.Add(obj);
			Garden.OnAutoWatersChanged?.Invoke();
		}

		internal static void Unregister(IGardenSizeAdder obj)
		{
			sizeAdders.Remove(obj);
			Garden.OnSizeAddersChanged?.Invoke();
		}

		internal static void Unregister(IGardenAutoWaterProvider obj)
		{
			autoWaters.Remove(obj);
			Garden.OnAutoWatersChanged?.Invoke();
		}
	}
	public interface IGardenSizeAdder
	{
		Vector2Int GetValue(string gardenID);
	}
	public interface IGardenAutoWaterProvider
	{
		bool TakeEffect(string gardenID);
	}
}
namespace Duckov.Crops.UI
{
	public class CellContextDisplay : MonoBehaviour
	{
		[SerializeField]
		private GardenView master;

		[SerializeField]
		private UnityEngine.CanvasGroup canvasGroup;

		[SerializeField]
		private GameObject plantInfo;

		[SerializeField]
		private TextMeshProUGUI plantingCropNameText;

		[SerializeField]
		private CostDisplay plantCostDisplay;

		[SerializeField]
		private GameObject currentCropInfo;

		[SerializeField]
		private TextMeshProUGUI cropNameText;

		[SerializeField]
		private TextMeshProUGUI cropCountdownText;

		[SerializeField]
		private GameObject noWaterIndicator;

		[SerializeField]
		private GameObject ripenIndicator;

		[SerializeField]
		private GameObject operationInfo;

		[SerializeField]
		private TextMeshProUGUI operationNameText;

		private Garden Garden
		{
			get
			{
				if (master == null)
				{
					return null;
				}
				return master.Target;
			}
		}

		private Vector2Int HoveringCoord
		{
			get
			{
				if (master == null)
				{
					return default(Vector2Int);
				}
				return master.HoveringCoord;
			}
		}

		private Crop HoveringCrop
		{
			get
			{
				if (master == null)
				{
					return null;
				}
				return master.HoveringCrop;
			}
		}

		private bool AnyContent
		{
			get
			{
				if (!plantInfo.activeSelf && !currentCropInfo.activeSelf)
				{
					return operationInfo.activeSelf;
				}
				return true;
			}
		}

		private void Show()
		{
			canvasGroup.alpha = 1f;
		}

		private void Hide()
		{
			canvasGroup.alpha = 0f;
		}

		private void Awake()
		{
			master.onContextChanged += OnContextChanged;
		}

		private void Start()
		{
			Refresh();
		}

		private void Update()
		{
			if (master.Hovering && AnyContent)
			{
				Show();
			}
			else
			{
				Hide();
			}
			if ((bool)HoveringCrop)
			{
				UpdateCurrentCropInfo();
			}
		}

		private void LateUpdate()
		{
			Vector3 worldPoint = Garden.CoordToWorldPosition(HoveringCoord) + Vector3.up * 2f;
			Vector2 vector = RectTransformUtility.WorldToScreenPoint(Camera.main, worldPoint);
			base.transform.position = vector;
		}

		private void OnContextChanged()
		{
			Refresh();
		}

		private void Refresh()
		{
			HideAll();
			switch (master.Tool)
			{
			case GardenView.ToolType.Plant:
				if ((bool)HoveringCrop)
				{
					SetupCurrentCropInfo();
					break;
				}
				SetupPlantInfo();
				if (master.PlantingSeedTypeID > 0)
				{
					SetupOperationInfo();
				}
				break;
			case GardenView.ToolType.Harvest:
				if (!(HoveringCrop == null))
				{
					SetupCurrentCropInfo();
					if (HoveringCrop.Ripen)
					{
						SetupOperationInfo();
					}
				}
				break;
			case GardenView.ToolType.Water:
				if (!(HoveringCrop == null))
				{
					SetupCurrentCropInfo();
					SetupOperationInfo();
				}
				break;
			case GardenView.ToolType.Destroy:
				if (!(HoveringCrop == null))
				{
					SetupCurrentCropInfo();
					SetupOperationInfo();
				}
				break;
			case GardenView.ToolType.None:
				break;
			}
		}

		private void SetupCurrentCropInfo()
		{
			currentCropInfo.SetActive(value: true);
			cropNameText.text = HoveringCrop.DisplayName;
			UpdateCurrentCropInfo();
		}

		private void UpdateCurrentCropInfo()
		{
			if (!(HoveringCrop == null))
			{
				cropCountdownText.text = HoveringCrop.RemainingTime.ToString("hh\\:mm\\:ss");
				cropCountdownText.gameObject.SetActive(!HoveringCrop.Ripen && HoveringCrop.Data.watered);
				noWaterIndicator.SetActive(!HoveringCrop.Data.watered);
				ripenIndicator.SetActive(HoveringCrop.Ripen);
			}
		}

		private void SetupOperationInfo()
		{
			operationInfo.SetActive(value: true);
			operationNameText.text = master.ToolDisplayName;
		}

		private void SetupPlantInfo()
		{
			if (master.SeedSelected)
			{
				plantInfo.SetActive(value: true);
				plantingCropNameText.text = master.SeedMeta.DisplayName;
				plantCostDisplay.Setup(new Cost((master.PlantingSeedTypeID, 1L)));
			}
		}

		private void HideAll()
		{
			plantInfo.SetActive(value: false);
			currentCropInfo.SetActive(value: false);
			operationInfo.SetActive(value: false);
			Hide();
		}
	}
	public class GardenView : View, IPointerClickHandler, IEventSystemHandler, IPointerMoveHandler, IPointerDownHandler, IPointerUpHandler, IPointerExitHandler, ICursorDataProvider
	{
		public enum ToolType
		{
			None,
			Plant,
			Harvest,
			Water,
			Destroy
		}

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private GameObject mainEventReceiver;

		[SerializeField]
		private UnityEngine.UI.Button btn_ChangePlant;

		[SerializeField]
		private GameObject plantModePanel;

		[SerializeField]
		private ItemMetaDisplay seedItemDisplay;

		[SerializeField]
		private GameObject seedItemPlaceHolder;

		[SerializeField]
		private TextMeshProUGUI seedAmountText;

		[SerializeField]
		private GardenViewCropSelector cropSelector;

		[SerializeField]
		private Transform cellHoveringGizmos;

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKey_Plant = "Garden_Plant";

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKey_Harvest = "Garden_Harvest";

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKey_Destroy = "Garden_Destroy";

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKey_Water = "Garden_Water";

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKey_TargetOccupied = "Garden_TargetOccupied";

		[SerializeField]
		private Transform cameraRig;

		[SerializeField]
		private UnityEngine.UI.Image cursorIcon;

		[SerializeField]
		private TextMeshProUGUI cursorAmountDisplay;

		[SerializeField]
		private ItemMetaDisplay cursorItemDisplay;

		[SerializeField]
		private Sprite iconPlant;

		[SerializeField]
		private Sprite iconHarvest;

		[SerializeField]
		private Sprite iconWater;

		[SerializeField]
		private Sprite iconDestroy;

		[SerializeField]
		private CursorData cursorPlant;

		[SerializeField]
		private CursorData cursorHarvest;

		[SerializeField]
		private CursorData cursorWater;

		[SerializeField]
		private CursorData cursorDestroy;

		[SerializeField]
		private Transform cursor3DTransform;

		[SerializeField]
		private Vector3 cursor3DOffset = Vector3.up;

		[SerializeField]
		private GameObject cursor3D_Plant;

		[SerializeField]
		private GameObject cursor3D_Harvest;

		[SerializeField]
		private GameObject cursor3D_Water;

		[SerializeField]
		private GameObject cursor3D_Destory;

		private Vector3 camFocusPos;

		private int _plantingSeedTypeID;

		private bool enabledCursor;

		private bool show3DCursor;

		private bool hoveringBG;

		private int seedAmount;

		private bool dragging;

		public static GardenView Instance { get; private set; }

		public Garden Target { get; private set; }

		public bool SeedSelected { get; private set; }

		public int PlantingSeedTypeID
		{
			get
			{
				return _plantingSeedTypeID;
			}
			private set
			{
				_plantingSeedTypeID = value;
				SeedMeta = ItemAssetsCollection.GetMetaData(value);
			}
		}

		public ItemMetaData SeedMeta { get; private set; }

		public ToolType Tool { get; private set; }

		public bool Hovering { get; private set; }

		public Vector2Int HoveringCoord { get; private set; }

		public Crop HoveringCrop { get; private set; }

		public string ToolDisplayName => Tool switch
		{
			ToolType.None => "...", 
			ToolType.Plant => textKey_Plant.ToPlainText(), 
			ToolType.Harvest => textKey_Harvest.ToPlainText(), 
			ToolType.Water => textKey_Water.ToPlainText(), 
			ToolType.Destroy => textKey_Destroy.ToPlainText(), 
			_ => "?", 
		};

		public event Action onContextChanged;

		public event Action onToolChanged;

		protected override void Awake()
		{
			base.Awake();
			btn_ChangePlant.onClick.AddListener(OnBtnChangePlantClicked);
			ItemUtilities.OnPlayerItemOperation += OnPlayerItemOperation;
			Instance = this;
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			ItemUtilities.OnPlayerItemOperation -= OnPlayerItemOperation;
		}

		private void OnDisable()
		{
			if ((bool)cellHoveringGizmos)
			{
				cellHoveringGizmos.gameObject.SetActive(value: false);
			}
		}

		private void OnPlayerItemOperation()
		{
			if (base.gameObject.activeSelf && SeedSelected)
			{
				RefreshSeedAmount();
			}
		}

		public static void Show(Garden target)
		{
			Instance.Target = target;
			Instance.Open();
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			if (Target == null)
			{
				Target = UnityEngine.Object.FindObjectOfType<Garden>();
			}
			if (Target == null)
			{
				UnityEngine.Debug.Log("No Garden instance found. Aborting..");
				Close();
			}
			fadeGroup.Show();
			RefreshSeedInfoDisplay();
			EnableCursor();
			SetTool(Tool);
			CenterCamera();
		}

		protected override void OnClose()
		{
			base.OnClose();
			cropSelector.Hide();
			fadeGroup.Hide();
			ReleaseCursor();
		}

		private void EnableCursor()
		{
			CursorManager.Register(this);
		}

		private void ReleaseCursor()
		{
			CursorManager.Unregister(this);
		}

		private void ChangeCursor()
		{
			CursorManager.NotifyRefresh();
		}

		private void Update()
		{
			UpdateContext();
			UpdateCursor3D();
		}

		private void OnBtnChangePlantClicked()
		{
			cropSelector.Show();
		}

		private void OnContextChanged()
		{
			this.onContextChanged?.Invoke();
			RefreshHoveringGizmos();
			RefreshCursor();
			if (dragging && Hovering)
			{
				ExecuteTool(HoveringCoord);
			}
			ChangeCursor();
			RefreshCursor3DActive();
		}

		private void RefreshCursor()
		{
			cursorIcon.gameObject.SetActive(value: false);
			cursorAmountDisplay.gameObject.SetActive(value: false);
			cursorItemDisplay.gameObject.SetActive(value: false);
			switch (Tool)
			{
			case ToolType.Plant:
				cursorAmountDisplay.gameObject.SetActive(SeedSelected);
				cursorItemDisplay.gameObject.SetActive(SeedSelected);
				cursorIcon.sprite = iconPlant;
				break;
			case ToolType.Harvest:
				cursorIcon.gameObject.SetActive(value: true);
				cursorIcon.sprite = iconHarvest;
				break;
			case ToolType.Water:
				cursorIcon.gameObject.SetActive(value: true);
				cursorIcon.sprite = iconWater;
				break;
			case ToolType.Destroy:
				cursorIcon.gameObject.SetActive(value: true);
				cursorIcon.sprite = iconDestroy;
				break;
			case ToolType.None:
				break;
			}
		}

		private void RefreshHoveringGizmos()
		{
			if ((bool)cellHoveringGizmos)
			{
				if (!Hovering || !base.enabled)
				{
					cellHoveringGizmos.gameObject.SetActive(value: false);
					return;
				}
				cellHoveringGizmos.gameObject.SetActive(value: true);
				cellHoveringGizmos.SetParent(null);
				cellHoveringGizmos.localScale = Vector3.one;
				cellHoveringGizmos.position = Target.CoordToWorldPosition(HoveringCoord);
				cellHoveringGizmos.rotation = Quaternion.LookRotation(-Vector3.up);
			}
		}

		public void SetTool(ToolType action)
		{
			Tool = action;
			OnContextChanged();
			plantModePanel.SetActive(action == ToolType.Plant);
			this.onToolChanged?.Invoke();
			RefreshSeedAmount();
		}

		private CursorData GetCursorByTool(ToolType action)
		{
			return null;
		}

		private void UpdateContext()
		{
			bool hovering = Hovering;
			Crop hoveringCrop = HoveringCrop;
			Vector2Int hoveringCoord = HoveringCoord;
			Vector2Int? pointingCoord = GetPointingCoord();
			if (!pointingCoord.HasValue)
			{
				HoveringCrop = null;
				return;
			}
			HoveringCoord = pointingCoord.Value;
			HoveringCrop = Target[HoveringCoord];
			Hovering = hoveringBG;
			if (!HoveringCrop)
			{
				Hovering &= Target.IsCoordValid(HoveringCoord);
			}
			if (hovering != (bool)HoveringCrop || hoveringCrop != HoveringCrop || hoveringCoord != HoveringCoord)
			{
				OnContextChanged();
			}
		}

		private void UpdateCursor3D()
		{
			Vector3 planePoint;
			bool flag = TryPointerOnPlanePoint(UIInputManager.Point, out planePoint);
			show3DCursor = flag && Hovering;
			cursor3DTransform.gameObject.SetActive(show3DCursor);
			if (flag)
			{
				Vector3 position = cursor3DTransform.position;
				Vector3 vector = planePoint + cursor3DOffset;
				Vector3 position2 = ((!show3DCursor) ? vector : Vector3.Lerp(position, vector, 0.25f));
				cursor3DTransform.position = position2;
			}
		}

		private void RefreshCursor3DActive()
		{
			cursor3D_Plant.SetActive(ShouldShowCursor(ToolType.Plant));
			cursor3D_Water.SetActive(ShouldShowCursor(ToolType.Water));
			cursor3D_Harvest.SetActive(ShouldShowCursor(ToolType.Harvest));
			cursor3D_Destory.SetActive(ShouldShowCursor(ToolType.Destroy));
			bool ShouldShowCursor(ToolType toolType)
			{
				if (Tool != toolType)
				{
					return false;
				}
				if (!Hovering)
				{
					return false;
				}
				switch (toolType)
				{
				case ToolType.None:
					return false;
				case ToolType.Plant:
					if (SeedSelected && seedAmount > 0)
					{
						return !HoveringCrop;
					}
					return false;
				case ToolType.Harvest:
					if ((bool)HoveringCrop)
					{
						return HoveringCrop.Ripen;
					}
					return false;
				case ToolType.Water:
					return HoveringCrop;
				case ToolType.Destroy:
					return HoveringCrop;
				default:
					return false;
				}
			}
		}

		public void SelectSeed(int seedTypeID)
		{
			PlantingSeedTypeID = seedTypeID;
			if (seedTypeID > 0)
			{
				SeedSelected = true;
			}
			RefreshSeedInfoDisplay();
			OnContextChanged();
		}

		private void RefreshSeedInfoDisplay()
		{
			if (SeedSelected)
			{
				seedItemDisplay.Setup(PlantingSeedTypeID);
				cursorItemDisplay.Setup(PlantingSeedTypeID);
			}
			seedItemDisplay.gameObject.SetActive(SeedSelected);
			seedItemPlaceHolder.gameObject.SetActive(!SeedSelected);
			RefreshSeedAmount();
		}

		private bool TryPointerOnPlanePoint(Vector2 pointerPos, out Vector3 planePoint)
		{
			planePoint = default(Vector3);
			if (Target == null)
			{
				return false;
			}
			Ray ray = RectTransformUtility.ScreenPointToRay(Camera.main, pointerPos);
			if (!new Plane(Target.transform.up, Target.transform.position).Raycast(ray, out var enter))
			{
				return false;
			}
			planePoint = ray.GetPoint(enter);
			return true;
		}

		private bool TryPointerPosToCoord(Vector2 pointerPos, out Vector2Int result)
		{
			result = default(Vector2Int);
			if (Target == null)
			{
				return false;
			}
			Ray ray = RectTransformUtility.ScreenPointToRay(Camera.main, pointerPos);
			if (!new Plane(Target.transform.up, Target.transform.position).Raycast(ray, out var enter))
			{
				return false;
			}
			Vector3 point = ray.GetPoint(enter);
			result = Target.WorldPositionToCoord(point);
			return true;
		}

		private Vector2Int? GetPointingCoord()
		{
			if (!TryPointerPosToCoord(UIInputManager.Point, out var result))
			{
				return null;
			}
			return result;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (TryPointerPosToCoord(eventData.position, out var result))
			{
				ExecuteTool(result);
			}
		}

		private void ExecuteTool(Vector2Int coord)
		{
			switch (Tool)
			{
			case ToolType.Plant:
				CropActionPlant(coord);
				break;
			case ToolType.Harvest:
				CropActionHarvest(coord);
				break;
			case ToolType.Water:
				CropActionWater(coord);
				break;
			case ToolType.Destroy:
				CropActionDestroy(coord);
				break;
			case ToolType.None:
				break;
			}
		}

		private void CropActionDestroy(Vector2Int coord)
		{
			Crop crop = Target[coord];
			if (!(crop == null))
			{
				if (crop.Ripen)
				{
					crop.Harvest();
				}
				else
				{
					crop.DestroyCrop();
				}
			}
		}

		private void CropActionWater(Vector2Int coord)
		{
			Crop crop = Target[coord];
			if (!(crop == null))
			{
				crop.Water();
			}
		}

		private void CropActionHarvest(Vector2Int coord)
		{
			Crop crop = Target[coord];
			if (!(crop == null))
			{
				crop.Harvest();
			}
		}

		private void CropActionPlant(Vector2Int coord)
		{
			if (!Target.IsCoordValid(coord) || Target[coord] != null)
			{
				return;
			}
			CropInfo? cropInfoFromSeedType = GetCropInfoFromSeedType(PlantingSeedTypeID);
			if (cropInfoFromSeedType.HasValue)
			{
				Cost cost = new Cost((PlantingSeedTypeID, 1L));
				if (cost.Pay())
				{
					Target.Plant(coord, cropInfoFromSeedType.Value.id);
				}
			}
		}

		private CropInfo? GetCropInfoFromSeedType(int plantingSeedTypeID)
		{
			SeedInfo seedInfo = CropDatabase.GetSeedInfo(plantingSeedTypeID);
			if (seedInfo.cropIDs == null)
			{
				return null;
			}
			if (seedInfo.cropIDs.Count <= 0)
			{
				return null;
			}
			return CropDatabase.GetCropInfo(seedInfo.GetRandomCropID());
		}

		public void OnPointerMove(PointerEventData eventData)
		{
			if (eventData.pointerCurrentRaycast.gameObject == mainEventReceiver)
			{
				hoveringBG = true;
			}
			else
			{
				hoveringBG = false;
			}
		}

		private void RefreshSeedAmount()
		{
			if (SeedSelected)
			{
				string text = $"x{seedAmount = ItemUtilities.GetItemCount(PlantingSeedTypeID)}";
				seedAmountText.text = text;
				cursorAmountDisplay.text = text;
			}
			else
			{
				seedAmountText.text = "";
				cursorAmountDisplay.text = "";
				seedAmount = 0;
			}
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			dragging = true;
		}

		public void OnPointerUp(PointerEventData eventData)
		{
			dragging = false;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			dragging = false;
		}

		private void UpdateCamera()
		{
			cameraRig.transform.position = camFocusPos;
		}

		private void CenterCamera()
		{
			if (!(Target == null))
			{
				camFocusPos = Target.transform.TransformPoint(Target.cameraRigCenter);
				UpdateCamera();
			}
		}

		public CursorData GetCursorData()
		{
			return GetCursorByTool(Tool);
		}
	}
	public class GardenViewCropSelector : MonoBehaviour
	{
		[SerializeField]
		private GardenView master;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button btnConfirm;

		[SerializeField]
		private InventoryDisplay playerInventoryDisplay;

		[SerializeField]
		private InventoryDisplay storageInventoryDisplay;

		private void Awake()
		{
			btnConfirm.onClick.AddListener(OnConfirm);
		}

		private void OnConfirm()
		{
			Item selectedItem = ItemUIUtilities.SelectedItem;
			if (selectedItem != null)
			{
				master.SelectSeed(selectedItem.TypeID);
			}
			Hide();
		}

		public void Show()
		{
			fadeGroup.Show();
			if (!(LevelManager.Instance == null))
			{
				ItemUIUtilities.Select(null);
				playerInventoryDisplay.Setup(CharacterMainControl.Main.CharacterItem.Inventory, null, null, movable: false, (Item e) => e != null && CropDatabase.IsSeed(e.TypeID));
				storageInventoryDisplay.Setup(PlayerStorage.Inventory, null, null, movable: false, (Item e) => e != null && CropDatabase.IsSeed(e.TypeID));
			}
		}

		private void OnEnable()
		{
			ItemUIUtilities.OnSelectionChanged += OnSelectionChanged;
		}

		private void OnDisable()
		{
			ItemUIUtilities.OnSelectionChanged -= OnSelectionChanged;
		}

		private void OnSelectionChanged()
		{
		}

		public void Hide()
		{
			fadeGroup.Hide();
		}
	}
	public class GardenViewToolButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private GardenView master;

		[SerializeField]
		private GardenView.ToolType tool;

		[SerializeField]
		private GameObject indicator;

		public void OnPointerClick(PointerEventData eventData)
		{
			master.SetTool(tool);
		}

		private void Awake()
		{
			master.onToolChanged += OnToolChanged;
		}

		private void Start()
		{
			Refresh();
		}

		private void Refresh()
		{
			indicator.SetActive(tool == master.Tool);
		}

		private void OnToolChanged()
		{
			Refresh();
		}
	}
}
namespace Duckov.Endowment
{
	public class EndowmentEntry : MonoBehaviour
	{
		[Serializable]
		public struct ModifierDescription
		{
			public string statKey;

			public ModifierType type;

			public float value;

			[LocalizationKey("Default")]
			private string DisplayNameKey
			{
				get
				{
					return "Stat_" + statKey;
				}
				set
				{
				}
			}

			public string DescriptionText
			{
				get
				{
					string text = DisplayNameKey.ToPlainText();
					string text2 = "";
					switch (type)
					{
					case ModifierType.Add:
						text2 = ((!(value >= 0f)) ? $"{value}" : $"+{value}");
						break;
					case ModifierType.PercentageAdd:
						text2 = ((!(value >= 0f)) ? $"-{(0f - value) * 100f:00.#}%" : $"+{value * 100f:00.#}%");
						break;
					case ModifierType.PercentageMultiply:
						text2 = $"x{(1f + value) * 100f:00.#}%";
						break;
					}
					return text + " " + text2;
				}
			}
		}

		[SerializeField]
		private EndowmentIndex index;

		[SerializeField]
		private Sprite icon;

		[SerializeField]
		[LocalizationKey("Default")]
		private string requirementTextKey;

		[SerializeField]
		private bool unlockedByDefault;

		[SerializeField]
		private ModifierDescription[] modifiers;

		public UnityEvent<EndowmentEntry> onActivate;

		public UnityEvent<EndowmentEntry> onDeactivate;

		public EndowmentIndex Index => index;

		[LocalizationKey("Default")]
		private string displayNameKey
		{
			get
			{
				return $"Endowmment_{index}";
			}
			set
			{
			}
		}

		[LocalizationKey("Default")]
		private string descriptionKey
		{
			get
			{
				return $"Endowmment_{index}_Desc";
			}
			set
			{
			}
		}

		public string RequirementText => requirementTextKey.ToPlainText();

		public Sprite Icon => icon;

		public string DisplayName => displayNameKey.ToPlainText();

		public string Description => descriptionKey.ToPlainText();

		public string DescriptionAndEffects
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				string description = Description;
				stringBuilder.AppendLine(description);
				ModifierDescription[] array = Modifiers;
				foreach (ModifierDescription modifierDescription in array)
				{
					stringBuilder.AppendLine("- " + modifierDescription.DescriptionText);
				}
				return stringBuilder.ToString();
			}
		}

		public ModifierDescription[] Modifiers => modifiers;

		private Item CharacterItem
		{
			get
			{
				if (CharacterMainControl.Main == null)
				{
					return null;
				}
				return CharacterMainControl.Main.CharacterItem;
			}
		}

		public bool UnlockedByDefault => unlockedByDefault;

		public void Activate()
		{
			ApplyModifiers();
			onActivate?.Invoke(this);
		}

		public void Deactivate()
		{
			DeleteModifiers();
			onDeactivate?.Invoke(this);
		}

		private void ApplyModifiers()
		{
			if (!(CharacterItem == null))
			{
				DeleteModifiers();
				ModifierDescription[] array = modifiers;
				for (int i = 0; i < array.Length; i++)
				{
					ModifierDescription modifierDescription = array[i];
					CharacterItem.AddModifier(modifierDescription.statKey, new Modifier(modifierDescription.type, modifierDescription.value, this));
				}
			}
		}

		private void DeleteModifiers()
		{
			if (!(CharacterItem == null))
			{
				CharacterItem.RemoveAllModifiersFrom(this);
			}
		}
	}
	public class EndowmentManager : MonoBehaviour
	{
		private const string SaveKey = "Endowment_SelectedIndex";

		public static Action<EndowmentIndex> OnEndowmentChanged;

		public static Action<EndowmentIndex> OnEndowmentUnlock;

		[SerializeField]
		private List<EndowmentEntry> entries = new List<EndowmentEntry>();

		private ReadOnlyCollection<EndowmentEntry> _entries_ReadOnly;

		private static EndowmentManager _instance { get; set; }

		public static EndowmentManager Instance
		{
			get
			{
				if (_instance == null)
				{
					_ = GameManager.Instance;
				}
				return _instance;
			}
		}

		public static EndowmentIndex SelectedIndex
		{
			get
			{
				return SavesSystem.Load<EndowmentIndex>("Endowment_SelectedIndex");
			}
			private set
			{
				SavesSystem.Save("Endowment_SelectedIndex", value);
			}
		}

		public ReadOnlyCollection<EndowmentEntry> Entries
		{
			get
			{
				if (_entries_ReadOnly == null)
				{
					_entries_ReadOnly = new ReadOnlyCollection<EndowmentEntry>(entries);
				}
				return _entries_ReadOnly;
			}
		}

		public static EndowmentEntry Current
		{
			get
			{
				if (_instance == null)
				{
					return null;
				}
				return _instance.entries.Find((EndowmentEntry e) => e != null && e.Index == SelectedIndex);
			}
		}

		public static EndowmentIndex CurrentIndex
		{
			get
			{
				if (Current == null)
				{
					return EndowmentIndex.None;
				}
				return Current.Index;
			}
		}

		private EndowmentEntry GetEntry(EndowmentIndex index)
		{
			return entries.Find((EndowmentEntry e) => e != null && e.Index == index);
		}

		private static string GetUnlockKey(EndowmentIndex index)
		{
			return $"Endowment_Unlock_R_{index}";
		}

		public static bool GetEndowmentUnlocked(EndowmentIndex index)
		{
			if (Instance != null)
			{
				if (Instance.GetEntry(index).UnlockedByDefault)
				{
					return true;
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Endowment Manager 不存在。");
			}
			return SavesSystem.LoadGlobal(GetUnlockKey(index), defaultValue: false);
		}

		private static void SetEndowmentUnlocked(EndowmentIndex index, bool value = true)
		{
			SavesSystem.SaveGlobal(GetUnlockKey(index), value);
		}

		public static bool UnlockEndowment(EndowmentIndex index)
		{
			try
			{
				OnEndowmentUnlock?.Invoke(index);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			if (GetEndowmentUnlocked(index))
			{
				UnityEngine.Debug.Log("尝试解锁天赋，但天赋已经解锁");
				return false;
			}
			SetEndowmentUnlocked(index);
			return true;
		}

		private void Awake()
		{
			if (_instance != null)
			{
				UnityEngine.Debug.LogError("检测到多个Endowment Manager");
				return;
			}
			_instance = this;
			if (LevelManager.LevelInited)
			{
				ApplyCurrentEndowment();
			}
			LevelManager.OnLevelInitialized += OnLevelInitialized;
		}

		private void OnDestroy()
		{
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void OnLevelInitialized()
		{
			ApplyCurrentEndowment();
			MakeSureEndowmentAchievementsUnlocked();
		}

		private void MakeSureEndowmentAchievementsUnlocked()
		{
			for (int i = 0; i < 5; i++)
			{
				EndowmentIndex index = (EndowmentIndex)i;
				EndowmentEntry entry = Instance.GetEntry(index);
				if (!(entry == null) && !entry.UnlockedByDefault && GetEndowmentUnlocked(index))
				{
					AchievementManager.UnlockEndowmentAchievement(index);
				}
			}
		}

		private void ApplyCurrentEndowment()
		{
			if (!LevelManager.LevelInited)
			{
				return;
			}
			foreach (EndowmentEntry entry in entries)
			{
				if (!(entry == null))
				{
					entry.Deactivate();
				}
			}
			EndowmentEntry current2 = Current;
			if (!(current2 == null))
			{
				current2.Activate();
			}
		}

		internal void SelectIndex(EndowmentIndex index)
		{
			SelectedIndex = index;
			ApplyCurrentEndowment();
			OnEndowmentChanged?.Invoke(index);
		}
	}
	public enum EndowmentIndex
	{
		None,
		Surviver,
		Porter,
		Berserker,
		Marksman,
		_Count
	}
}
namespace Duckov.Endowment.UI
{
	public class EndowmentDisplay : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI displayNameText;

		[SerializeField]
		private TextMeshProUGUI descriptionsText;

		private void Refresh()
		{
			EndowmentEntry current = EndowmentManager.Current;
			if (current == null)
			{
				displayNameText.text = "?";
				descriptionsText.text = "?";
			}
			else
			{
				displayNameText.text = current.DisplayName;
				descriptionsText.text = current.DescriptionAndEffects;
			}
		}

		private void OnEnable()
		{
			Refresh();
		}
	}
	public class EndowmentSelectionEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private TextMeshProUGUI displayNameText;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private GameObject selectedIndicator;

		[SerializeField]
		private GameObject lockedIndcator;

		[SerializeField]
		private TextMeshProUGUI requirementText;

		public Action<EndowmentSelectionEntry, PointerEventData> onClicked;

		public string DisplayName
		{
			get
			{
				if (Target == null)
				{
					return "-";
				}
				return Target.DisplayName;
			}
		}

		public string Description
		{
			get
			{
				if (Target == null)
				{
					return "-";
				}
				return Target.Description;
			}
		}

		public string DescriptionAndEffects
		{
			get
			{
				if (Target == null)
				{
					return "-";
				}
				return Target.DescriptionAndEffects;
			}
		}

		public EndowmentIndex Index
		{
			get
			{
				if (Target == null)
				{
					return EndowmentIndex.None;
				}
				return Target.Index;
			}
		}

		public EndowmentEntry Target { get; private set; }

		public bool Selected { get; private set; }

		public bool Unlocked => EndowmentManager.GetEndowmentUnlocked(Index);

		public bool Locked => !Unlocked;

		public void Setup(EndowmentEntry target)
		{
			Target = target;
			if (!(Target == null))
			{
				displayNameText.text = Target.DisplayName;
				icon.sprite = Target.Icon;
				requirementText.text = "- " + Target.RequirementText + " -";
				Refresh();
			}
		}

		private void Refresh()
		{
			if (!(Target == null))
			{
				selectedIndicator.SetActive(Selected);
				lockedIndcator.SetActive(Locked);
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (!Locked)
			{
				onClicked?.Invoke(this, eventData);
			}
		}

		internal void SetSelection(bool value)
		{
			Selected = value;
			Refresh();
		}
	}
	public class EndowmentSelectionPanel : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private EndowmentSelectionEntry entryTemplate;

		[SerializeField]
		private TextMeshProUGUI descriptionText;

		[SerializeField]
		private UnityEngine.UI.Button confirmButton;

		[SerializeField]
		private UnityEngine.UI.Button cancelButton;

		private PrefabPool<EndowmentSelectionEntry> _pool;

		private bool confirmed;

		private bool canceled;

		private PrefabPool<EndowmentSelectionEntry> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<EndowmentSelectionEntry>(entryTemplate, null, null, null, null, collectionCheck: true, 10, 10000, delegate(EndowmentSelectionEntry e)
					{
						e.onClicked = (Action<EndowmentSelectionEntry, PointerEventData>)Delegate.Combine(e.onClicked, new Action<EndowmentSelectionEntry, PointerEventData>(OnEntryClicked));
					});
				}
				return _pool;
			}
		}

		public EndowmentSelectionEntry Selection { get; private set; }

		protected override void Awake()
		{
			base.Awake();
			confirmButton.onClick.AddListener(OnConfirmButtonClicked);
			cancelButton.onClick.AddListener(OnCancelButtonClicked);
		}

		protected override void OnCancel()
		{
			base.OnCancel();
			canceled = true;
		}

		private void OnCancelButtonClicked()
		{
			canceled = true;
		}

		private void OnConfirmButtonClicked()
		{
			confirmed = true;
		}

		private void OnEntryClicked(EndowmentSelectionEntry entry, PointerEventData data)
		{
			if (!entry.Locked)
			{
				Select(entry);
			}
		}

		private void Select(EndowmentSelectionEntry entry)
		{
			Selection = entry;
			foreach (EndowmentSelectionEntry activeEntry in Pool.ActiveEntries)
			{
				activeEntry.SetSelection(activeEntry == entry);
			}
			RefreshDescription();
		}

		public void Setup()
		{
			if (EndowmentManager.Instance == null)
			{
				return;
			}
			Pool.ReleaseAll();
			foreach (EndowmentEntry entry in EndowmentManager.Instance.Entries)
			{
				if (!(entry == null))
				{
					Pool.Get().Setup(entry);
				}
			}
			foreach (EndowmentSelectionEntry activeEntry in Pool.ActiveEntries)
			{
				if (activeEntry.Target.Index == EndowmentManager.SelectedIndex)
				{
					Select(activeEntry);
					break;
				}
			}
		}

		private void RefreshDescription()
		{
			if (Selection == null)
			{
				descriptionText.text = "-";
			}
			descriptionText.text = Selection.DescriptionAndEffects;
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			Execute().Forget();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		public async UniTask Execute()
		{
			Setup();
			await fadeGroup.ShowAndReturnTask();
			await WaitForConfirm();
			if (confirmed && Selection.Index != EndowmentManager.CurrentIndex)
			{
				EndowmentManager.Instance.SelectIndex(Selection.Index);
				SceneLoader.Instance.LoadBaseScene(null, doCircleFade: false).Forget();
			}
			Close();
		}

		private async UniTask WaitForConfirm()
		{
			confirmed = false;
			canceled = false;
			while ((!confirmed || !(Selection != null)) && !canceled)
			{
				await UniTask.Yield();
			}
		}

		internal void SkipHide()
		{
			if (fadeGroup != null)
			{
				fadeGroup.SkipHide();
			}
		}

		public static void Show()
		{
			EndowmentSelectionPanel viewInstance = View.GetViewInstance<EndowmentSelectionPanel>();
			if (!(viewInstance == null))
			{
				viewInstance.Open();
			}
		}
	}
}
namespace Duckov.CreditsUtility
{
	public class CreditsDisplay : MonoBehaviour
	{
		private class GenerationStatus
		{
			public List<Token> records = new List<Token>();

			public Stack<Transform> transforms = new Stack<Transform>();

			public bool s;

			public bool l;

			public bool b;

			public Color color = Color.white;

			public VerticalEntry activeItem;

			public void Flush()
			{
				s = false;
				l = false;
				b = false;
				color = Color.white;
			}
		}

		[SerializeField]
		private bool setupOnAwake;

		[SerializeField]
		private TextAsset content;

		[SerializeField]
		private Transform rootContentTransform;

		[SerializeField]
		private float internalItemSpacing = 8f;

		[SerializeField]
		private float mainSpacing = 16f;

		[SerializeField]
		private float itemWidth = 350f;

		[UnityEngine.Header("Prefabs")]
		[SerializeField]
		private HorizontalEntry horizontalPrefab;

		[SerializeField]
		private VerticalEntry verticalPrefab;

		[SerializeField]
		private EmptyEntry emptyPrefab;

		[SerializeField]
		private TextEntry textPrefab;

		[SerializeField]
		private ImageEntry imagePrefab;

		private GenerationStatus status;

		private Transform CurrentTransform => GetCurrentTransform();

		private void ParseAndDisplay()
		{
			Reset();
			CreditsLexer creditsLexer = new CreditsLexer(content.text);
			BeginVerticalLayout();
			foreach (Token item in creditsLexer)
			{
				if (status.records.Count > 0)
				{
					_ = status.records[status.records.Count - 1];
				}
				status.records.Add(item);
				switch (item.type)
				{
				case TokenType.Invalid:
					UnityEngine.Debug.LogError("Invalid Token: " + item.text);
					continue;
				case TokenType.End:
					break;
				case TokenType.String:
					DoText(item.text);
					continue;
				case TokenType.Instructor:
					DoInstructor(item.text);
					continue;
				case TokenType.EmptyLine:
					EndItem();
					continue;
				default:
					continue;
				}
				break;
			}
			EndLayout();
		}

		private void EndItem()
		{
			if ((bool)status.activeItem)
			{
				status.activeItem = null;
				EndLayout();
			}
		}

		private void BeginItem()
		{
			status.activeItem = BeginVerticalLayout();
			status.activeItem.SetLayoutSpacing(internalItemSpacing);
			status.activeItem.SetPreferredWidth(itemWidth);
		}

		private void DoEmpty(params string[] elements)
		{
			UnityEngine.Object.Instantiate(emptyPrefab, CurrentTransform).Setup(elements);
		}

		private void DoInstructor(string text)
		{
			string[] array = text.Split(' ');
			if (array.Length >= 1)
			{
				switch (array[0])
				{
				case "Horizontal":
					BeginHorizontalLayout(array);
					break;
				case "Vertical":
					BeginVerticalLayout(array);
					break;
				case "End":
					EndLayout();
					break;
				case "s":
					status.s = true;
					break;
				case "l":
					status.l = true;
					break;
				case "b":
					status.b = true;
					break;
				case "color":
					DoColor(array);
					break;
				case "image":
					DoImage(array);
					break;
				case "Space":
					DoEmpty(array);
					break;
				}
			}
		}

		private void DoImage(string[] elements)
		{
			if (status.activeItem == null)
			{
				BeginItem();
			}
			UnityEngine.Object.Instantiate(imagePrefab, CurrentTransform).Setup(elements);
		}

		private void DoColor(string[] elements)
		{
			if (elements.Length >= 2)
			{
				ColorUtility.TryParseHtmlString(elements[1], out var color);
				status.color = color;
			}
		}

		private void DoText(string text)
		{
			if (status.activeItem == null)
			{
				BeginItem();
			}
			TextEntry textEntry = UnityEngine.Object.Instantiate(textPrefab, CurrentTransform);
			int size = 30;
			if (status.s)
			{
				size = 20;
			}
			if (status.l)
			{
				size = 40;
			}
			textEntry.Setup(bold: status.b, text: text, color: status.color, size: size);
			status.Flush();
		}

		private Transform GetCurrentTransform()
		{
			if (status == null)
			{
				return rootContentTransform;
			}
			if (status.transforms.Count == 0)
			{
				return rootContentTransform;
			}
			return status.transforms.Peek();
		}

		public void PushTransform(Transform trans)
		{
			if (status == null)
			{
				UnityEngine.Debug.LogError("Status not found. Credits Display functions should be called after initialization.", this);
			}
			else
			{
				status.transforms.Push(trans);
			}
		}

		public Transform PopTransform()
		{
			if (status == null)
			{
				UnityEngine.Debug.LogError("Status not found. Credits Display functions should be called after initialization.", this);
				return null;
			}
			if (status.transforms.Count == 0)
			{
				UnityEngine.Debug.LogError("Nothing to pop. Makesure to match push and pop.", this);
				return null;
			}
			return status.transforms.Pop();
		}

		private void Awake()
		{
			if (setupOnAwake)
			{
				ParseAndDisplay();
			}
		}

		private void Reset()
		{
			while (base.transform.childCount > 0)
			{
				Transform child = base.transform.GetChild(0);
				child.SetParent(null);
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(child.gameObject);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(child.gameObject);
				}
			}
			status = new GenerationStatus();
		}

		private VerticalEntry BeginVerticalLayout(params string[] args)
		{
			VerticalEntry verticalEntry = UnityEngine.Object.Instantiate(verticalPrefab, CurrentTransform);
			verticalEntry.Setup(args);
			verticalEntry.SetLayoutSpacing(mainSpacing);
			PushTransform(verticalEntry.transform);
			return verticalEntry;
		}

		private void EndLayout(params string[] args)
		{
			if (status.activeItem != null)
			{
				EndItem();
			}
			PopTransform();
		}

		private HorizontalEntry BeginHorizontalLayout(params string[] args)
		{
			HorizontalEntry horizontalEntry = UnityEngine.Object.Instantiate(horizontalPrefab, CurrentTransform);
			horizontalEntry.Setup(args);
			PushTransform(horizontalEntry.transform);
			return horizontalEntry;
		}
	}
	public enum TokenType
	{
		Invalid = -1,
		End,
		String,
		Instructor,
		EmptyLine,
		Comment
	}
	public struct Token
	{
		public TokenType type;

		public string text;

		public Token(TokenType type, string text = null)
		{
			this.type = type;
			this.text = text;
		}
	}
	public class CreditsLexer : IEnumerable<Token>, IEnumerable
	{
		private readonly string content;

		private ushort cursor;

		private ushort lineBegin;

		public CreditsLexer(string content)
		{
			this.content = content;
			cursor = 0;
			lineBegin = 0;
		}

		public void Reset()
		{
			cursor = 0;
			lineBegin = 0;
		}

		private void TrimLeft()
		{
			while (cursor < content.Length)
			{
				char c = content[cursor];
				if (!char.IsWhiteSpace(c) || c == '\n')
				{
					break;
				}
				cursor++;
			}
		}

		public Token Next()
		{
			TrimLeft();
			if (cursor >= content.Length)
			{
				cursor++;
				return new Token(TokenType.End);
			}
			switch (content[cursor])
			{
			case '\n':
				cursor++;
				return new Token(TokenType.EmptyLine);
			case '#':
			{
				cursor++;
				int startIndex = cursor;
				while (cursor < content.Length && content[cursor] != '\n')
				{
					cursor++;
				}
				cursor++;
				return new Token(TokenType.Comment, content.Substring(startIndex, cursor));
			}
			case '[':
			{
				cursor++;
				int num2 = cursor;
				while (cursor < content.Length)
				{
					if (content[cursor] == ']')
					{
						string text = content.Substring(num2, cursor - num2);
						while (cursor < content.Length)
						{
							cursor++;
							if (cursor >= content.Length)
							{
								break;
							}
							char c = content[cursor];
							if (c == '\n')
							{
								cursor++;
								break;
							}
							if (!char.IsWhiteSpace(c))
							{
								break;
							}
						}
						return new Token(TokenType.Instructor, text);
					}
					if (content[cursor] == '\n')
					{
						cursor++;
						return new Token(TokenType.Invalid, content.Substring(num2, cursor - num2));
					}
					cursor++;
				}
				return new Token(TokenType.Invalid, content.Substring(num2 - 1));
			}
			default:
			{
				int num = cursor;
				string raw;
				while (cursor < content.Length)
				{
					switch (content[cursor])
					{
					case '\n':
						raw = content.Substring(num, cursor - num);
						cursor++;
						return new Token(TokenType.String, ConvertEscapes(raw));
					case '#':
						raw = content.Substring(num, cursor - num);
						return new Token(TokenType.String, ConvertEscapes(raw));
					}
					cursor++;
				}
				raw = content.Substring(num, cursor - num);
				return new Token(TokenType.String, ConvertEscapes(raw));
			}
			}
		}

		private string ConvertEscapes(string raw)
		{
			return raw.Replace("\\n", "\n");
		}

		public IEnumerator<Token> GetEnumerator()
		{
			while (cursor < content.Length)
			{
				yield return Next();
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public class EmptyEntry : MonoBehaviour
	{
		[SerializeField]
		private LayoutElement layoutElement;

		[SerializeField]
		private float defaultWidth;

		[SerializeField]
		private float defaultHeight;

		public void Setup(params string[] args)
		{
			layoutElement.preferredWidth = defaultWidth;
			layoutElement.preferredHeight = defaultHeight;
			if (args == null)
			{
				return;
			}
			for (int i = 0; i < args.Length; i++)
			{
				if (i == 1)
				{
					TrySetWidth(args[i]);
				}
				if (i == 2)
				{
					TrySetHeight(args[i]);
				}
			}
		}

		private void TrySetWidth(string v)
		{
			if (float.TryParse(v, out var result))
			{
				layoutElement.preferredWidth = result;
			}
		}

		private void TrySetHeight(string v)
		{
			if (float.TryParse(v, out var result))
			{
				layoutElement.preferredHeight = result;
			}
		}
	}
	public class HorizontalEntry : MonoBehaviour
	{
		public void Setup(params string[] args)
		{
		}
	}
	public class ImageEntry : MonoBehaviour
	{
		[SerializeField]
		private UnityEngine.UI.Image image;

		[SerializeField]
		private LayoutElement layoutElement;

		internal void Setup(string[] elements)
		{
			if (elements.Length < 2)
			{
				return;
			}
			for (int i = 0; i < elements.Length; i++)
			{
				switch (i)
				{
				case 1:
				{
					string text = elements[1];
					Sprite sprite = GameplayDataSettings.GetSprite(text);
					if (sprite == null)
					{
						UnityEngine.Debug.LogError("Cannot find sprite:" + text);
					}
					else
					{
						image.sprite = sprite;
					}
					break;
				}
				case 2:
				{
					if (float.TryParse(elements[2], out var result2))
					{
						layoutElement.preferredHeight = result2;
					}
					break;
				}
				case 3:
				{
					if (float.TryParse(elements[2], out var result))
					{
						layoutElement.preferredWidth = result;
					}
					break;
				}
				}
			}
		}
	}
	public class TextEntry : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI text;

		public int defaultSize = 26;

		internal void Setup(string text, Color color, int size = -1, bool bold = false)
		{
			this.text.text = text;
			if (size < 0)
			{
				size = defaultSize;
			}
			this.text.color = color;
			this.text.fontSize = size;
			this.text.fontStyle = (FontStyles)((int)(this.text.fontStyle & ~FontStyles.Bold) | (bold ? 1 : 0));
		}
	}
	public class VerticalEntry : MonoBehaviour
	{
		[SerializeField]
		private VerticalLayoutGroup layoutGroup;

		[SerializeField]
		private LayoutElement layoutElement;

		public void Setup(params string[] args)
		{
		}

		public void SetLayoutSpacing(float spacing)
		{
			layoutGroup.spacing = spacing;
		}

		public void SetPreferredWidth(float width)
		{
			layoutElement.preferredWidth = width;
		}
	}
}
namespace Duckov.DeathLotteries
{
	public class DeathLottery : MonoBehaviour
	{
		[Serializable]
		private struct dummyItemEntry
		{
			[ItemTypeID]
			public int typeID;
		}

		[Serializable]
		public struct OptionalCosts
		{
			[SerializeField]
			public Cost costA;

			[SerializeField]
			public bool useCostB;

			[SerializeField]
			public Cost costB;
		}

		[Serializable]
		public struct Status
		{
			public bool valid;

			public uint deadCharacterToken;

			public List<int> selectedItems;

			public List<ItemTreeData> candidates;

			public int SelectedCount => selectedItems.Count;
		}

		public const int MaxCandidateCount = 8;

		[SerializeField]
		[LocalizationKey("Default")]
		private string selectNotificationFormatKey = "DeathLottery_SelectNotification";

		[SerializeField]
		private Tag[] requireTags;

		[SerializeField]
		private Tag[] excludeTags;

		[SerializeField]
		private RandomContainer<dummyItemEntry> dummyItems;

		[SerializeField]
		private OptionalCosts[] costs;

		private Status status;

		private List<Item> itemInstances = new List<Item>();

		private bool loading;

		public int MaxChances => costs.Length;

		public static uint CurrentDeadCharacterToken => SavesSystem.Load<uint>("DeadCharacterToken");

		private string SelectNotificationFormat => selectNotificationFormatKey.ToPlainText();

		public OptionalCosts[] Costs => costs;

		public List<Item> ItemInstances => itemInstances;

		public Status CurrentStatus
		{
			get
			{
				if (loading)
				{
					return default(Status);
				}
				if (!status.valid)
				{
					return default(Status);
				}
				return status;
			}
		}

		public int RemainingChances => 0;

		public bool Loading => loading;

		public static event Action<DeathLottery> OnRequestUI;

		public void RequestUI()
		{
			DeathLottery.OnRequestUI?.Invoke(this);
		}

		private async UniTask Load()
		{
			loading = true;
			status = SavesSystem.Load<Status>("DeathLottery/status");
			if (!status.valid)
			{
				await CreateNewStatus();
			}
			else if (status.deadCharacterToken == CurrentDeadCharacterToken)
			{
				await LoadItemInstances();
			}
			else
			{
				await CreateNewStatus();
			}
			loading = false;
		}

		private async UniTask LoadItemInstances()
		{
			ClearItemInstances();
			foreach (ItemTreeData candidate in status.candidates)
			{
				if (candidate != null)
				{
					Item item = await ItemTreeData.InstantiateAsync(candidate);
					itemInstances.Add(item);
					item.transform.SetParent(base.transform);
				}
			}
		}

		private void ClearItemInstances()
		{
			for (int i = 0; i < itemInstances.Count; i++)
			{
				Item item = itemInstances[i];
				if (!(item.ParentItem != null))
				{
					item.DestroyTree();
				}
			}
			itemInstances.Clear();
		}

		[ContextMenu("ForceCreateNewStatus")]
		private void ForceCreateNewStatus()
		{
			if (!Loading)
			{
				ForceCreateNewStatusTask().Forget();
			}
		}

		private async UniTask ForceCreateNewStatusTask()
		{
			loading = true;
			await CreateNewStatus();
			loading = false;
		}

		private async UniTask CreateNewStatus()
		{
			List<ItemTreeData> candidates = new List<ItemTreeData>();
			Item deadCharacter = await ItemSavesUtilities.LoadLastDeadCharacterItem();
			if (deadCharacter == null)
			{
				return;
			}
			List<Item> obj = await SelectCandidates(deadCharacter);
			deadCharacter.DestroyTree();
			ClearItemInstances();
			foreach (Item item2 in obj)
			{
				item2.transform.SetParent(base.transform);
				itemInstances.Add(item2);
				ItemTreeData item = ItemTreeData.FromItem(item2);
				candidates.Add(item);
			}
			status = new Status
			{
				valid = true,
				deadCharacterToken = CurrentDeadCharacterToken,
				selectedItems = new List<int>(),
				candidates = candidates
			};
		}

		private void Awake()
		{
			SavesSystem.OnCollectSaveData += Save;
		}

		private void Start()
		{
			Load().Forget();
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
		}

		private void Save()
		{
			if (!loading)
			{
				SavesSystem.Save("DeathLottery/status", status);
			}
		}

		private async UniTask<List<Item>> SelectCandidates(Item deadCharacter)
		{
			List<Item> candidates = new List<Item>();
			if (deadCharacter.Slots != null)
			{
				foreach (Slot slot in deadCharacter.Slots)
				{
					if (slot == null)
					{
						continue;
					}
					Item content = slot.Content;
					if (content == null || !CanBeACandidate(content))
					{
						continue;
					}
					content.Detach();
					candidates.Add(content);
					if (candidates.Count < 8)
					{
						continue;
					}
					goto IL_0112;
				}
			}
			List<Item> list = new List<Item>();
			foreach (Item item2 in list)
			{
				item2.Detach();
			}
			int amount = 8 - candidates.Count;
			Item[] randomSubSet = list.GetRandomSubSet(amount);
			if (randomSubSet != null)
			{
				candidates.AddRange(randomSubSet);
			}
			goto IL_0112;
			IL_0112:
			int maxAttempts = 100;
			int attempts = 0;
			while (candidates.Count < 8)
			{
				attempts++;
				if (attempts > maxAttempts)
				{
					UnityEngine.Debug.LogError("无法生成candidate");
					break;
				}
				Item item = await ItemAssetsCollection.InstantiateAsync(dummyItems.GetRandom().typeID);
				if (!(item == null))
				{
					candidates.Add(item);
				}
			}
			candidates.RandomizeOrder();
			return candidates;
		}

		private bool CanBeACandidate(Item item)
		{
			if (item == null)
			{
				return false;
			}
			Tag[] array = excludeTags;
			foreach (Tag item2 in array)
			{
				if (item.Tags.Contains(item2))
				{
					return false;
				}
			}
			array = requireTags;
			foreach (Tag item3 in array)
			{
				if (item.Tags.Contains(item3))
				{
					return true;
				}
			}
			return false;
		}

		public async UniTask<bool> Select(int index, Cost payWhenSucceed)
		{
			if (loading)
			{
				return false;
			}
			if (!status.valid)
			{
				return false;
			}
			if (status.SelectedCount >= MaxChances)
			{
				return false;
			}
			if (status.selectedItems.Contains(index))
			{
				return false;
			}
			Item instance = await ItemTreeData.InstantiateAsync(status.candidates[index]);
			if (instance == null)
			{
				return false;
			}
			if (!payWhenSucceed.Enough)
			{
				return false;
			}
			if ((bool)instance.GetComponent<ItemSetting_Gun>())
			{
				Item item = await ItemUtilities.GenerateBullet(instance);
				if (item != null)
				{
					SendToPlayer(item);
				}
			}
			SendToPlayer(instance);
			status.selectedItems.Add(index);
			payWhenSucceed.Pay();
			NotificationText.Push(SelectNotificationFormat.Format(new
			{
				itemName = instance.DisplayName
			}));
			return true;
			static void SendToPlayer(Item item2)
			{
				if (!(item2 == null) && !ItemUtilities.SendToPlayerCharacter(item2))
				{
					ItemUtilities.SendToPlayerStorage(item2);
				}
			}
		}

		internal OptionalCosts GetCost()
		{
			if (!status.valid)
			{
				return default(OptionalCosts);
			}
			if (status.SelectedCount >= Costs.Length)
			{
				return default(OptionalCosts);
			}
			return Costs[status.SelectedCount];
		}
	}
	public class DeathLotteryInteractable : InteractableBase
	{
		[SerializeField]
		private DeathLottery deathLottery;

		protected override bool IsInteractable()
		{
			if (deathLottery == null)
			{
				return false;
			}
			if (!deathLottery.CurrentStatus.valid)
			{
				return false;
			}
			if (deathLottery.Loading)
			{
				return false;
			}
			return true;
		}

		protected override void OnInteractFinished()
		{
			deathLottery.RequestUI();
		}
	}
	public class CardDisplay : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerMoveHandler
	{
		private RectTransform rectTransform;

		[SerializeField]
		private RectTransform cardTransform;

		[SerializeField]
		private FadeGroup frontFadeGroup;

		[SerializeField]
		private FadeGroup backFadeGroup;

		[SerializeField]
		private float idleAmp = 10f;

		[SerializeField]
		private float idleFrequency = 0.5f;

		[SerializeField]
		private float rotateSpeed = 300f;

		[SerializeField]
		private float flipSpeed = 300f;

		private bool facingFront;

		private bool hovering;

		private Vector2 pointerPosition;

		private Rect cachedRect;

		private float cachedRadius;

		private void Awake()
		{
			rectTransform = base.transform as RectTransform;
			RefreshFadeGroups();
		}

		private void CacheRadius()
		{
			cachedRect = rectTransform.rect;
			Rect rect = cachedRect;
			cachedRadius = Mathf.Sqrt(rect.width * rect.width + rect.height * rect.height) / 2f;
		}

		private void Update()
		{
			if (rectTransform.rect != cachedRect)
			{
				CacheRadius();
			}
			HandleAnimation();
		}

		private void HandleAnimation()
		{
			Quaternion rotation = cardTransform.rotation;
			if ((facingFront && !frontFadeGroup.IsShown) || (!facingFront && !backFadeGroup.IsShown))
			{
				rotation = Quaternion.RotateTowards(rotation, Quaternion.Euler(0f, 90f, 0f), flipSpeed * Time.deltaTime);
				if (Mathf.Approximately(Quaternion.Angle(rotation, Quaternion.Euler(0f, 90f, 0f)), 0f))
				{
					rotation = Quaternion.Euler(0f, -90f, 0f);
					RefreshFadeGroups();
				}
			}
			else
			{
				rotation = Quaternion.RotateTowards(rotation, GetIdealRotation(), rotateSpeed * Time.deltaTime);
			}
			cardTransform.rotation = rotation;
		}

		private void OnEnable()
		{
			CacheRadius();
		}

		private Quaternion GetIdealRotation()
		{
			if (rectTransform.rect != cachedRect)
			{
				CacheRadius();
			}
			if (hovering && !Mathf.Approximately(cachedRadius, 0f))
			{
				RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, pointerPosition, null, out var localPoint);
				Vector2 center = rectTransform.rect.center;
				Vector2 vector = localPoint - center;
				float num = Mathf.Max(10f, cachedRadius);
				Vector2 vector2 = Vector2.ClampMagnitude(vector / num, 1f);
				return Quaternion.Euler((0f - vector2.y) * idleAmp, (0f - vector2.x) * idleAmp, 0f);
			}
			return Quaternion.Euler(Mathf.Sin(Time.time * idleFrequency * MathF.PI * 2f) * idleAmp, Mathf.Cos(Time.time * idleFrequency * MathF.PI * 2f) * idleAmp, 0f);
		}

		private void SkipAnimation()
		{
			RefreshFadeGroups();
			cardTransform.rotation = GetIdealRotation();
		}

		public void SetFacing(bool facingFront, bool skipAnimation = false)
		{
			this.facingFront = facingFront;
			if (skipAnimation)
			{
				SkipAnimation();
			}
		}

		public void Flip()
		{
			SetFacing(!facingFront);
		}

		private void RefreshFadeGroups()
		{
			if (facingFront)
			{
				frontFadeGroup.Show();
				backFadeGroup.Hide();
			}
			else
			{
				frontFadeGroup.Hide();
				backFadeGroup.Show();
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			hovering = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			hovering = false;
		}

		public void OnPointerMove(PointerEventData eventData)
		{
			pointerPosition = eventData.position;
		}
	}
	public class DeathLotteryCard : MonoBehaviour, IPointerClickHandler, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler
	{
		[SerializeField]
		private CardDisplay cardDisplay;

		[SerializeField]
		private ItemDisplay itemDisplay;

		[SerializeField]
		private CostDisplay costDisplay;

		[SerializeField]
		private GameObject freeIndicator;

		[SerializeField]
		private FadeGroup costFade;

		[SerializeField]
		private GameObject selectedIndicator;

		private DeathLotteryVIew master;

		private int index;

		private Item targetItem;

		public int Index => index;

		private bool Selected
		{
			get
			{
				if (master == null)
				{
					return false;
				}
				if (master.Target == null)
				{
					return false;
				}
				if (master.Target.CurrentStatus.selectedItems == null)
				{
					return false;
				}
				return master.Target.CurrentStatus.selectedItems.Contains(Index);
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (!(master == null) && !(master.Target == null))
			{
				DeathLottery.OptionalCosts cost = master.Target.GetCost();
				master.NotifyEntryClicked(this, cost.costA);
			}
		}

		public void Setup(DeathLotteryVIew master, int index)
		{
			if (!(master == null) && !(master.Target == null))
			{
				this.master = master;
				targetItem = master.Target.ItemInstances[index];
				this.index = index;
				itemDisplay.Setup(targetItem);
				cardDisplay.SetFacing(master.Target.CurrentStatus.selectedItems.Contains(index), skipAnimation: true);
				Refresh();
			}
		}

		public void NotifyFacing(bool uncovered)
		{
			cardDisplay.SetFacing(uncovered);
			Refresh();
		}

		private void Refresh()
		{
			selectedIndicator.SetActive(Selected);
		}

		private void Awake()
		{
			costFade.Hide();
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (master.Target.CurrentStatus.SelectedCount < master.Target.MaxChances)
			{
				Cost costA = master.Target.GetCost().costA;
				costDisplay.Setup(costA);
				freeIndicator.SetActive(costA.IsFree);
				costFade.Show();
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			costFade.Hide();
		}
	}
	public class DeathLotteryVIew : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[LocalizationKey("Default")]
		[SerializeField]
		private string remainingTextFormatKey = "DeathLottery_Remaining";

		[LocalizationKey("Default")]
		[SerializeField]
		private string noRemainingChances = "DeathLottery_NoRemainingChances";

		[SerializeField]
		private TextMeshProUGUI remainingCountText;

		[SerializeField]
		private DeathLotteryCard[] cards;

		[SerializeField]
		private FadeGroup selectionBusyIndicator;

		private DeathLottery target;

		private UniTask selectTask;

		private string RemainingTextFormat => remainingTextFormatKey.ToPlainText();

		public DeathLottery Target => target;

		public int RemainingChances
		{
			get
			{
				if (Target == null)
				{
					return 0;
				}
				return Target.RemainingChances;
			}
		}

		private bool ProcessingSelection => selectTask.Status == UniTaskStatus.Pending;

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
			selectionBusyIndicator.SkipHide();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		protected override void Awake()
		{
			base.Awake();
			DeathLottery.OnRequestUI += Show;
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			DeathLottery.OnRequestUI -= Show;
		}

		private void Show(DeathLottery target)
		{
			this.target = target;
			Setup();
			Open();
		}

		private void RefreshTexts()
		{
			remainingCountText.text = ((RemainingChances > 0) ? RemainingTextFormat.Format(new
			{
				amount = RemainingChances
			}) : noRemainingChances.ToPlainText());
		}

		private void Setup()
		{
			if (target == null || target.Loading)
			{
				return;
			}
			DeathLottery.Status currentStatus = target.CurrentStatus;
			if (currentStatus.valid)
			{
				for (int i = 0; i < currentStatus.candidates.Count; i++)
				{
					cards[i].Setup(this, i);
				}
				RefreshTexts();
				HandleRemaining();
			}
		}

		internal void NotifyEntryClicked(DeathLotteryCard deathLotteryCard, Cost cost)
		{
			if (!(deathLotteryCard == null) && !ProcessingSelection && RemainingChances > 0)
			{
				int index = deathLotteryCard.Index;
				if (!target.CurrentStatus.selectedItems.Contains(index))
				{
					selectTask = SelectTask(index, cost);
				}
			}
		}

		private async UniTask SelectTask(int index, Cost cost)
		{
			selectionBusyIndicator.Show();
			bool uncovered = await target.Select(index, cost);
			cards[index].NotifyFacing(uncovered);
			RefreshTexts();
			selectionBusyIndicator.Hide();
			HandleRemaining();
		}

		private void HandleRemaining()
		{
			if (RemainingChances <= 0)
			{
				DeathLotteryCard[] array = cards;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].NotifyFacing(uncovered: true);
				}
			}
		}
	}
}
namespace Duckov.BlackMarkets
{
	public class BlackMarket : MonoBehaviour
	{
		public class OnRequestMaxRefreshChanceEventContext
		{
			private int value;

			public int Value => value;

			public void Add(int count = 1)
			{
				value += count;
			}
		}

		public class OnRequestRefreshTimeFactorEventContext
		{
			private float value = 1f;

			public float Value => value;

			public void Add(float count = -0.1f)
			{
				value += count;
			}
		}

		[Serializable]
		public class DemandSupplyEntry
		{
			[SerializeField]
			[ItemTypeID]
			internal int itemID;

			[SerializeField]
			internal int remaining;

			[SerializeField]
			internal float priceFactor;

			[SerializeField]
			internal int batchCount;

			public int ItemID => itemID;

			internal ItemMetaData ItemMetaData => ItemAssetsCollection.GetMetaData(itemID);

			public int Remaining => remaining;

			public int TotalPrice => Mathf.FloorToInt((float)ItemMetaData.priceEach * priceFactor * (float)ItemMetaData.defaultStackCount * (float)batchCount);

			public Cost BuyCost => new Cost(TotalPrice);

			public Cost SellCost => new Cost((ItemMetaData.id, ItemMetaData.defaultStackCount * batchCount));

			public string ItemDisplayName => ItemMetaData.DisplayName;

			public event Action<DemandSupplyEntry> onChanged;

			internal void NotifyChange()
			{
				this.onChanged?.Invoke(this);
			}
		}

		[Serializable]
		public struct SaveData
		{
			public bool valid;

			public long lastRefreshedTimeRaw;

			public int refreshChance;

			public DemandSupplyEntry[] demands;

			public DemandSupplyEntry[] supplies;

			public SaveData(BlackMarket blackMarket)
			{
				valid = true;
				lastRefreshedTimeRaw = blackMarket.lastRefreshedTimeRaw;
				demands = blackMarket.demands.ToArray();
				supplies = blackMarket.supplies.ToArray();
				refreshChance = blackMarket.refreshChance;
			}
		}

		[SerializeField]
		private int demandsCount = 3;

		[SerializeField]
		private int suppliesCount = 3;

		[SerializeField]
		private List<Tag> excludeTags;

		[SerializeField]
		private RandomContainer<Tag> tags;

		[SerializeField]
		private RandomContainer<int> qualities;

		[SerializeField]
		private RandomContainer<int> demandAmountRand;

		[SerializeField]
		private RandomContainer<float> demandFactorRand;

		[SerializeField]
		private RandomContainer<int> demandBatchCountRand;

		[SerializeField]
		private RandomContainer<int> supplyAmountRand;

		[SerializeField]
		private RandomContainer<float> supplyFactorRand;

		[SerializeField]
		private RandomContainer<int> supplyBatchCountRand;

		[SerializeField]
		[TimeSpan]
		private long timeToRefresh;

		[SerializeField]
		private int refreshChance;

		private static bool dirty = true;

		private int cachedMaxRefreshChance = -1;

		[DateTime]
		private long lastRefreshedTimeRaw;

		private List<DemandSupplyEntry> demands = new List<DemandSupplyEntry>();

		private List<DemandSupplyEntry> supplies = new List<DemandSupplyEntry>();

		private ReadOnlyCollection<DemandSupplyEntry> _demands_readonly;

		private ReadOnlyCollection<DemandSupplyEntry> _supplies_readonly;

		private const string SaveKey = "BlackMarket_Data";

		public static BlackMarket Instance { get; private set; }

		public int RefreshChance
		{
			get
			{
				return Mathf.Min(refreshChance, MaxRefreshChance);
			}
			set
			{
				refreshChance = value;
				BlackMarket.onRefreshChanceChanged?.Invoke(this);
			}
		}

		public int MaxRefreshChance
		{
			get
			{
				if (dirty)
				{
					OnRequestMaxRefreshChanceEventContext onRequestMaxRefreshChanceEventContext = new OnRequestMaxRefreshChanceEventContext();
					onRequestMaxRefreshChanceEventContext.Add();
					BlackMarket.onRequestMaxRefreshChance?.Invoke(onRequestMaxRefreshChanceEventContext);
					cachedMaxRefreshChance = onRequestMaxRefreshChanceEventContext.Value;
				}
				return cachedMaxRefreshChance;
			}
		}

		private TimeSpan TimeToRefresh
		{
			get
			{
				OnRequestRefreshTimeFactorEventContext onRequestRefreshTimeFactorEventContext = new OnRequestRefreshTimeFactorEventContext();
				BlackMarket.onRequestRefreshTime?.Invoke(onRequestRefreshTimeFactorEventContext);
				float num = Mathf.Max(onRequestRefreshTimeFactorEventContext.Value, 0.01f);
				return TimeSpan.FromTicks((long)((float)timeToRefresh * num));
			}
		}

		private DateTime LastRefreshedTime
		{
			get
			{
				return DateTime.FromBinary(lastRefreshedTimeRaw);
			}
			set
			{
				lastRefreshedTimeRaw = value.ToBinary();
			}
		}

		private TimeSpan TimeSinceLastRefreshedTime
		{
			get
			{
				if (DateTime.UtcNow < LastRefreshedTime)
				{
					LastRefreshedTime = DateTime.UtcNow;
				}
				return DateTime.UtcNow - LastRefreshedTime;
			}
		}

		public TimeSpan RemainingTimeBeforeRefresh => TimeToRefresh - TimeSinceLastRefreshedTime;

		public ReadOnlyCollection<DemandSupplyEntry> Demands
		{
			get
			{
				if (_demands_readonly == null)
				{
					_demands_readonly = new ReadOnlyCollection<DemandSupplyEntry>(demands);
				}
				return _demands_readonly;
			}
		}

		public ReadOnlyCollection<DemandSupplyEntry> Supplies
		{
			get
			{
				if (_supplies_readonly == null)
				{
					_supplies_readonly = new ReadOnlyCollection<DemandSupplyEntry>(supplies);
				}
				return _supplies_readonly;
			}
		}

		public static event Action<BlackMarket> onRefreshChanceChanged;

		public static event Action<OnRequestMaxRefreshChanceEventContext> onRequestMaxRefreshChance;

		public static event Action<OnRequestRefreshTimeFactorEventContext> onRequestRefreshTime;

		public event Action onAfterGenerateEntries;

		public static void NotifyMaxRefreshChanceChanged()
		{
			dirty = true;
		}

		private ItemFilter ContructRandomFilter()
		{
			Tag random = tags.GetRandom();
			int random2 = qualities.GetRandom();
			if (GameMetaData.Instance.IsDemo)
			{
				excludeTags.Add(GameplayDataSettings.Tags.LockInDemoTag);
			}
			return new ItemFilter
			{
				requireTags = new Tag[1] { random },
				excludeTags = excludeTags.ToArray(),
				minQuality = random2,
				maxQuality = random2
			};
		}

		public async UniTask<bool> Buy(DemandSupplyEntry entry)
		{
			if (entry == null)
			{
				return false;
			}
			if (entry.remaining <= 0)
			{
				return false;
			}
			if (!supplies.Contains(entry))
			{
				return false;
			}
			if (!entry.BuyCost.Pay())
			{
				return false;
			}
			await entry.SellCost.Return(directToBuffer: true);
			entry.remaining--;
			entry.NotifyChange();
			return true;
		}

		public async UniTask<bool> Sell(DemandSupplyEntry entry)
		{
			if (entry == null)
			{
				return false;
			}
			if (entry.remaining <= 0)
			{
				return false;
			}
			if (!demands.Contains(entry))
			{
				return false;
			}
			if (!entry.SellCost.Pay())
			{
				return false;
			}
			await entry.BuyCost.Return();
			entry.remaining--;
			entry.NotifyChange();
			return true;
		}

		private void GenerateDemandsAndSupplies()
		{
			demands.Clear();
			supplies.Clear();
			int num = 0;
			for (int i = 0; i < demandsCount; i++)
			{
				num++;
				if (num > 100)
				{
					UnityEngine.Debug.LogError("黑市构建需求失败。尝试次数超过100次。");
					break;
				}
				int[] array = ItemAssetsCollection.Search(ContructRandomFilter());
				if (array.Length == 0)
				{
					i--;
					continue;
				}
				int random = array.GetRandom();
				ItemAssetsCollection.GetMetaData(random);
				int random2 = demandAmountRand.GetRandom();
				float random3 = demandFactorRand.GetRandom();
				int random4 = demandBatchCountRand.GetRandom();
				DemandSupplyEntry item = new DemandSupplyEntry
				{
					itemID = random,
					remaining = random2,
					priceFactor = random3,
					batchCount = random4
				};
				demands.Add(item);
			}
			num = 0;
			for (int j = 0; j < suppliesCount; j++)
			{
				num++;
				if (num > 100)
				{
					UnityEngine.Debug.LogError("黑市构建供应失败。尝试次数超过100次。");
					break;
				}
				int[] array2 = ItemAssetsCollection.Search(ContructRandomFilter());
				if (array2.Length == 0)
				{
					j--;
					continue;
				}
				int candidate = array2.GetRandom();
				if (demands.Any((DemandSupplyEntry e) => e.ItemID == candidate))
				{
					j--;
					continue;
				}
				ItemAssetsCollection.GetMetaData(candidate);
				int random5 = supplyAmountRand.GetRandom();
				float random6 = supplyFactorRand.GetRandom();
				int random7 = supplyBatchCountRand.GetRandom();
				DemandSupplyEntry item2 = new DemandSupplyEntry
				{
					itemID = candidate,
					remaining = random5,
					priceFactor = random6,
					batchCount = random7
				};
				supplies.Add(item2);
			}
			this.onAfterGenerateEntries?.Invoke();
			if (LevelManager.LevelInited)
			{
				LevelManager.Instance.SaveMainCharacter();
				SavesSystem.CollectSaveData();
				SavesSystem.SaveFile();
			}
		}

		public void PayAndRegenerate()
		{
			if (RefreshChance > 0)
			{
				RefreshChance--;
				GenerateDemandsAndSupplies();
			}
		}

		private void FixedUpdate()
		{
			if (RefreshChance >= MaxRefreshChance)
			{
				LastRefreshedTime = DateTime.UtcNow;
				return;
			}
			TimeSpan timeSinceLastRefreshedTime = TimeSinceLastRefreshedTime;
			if (!(timeSinceLastRefreshedTime > TimeToRefresh))
			{
				return;
			}
			while (timeSinceLastRefreshedTime > TimeToRefresh)
			{
				timeSinceLastRefreshedTime -= TimeToRefresh;
				RefreshChance++;
				if (RefreshChance >= MaxRefreshChance)
				{
					break;
				}
			}
			if (timeSinceLastRefreshedTime > TimeSpan.Zero)
			{
				LastRefreshedTime = DateTime.UtcNow - timeSinceLastRefreshedTime;
			}
		}

		private void Awake()
		{
			Instance = this;
			SavesSystem.OnCollectSaveData += Save;
		}

		private void Start()
		{
			Load();
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
		}

		private void Save()
		{
			SaveData value = new SaveData(this);
			SavesSystem.Save("BlackMarket_Data", value);
		}

		private void Load()
		{
			SaveData saveData = SavesSystem.Load<SaveData>("BlackMarket_Data");
			if (!saveData.valid)
			{
				GenerateDemandsAndSupplies();
				return;
			}
			demands.Clear();
			demands.AddRange(saveData.demands);
			supplies.Clear();
			supplies.AddRange(saveData.supplies);
			lastRefreshedTimeRaw = saveData.lastRefreshedTimeRaw;
			refreshChance = saveData.refreshChance;
		}
	}
}
namespace Duckov.BlackMarkets.UI
{
	public class BlackMarketView : View
	{
		public enum Mode
		{
			None,
			Demand,
			Supply
		}

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private DemandPanel demandPanel;

		[SerializeField]
		private SupplyPanel supplyPanel;

		[SerializeField]
		private TextMeshProUGUI refreshETAText;

		[SerializeField]
		private TextMeshProUGUI refreshChanceText;

		[SerializeField]
		private UnityEngine.UI.Button btn_demandPanel;

		[SerializeField]
		private UnityEngine.UI.Button btn_supplyPanel;

		[SerializeField]
		private UnityEngine.UI.Button btn_refresh;

		[SerializeField]
		private GameObject refreshInteractableIndicator;

		private Mode mode;

		public static BlackMarketView Instance => View.GetViewInstance<BlackMarketView>();

		protected override bool ShowOpenCloseButtons => false;

		public BlackMarket Target { get; private set; }

		private bool ShowDemand => (Mode.Demand | mode) == mode;

		private bool ShowSupply => (Mode.Supply | mode) == mode;

		protected override void Awake()
		{
			base.Awake();
			btn_demandPanel.onClick.AddListener(delegate
			{
				SetMode(Mode.Demand);
			});
			btn_supplyPanel.onClick.AddListener(delegate
			{
				SetMode(Mode.Supply);
			});
			btn_refresh.onClick.AddListener(OnRefreshBtnClicked);
		}

		private void OnEnable()
		{
			BlackMarket.onRefreshChanceChanged += OnRefreshChanceChanced;
		}

		private void OnDisable()
		{
			BlackMarket.onRefreshChanceChanged -= OnRefreshChanceChanced;
		}

		private void OnRefreshChanceChanced(BlackMarket market)
		{
			RefreshRefreshButton();
		}

		private void RefreshRefreshButton()
		{
			if (Target == null)
			{
				refreshChanceText.text = "ERROR";
				refreshInteractableIndicator.SetActive(value: false);
			}
			int refreshChance = Target.RefreshChance;
			int maxRefreshChance = Target.MaxRefreshChance;
			refreshChanceText.text = $"{refreshChance}/{maxRefreshChance}";
			refreshInteractableIndicator.SetActive(refreshChance > 0);
		}

		private void OnRefreshBtnClicked()
		{
			if (!(Target == null))
			{
				Target.PayAndRegenerate();
			}
		}

		public static void Show(Mode mode)
		{
			if (!(Instance == null) && !(BlackMarket.Instance == null))
			{
				Instance.Setup(BlackMarket.Instance, mode);
				Instance.Open();
			}
		}

		private void Setup(BlackMarket target, Mode mode)
		{
			Target = target;
			demandPanel.Setup(target);
			supplyPanel.Setup(target);
			RefreshRefreshButton();
			SetMode(mode);
			Open();
		}

		private void SetMode(Mode mode)
		{
			this.mode = mode;
			demandPanel.gameObject.SetActive(ShowDemand);
			supplyPanel.gameObject.SetActive(ShowSupply);
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		private void Update()
		{
			if (!(Target == null))
			{
				int refreshChance = Target.RefreshChance;
				int maxRefreshChance = Target.MaxRefreshChance;
				string text;
				if (refreshChance < maxRefreshChance)
				{
					TimeSpan remainingTimeBeforeRefresh = Target.RemainingTimeBeforeRefresh;
					text = $"{Mathf.FloorToInt((float)remainingTimeBeforeRefresh.TotalHours):00}:{remainingTimeBeforeRefresh.Minutes:00}:{remainingTimeBeforeRefresh.Seconds:00}";
				}
				else
				{
					text = "--:--:--";
				}
				refreshETAText.text = text;
			}
		}
	}
	public class DemandPanel : MonoBehaviour
	{
		[SerializeField]
		private DemandPanel_Entry entryTemplate;

		private PrefabPool<DemandPanel_Entry> _entryPool;

		public BlackMarket Target { get; private set; }

		private PrefabPool<DemandPanel_Entry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<DemandPanel_Entry>(entryTemplate, null, null, null, null, collectionCheck: true, 10, 10000, OnCreateEntry);
				}
				return _entryPool;
			}
		}

		private void OnCreateEntry(DemandPanel_Entry entry)
		{
			entry.onDealButtonClicked += OnEntryClicked;
		}

		private void OnEntryClicked(DemandPanel_Entry entry)
		{
			Target.Sell(entry.Target);
		}

		internal void Setup(BlackMarket target)
		{
			if (target == null)
			{
				UnityEngine.Debug.LogError("加载 BlackMarket 的 DemandPanel 失败。Black Market 对象不存在。");
				return;
			}
			Target = target;
			Refresh();
			if (base.isActiveAndEnabled)
			{
				RegisterEvents();
			}
		}

		private void OnEnable()
		{
			RegisterEvents();
			Refresh();
		}

		private void OnDisable()
		{
			UnregsiterEvents();
		}

		private void Refresh()
		{
			if (Target == null)
			{
				return;
			}
			EntryPool.ReleaseAll();
			foreach (BlackMarket.DemandSupplyEntry demand in Target.Demands)
			{
				EntryPool.Get().Setup(demand);
			}
		}

		private void UnregsiterEvents()
		{
			if (!(Target == null))
			{
				Target.onAfterGenerateEntries -= OnAfterTargetGenerateEntries;
			}
		}

		private void RegisterEvents()
		{
			if (!(Target == null))
			{
				UnregsiterEvents();
				Target.onAfterGenerateEntries += OnAfterTargetGenerateEntries;
			}
		}

		private void OnAfterTargetGenerateEntries()
		{
			Refresh();
		}
	}
	public class DemandPanel_Entry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		[SerializeField]
		private TextMeshProUGUI titleDisplay;

		[SerializeField]
		private CostDisplay costDisplay;

		[SerializeField]
		private TextMeshProUGUI moneyDisplay;

		[SerializeField]
		private GameObject remainingInfoContainer;

		[SerializeField]
		private TextMeshProUGUI remainingAmountDisplay;

		[SerializeField]
		private GameObject canInteractIndicator;

		[SerializeField]
		private GameObject outOfStockIndicator;

		[SerializeField]
		[LocalizationKey("UIText")]
		private string titleFormatKey_Normal = "BlackMarket_Demand_Title_Normal";

		[SerializeField]
		[LocalizationKey("UIText")]
		private string titleFormatKey_High = "BlackMarket_Demand_Title_High";

		[SerializeField]
		private UnityEngine.UI.Button dealButton;

		public BlackMarket.DemandSupplyEntry Target { get; private set; }

		private string TitleFormatKey
		{
			get
			{
				if (Target == null)
				{
					return "?";
				}
				if (Target.priceFactor >= 1.9f)
				{
					return titleFormatKey_High;
				}
				return titleFormatKey_Normal;
			}
		}

		private string TitleText
		{
			get
			{
				if (Target == null)
				{
					return "?";
				}
				return TitleFormatKey.ToPlainText().Format(new
				{
					itemName = Target.ItemDisplayName
				});
			}
		}

		public event Action<DemandPanel_Entry> onDealButtonClicked;

		private bool CanInteract()
		{
			if (Target == null)
			{
				return false;
			}
			if (Target.remaining <= 0)
			{
				return false;
			}
			return Target.SellCost.Enough;
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			if (Target != null)
			{
				Target.onChanged -= OnChanged;
			}
		}

		private void OnChanged(BlackMarket.DemandSupplyEntry entry)
		{
			Refresh();
		}

		public void OnDealButtonClicked()
		{
			this.onDealButtonClicked?.Invoke(this);
		}

		internal void Setup(BlackMarket.DemandSupplyEntry target)
		{
			if (target == null)
			{
				UnityEngine.Debug.LogError("找不到对象", base.gameObject);
				return;
			}
			Target = target;
			costDisplay.Setup(target.SellCost);
			moneyDisplay.text = $"{target.TotalPrice}";
			titleDisplay.text = TitleText;
			Refresh();
			target.onChanged += OnChanged;
		}

		private void OnEnable()
		{
			ItemUtilities.OnPlayerItemOperation += Refresh;
		}

		private void OnDisable()
		{
			ItemUtilities.OnPlayerItemOperation -= Refresh;
		}

		private void Awake()
		{
			dealButton.onClick.AddListener(OnDealButtonClicked);
		}

		private void Refresh()
		{
			if (Target == null)
			{
				UnityEngine.Debug.LogError("找不到对象", base.gameObject);
				return;
			}
			remainingAmountDisplay.text = $"{Target.Remaining}";
			bool active = CanInteract();
			canInteractIndicator.SetActive(active);
			bool active2 = Target.Remaining <= 0;
			outOfStockIndicator.SetActive(active2);
			remainingInfoContainer.SetActive(Target.remaining > 1);
		}
	}
	public class SupplyPanel : MonoBehaviour
	{
		[SerializeField]
		private SupplyPanel_Entry entryTemplate;

		private PrefabPool<SupplyPanel_Entry> _entryPool;

		public BlackMarket Target { get; private set; }

		private PrefabPool<SupplyPanel_Entry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<SupplyPanel_Entry>(entryTemplate, null, null, null, null, collectionCheck: true, 10, 10000, OnCreateEntry);
				}
				return _entryPool;
			}
		}

		private void OnCreateEntry(SupplyPanel_Entry entry)
		{
			entry.onDealButtonClicked += OnEntryClicked;
		}

		private void OnEntryClicked(SupplyPanel_Entry entry)
		{
			UnityEngine.Debug.Log("Supply entry clicked");
			Target.Buy(entry.Target);
		}

		internal void Setup(BlackMarket target)
		{
			if (target == null)
			{
				UnityEngine.Debug.LogError("加载 BlackMarket 的 Supply Panel 失败。Black Market 对象不存在。");
				return;
			}
			Target = target;
			Refresh();
			if (base.isActiveAndEnabled)
			{
				RegisterEvents();
			}
		}

		private void OnEnable()
		{
			RegisterEvents();
			Refresh();
		}

		private void OnDisable()
		{
			UnregsiterEvents();
		}

		private void Refresh()
		{
			if (Target == null)
			{
				return;
			}
			EntryPool.ReleaseAll();
			foreach (BlackMarket.DemandSupplyEntry supply in Target.Supplies)
			{
				EntryPool.Get().Setup(supply);
			}
		}

		private void UnregsiterEvents()
		{
			if (!(Target == null))
			{
				Target.onAfterGenerateEntries -= OnAfterTargetGenerateEntries;
			}
		}

		private void RegisterEvents()
		{
			if (!(Target == null))
			{
				UnregsiterEvents();
				Target.onAfterGenerateEntries += OnAfterTargetGenerateEntries;
			}
		}

		private void OnAfterTargetGenerateEntries()
		{
			Refresh();
		}
	}
	public class SupplyPanel_Entry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		[SerializeField]
		private TextMeshProUGUI titleDisplay;

		[SerializeField]
		private CostDisplay costDisplay;

		[SerializeField]
		private ItemAmountDisplay resultDisplay;

		[SerializeField]
		private GameObject remainingInfoContainer;

		[SerializeField]
		private TextMeshProUGUI remainingAmountDisplay;

		[SerializeField]
		private GameObject canInteractIndicator;

		[SerializeField]
		private GameObject outOfStockIndicator;

		[SerializeField]
		[LocalizationKey("UIText")]
		private string titleFormatKey_Normal = "BlackMarket_Supply_Title_Normal";

		[SerializeField]
		[LocalizationKey("UIText")]
		private string titleFormatKey_Low = "BlackMarket_Supply_Title_Low";

		[SerializeField]
		private UnityEngine.UI.Button dealButton;

		public BlackMarket.DemandSupplyEntry Target { get; private set; }

		private string TitleFormatKey
		{
			get
			{
				if (Target == null)
				{
					return "?";
				}
				if (Target.priceFactor <= 0.9f)
				{
					return titleFormatKey_Low;
				}
				return titleFormatKey_Normal;
			}
		}

		private string TitleText
		{
			get
			{
				if (Target == null)
				{
					return "?";
				}
				return TitleFormatKey.ToPlainText().Format(new
				{
					itemName = Target.ItemDisplayName
				});
			}
		}

		public event Action<SupplyPanel_Entry> onDealButtonClicked;

		private bool CanInteract()
		{
			if (Target == null)
			{
				return false;
			}
			if (Target.remaining <= 0)
			{
				return false;
			}
			return Target.BuyCost.Enough;
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			if (Target != null)
			{
				Target.onChanged -= OnChanged;
			}
		}

		private void OnChanged(BlackMarket.DemandSupplyEntry entry)
		{
			Refresh();
		}

		internal void Setup(BlackMarket.DemandSupplyEntry target)
		{
			if (target == null)
			{
				UnityEngine.Debug.LogError("找不到对象", base.gameObject);
				return;
			}
			Target = target;
			costDisplay.Setup(target.BuyCost);
			resultDisplay.Setup(target.ItemID, target.ItemMetaData.defaultStackCount);
			titleDisplay.text = TitleText;
			Refresh();
			target.onChanged += OnChanged;
		}

		private void OnEnable()
		{
			ItemUtilities.OnPlayerItemOperation += Refresh;
		}

		private void OnDisable()
		{
			ItemUtilities.OnPlayerItemOperation -= Refresh;
		}

		private void Awake()
		{
			dealButton.onClick.AddListener(OnDealButtonClicked);
		}

		private void OnDealButtonClicked()
		{
			this.onDealButtonClicked?.Invoke(this);
		}

		private void Refresh()
		{
			if (Target == null)
			{
				UnityEngine.Debug.LogError("找不到对象", base.gameObject);
				return;
			}
			remainingAmountDisplay.text = $"{Target.Remaining}";
			bool active = CanInteract();
			canInteractIndicator.SetActive(active);
			bool active2 = Target.Remaining <= 0;
			outOfStockIndicator.SetActive(active2);
			remainingInfoContainer.SetActive(Target.remaining > 1);
		}
	}
}
namespace Duckov.Bitcoins
{
	public class BitcoinMiner : MonoBehaviour
	{
		[Serializable]
		private struct SaveData
		{
			public ItemTreeData itemData;

			public double work;

			public float cachedPerformance;

			public long lastUpdateDateTimeRaw;
		}

		[SerializeField]
		[ItemTypeID]
		private int minerItemID = 397;

		[SerializeField]
		[ItemTypeID]
		private int coinItemID = 388;

		[SerializeField]
		private double workPerCoin = 1.0;

		private Item item;

		private double work;

		private static readonly double wps_1 = 2.3148148148148147E-05;

		private static readonly double wps_12 = 5.555555555555556E-05;

		private static double? _cached_k;

		[DateTime]
		private long lastUpdateDateTimeRaw;

		private float cachedPerformance;

		public const string SaveKey = "BitcoinMiner_Data";

		private const string PerformaceStatKey = "Performance";

		public static BitcoinMiner Instance { get; private set; }

		private double Progress => work;

		private static double K_1_12
		{
			get
			{
				if (!_cached_k.HasValue)
				{
					_cached_k = (wps_12 - wps_1) / 11.0;
				}
				return _cached_k.Value;
			}
		}

		public double WorkPerSecond
		{
			get
			{
				if (IsInventoryFull)
				{
					return 0.0;
				}
				if (cachedPerformance < 1f)
				{
					return (double)cachedPerformance * wps_1;
				}
				return wps_1 + (double)(cachedPerformance - 1f) * K_1_12;
			}
		}

		public double HoursPerCoin => workPerCoin / 3600.0 / WorkPerSecond;

		public bool IsInventoryFull
		{
			get
			{
				if (item == null)
				{
					return false;
				}
				return item.Inventory.GetFirstEmptyPosition() < 0;
			}
		}

		public TimeSpan TimePerCoin
		{
			get
			{
				if (WorkPerSecond > 0.0)
				{
					return TimeSpan.FromSeconds(workPerCoin / WorkPerSecond);
				}
				return TimeSpan.MaxValue;
			}
		}

		public TimeSpan RemainingTime
		{
			get
			{
				if (WorkPerSecond > 0.0)
				{
					return TimeSpan.FromSeconds((workPerCoin - work) / WorkPerSecond);
				}
				return TimeSpan.MaxValue;
			}
		}

		private DateTime LastUpdateDateTime
		{
			get
			{
				DateTime dateTime = DateTime.FromBinary(lastUpdateDateTimeRaw);
				if (dateTime > DateTime.UtcNow)
				{
					lastUpdateDateTimeRaw = DateTime.UtcNow.ToBinary();
					dateTime = DateTime.UtcNow;
					GameManager.TimeTravelDetected();
				}
				return dateTime;
			}
			set
			{
				lastUpdateDateTimeRaw = value.ToBinary();
			}
		}

		public bool Loading { get; private set; }

		public bool Initialized { get; private set; }

		public bool CreatingCoin { get; private set; }

		public Item Item => item;

		public float NormalizedProgress => (float)(work / workPerCoin);

		public double Performance
		{
			get
			{
				if (Item == null)
				{
					return 0.0;
				}
				return Item.GetStatValue("Performance".GetHashCode());
			}
		}

		private void Awake()
		{
			if (Instance != null)
			{
				UnityEngine.Debug.LogError("存在多个BitcoinMiner");
				return;
			}
			Instance = this;
			SavesSystem.OnCollectSaveData += Save;
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
		}

		private void Start()
		{
			Load();
		}

		private async UniTask Setup(SaveData data)
		{
			if (Loading)
			{
				UnityEngine.Debug.LogError("已经在加载中");
				return;
			}
			Loading = true;
			item = await ItemTreeData.InstantiateAsync(data.itemData);
			item.transform.SetParent(base.transform);
			work = data.work;
			lastUpdateDateTimeRaw = data.lastUpdateDateTimeRaw;
			cachedPerformance = data.cachedPerformance;
			Loading = false;
			Initialized = true;
		}

		private async UniTask Initialize()
		{
			if (Loading)
			{
				UnityEngine.Debug.LogError("已经在加载中");
				return;
			}
			Loading = true;
			item = await ItemAssetsCollection.InstantiateAsync(minerItemID);
			item.transform.SetParent(base.transform);
			work = 0.0;
			cachedPerformance = 0f;
			LastUpdateDateTime = DateTime.UtcNow;
			Loading = false;
			Initialized = true;
		}

		private void Load()
		{
			if (SavesSystem.KeyExisits("BitcoinMiner_Data"))
			{
				SaveData data = SavesSystem.Load<SaveData>("BitcoinMiner_Data");
				Setup(data).Forget();
			}
			else
			{
				Initialize().Forget();
			}
		}

		private void Save()
		{
			if (!Loading && Initialized)
			{
				SaveData value = new SaveData
				{
					itemData = ItemTreeData.FromItem(item),
					work = work,
					lastUpdateDateTimeRaw = lastUpdateDateTimeRaw,
					cachedPerformance = cachedPerformance
				};
				SavesSystem.Save("BitcoinMiner_Data", value);
			}
		}

		private void UpdateWork()
		{
			if (Loading || !Initialized)
			{
				return;
			}
			double totalSeconds = (DateTime.UtcNow - LastUpdateDateTime).TotalSeconds;
			double num = WorkPerSecond * totalSeconds;
			bool isInventoryFull = IsInventoryFull;
			if (work < 0.0)
			{
				work = 0.0;
			}
			work += num;
			if (work >= workPerCoin && !CreatingCoin)
			{
				if (!isInventoryFull)
				{
					CreateCoin().Forget();
				}
				else
				{
					work = workPerCoin;
				}
			}
			cachedPerformance = item.GetStatValue("Performance".GetHashCode());
			LastUpdateDateTime = DateTime.UtcNow;
		}

		private async UniTask CreateCoin()
		{
			if (!CreatingCoin)
			{
				CreatingCoin = true;
				Item item = await ItemAssetsCollection.InstantiateAsync(coinItemID);
				this.item.Inventory.AddAndMerge(item);
				work -= workPerCoin;
				CreatingCoin = false;
			}
		}

		private void FixedUpdate()
		{
			UpdateWork();
		}
	}
}
namespace Duckov.BasketBalls
{
	public class Basket : MonoBehaviour
	{
		[SerializeField]
		private Animator netAnimator;

		[SerializeField]
		private List<Condition> conditions = new List<Condition>();

		[SerializeField]
		private BasketTrigger trigger;

		public UnityEvent<BasketBall> onGoal;

		private void Awake()
		{
			trigger.onGoal.AddListener(OnGoal);
		}

		private void OnGoal(BasketBall ball)
		{
			if (conditions.Satisfied())
			{
				onGoal.Invoke(ball);
				netAnimator.SetTrigger("Goal");
			}
		}
	}
	public class BasketBall : MonoBehaviour
	{
	}
	public class BasketTrigger : MonoBehaviour
	{
		public UnityEvent<BasketBall> onGoal;

		private void OnTriggerEnter(Collider other)
		{
			UnityEngine.Debug.Log("ONTRIGGERENTER:" + other.name);
			BasketBall component = other.GetComponent<BasketBall>();
			if (!(component == null))
			{
				onGoal.Invoke(component);
			}
		}
	}
}
namespace Duckov.Buildings
{
	public class BuildingArea : MonoBehaviour, IDrawGizmos
	{
		[SerializeField]
		private string areaID;

		[SerializeField]
		private Vector2Int size;

		[SerializeField]
		private LayerMask physicsCollisionLayers = -1;

		private List<Building> activeBuildings = new List<Building>();

		private int raycastHitCount;

		private RaycastHit[] raycastHitBuffer = new RaycastHit[5];

		public string AreaID => areaID;

		public Vector2Int Size => size;

		public Vector2Int LowerLeftCorner => CenterCoord - (size - Vector2Int.one);

		private Vector2Int CenterCoord => new Vector2Int(Mathf.RoundToInt(base.transform.position.x), Mathf.RoundToInt(base.transform.position.z));

		private int Width => size.x;

		private int Height => size.y;

		public BuildingManager.BuildingAreaData AreaData => BuildingManager.GetOrCreateAreaData(AreaID);

		public Plane Plane => new Plane(base.transform.up, base.transform.position);

		private void Awake()
		{
			BuildingManager.OnBuildingBuilt += OnBuildingBuilt;
		}

		private void OnDestroy()
		{
			BuildingManager.OnBuildingBuilt -= OnBuildingBuilt;
		}

		private void OnBuildingBuilt(int guid)
		{
			BuildingManager.BuildingData buildingData = BuildingManager.GetBuildingData(guid);
			if (buildingData != null)
			{
				Display(buildingData);
			}
		}

		private void Start()
		{
			RepaintAll();
		}

		public void DrawGizmos()
		{
			if (GizmoContext.InSelection(this))
			{
				int num = CenterCoord.x - (size.x - 1);
				int num2 = CenterCoord.x + (size.x - 1) + 1;
				int num3 = CenterCoord.y - (size.y - 1);
				int num4 = CenterCoord.y + (size.y - 1) + 1;
				Vector3 vector = new Vector3(-0.5f, 0f, -0.5f);
				for (int i = num; i <= num2; i++)
				{
					Drawing.Draw.Line(new Vector3(i, 0f, num3) + vector, new Vector3(i, 0f, num4) + vector);
				}
				for (int j = num3; j <= num4; j++)
				{
					Drawing.Draw.Line(new Vector3(num, 0f, j) + vector, new Vector3(num2, 0f, j) + vector);
				}
			}
		}

		public bool IsPlacementWithinRange(Vector2Int dimensions, BuildingRotation rotation, Vector2Int coord)
		{
			if ((int)rotation % 2 > 0)
			{
				dimensions = new Vector2Int(dimensions.y, dimensions.x);
			}
			coord -= CenterCoord;
			if (coord.x > -size.x && coord.y > -size.y && coord.x + dimensions.x <= size.x)
			{
				return coord.y + dimensions.y <= size.y;
			}
			return false;
		}

		public Vector2Int CursorToCoord(Vector3 point, Vector2Int dimensions, BuildingRotation rotation)
		{
			if ((int)rotation % 2 > 0)
			{
				dimensions = new Vector2Int(dimensions.y, dimensions.x);
			}
			int x = Mathf.RoundToInt(point.x) - dimensions.x / 2;
			int y = Mathf.RoundToInt(point.z) - dimensions.y / 2;
			return new Vector2Int(x, y);
		}

		private void ReleaseAllBuildings()
		{
			for (int num = activeBuildings.Count - 1; num >= 0; num--)
			{
				Building building = activeBuildings[num];
				if (!(building == null))
				{
					UnityEngine.Object.Destroy(building.gameObject);
				}
			}
			activeBuildings.Clear();
		}

		public void RepaintAll()
		{
			ReleaseAllBuildings();
			BuildingManager.BuildingAreaData areaData = AreaData;
			if (areaData == null)
			{
				return;
			}
			foreach (BuildingManager.BuildingData building in areaData.Buildings)
			{
				Display(building);
			}
		}

		private void Display(BuildingManager.BuildingData building)
		{
			if (building == null)
			{
				return;
			}
			Building prefab = building.Info.Prefab;
			if (prefab == null)
			{
				UnityEngine.Debug.LogError("No prefab for building " + building.ID);
				return;
			}
			for (int num = activeBuildings.Count - 1; num >= 0; num--)
			{
				Building building2 = activeBuildings[num];
				if (building2 == null)
				{
					activeBuildings.RemoveAt(num);
				}
				else if (building2.GUID == building.GUID)
				{
					UnityEngine.Debug.LogError($"重复显示建筑{building.Info.DisplayName}({building.GUID})");
					return;
				}
			}
			Building building3 = UnityEngine.Object.Instantiate(prefab, base.transform);
			building3.Setup(building);
			building3.transform.position = building.GetTransformPosition();
			activeBuildings.Add(building3);
			if (building3.unlockAchievement && (bool)AchievementManager.Instance)
			{
				AchievementManager.Instance.Unlock("Building_" + building3.ID.Trim());
			}
		}

		internal Vector3 CoordToWorldPosition(Vector2Int coord, Vector2Int dimensions, BuildingRotation rotation)
		{
			if ((int)rotation % 2 > 0)
			{
				dimensions = new Vector2Int(dimensions.y, dimensions.x);
			}
			return new Vector3((float)coord.x - 0.5f + (float)dimensions.x / 2f, 0f, (float)coord.y - 0.5f + (float)dimensions.y / 2f);
		}

		internal bool PhysicsCollide(Vector2Int dimensions, BuildingRotation rotation, Vector2Int coord, float castBeginHeight = 0f, float castHeight = 2f)
		{
			if ((int)rotation % 2 != 0)
			{
				dimensions = new Vector2Int(dimensions.y, dimensions.x);
			}
			raycastHitCount = 0;
			for (int i = coord.y; i < coord.y + dimensions.y; i++)
			{
				for (int j = coord.x; j < coord.x + dimensions.x; j++)
				{
					Vector3 vector = new Vector3(j, castBeginHeight, i);
					raycastHitCount += Physics.RaycastNonAlloc(vector, Vector3.up, raycastHitBuffer, castHeight, physicsCollisionLayers);
					raycastHitCount += Physics.RaycastNonAlloc(vector + Vector3.up * castHeight, Vector3.down, raycastHitBuffer, castHeight, physicsCollisionLayers);
					if (raycastHitCount > 0)
					{
						return true;
					}
				}
			}
			return false;
		}

		internal Building GetBuildingInstanceAt(Vector2Int coord)
		{
			BuildingManager.BuildingData buildingData = AreaData.GetBuildingAt(coord);
			if (buildingData == null)
			{
				return null;
			}
			return activeBuildings.Find((Building e) => e != null && e.GUID == buildingData.GUID);
		}
	}
	public class Building : MonoBehaviour, IDrawGizmos
	{
		[SerializeField]
		private string id;

		[SerializeField]
		private Vector2Int dimensions;

		[SerializeField]
		private GameObject graphicsContainer;

		[SerializeField]
		private GameObject functionContainer;

		private BuildingManager.BuildingData data;

		public bool unlockAchievement;

		private GameObject areaMesh;

		private int guid => data.GUID;

		public int GUID => guid;

		public string ID => id;

		public Vector2Int Dimensions => dimensions;

		[LocalizationKey("Default")]
		public string DisplayNameKey
		{
			get
			{
				return "Building_" + ID;
			}
			set
			{
			}
		}

		public string DisplayName => DisplayNameKey.ToPlainText();

		[LocalizationKey("Default")]
		public string DescriptionKey
		{
			get
			{
				return "Building_" + ID + "_Desc";
			}
			set
			{
			}
		}

		public string Description => DescriptionKey.ToPlainText();

		public Vector3 GetOffset(BuildingRotation rotation = BuildingRotation.Zero)
		{
			bool num = (int)rotation % 2 != 0;
			float num2 = (num ? dimensions.y : dimensions.x) - 1;
			float num3 = (num ? dimensions.x : dimensions.y) - 1;
			return new Vector3(num2 / 2f, 0f, num3 / 2f);
		}

		public static string GetDisplayName(string id)
		{
			return ("Building_" + id).ToPlainText();
		}

		private void Awake()
		{
			if (graphicsContainer == null)
			{
				UnityEngine.Debug.LogError("建筑" + DisplayName + "未配置 Graphics Container");
				graphicsContainer = base.transform.Find("Graphics")?.gameObject;
			}
			if (functionContainer == null)
			{
				UnityEngine.Debug.LogError("建筑" + DisplayName + "未配置 Function Container");
				functionContainer = base.transform.Find("Function")?.gameObject;
			}
			CreateAreaMesh();
		}

		private void CreateAreaMesh()
		{
			if (areaMesh == null)
			{
				areaMesh = UnityEngine.Object.Instantiate(GameplayDataSettings.Prefabs.BuildingBlockAreaMesh, base.transform);
				areaMesh.transform.localPosition = Vector3.zero;
				areaMesh.transform.localRotation = quaternion.identity;
				areaMesh.transform.localScale = new Vector3((float)dimensions.x - 0.02f, 1f, (float)dimensions.y - 0.02f);
				areaMesh.transform.SetParent(functionContainer.transform, worldPositionStays: true);
			}
		}

		private void RegisterEvents()
		{
			BuildingManager.OnBuildingDestroyed += OnBuildingDestroyed;
		}

		private void OnBuildingDestroyed(int guid)
		{
			if (guid == GUID)
			{
				Release();
			}
		}

		private void Release()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private void UnregisterEvents()
		{
			BuildingManager.OnBuildingDestroyed -= OnBuildingDestroyed;
		}

		public void DrawGizmos()
		{
			if (!GizmoContext.InSelection(this))
			{
				return;
			}
			using (Drawing.Draw.WithColor(new Color(1f, 1f, 1f, 0.5f)))
			{
				using (Drawing.Draw.InLocalSpace(base.transform))
				{
					float3 @float = GetOffset();
					float2 size = new float2(0.9f, 0.9f);
					for (int i = 0; i < Dimensions.y; i++)
					{
						for (int j = 0; j < Dimensions.x; j++)
						{
							Drawing.Draw.SolidPlane(new float3(j, 0f, i) - @float, Vector3.up, size);
						}
					}
				}
			}
		}

		internal void Setup(BuildingManager.BuildingData data)
		{
			this.data = data;
			base.transform.localRotation = Quaternion.Euler(0f, (int)data.Rotation * 90, 0f);
			RegisterEvents();
		}

		private void OnDestroy()
		{
			UnregisterEvents();
		}

		internal void SetupPreview()
		{
			functionContainer.SetActive(value: false);
			Collider[] componentsInChildren = graphicsContainer.GetComponentsInChildren<Collider>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].enabled = false;
			}
		}
	}
	[CreateAssetMenu]
	public class BuildingDataCollection : ScriptableObject
	{
		[SerializeField]
		private List<BuildingInfo> infos = new List<BuildingInfo>();

		[SerializeField]
		private List<Building> prefabs;

		public ReadOnlyCollection<BuildingInfo> readonlyInfos;

		public static BuildingDataCollection Instance => GameplayDataSettings.BuildingDataCollection;

		public ReadOnlyCollection<BuildingInfo> Infos
		{
			get
			{
				if (readonlyInfos == null)
				{
					readonlyInfos = new ReadOnlyCollection<BuildingInfo>(infos);
				}
				return readonlyInfos;
			}
		}

		internal static BuildingInfo GetInfo(string id)
		{
			if (Instance == null)
			{
				return default(BuildingInfo);
			}
			return Instance.infos.FirstOrDefault((BuildingInfo e) => e.id == id);
		}

		internal static Building GetPrefab(string prefabName)
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.prefabs.FirstOrDefault((Building e) => e != null && e.name == prefabName);
		}
	}
	[Serializable]
	public struct BuildingInfo
	{
		public string id;

		public string prefabName;

		public int maxAmount;

		public Cost cost;

		public string[] requireBuildings;

		public string[] alternativeFor;

		public int[] requireQuests;

		public Sprite iconReference;

		public bool Valid => !string.IsNullOrEmpty(id);

		public Building Prefab => BuildingDataCollection.GetPrefab(prefabName);

		public Vector2Int Dimensions
		{
			get
			{
				if (!Prefab)
				{
					return default(Vector2Int);
				}
				return Prefab.Dimensions;
			}
		}

		[LocalizationKey("Default")]
		public string DisplayNameKey => "Building_" + id;

		public string DisplayName => DisplayNameKey.ToPlainText();

		[LocalizationKey("Default")]
		public string DescriptionKey => "Building_" + id + "_Desc";

		public string Description => DescriptionKey.ToPlainText();

		public int CurrentAmount
		{
			get
			{
				if (BuildingManager.Instance == null)
				{
					return 0;
				}
				return BuildingManager.GetBuildingAmount(id);
			}
		}

		public bool ReachedAmountLimit
		{
			get
			{
				if (maxAmount <= 0)
				{
					return false;
				}
				return CurrentAmount >= maxAmount;
			}
		}

		public int TokenAmount
		{
			get
			{
				if (BuildingManager.Instance == null)
				{
					return 0;
				}
				return BuildingManager.Instance.GetTokenAmount(id);
			}
		}

		public static string GetDisplayName(string id)
		{
			return ("Building_" + id).ToPlainText();
		}

		internal bool RequirementsSatisfied()
		{
			string[] array = requireBuildings;
			for (int i = 0; i < array.Length; i++)
			{
				if (!BuildingManager.Any(array[i]))
				{
					return false;
				}
			}
			if (!QuestManager.AreQuestFinished(requireQuests))
			{
				return false;
			}
			return true;
		}
	}
	public class BuildingEffect : MonoBehaviour
	{
		[Serializable]
		public struct ModifierDescription
		{
			public string stat;

			public ModifierType type;

			public float value;
		}

		[SerializeField]
		private string buildingID;

		[SerializeField]
		private List<ModifierDescription> modifierDescriptions = new List<ModifierDescription>();

		private List<Modifier> modifiers = new List<Modifier>();

		private void Awake()
		{
			BuildingManager.OnBuildingListChanged += OnBuildingStatusChanged;
			LevelManager.OnLevelInitialized += OnLevelInitialized;
		}

		private void OnDestroy()
		{
			DisableEffects();
			BuildingManager.OnBuildingListChanged -= OnBuildingStatusChanged;
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void OnLevelInitialized()
		{
			Refresh();
		}

		private void Start()
		{
			Refresh();
		}

		private void OnBuildingStatusChanged()
		{
			Refresh();
		}

		private void Refresh()
		{
			DisableEffects();
			if (IsBuildingConstructed())
			{
				EnableEffects();
			}
		}

		private bool IsBuildingConstructed()
		{
			return BuildingManager.Any(buildingID);
		}

		private void DisableEffects()
		{
			foreach (Modifier modifier in modifiers)
			{
				modifier?.RemoveFromTarget();
			}
			modifiers.Clear();
		}

		private void EnableEffects()
		{
			DisableEffects();
			if (CharacterMainControl.Main == null)
			{
				return;
			}
			foreach (ModifierDescription modifierDescription in modifierDescriptions)
			{
				Apply(modifierDescription);
			}
		}

		private void Apply(ModifierDescription description)
		{
			Stat stat = CharacterMainControl.Main?.CharacterItem?.GetStat(description.stat);
			if (stat != null)
			{
				Modifier modifier = new Modifier(description.type, description.value, this);
				stat.AddModifier(modifier);
				modifiers.Add(modifier);
			}
		}
	}
	public class BuildingManager : MonoBehaviour
	{
		[Serializable]
		public class BuildingTokenAmountEntry
		{
			public string id;

			public int amount;
		}

		[Serializable]
		public class BuildingAreaData
		{
			[SerializeField]
			private string areaID;

			[SerializeField]
			private List<BuildingData> buildings = new List<BuildingData>();

			public string AreaID => areaID;

			public List<BuildingData> Buildings => buildings;

			public bool Any(string buildingID)
			{
				foreach (BuildingData building in buildings)
				{
					if (building != null)
					{
						if (building.ID == buildingID)
						{
							return true;
						}
						if (building.Info.alternativeFor.Contains(buildingID))
						{
							return true;
						}
					}
				}
				return false;
			}

			public bool Add(string buildingID, BuildingRotation rotation, Vector2Int coord, int guid = -1)
			{
				GetBuildingInfo(buildingID);
				if (guid < 0)
				{
					guid = GenerateBuildingGUID(buildingID);
				}
				buildings.Add(new BuildingData(guid, buildingID, rotation, coord));
				return true;
			}

			public bool Remove(int buildingGUID)
			{
				BuildingData buildingData = buildings.Find((BuildingData e) => e != null && e.GUID == buildingGUID);
				if (buildingData != null)
				{
					return buildings.Remove(buildingData);
				}
				return false;
			}

			public bool Remove(BuildingData building)
			{
				return buildings.Remove(building);
			}

			public BuildingData GetBuildingAt(Vector2Int coord)
			{
				foreach (BuildingData building in buildings)
				{
					if (GetOccupyingCoords(building.Dimensions, building.Rotation, building.Coord).Contains(coord))
					{
						return building;
					}
				}
				return null;
			}

			public HashSet<Vector2Int> GetAllOccupiedCoords()
			{
				HashSet<Vector2Int> hashSet = new HashSet<Vector2Int>();
				foreach (BuildingData building in buildings)
				{
					Vector2Int[] occupyingCoords = GetOccupyingCoords(building.Dimensions, building.Rotation, building.Coord);
					hashSet.AddRange(occupyingCoords);
				}
				return hashSet;
			}

			public bool Collide(Vector2Int dimensions, BuildingRotation rotation, Vector2Int coord)
			{
				HashSet<Vector2Int> allOccupiedCoords = GetAllOccupiedCoords();
				Vector2Int[] occupyingCoords = GetOccupyingCoords(dimensions, rotation, coord);
				foreach (Vector2Int item in occupyingCoords)
				{
					if (allOccupiedCoords.Contains(item))
					{
						return true;
					}
				}
				return false;
			}

			internal bool Any(Func<BuildingData, bool> predicate)
			{
				return buildings.Any(predicate);
			}

			public BuildingAreaData()
			{
			}

			public BuildingAreaData(string areaID)
			{
				this.areaID = areaID;
			}
		}

		[Serializable]
		public class BuildingData
		{
			[SerializeField]
			private int guid;

			[SerializeField]
			private string id;

			[SerializeField]
			private Vector2Int coord;

			[SerializeField]
			private BuildingRotation rotation;

			public int GUID => guid;

			public string ID => id;

			public Vector2Int Dimensions => Info.Dimensions;

			public Vector2Int Coord => coord;

			public BuildingRotation Rotation => rotation;

			public BuildingInfo Info => BuildingDataCollection.GetInfo(id);

			public BuildingData(int guid, string id, BuildingRotation rotation, Vector2Int coord)
			{
				this.guid = guid;
				this.id = id;
				this.coord = coord;
				this.rotation = rotation;
			}

			internal Vector3 GetTransformPosition()
			{
				Vector2Int vector2Int = Dimensions;
				if ((int)rotation % 2 > 0)
				{
					vector2Int = new Vector2Int(vector2Int.y, vector2Int.x);
				}
				return new Vector3((float)coord.x - 0.5f + (float)vector2Int.x / 2f, 0f, (float)coord.y - 0.5f + (float)vector2Int.y / 2f);
			}
		}

		[Serializable]
		private struct SaveData
		{
			[SerializeField]
			public List<BuildingAreaData> data;

			[SerializeField]
			public List<BuildingTokenAmountEntry> tokenAmounts;
		}

		private List<BuildingTokenAmountEntry> tokens = new List<BuildingTokenAmountEntry>();

		[SerializeField]
		private List<BuildingAreaData> areas = new List<BuildingAreaData>();

		private const string SaveKey = "BuildingData";

		private static bool returningBuilding;

		public static BuildingManager Instance { get; private set; }

		public List<BuildingAreaData> Areas => areas;

		public static event Action OnBuildingListChanged;

		public static event Action<int> OnBuildingBuilt;

		public static event Action<int> OnBuildingDestroyed;

		public static event Action<int, BuildingInfo> OnBuildingBuiltComplex;

		public static event Action<int, BuildingInfo> OnBuildingDestroyedComplex;

		private static int GenerateBuildingGUID(string buildingID)
		{
			int result = default(int);
			Regenerate();
			while (Any((BuildingData e) => e != null && e.GUID == result))
			{
				Regenerate();
			}
			return result;
			void Regenerate()
			{
				result = UnityEngine.Random.Range(0, int.MaxValue);
			}
		}

		public int GetTokenAmount(string id)
		{
			return tokens.Find((BuildingTokenAmountEntry e) => e.id == id)?.amount ?? 0;
		}

		private void SetTokenAmount(string id, int amount)
		{
			BuildingTokenAmountEntry buildingTokenAmountEntry = tokens.Find((BuildingTokenAmountEntry e) => e.id == id);
			if (buildingTokenAmountEntry != null)
			{
				buildingTokenAmountEntry.amount = amount;
				return;
			}
			buildingTokenAmountEntry = new BuildingTokenAmountEntry
			{
				id = id,
				amount = amount
			};
			tokens.Add(buildingTokenAmountEntry);
		}

		private void AddToken(string id, int amount = 1)
		{
			BuildingTokenAmountEntry buildingTokenAmountEntry = tokens.Find((BuildingTokenAmountEntry e) => e.id == id);
			if (buildingTokenAmountEntry == null)
			{
				buildingTokenAmountEntry = new BuildingTokenAmountEntry
				{
					id = id,
					amount = 0
				};
				tokens.Add(buildingTokenAmountEntry);
			}
			buildingTokenAmountEntry.amount += amount;
		}

		private bool PayToken(string id)
		{
			BuildingTokenAmountEntry buildingTokenAmountEntry = tokens.Find((BuildingTokenAmountEntry e) => e.id == id);
			if (buildingTokenAmountEntry == null)
			{
				return false;
			}
			if (buildingTokenAmountEntry.amount <= 0)
			{
				return false;
			}
			buildingTokenAmountEntry.amount--;
			return true;
		}

		public static Vector2Int[] GetOccupyingCoords(Vector2Int dimensions, BuildingRotation rotations, Vector2Int coord)
		{
			if ((int)rotations % 2 != 0)
			{
				dimensions = new Vector2Int(dimensions.y, dimensions.x);
			}
			Vector2Int[] array = new Vector2Int[dimensions.x * dimensions.y];
			for (int i = 0; i < dimensions.y; i++)
			{
				for (int j = 0; j < dimensions.x; j++)
				{
					int num = j + dimensions.x * i;
					array[num] = coord + new Vector2Int(j, i);
				}
			}
			return array;
		}

		public BuildingAreaData GetOrCreateArea(string id)
		{
			BuildingAreaData buildingAreaData = areas.Find((BuildingAreaData e) => e != null && e.AreaID == id);
			if (buildingAreaData != null)
			{
				return buildingAreaData;
			}
			BuildingAreaData buildingAreaData2 = new BuildingAreaData(id);
			areas.Add(buildingAreaData2);
			return buildingAreaData2;
		}

		public BuildingAreaData GetArea(string id)
		{
			return areas.Find((BuildingAreaData e) => e != null && e.AreaID == id);
		}

		private void CleanupAndSort()
		{
		}

		public static BuildingInfo GetBuildingInfo(string id)
		{
			return BuildingDataCollection.GetInfo(id);
		}

		public static bool Any(string id, bool includeTokens = false)
		{
			if (Instance == null)
			{
				return false;
			}
			if (includeTokens && Instance.GetTokenAmount(id) > 0)
			{
				return true;
			}
			foreach (BuildingAreaData area in Instance.Areas)
			{
				if (area.Any(id))
				{
					return true;
				}
			}
			return false;
		}

		public static bool Any(Func<BuildingData, bool> predicate)
		{
			if (Instance == null)
			{
				return false;
			}
			foreach (BuildingAreaData area in Instance.Areas)
			{
				if (area.Any(predicate))
				{
					return true;
				}
			}
			return false;
		}

		public static int GetBuildingAmount(string id)
		{
			if (Instance == null)
			{
				return 0;
			}
			int num = 0;
			foreach (BuildingAreaData area in Instance.Areas)
			{
				foreach (BuildingData building in area.Buildings)
				{
					if (building.ID == id)
					{
						num++;
					}
				}
			}
			return num;
		}

		private void Awake()
		{
			Instance = this;
			SavesSystem.OnCollectSaveData += OnCollectSaveData;
			Load();
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= OnCollectSaveData;
		}

		private void OnCollectSaveData()
		{
			Save();
		}

		private void Load()
		{
			SaveData saveData = SavesSystem.Load<SaveData>("BuildingData");
			areas.Clear();
			if (saveData.data != null)
			{
				areas.AddRange(saveData.data);
			}
			tokens.Clear();
			if (saveData.tokenAmounts != null)
			{
				tokens.AddRange(saveData.tokenAmounts);
			}
		}

		private void Save()
		{
			SaveData value = new SaveData
			{
				data = new List<BuildingAreaData>(areas),
				tokenAmounts = new List<BuildingTokenAmountEntry>(tokens)
			};
			SavesSystem.Save("BuildingData", value);
		}

		internal static BuildingAreaData GetAreaData(string areaID)
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.Areas.Find((BuildingAreaData e) => e != null && e.AreaID == areaID);
		}

		internal static BuildingAreaData GetOrCreateAreaData(string areaID)
		{
			if (Instance == null)
			{
				return null;
			}
			return Instance.GetOrCreateArea(areaID);
		}

		internal static BuildingData GetBuildingData(int guid, string areaID = null)
		{
			if (areaID == null)
			{
				foreach (BuildingAreaData area in Instance.Areas)
				{
					BuildingData buildingData = area.Buildings.Find((BuildingData e) => e != null && e.GUID == guid);
					if (buildingData != null)
					{
						return buildingData;
					}
				}
				return null;
			}
			return GetAreaData(areaID)?.Buildings.Find((BuildingData e) => e != null && e.GUID == guid);
		}

		internal static BuildingBuyAndPlaceResults BuyAndPlace(string areaID, string id, Vector2Int coord, BuildingRotation rotation)
		{
			if (Instance == null)
			{
				return BuildingBuyAndPlaceResults.NoReferences;
			}
			BuildingInfo buildingInfo = GetBuildingInfo(id);
			if (!buildingInfo.Valid)
			{
				return BuildingBuyAndPlaceResults.InvalidBuildingInfo;
			}
			GetBuildingAmount(id);
			if (buildingInfo.ReachedAmountLimit)
			{
				return BuildingBuyAndPlaceResults.ReachedAmountLimit;
			}
			Instance.GetTokenAmount(id);
			if (!Instance.PayToken(id) && !buildingInfo.cost.Pay())
			{
				return BuildingBuyAndPlaceResults.PaymentFailure;
			}
			BuildingAreaData orCreateArea = Instance.GetOrCreateArea(areaID);
			int num = GenerateBuildingGUID(id);
			orCreateArea.Add(id, rotation, coord, num);
			BuildingManager.OnBuildingListChanged?.Invoke();
			BuildingManager.OnBuildingBuilt?.Invoke(num);
			BuildingManager.OnBuildingBuiltComplex?.Invoke(num, buildingInfo);
			AudioManager.Post("UI/building_up");
			return BuildingBuyAndPlaceResults.Succeed;
		}

		internal static bool DestroyBuilding(int guid, string areaID = null)
		{
			if (!TryGetBuildingDataAndAreaData(guid, out var buildingData, out var areaData, areaID))
			{
				return false;
			}
			areaData.Remove(buildingData);
			BuildingManager.OnBuildingListChanged?.Invoke();
			BuildingManager.OnBuildingDestroyed?.Invoke(guid);
			BuildingManager.OnBuildingDestroyedComplex?.Invoke(guid, buildingData.Info);
			return true;
		}

		internal static bool TryGetBuildingDataAndAreaData(int guid, out BuildingData buildingData, out BuildingAreaData areaData, string areaID = null)
		{
			buildingData = null;
			areaData = null;
			if (Instance == null)
			{
				return false;
			}
			if (areaID == null)
			{
				foreach (BuildingAreaData area2 in Instance.areas)
				{
					BuildingData buildingData2 = area2.Buildings.Find((BuildingData e) => e != null && e.GUID == guid);
					if (buildingData2 != null)
					{
						areaData = area2;
						buildingData = buildingData2;
						return true;
					}
				}
			}
			else
			{
				BuildingAreaData area = Instance.GetArea(areaID);
				if (area == null)
				{
					return false;
				}
				BuildingData buildingData3 = area.Buildings.Find((BuildingData e) => e != null && e.GUID == guid);
				if (buildingData3 != null)
				{
					areaData = area;
					buildingData = buildingData3;
				}
			}
			return false;
		}

		internal static async UniTask<bool> ReturnBuilding(int guid, string areaID = null)
		{
			if (returningBuilding)
			{
				return false;
			}
			returningBuilding = true;
			if (!TryGetBuildingDataAndAreaData(guid, out var buildingData, out var areaData, areaID))
			{
				return false;
			}
			Instance.AddToken(buildingData.ID);
			areaData.Remove(buildingData);
			BuildingManager.OnBuildingListChanged?.Invoke();
			BuildingManager.OnBuildingDestroyed?.Invoke(guid);
			BuildingManager.OnBuildingDestroyedComplex?.Invoke(guid, buildingData.Info);
			returningBuilding = false;
			return true;
		}

		internal static async UniTask<int> ReturnBuildings(string areaID = null, params int[] buildings)
		{
			int count = 0;
			for (int i = 0; i < buildings.Length; i++)
			{
				if (await ReturnBuilding(buildings[i], areaID))
				{
					count++;
				}
			}
			return count;
		}

		internal static async UniTask<int> ReturnBuildingsOfType(string buildingID, string areaID = null)
		{
			if (Instance == null)
			{
				return 0;
			}
			List<BuildingAreaData> list = new List<BuildingAreaData>();
			if (areaID != null)
			{
				BuildingAreaData area = Instance.GetArea(areaID);
				if (area == null)
				{
					return 0;
				}
				list.Add(area);
			}
			else
			{
				list.AddRange(Instance.Areas);
			}
			returningBuilding = true;
			int num = 0;
			foreach (BuildingAreaData item in list)
			{
				foreach (BuildingData item2 in item.Buildings.FindAll((BuildingData e) => e != null && e.ID == buildingID))
				{
					Instance.AddToken(item2.ID);
					item.Remove(item2);
					BuildingManager.OnBuildingDestroyed?.Invoke(item2.GUID);
					BuildingManager.OnBuildingDestroyedComplex?.Invoke(item2.GUID, item2.Info);
					num++;
				}
			}
			BuildingManager.OnBuildingListChanged?.Invoke();
			returningBuilding = false;
			return num;
		}
	}
	public enum BuildingBuyAndPlaceResults
	{
		Succeed,
		NoReferences,
		InvalidBuildingInfo,
		PaymentFailure,
		ReachedAmountLimit
	}
	public enum BuildingRotation
	{
		Zero,
		Quarter,
		Half,
		ThreeQuarter
	}
}
namespace Duckov.Buildings.UI
{
	public class BuilderView : View, IPointerClickHandler, IEventSystemHandler
	{
		private enum Mode
		{
			None,
			Placing,
			Destroying
		}

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private BuildingSelectionPanel selectionPanel;

		[SerializeField]
		private BuildingContextMenu contextMenu;

		[SerializeField]
		private GameObject placingModeInputIndicator;

		[SerializeField]
		private RectTransform followCursorUI;

		[SerializeField]
		private FadeGroup hoveringBuildingFadeGroup;

		[SerializeField]
		private CinemachineVirtualCamera vcam;

		[SerializeField]
		private float cameraSpeed = 10f;

		[SerializeField]
		private float pitch = 45f;

		[SerializeField]
		private float cameraDistance = 10f;

		[SerializeField]
		private float yaw = -45f;

		[SerializeField]
		private Vector3 cameraCursor;

		[SerializeField]
		private BuildingInfo placingBuildingInfo;

		[SerializeField]
		private InputActionReference input_Rotate;

		[SerializeField]
		private InputActionReference input_RequestContextMenu;

		[SerializeField]
		private InputActionReference input_MoveCamera;

		[SerializeField]
		private GridDisplay gridDisplay;

		[SerializeField]
		private BuildingArea targetArea;

		[SerializeField]
		private Mode mode;

		private Building previewBuilding;

		[SerializeField]
		private BuildingRotation previewRotation;

		public static BuilderView Instance => View.GetViewInstance<BuilderView>();

		public void SetupAndShow(BuildingArea targetArea)
		{
			this.targetArea = targetArea;
			Open();
		}

		protected override void Awake()
		{
			base.Awake();
			input_Rotate.action.actionMap.Enable();
			input_MoveCamera.action.actionMap.Enable();
			selectionPanel.onButtonSelected += OnButtonSelected;
			selectionPanel.onRecycleRequested += OnRecycleRequested;
			BuildingManager.OnBuildingListChanged += OnBuildingListChanged;
		}

		private void OnRecycleRequested(BuildingBtnEntry entry)
		{
			BuildingManager.ReturnBuildingsOfType(entry.Info.id).Forget();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			BuildingManager.OnBuildingListChanged -= OnBuildingListChanged;
		}

		private void OnBuildingListChanged()
		{
			selectionPanel.Refresh();
		}

		private void OnButtonSelected(BuildingBtnEntry entry)
		{
			if (!entry.CostEnough)
			{
				NotifyCostNotEnough(entry);
			}
			else if (!entry.Info.ReachedAmountLimit)
			{
				BeginPlacing(entry.Info);
			}
		}

		private void NotifyCostNotEnough(BuildingBtnEntry entry)
		{
			UnityEngine.Debug.Log("Resource not enough " + entry.Info.DisplayName);
		}

		private void SetMode(Mode mode)
		{
			placingModeInputIndicator.SetActive(value: false);
			OnExitMode(this.mode);
			this.mode = mode;
			switch (mode)
			{
			case Mode.Placing:
				placingModeInputIndicator.SetActive(value: true);
				break;
			case Mode.None:
			case Mode.Destroying:
				break;
			}
		}

		private void OnExitMode(Mode mode)
		{
			contextMenu.Hide();
			switch (mode)
			{
			case Mode.Placing:
				OnExitPlacing();
				break;
			case Mode.None:
			case Mode.Destroying:
				break;
			}
		}

		public void BeginPlacing(BuildingInfo info)
		{
			if (previewBuilding != null)
			{
				UnityEngine.Object.Destroy(previewBuilding.gameObject);
			}
			placingBuildingInfo = info;
			SetMode(Mode.Placing);
			if (info.Prefab == null)
			{
				UnityEngine.Debug.LogError("建筑 " + info.DisplayName + " 没有prefab");
			}
			previewBuilding = UnityEngine.Object.Instantiate(info.Prefab);
			if (previewBuilding.ID != info.id)
			{
				UnityEngine.Debug.LogError("建筑 " + info.DisplayName + " 的 prefab 上的 ID 设置错误");
			}
			SetupPreview(previewBuilding);
			UpdatePlacing();
		}

		public void BeginDestroying()
		{
			SetMode(Mode.Destroying);
		}

		private void SetupPreview(Building previewBuilding)
		{
			if (!(previewBuilding == null))
			{
				previewBuilding.SetupPreview();
			}
		}

		private void OnExitPlacing()
		{
			if (previewBuilding != null)
			{
				UnityEngine.Object.Destroy(previewBuilding.gameObject);
			}
			GridDisplay.HidePreview();
		}

		private void Update()
		{
			switch (mode)
			{
			case Mode.None:
				UpdateNone();
				break;
			case Mode.Placing:
				UpdatePlacing();
				break;
			case Mode.Destroying:
				UpdateDestroying();
				break;
			}
			UpdateCamera();
			UpdateContextMenuIndicator();
		}

		private void UpdateContextMenuIndicator()
		{
			TryGetPointingCoord(out var coord);
			bool num = targetArea.GetBuildingInstanceAt(coord);
			bool flag = contextMenu.isActiveAndEnabled;
			RectTransformUtility.ScreenPointToLocalPointInRectangle(followCursorUI.parent as RectTransform, Mouse.current.position.value, null, out var localPoint);
			followCursorUI.localPosition = localPoint;
			int num2;
			if (num)
			{
				num2 = ((!flag) ? 1 : 0);
				if (num2 != 0 && !hoveringBuildingFadeGroup.IsShown)
				{
					hoveringBuildingFadeGroup.Show();
				}
			}
			else
			{
				num2 = 0;
			}
			if (num2 == 0 && hoveringBuildingFadeGroup.IsShown)
			{
				hoveringBuildingFadeGroup.Hide();
			}
		}

		private void UpdateNone()
		{
			if (input_RequestContextMenu.action.WasPressedThisFrame() && TryGetPointingCoord(out var coord))
			{
				Building buildingInstanceAt = targetArea.GetBuildingInstanceAt(coord);
				if (buildingInstanceAt == null)
				{
					contextMenu.Hide();
				}
				else
				{
					contextMenu.Setup(buildingInstanceAt);
				}
			}
		}

		private void UpdateDestroying()
		{
			if (!TryGetPointingCoord(out var coord))
			{
				GridDisplay.HidePreview();
				return;
			}
			BuildingManager.BuildingData buildingAt = targetArea.AreaData.GetBuildingAt(coord);
			if (buildingAt == null)
			{
				GridDisplay.HidePreview();
			}
			else
			{
				gridDisplay.SetBuildingPreviewCoord(buildingAt.Coord, buildingAt.Dimensions, buildingAt.Rotation, validPlacement: false);
			}
		}

		private void ConfirmDestroy()
		{
			if (TryGetPointingCoord(out var coord))
			{
				BuildingManager.BuildingData buildingAt = targetArea.AreaData.GetBuildingAt(coord);
				if (buildingAt != null)
				{
					BuildingManager.ReturnBuilding(buildingAt.GUID).Forget();
					SetMode(Mode.None);
				}
			}
		}

		private void ConfirmPlacement()
		{
			Vector2Int coord;
			if (previewBuilding == null)
			{
				UnityEngine.Debug.Log("No Previewing Building");
			}
			else if (!TryGetPointingCoord(out coord, previewBuilding))
			{
				previewBuilding.gameObject.SetActive(value: false);
				UnityEngine.Debug.Log("Mouse Not in Plane!");
			}
			else if (!IsValidPlacement(previewBuilding.Dimensions, previewRotation, coord))
			{
				UnityEngine.Debug.Log("Invalid Placement!");
			}
			else
			{
				BuildingManager.BuyAndPlace(targetArea.AreaID, previewBuilding.ID, coord, previewRotation);
				SetMode(Mode.None);
			}
		}

		private void UpdatePlacing()
		{
			if ((bool)previewBuilding)
			{
				if (!TryGetPointingCoord(out var coord, previewBuilding))
				{
					previewBuilding.gameObject.SetActive(value: false);
					return;
				}
				bool validPlacement = IsValidPlacement(previewBuilding.Dimensions, previewRotation, coord);
				gridDisplay.SetBuildingPreviewCoord(coord, previewBuilding.Dimensions, previewRotation, validPlacement);
				ShowPreview(coord);
				if (input_Rotate.action.WasPressedThisFrame())
				{
					float num = input_Rotate.action.ReadValue<float>();
					previewRotation = (BuildingRotation)(((float)previewRotation + num + 4f) % 4f);
				}
				if (input_RequestContextMenu.action.WasPressedThisFrame())
				{
					SetMode(Mode.None);
				}
			}
			else
			{
				SetMode(Mode.None);
			}
		}

		private void ShowPreview(Vector2Int coord)
		{
			Vector3 position = targetArea.CoordToWorldPosition(coord, previewBuilding.Dimensions, previewRotation);
			previewBuilding.transform.position = position;
			previewBuilding.gameObject.SetActive(value: true);
			Quaternion quaternion = Quaternion.Euler(new Vector3(0f, 90 * (int)previewRotation, 0f));
			previewBuilding.transform.rotation = targetArea.transform.rotation * quaternion;
		}

		public bool TryGetPointingCoord(out Vector2Int coord, Building previewBuilding = null)
		{
			coord = default(Vector2Int);
			Ray pointRay = UIInputManager.GetPointRay();
			if (!targetArea.Plane.Raycast(pointRay, out var enter))
			{
				return false;
			}
			Vector3 point = pointRay.GetPoint(enter);
			if (previewBuilding != null)
			{
				coord = targetArea.CursorToCoord(point, previewBuilding.Dimensions, previewRotation);
				return true;
			}
			coord = targetArea.CursorToCoord(point, Vector2Int.one, BuildingRotation.Zero);
			return true;
		}

		private bool IsValidPlacement(Vector2Int dimensions, BuildingRotation rotation, Vector2Int coord)
		{
			if (!targetArea.IsPlacementWithinRange(dimensions, rotation, coord))
			{
				return false;
			}
			if (targetArea.AreaData.Collide(dimensions, rotation, coord))
			{
				return false;
			}
			if (targetArea.PhysicsCollide(dimensions, rotation, coord))
			{
				return false;
			}
			return true;
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			SetMode(Mode.None);
			fadeGroup.Show();
			selectionPanel.Setup(targetArea);
			gridDisplay.Setup(targetArea);
			cameraCursor = targetArea.transform.position;
			UpdateCamera();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
			GridDisplay.Close();
			if (previewBuilding != null)
			{
				UnityEngine.Object.Destroy(previewBuilding.gameObject);
			}
		}

		private void UpdateCamera()
		{
			if (input_MoveCamera.action.IsPressed())
			{
				Vector2 vector = input_MoveCamera.action.ReadValue<Vector2>();
				Transform transform = vcam.transform;
				float num = Mathf.Abs(Vector3.Dot(transform.forward, Vector3.up));
				float num2 = Mathf.Abs(Vector3.Dot(transform.up, Vector3.up));
				Vector3 vector2 = ((num > num2) ? transform.up : transform.forward).ProjectOntoPlane(Vector3.up);
				Vector3 vector3 = transform.right.ProjectOntoPlane(Vector3.up);
				cameraCursor += (vector3 * vector.x + vector2 * vector.y) * cameraSpeed * Time.unscaledDeltaTime;
				cameraCursor.x = Mathf.Clamp(cameraCursor.x, targetArea.transform.position.x - (float)targetArea.Size.x, targetArea.transform.position.x + (float)targetArea.Size.x);
				cameraCursor.z = Mathf.Clamp(cameraCursor.z, targetArea.transform.position.z - (float)targetArea.Size.y, targetArea.transform.position.z + (float)targetArea.Size.y);
			}
			vcam.transform.position = cameraCursor + Quaternion.Euler(0f, yaw, 0f) * Quaternion.Euler(pitch, 0f, 0f) * Vector3.forward * cameraDistance;
			vcam.transform.LookAt(cameraCursor, Vector3.up);
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (eventData.button == PointerEventData.InputButton.Left)
			{
				contextMenu.Hide();
				switch (mode)
				{
				case Mode.Placing:
					ConfirmPlacement();
					break;
				case Mode.Destroying:
					ConfirmDestroy();
					break;
				}
			}
		}

		public static void Show(BuildingArea target)
		{
			Instance.SetupAndShow(target);
		}
	}
	public class BuildingBtnEntry : MonoBehaviour
	{
		[SerializeField]
		private UnityEngine.UI.Button button;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TextMeshProUGUI nameText;

		[SerializeField]
		private TextMeshProUGUI descriptionText;

		[SerializeField]
		private CostDisplay costDisplay;

		[SerializeField]
		private LongPressButton recycleButton;

		[SerializeField]
		private TextMeshProUGUI amountText;

		[SerializeField]
		[LocalizationKey("Default")]
		private string tokenFormatKey;

		[SerializeField]
		private TextMeshProUGUI tokenText;

		[SerializeField]
		private GameObject reachedAmountLimitationIndicator;

		[SerializeField]
		private UnityEngine.UI.Image backGround;

		[SerializeField]
		private Color normalColor;

		[SerializeField]
		private Color avaliableColor;

		private BuildingInfo info;

		private string TokenFormat => tokenFormatKey.ToPlainText();

		public BuildingInfo Info => info;

		public bool CostEnough
		{
			get
			{
				if (info.TokenAmount > 0)
				{
					return true;
				}
				if (info.cost.Enough)
				{
					return true;
				}
				return false;
			}
		}

		public event Action<BuildingBtnEntry> onButtonClicked;

		public event Action<BuildingBtnEntry> onRecycleRequested;

		private void Awake()
		{
			button.onClick.AddListener(OnButtonClicked);
			recycleButton.onPressFullfilled.AddListener(OnRecycleButtonTriggered);
		}

		private void OnRecycleButtonTriggered()
		{
			this.onRecycleRequested?.Invoke(this);
		}

		private void OnEnable()
		{
			BuildingManager.OnBuildingListChanged += Refresh;
		}

		private void OnDisable()
		{
			BuildingManager.OnBuildingListChanged -= Refresh;
		}

		private void OnButtonClicked()
		{
			this.onButtonClicked?.Invoke(this);
		}

		internal void Setup(BuildingInfo buildingInfo)
		{
			info = buildingInfo;
			Refresh();
		}

		private void Refresh()
		{
			int tokenAmount = info.TokenAmount;
			nameText.text = info.DisplayName;
			descriptionText.text = info.Description;
			tokenText.text = TokenFormat.Format(new { tokenAmount });
			icon.sprite = info.iconReference;
			costDisplay.Setup(info.cost);
			costDisplay.gameObject.SetActive(tokenAmount <= 0);
			bool reachedAmountLimit = info.ReachedAmountLimit;
			amountText.text = ((info.maxAmount > 0) ? $"{info.CurrentAmount}/{info.maxAmount}" : $"{info.CurrentAmount}/∞");
			reachedAmountLimitationIndicator.SetActive(reachedAmountLimit);
			bool flag = !info.ReachedAmountLimit && CostEnough;
			backGround.color = (flag ? avaliableColor : normalColor);
			recycleButton.gameObject.SetActive(info.CurrentAmount > 0);
		}
	}
	public class BuildingContextMenu : MonoBehaviour
	{
		private RectTransform rectTransform;

		[SerializeField]
		private TextMeshProUGUI nameText;

		[SerializeField]
		private BuildingContextMenuEntry recycleButton;

		public Building Target { get; private set; }

		private void Awake()
		{
			rectTransform = base.transform as RectTransform;
			recycleButton.onPointerClick += OnRecycleButtonClicked;
		}

		private void OnRecycleButtonClicked(BuildingContextMenuEntry entry)
		{
			if (!(Target == null))
			{
				BuildingManager.ReturnBuilding(Target.GUID).Forget();
			}
		}

		public void Setup(Building target)
		{
			Target = target;
			if (target == null)
			{
				Hide();
				return;
			}
			nameText.text = target.DisplayName;
			Show();
		}

		private void LateUpdate()
		{
			if (Target == null)
			{
				Hide();
				return;
			}
			Vector2 screenPoint = RectTransformUtility.WorldToScreenPoint(GameCamera.Instance.renderCamera, Target.transform.position);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(base.transform.parent as RectTransform, screenPoint, null, out var localPoint);
			rectTransform.localPosition = localPoint;
		}

		private void Show()
		{
			base.gameObject.SetActive(value: true);
		}

		public void Hide()
		{
			base.gameObject.SetActive(value: false);
		}
	}
	public class BuildingContextMenuEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKey;

		public event Action<BuildingContextMenuEntry> onPointerClick;

		private void OnEnable()
		{
			text.text = textKey.ToPlainText();
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			this.onPointerClick?.Invoke(this);
		}
	}
	public class BuildingSelectionPanel : MonoBehaviour
	{
		[SerializeField]
		private BuildingBtnEntry buildingBtnTemplate;

		private PrefabPool<BuildingBtnEntry> _pool;

		private BuildingArea targetArea;

		private PrefabPool<BuildingBtnEntry> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<BuildingBtnEntry>(buildingBtnTemplate, null, OnGetButtonEntry, OnReleaseButtonEntry);
				}
				return _pool;
			}
		}

		public event Action<BuildingBtnEntry> onButtonSelected;

		public event Action<BuildingBtnEntry> onRecycleRequested;

		private void OnGetButtonEntry(BuildingBtnEntry entry)
		{
			entry.onButtonClicked += OnButtonSelected;
			entry.onRecycleRequested += OnRecycleRequested;
		}

		private void OnReleaseButtonEntry(BuildingBtnEntry entry)
		{
			entry.onButtonClicked -= OnButtonSelected;
			entry.onRecycleRequested -= OnRecycleRequested;
		}

		private void OnRecycleRequested(BuildingBtnEntry entry)
		{
			this.onRecycleRequested?.Invoke(entry);
		}

		private void OnButtonSelected(BuildingBtnEntry entry)
		{
			this.onButtonSelected?.Invoke(entry);
		}

		public void Show()
		{
		}

		internal void Setup(BuildingArea targetArea)
		{
			this.targetArea = targetArea;
			Refresh();
		}

		public void Refresh()
		{
			Pool.ReleaseAll();
			BuildingInfo[] buildingsToDisplay = GetBuildingsToDisplay();
			foreach (BuildingInfo buildingInfo in buildingsToDisplay)
			{
				BuildingBtnEntry buildingBtnEntry = Pool.Get();
				buildingBtnEntry.Setup(buildingInfo);
				buildingBtnEntry.transform.SetAsLastSibling();
			}
			foreach (BuildingBtnEntry activeEntry in Pool.ActiveEntries)
			{
				if (!activeEntry.CostEnough)
				{
					activeEntry.transform.SetAsLastSibling();
				}
			}
		}

		public static BuildingInfo[] GetBuildingsToDisplay()
		{
			BuildingDataCollection instance = BuildingDataCollection.Instance;
			if (instance == null)
			{
				return new BuildingInfo[0];
			}
			List<BuildingInfo> list = new List<BuildingInfo>();
			foreach (BuildingInfo info in instance.Infos)
			{
				if (info.CurrentAmount > 0 || info.RequirementsSatisfied())
				{
					list.Add(info);
				}
			}
			return list.ToArray();
		}
	}
	public class GridDisplay : MonoBehaviour
	{
		[HideInInspector]
		[SerializeField]
		private BuildingArea targetArea;

		[SerializeField]
		private float animationDuration;

		[SerializeField]
		private AnimationCurve showCurve;

		[SerializeField]
		private AnimationCurve hideCurve;

		private static int gridShowHideTaskToken;

		public static GridDisplay Instance { get; private set; }

		private void Awake()
		{
			Instance = this;
			Close();
		}

		public void Setup(BuildingArea buildingArea)
		{
			Vector2Int lowerLeftCorner = buildingArea.LowerLeftCorner;
			Vector4 value = new Vector4(lowerLeftCorner.x, lowerLeftCorner.y, buildingArea.Size.x * 2 - 1, buildingArea.Size.y * 2 - 1);
			Shader.SetGlobalVector("BuildingGrid_AreaPosAndSize", value);
			ShowGrid();
			HidePreview();
			ShowGrid();
		}

		public static void Close()
		{
			HidePreview();
			HideGrid();
		}

		public static async UniTask SetGridShowHide(bool show, AnimationCurve curve, float duration)
		{
			int token;
			do
			{
				token = UnityEngine.Random.Range(0, int.MaxValue);
			}
			while (token == gridShowHideTaskToken);
			gridShowHideTaskToken = token;
			float time = 0f;
			if (duration <= 0f)
			{
				Shader.SetGlobalFloat("BuildingGrid_Building", show ? 1 : 0);
				return;
			}
			while (time < duration)
			{
				time += Time.unscaledDeltaTime;
				float time2 = time / duration;
				float value = Mathf.Lerp((!show) ? 1 : 0, show ? 1 : 0, curve.Evaluate(time2));
				Shader.SetGlobalFloat("BuildingGrid_Building", value);
				await UniTask.Yield();
				if (token != gridShowHideTaskToken)
				{
					return;
				}
			}
			Shader.SetGlobalFloat("BuildingGrid_Building", show ? 1 : 0);
		}

		public static void HideGrid()
		{
			if ((bool)Instance)
			{
				SetGridShowHide(show: false, Instance.hideCurve, Instance.animationDuration).Forget();
			}
			else
			{
				Shader.SetGlobalFloat("BuildingGrid_Building", 0f);
			}
		}

		public static void ShowGrid()
		{
			if ((bool)Instance)
			{
				SetGridShowHide(show: true, Instance.showCurve, Instance.animationDuration).Forget();
			}
			else
			{
				Shader.SetGlobalFloat("BuildingGrid_Building", 1f);
			}
		}

		public static void HidePreview()
		{
			Shader.SetGlobalVector("BuildingGrid_BuildingPosAndSize", Vector4.zero);
		}

		internal void SetBuildingPreviewCoord(Vector2Int coord, Vector2Int dimensions, BuildingRotation rotation, bool validPlacement)
		{
			if ((int)rotation % 2 > 0)
			{
				dimensions = new Vector2Int(dimensions.y, dimensions.x);
			}
			Vector4 value = new Vector4(coord.x, coord.y, dimensions.x, dimensions.y);
			Shader.SetGlobalVector("BuildingGrid_BuildingPosAndSize", value);
			Shader.SetGlobalFloat("BuildingGrid_CanBuild", validPlacement ? 1 : 0);
		}
	}
}
namespace Duckov.Aquariums
{
	public class Aquarium : MonoBehaviour
	{
		private class ItemGraphicPair
		{
			public Item item;

			public ItemGraphicInfo graphic;
		}

		[SerializeField]
		private string id = "Default";

		[SerializeField]
		private Transform graphicsParent;

		[ItemTypeID]
		private int aquariumItemTypeID = 1158;

		private Item aquariumItem;

		private List<ItemGraphicPair> graphicRecords = new List<ItemGraphicPair>();

		private bool loading;

		private bool loaded;

		private int loadToken;

		private bool dirty = true;

		private string ItemSaveKey => "Aquarium/Item/" + id;

		private void Awake()
		{
			SavesSystem.OnCollectSaveData += Save;
		}

		private void Start()
		{
			Load().Forget();
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
		}

		private async UniTask Load()
		{
			if (aquariumItem != null)
			{
				aquariumItem.DestroyTree();
			}
			int token = ++loadToken;
			loading = true;
			Item item = await ItemSavesUtilities.LoadItem(ItemSaveKey);
			if (token != loadToken)
			{
				return;
			}
			if (item == null)
			{
				item = await ItemAssetsCollection.InstantiateAsync(aquariumItemTypeID);
				if (token != loadToken)
				{
					return;
				}
			}
			aquariumItem = item;
			aquariumItem.transform.SetParent(base.transform);
			aquariumItem.onChildChanged += OnChildChanged;
			loading = false;
			loaded = true;
		}

		private void OnChildChanged(Item item)
		{
			dirty = true;
		}

		private void FixedUpdate()
		{
			if (!loading && dirty)
			{
				Refresh();
				dirty = false;
			}
		}

		private void Refresh()
		{
			if (aquariumItem == null)
			{
				return;
			}
			foreach (Item allChild in aquariumItem.GetAllChildren(includingGrandChildren: false, excludeSelf: true))
			{
				if (!(allChild == null) && allChild.Tags.Contains("Fish"))
				{
					_ = GetOrCreateGraphic(allChild) == null;
				}
			}
			graphicRecords.RemoveAll((ItemGraphicPair e) => e == null || e.graphic == null);
			for (int num = 0; num < graphicRecords.Count; num++)
			{
				ItemGraphicPair itemGraphicPair = graphicRecords[num];
				if (itemGraphicPair.item == null || itemGraphicPair.item.ParentItem != aquariumItem)
				{
					if (itemGraphicPair.graphic != null)
					{
						UnityEngine.Object.Destroy(itemGraphicPair.graphic);
					}
					graphicRecords.RemoveAt(num);
					num--;
				}
			}
		}

		private ItemGraphicInfo GetOrCreateGraphic(Item item)
		{
			if (item == null)
			{
				return null;
			}
			ItemGraphicPair itemGraphicPair = graphicRecords.Find((ItemGraphicPair e) => e != null && e.item == item);
			if (itemGraphicPair != null && itemGraphicPair.graphic != null)
			{
				return itemGraphicPair.graphic;
			}
			ItemGraphicInfo itemGraphicInfo = ItemGraphicInfo.CreateAGraphic(item, graphicsParent);
			if (itemGraphicPair != null)
			{
				graphicRecords.Remove(itemGraphicPair);
			}
			if (itemGraphicInfo == null)
			{
				return null;
			}
			itemGraphicInfo.GetComponent<IAquariumContent>()?.Setup(this);
			graphicRecords.Add(new ItemGraphicPair
			{
				item = item,
				graphic = itemGraphicInfo
			});
			return itemGraphicInfo;
		}

		public void Loot()
		{
			LootView.LootItem(aquariumItem);
		}

		private void Save()
		{
			if (!loading && loaded)
			{
				aquariumItem.Save(ItemSaveKey);
			}
		}
	}
	public interface IAquariumContent
	{
		void Setup(Aquarium master);
	}
}
namespace Duckov.Achievements
{
	[CreateAssetMenu]
	public class AchievementDatabase : ScriptableObject
	{
		[Serializable]
		public class Achievement
		{
			public string id { get; set; }

			public string overrideDisplayNameKey { get; set; }

			public string overrideDescriptionKey { get; set; }

			[LocalizationKey("Default")]
			private string DisplayNameKey
			{
				get
				{
					if (!string.IsNullOrWhiteSpace(overrideDisplayNameKey))
					{
						return overrideDisplayNameKey;
					}
					return "Achievement_" + id;
				}
				set
				{
				}
			}

			[LocalizationKey("Default")]
			public string DescriptionKey
			{
				get
				{
					if (!string.IsNullOrWhiteSpace(overrideDescriptionKey))
					{
						return overrideDescriptionKey;
					}
					return "Achievement_" + id + "_Desc";
				}
				set
				{
				}
			}

			public string DisplayName => DisplayNameKey.ToPlainText();

			public string Description => DescriptionKey.ToPlainText();
		}

		[SerializeField]
		private XlsxObject achievementChart;

		private Dictionary<string, Achievement> _dic;

		public static AchievementDatabase Instance => GameplayDataSettings.AchievementDatabase;

		private Dictionary<string, Achievement> dic
		{
			get
			{
				if (_dic == null)
				{
					RebuildDictionary();
				}
				return _dic;
			}
		}

		private void RebuildDictionary()
		{
			if (_dic == null)
			{
				_dic = new Dictionary<string, Achievement>();
			}
			_dic.Clear();
			if (achievementChart == null)
			{
				UnityEngine.Debug.LogError("Achievement Chart is not assinged", this);
				return;
			}
			using MemoryStream stream = new MemoryStream(achievementChart.bytes);
			foreach (Achievement item in stream.Query<Achievement>())
			{
				_dic[item.id.Trim()] = item;
			}
		}

		public static bool TryGetAchievementData(string id, out Achievement achievement)
		{
			achievement = null;
			if (Instance == null)
			{
				return false;
			}
			return Instance.dic.TryGetValue(id, out achievement);
		}

		internal bool IsIDValid(string id)
		{
			return dic.ContainsKey(id);
		}
	}
	public class AchievementManager : MonoBehaviour
	{
		private struct KillCountAchievement
		{
			public string key;

			public int value;

			public KillCountAchievement(string key, int value)
			{
				this.key = key;
				this.value = value;
			}
		}

		private List<string> _unlockedAchievements = new List<string>();

		private readonly string[] evacuateSceneIDs = new string[1] { "Level_GroundZero_Main" };

		private readonly string[] achievementSceneIDs = new string[6] { "Base", "Level_GroundZero_Main", "Level_HiddenWarehouse_Main", "Level_Farm_Main", "Level_JLab_Main", "Level_StormZone_Main" };

		private readonly KillCountAchievement[] KillCountAchivements = new KillCountAchievement[16]
		{
			new KillCountAchievement("Cname_ShortEagle", 10),
			new KillCountAchievement("Cname_ShortEagle", 1),
			new KillCountAchievement("Cname_Speedy", 1),
			new KillCountAchievement("Cname_StormBoss1", 1),
			new KillCountAchievement("Cname_StormBoss2", 1),
			new KillCountAchievement("Cname_StormBoss3", 1),
			new KillCountAchievement("Cname_StormBoss4", 1),
			new KillCountAchievement("Cname_StormBoss5", 1),
			new KillCountAchievement("Cname_Boss_Sniper", 1),
			new KillCountAchievement("Cname_Vida", 1),
			new KillCountAchievement("Cname_Roadblock", 1),
			new KillCountAchievement("Cname_SchoolBully", 1),
			new KillCountAchievement("Cname_Boss_Fly", 1),
			new KillCountAchievement("Cname_Boss_Arcade", 1),
			new KillCountAchievement("Cname_UltraMan", 1),
			new KillCountAchievement("Cname_LabTestObjective", 1)
		};

		public static AchievementManager Instance => GameManager.AchievementManager;

		public static bool CanUnlockAchievement
		{
			get
			{
				if (DifficultySelection.CustomDifficultyMarker)
				{
					return false;
				}
				return true;
			}
		}

		public List<string> UnlockedAchievements => _unlockedAchievements;

		public static event Action<AchievementManager> OnAchievementDataLoaded;

		public static event Action<string> OnAchievementUnlocked;

		private void Awake()
		{
			Load();
			RegisterEvents();
		}

		private void OnDestroy()
		{
			UnregisterEvents();
		}

		private void Start()
		{
			MakeSureMoneyAchievementsUnlocked();
		}

		private void RegisterEvents()
		{
			Quest.onQuestCompleted += OnQuestCompleted;
			SavesCounter.OnKillCountChanged = (Action<string, int>)Delegate.Combine(SavesCounter.OnKillCountChanged, new Action<string, int>(OnKillCountChanged));
			MultiSceneCore.OnSetSceneVisited += OnSetSceneVisited;
			LevelManager.OnEvacuated += OnEvacuated;
			EconomyManager.OnMoneyChanged += OnMoneyChanged;
			EndowmentManager.OnEndowmentUnlock = (Action<EndowmentIndex>)Delegate.Combine(EndowmentManager.OnEndowmentUnlock, new Action<EndowmentIndex>(OnEndowmentUnlocked));
			EconomyManager.OnEconomyManagerLoaded += OnEconomyManagerLoaded;
		}

		private void UnregisterEvents()
		{
			Quest.onQuestCompleted -= OnQuestCompleted;
			SavesCounter.OnKillCountChanged = (Action<string, int>)Delegate.Remove(SavesCounter.OnKillCountChanged, new Action<string, int>(OnKillCountChanged));
			MultiSceneCore.OnSetSceneVisited -= OnSetSceneVisited;
			LevelManager.OnEvacuated -= OnEvacuated;
			EconomyManager.OnMoneyChanged -= OnMoneyChanged;
			EndowmentManager.OnEndowmentUnlock = (Action<EndowmentIndex>)Delegate.Remove(EndowmentManager.OnEndowmentUnlock, new Action<EndowmentIndex>(OnEndowmentUnlocked));
			EconomyManager.OnEconomyManagerLoaded -= OnEconomyManagerLoaded;
		}

		private void OnEconomyManagerLoaded()
		{
			MakeSureMoneyAchievementsUnlocked();
		}

		private void OnEndowmentUnlocked(EndowmentIndex index)
		{
			Unlock($"Endowmment_{index}");
		}

		public static void UnlockEndowmentAchievement(EndowmentIndex index)
		{
			if (!(Instance == null))
			{
				Instance.Unlock($"Endowmment_{index}");
			}
		}

		private void OnMoneyChanged(long oldValue, long newValue)
		{
			if (oldValue < 10000 && newValue >= 10000)
			{
				Unlock("Money_10K");
			}
			if (oldValue < 100000 && newValue >= 100000)
			{
				Unlock("Money_100K");
			}
			if (oldValue < 1000000 && newValue >= 1000000)
			{
				Unlock("Money_1M");
			}
		}

		private void MakeSureMoneyAchievementsUnlocked()
		{
			long money = EconomyManager.Money;
			if (money >= 10000)
			{
				Unlock("Money_10K");
			}
			if (money >= 100000)
			{
				Unlock("Money_100K");
			}
			if (money >= 1000000)
			{
				Unlock("Money_1M");
			}
		}

		private void OnEvacuated(EvacuationInfo info)
		{
			string mainSceneID = MultiSceneCore.MainSceneID;
			if (evacuateSceneIDs.Contains(mainSceneID))
			{
				Unlock("Evacuate_" + mainSceneID);
			}
		}

		private void OnSetSceneVisited(string id)
		{
			if (achievementSceneIDs.Contains(id))
			{
				Unlock("Arrive_" + id);
			}
		}

		private void OnKillCountChanged(string key, int value)
		{
			Unlock("FirstBlood");
			if (AchievementDatabase.Instance == null)
			{
				return;
			}
			UnityEngine.Debug.Log("COUNTING " + key);
			KillCountAchievement[] killCountAchivements = KillCountAchivements;
			for (int i = 0; i < killCountAchivements.Length; i++)
			{
				KillCountAchievement killCountAchievement = killCountAchivements[i];
				if (killCountAchievement.key == key && value >= killCountAchievement.value)
				{
					Unlock($"Kill_{key}_{killCountAchievement.value}");
				}
			}
		}

		private void OnQuestCompleted(Quest quest)
		{
			if (!(AchievementDatabase.Instance == null))
			{
				string id = $"Quest_{quest.ID}";
				if (AchievementDatabase.TryGetAchievementData(id, out var _))
				{
					Unlock(id);
				}
			}
		}

		private void Save()
		{
			SavesSystem.SaveGlobal("Achievements", UnlockedAchievements);
		}

		private void Load()
		{
			UnlockedAchievements.Clear();
			List<string> list = SavesSystem.LoadGlobal<List<string>>("Achievements");
			if (list != null)
			{
				UnlockedAchievements.AddRange(list);
			}
			AchievementManager.OnAchievementDataLoaded?.Invoke(this);
		}

		public void Unlock(string id)
		{
			if (string.IsNullOrWhiteSpace(id))
			{
				UnityEngine.Debug.LogError("Trying to unlock a empty acheivement.", this);
				return;
			}
			id = id.Trim();
			if (!AchievementDatabase.TryGetAchievementData(id, out var _))
			{
				UnityEngine.Debug.LogError("Invalid acheivement id: " + id);
			}
			if (!UnlockedAchievements.Contains(id) && CanUnlockAchievement)
			{
				UnlockedAchievements.Add(id);
				Save();
				AchievementManager.OnAchievementUnlocked?.Invoke(id);
			}
		}

		public static bool IsIDValid(string id)
		{
			if (AchievementDatabase.Instance == null)
			{
				return false;
			}
			return AchievementDatabase.Instance.IsIDValid(id);
		}
	}
	public class StatisticsManager : MonoBehaviour
	{
		public static event Action<string, long, long> OnStatisticsChanged;

		private static string GetSaveKey(string statisticsKey)
		{
			return "Statistics/" + statisticsKey;
		}

		private static long Get(string key)
		{
			GetSaveKey(key);
			if (!SavesSystem.KeyExisits(key))
			{
				return 0L;
			}
			return SavesSystem.Load<long>(key);
		}

		private static void Set(string key, long value)
		{
			long arg = Get(key);
			GetSaveKey(key);
			SavesSystem.Save(key, value);
			StatisticsManager.OnStatisticsChanged?.Invoke(key, arg, value);
		}

		public static void Add(string key, long value = 1L)
		{
			long num = Get(key);
			try
			{
				num = checked(num + value);
			}
			catch (OverflowException exception)
			{
				UnityEngine.Debug.LogException(exception);
				UnityEngine.Debug.Log("Failed changing statistics of " + key + ". Overflow detected.");
				return;
			}
			Set(key, num);
		}

		private void Awake()
		{
			RegisterEvents();
		}

		private void OnDestroy()
		{
			UnregisterEvents();
		}

		private void RegisterEvents()
		{
		}

		private void UnregisterEvents()
		{
		}
	}
}
namespace Duckov.Economy
{
	public class EconomyManager : MonoBehaviour, ISaveDataProvider
	{
		[Serializable]
		public struct SaveData
		{
			public long money;

			public int[] unlockedItems;

			public int[] unlockesWaitingForConfirm;
		}

		[SerializeField]
		private string itemUnlockNotificationTextMainFormat = "物品 {itemDisplayName} 已解锁";

		[SerializeField]
		private string itemUnlockNotificationTextSubFormat = "请在对应商店中查看";

		private const string saveKey = "EconomyData";

		private long money;

		[SerializeField]
		private List<int> unlockedItemIds;

		[SerializeField]
		private List<int> unlockesWaitingForConfirm;

		public const int CashItemID = 451;

		public static string ItemUnlockNotificationTextMainFormat => Instance?.itemUnlockNotificationTextMainFormat;

		public static string ItemUnlockNotificationTextSubFormat => Instance?.itemUnlockNotificationTextSubFormat;

		public static EconomyManager Instance { get; private set; }

		public static long Money
		{
			get
			{
				if (Instance == null)
				{
					return 0L;
				}
				return Instance.money;
			}
			private set
			{
				long arg = Money;
				if (!(Instance == null))
				{
					Instance.money = value;
					EconomyManager.OnMoneyChanged?.Invoke(arg, value);
				}
			}
		}

		public static long Cash => ItemUtilities.GetItemCount(451);

		public ReadOnlyCollection<int> UnlockedItemIds => unlockedItemIds.AsReadOnly();

		public static event Action OnEconomyManagerLoaded;

		public static event Action<long, long> OnMoneyChanged;

		public static event Action<int> OnItemUnlockStateChanged;

		public static event Action<long> OnMoneyPaid;

		public static event Action<Cost> OnCostPaid;

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			SavesSystem.OnCollectSaveData += OnCollectSaveData;
			SavesSystem.OnSetFile += OnSetSaveFile;
			Load();
		}

		private void OnCollectSaveData()
		{
			Save();
		}

		private void OnSetSaveFile()
		{
			Load();
		}

		private void Load()
		{
			if (SavesSystem.KeyExisits("EconomyData"))
			{
				SetupSaveData(SavesSystem.Load<SaveData>("EconomyData"));
			}
			try
			{
				EconomyManager.OnEconomyManagerLoaded?.Invoke();
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
		}

		private void Save()
		{
			SavesSystem.Save("EconomyData", (SaveData)GenerateSaveData());
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= OnCollectSaveData;
			SavesSystem.OnSetFile -= OnSetSaveFile;
		}

		private static bool Pay(long amount, bool accountAvaliable = true, bool cashAvaliale = true)
		{
			long num = (accountAvaliable ? Money : 0);
			long num2 = (cashAvaliale ? Cash : 0);
			if (num + num2 < amount)
			{
				return false;
			}
			long num3 = amount;
			if (accountAvaliable)
			{
				if (num > amount)
				{
					num3 = 0L;
					Money -= amount;
				}
				else
				{
					num3 -= num;
					Money = 0L;
				}
			}
			if (cashAvaliale && num3 > 0)
			{
				ItemUtilities.ConsumeItems(451, num3);
				num3 = 0L;
			}
			if (amount > 0)
			{
				EconomyManager.OnMoneyPaid?.Invoke(amount);
			}
			return true;
		}

		public static bool Pay(Cost cost, bool accountAvaliable = true, bool cashAvaliale = true)
		{
			if (!IsEnough(cost, accountAvaliable))
			{
				return false;
			}
			if (!Pay(cost.money, accountAvaliable, cashAvaliale))
			{
				return false;
			}
			if (!ItemUtilities.ConsumeItems(cost))
			{
				return false;
			}
			EconomyManager.OnCostPaid?.Invoke(cost);
			return true;
		}

		public static bool IsEnough(Cost cost, bool accountAvaliable = true, bool cashAvaliale = true)
		{
			long num = (accountAvaliable ? Money : 0);
			long num2 = (cashAvaliale ? Cash : 0);
			if (num + num2 < cost.money)
			{
				return false;
			}
			if (cost.items != null)
			{
				Cost.ItemEntry[] items = cost.items;
				for (int i = 0; i < items.Length; i++)
				{
					Cost.ItemEntry itemEntry = items[i];
					if (ItemUtilities.GetItemCount(itemEntry.id) < itemEntry.amount)
					{
						return false;
					}
				}
			}
			return true;
		}

		public static bool Add(long amount)
		{
			if (Instance == null)
			{
				return false;
			}
			Money += amount;
			return true;
		}

		public static bool IsWaitingForUnlockConfirm(int itemTypeID)
		{
			if (GameplayDataSettings.Economy.UnlockedItemByDefault.Contains(itemTypeID))
			{
				return false;
			}
			if (Instance == null)
			{
				return false;
			}
			return Instance.unlockesWaitingForConfirm.Contains(itemTypeID);
		}

		public static bool IsUnlocked(int itemTypeID)
		{
			if (GameplayDataSettings.Economy.UnlockedItemByDefault.Contains(itemTypeID))
			{
				return true;
			}
			if (Instance == null)
			{
				return false;
			}
			return Instance.UnlockedItemIds.Contains(itemTypeID);
		}

		public static void Unlock(int itemTypeID, bool needConfirm = true, bool showUI = true)
		{
			if (!(Instance == null) && !Instance.unlockedItemIds.Contains(itemTypeID) && !Instance.unlockesWaitingForConfirm.Contains(itemTypeID))
			{
				if (needConfirm)
				{
					Instance.unlockesWaitingForConfirm.Add(itemTypeID);
				}
				else
				{
					Instance.unlockedItemIds.Add(itemTypeID);
				}
				EconomyManager.OnItemUnlockStateChanged?.Invoke(itemTypeID);
				ItemMetaData metaData = ItemAssetsCollection.GetMetaData(itemTypeID);
				UnityEngine.Debug.Log(ItemUnlockNotificationTextMainFormat);
				UnityEngine.Debug.Log(metaData.DisplayName);
				if (showUI)
				{
					NotificationText.Push("Notification_StockShoopItemUnlockFormat".ToPlainText().Format(new
					{
						displayName = metaData.DisplayName
					}));
				}
			}
		}

		public static void ConfirmUnlock(int itemTypeID)
		{
			if (!(Instance == null))
			{
				Instance.unlockesWaitingForConfirm.Remove(itemTypeID);
				Instance.unlockedItemIds.Add(itemTypeID);
				EconomyManager.OnItemUnlockStateChanged?.Invoke(itemTypeID);
			}
		}

		public object GenerateSaveData()
		{
			return new SaveData
			{
				money = Money,
				unlockedItems = unlockedItemIds.ToArray(),
				unlockesWaitingForConfirm = unlockesWaitingForConfirm.ToArray()
			};
		}

		public void SetupSaveData(object rawData)
		{
			if (rawData is SaveData saveData)
			{
				money = saveData.money;
				unlockedItemIds.Clear();
				if (saveData.unlockedItems != null)
				{
					unlockedItemIds.AddRange(saveData.unlockedItems);
				}
				unlockesWaitingForConfirm.Clear();
				if (saveData.unlockesWaitingForConfirm != null)
				{
					unlockesWaitingForConfirm.AddRange(saveData.unlockesWaitingForConfirm);
				}
			}
		}
	}
	[Serializable]
	public struct Cost
	{
		[Serializable]
		public struct ItemEntry
		{
			[ItemTypeID]
			public int id;

			public long amount;
		}

		public long money;

		public ItemEntry[] items;

		private static List<object> ReturnTaskLocks = new List<object>();

		public bool Enough => EconomyManager.IsEnough(this);

		public bool IsFree
		{
			get
			{
				if (money > 0)
				{
					return false;
				}
				if (items != null && items.Length != 0)
				{
					return false;
				}
				return true;
			}
		}

		public static bool TaskPending => ReturnTaskLocks.Count > 0;

		public bool Pay(bool accountAvaliable = true, bool cashAvaliable = true)
		{
			return EconomyManager.Pay(this, accountAvaliable, cashAvaliable);
		}

		public static Cost FromString(string costDescription)
		{
			int num = 0;
			List<ItemEntry> list = new List<ItemEntry>();
			string[] array = costDescription.Split(',');
			foreach (string text in array)
			{
				string[] array2 = text.Split(":");
				if (array2.Length != 2)
				{
					UnityEngine.Debug.LogError("Invalid cost description: " + text + "\n" + costDescription);
					continue;
				}
				string text2 = array2[0].Trim();
				if (!int.TryParse(array2[1].Trim(), out var result))
				{
					UnityEngine.Debug.LogError("Invalid cost description: " + text);
					continue;
				}
				if (text2 == "money")
				{
					num = result;
					continue;
				}
				int num2 = ItemAssetsCollection.TryGetIDByName(text2);
				if (num2 <= 0)
				{
					UnityEngine.Debug.LogError("Invalid item name " + text2);
					continue;
				}
				list.Add(new ItemEntry
				{
					id = num2,
					amount = result
				});
			}
			return new Cost
			{
				money = num,
				items = list.ToArray()
			};
		}

		internal async UniTask Return(bool directToBuffer = false, bool toPlayerInventory = false, int amountFactor = 1, List<Item> generatedItemsBuffer = null)
		{
			object taskLock = new object();
			ReturnTaskLocks.Add(taskLock);
			List<Item> generatedItems = new List<Item>();
			ItemEntry[] array = items;
			for (int i = 0; i < array.Length; i++)
			{
				ItemEntry item = array[i];
				long count = item.amount * amountFactor;
				while (count > 0)
				{
					Item item2 = await ItemAssetsCollection.InstantiateAsync(item.id);
					if (item2.Stackable)
					{
						if (count > item2.MaxStackCount)
						{
							item2.StackCount = item2.MaxStackCount;
						}
						else
						{
							item2.StackCount = (int)count;
						}
						if (item2.StackCount <= 0)
						{
							UnityEngine.Debug.LogError($"物品{item2.DisplayName}({item2.TypeID})的StackCount为{item2.StackCount},请检查");
							count--;
						}
						else
						{
							count -= item2.StackCount;
						}
					}
					else
					{
						count--;
					}
					generatedItems.Add(item2);
				}
			}
			foreach (Item item3 in generatedItems)
			{
				if (!toPlayerInventory || !ItemUtilities.SendToPlayerCharacterInventory(item3))
				{
					ItemUtilities.SendToPlayerStorage(item3, directToBuffer);
				}
			}
			generatedItemsBuffer?.AddRange(generatedItems);
			EconomyManager.Add(money * amountFactor);
			ReturnTaskLocks.Remove(taskLock);
		}

		public Cost(long money, (int id, long amount)[] items)
		{
			this.money = money;
			this.items = new ItemEntry[items.Length];
			for (int i = 0; i < items.Length; i++)
			{
				(int, long) tuple = items[i];
				ItemEntry[] array = this.items;
				int num = i;
				ItemEntry itemEntry = default(ItemEntry);
				(itemEntry.id, itemEntry.amount) = tuple;
				array[num] = itemEntry;
			}
		}

		public Cost(long money)
		{
			this.money = money;
			items = new ItemEntry[0];
		}

		public Cost(params (int id, long amount)[] items)
		{
			money = 0L;
			this.items = new ItemEntry[items.Length];
			for (int i = 0; i < items.Length; i++)
			{
				(int, long) tuple = items[i];
				ItemEntry[] array = this.items;
				int num = i;
				ItemEntry itemEntry = default(ItemEntry);
				(itemEntry.id, itemEntry.amount) = tuple;
				array[num] = itemEntry;
			}
		}
	}
	public class StockShop : MonoBehaviour, IMerchant, ISaveDataProvider
	{
		public class Entry
		{
			private StockShopDatabase.ItemEntry entry;

			[SerializeField]
			private bool show = true;

			[SerializeField]
			private int currentStock;

			public int MaxStock
			{
				get
				{
					if (entry.maxStock < 1)
					{
						entry.maxStock = 1;
					}
					return entry.maxStock;
				}
			}

			public int ItemTypeID => entry.typeID;

			public bool ForceUnlock
			{
				get
				{
					if (GameMetaData.Instance.IsDemo && entry.lockInDemo)
					{
						return false;
					}
					return entry.forceUnlock;
				}
			}

			public float PriceFactor => entry.priceFactor;

			public float Possibility => entry.possibility;

			public bool Show
			{
				get
				{
					return show;
				}
				set
				{
					show = value;
				}
			}

			public int CurrentStock
			{
				get
				{
					return currentStock;
				}
				set
				{
					currentStock = value;
					this.onStockChanged?.Invoke(this);
				}
			}

			public event Action<Entry> onStockChanged;

			public Entry(StockShopDatabase.ItemEntry cur)
			{
				entry = cur;
			}
		}

		[Serializable]
		public class OverrideSellingPriceEntry
		{
			[ItemTypeID]
			public int typeID;

			public float factor = 0.5f;
		}

		[Serializable]
		private class SaveData
		{
			public class StockCountEntry
			{
				public int itemTypeID;

				public int stock;
			}

			[DateTime]
			public long lastTimeRefreshedStock;

			public List<StockCountEntry> stockCounts = new List<StockCountEntry>();
		}

		[SerializeField]
		private string merchantID = "Albert";

		[LocalizationKey("Default")]
		public string DisplayNameKey;

		[TimeSpan]
		[SerializeField]
		private long refreshAfterTimeSpan;

		[SerializeField]
		private string purchaseNotificationTextFormatKey = "UI_StockShop_PurchasedNotification";

		[SerializeField]
		private bool accountAvaliable;

		[SerializeField]
		private bool returnCash;

		[SerializeField]
		private bool refreshStockOnStart;

		public float sellFactor = 0.5f;

		public List<Entry> entries = new List<Entry>();

		public List<OverrideSellingPriceEntry> overrideSellingPrice = new List<OverrideSellingPriceEntry>();

		[DateTime]
		[SerializeField]
		private long lastTimeRefreshedStock;

		private Dictionary<int, Item> itemInstances = new Dictionary<int, Item>();

		private bool buying;

		private bool selling;

		public string MerchantID => merchantID;

		public string OpinionKey => "Opinion_" + merchantID;

		public string DisplayName => DisplayNameKey.ToPlainText();

		private int Opinion
		{
			get
			{
				return Mathf.Clamp(CommonVariables.GetInt(OpinionKey), -100, 100);
			}
			set
			{
				CommonVariables.SetInt(OpinionKey, value);
			}
		}

		public string PurchaseNotificationTextFormat => purchaseNotificationTextFormatKey.ToPlainText();

		public bool AccountAvaliable => accountAvaliable;

		public TimeSpan TimeSinceLastRefresh
		{
			get
			{
				DateTime dateTime = DateTime.FromBinary(lastTimeRefreshedStock);
				if (dateTime > DateTime.UtcNow)
				{
					dateTime = DateTime.UtcNow;
					lastTimeRefreshedStock = DateTime.UtcNow.ToBinary();
					GameManager.TimeTravelDetected();
				}
				return DateTime.UtcNow - dateTime;
			}
		}

		public TimeSpan NextRefreshETA
		{
			get
			{
				TimeSpan timeSinceLastRefresh = TimeSinceLastRefresh;
				TimeSpan timeSpan = TimeSpan.FromTicks(refreshAfterTimeSpan) - timeSinceLastRefresh;
				if (timeSpan < TimeSpan.Zero)
				{
					timeSpan = TimeSpan.Zero;
				}
				return timeSpan;
			}
		}

		private string SaveKey => "StockShop_" + merchantID;

		public bool Busy
		{
			get
			{
				if (buying)
				{
					return true;
				}
				if (selling)
				{
					return true;
				}
				return false;
			}
		}

		public static event Action<StockShop> OnAfterItemSold;

		public static event Action<StockShop, Item> OnItemPurchased;

		public static event Action<StockShop, Item, int> OnItemSoldByPlayer;

		private async UniTask<Item> GetItemInstance(int typeID)
		{
			if (itemInstances.TryGetValue(typeID, out var value))
			{
				return value;
			}
			Item item = await ItemAssetsCollection.InstantiateAsync(typeID);
			item.transform.SetParent(base.transform);
			item.gameObject.SetActive(value: false);
			itemInstances[typeID] = item;
			return item;
		}

		public Item GetItemInstanceDirect(int typeID)
		{
			if (itemInstances.TryGetValue(typeID, out var value))
			{
				return value;
			}
			return null;
		}

		private void Awake()
		{
			InitializeEntries();
			SavesSystem.OnCollectSaveData += Save;
			SavesSystem.OnSetFile += Load;
			Load();
		}

		private void InitializeEntries()
		{
			StockShopDatabase.MerchantProfile merchantProfile = StockShopDatabase.Instance.GetMerchantProfile(merchantID);
			if (merchantProfile == null)
			{
				UnityEngine.Debug.Log("未配置商人 " + merchantID);
				return;
			}
			foreach (StockShopDatabase.ItemEntry entry in merchantProfile.entries)
			{
				entries.Add(new Entry(entry));
			}
		}

		private void Load()
		{
			if (SavesSystem.KeyExisits(SaveKey))
			{
				SaveData dataRaw = SavesSystem.Load<SaveData>(SaveKey);
				SetupSaveData(dataRaw);
			}
		}

		private void Save()
		{
			if (!(GenerateSaveData() is SaveData value))
			{
				UnityEngine.Debug.LogError("没法正确生成StockShop的SaveData");
			}
			else
			{
				SavesSystem.Save(SaveKey, value);
			}
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= Save;
			SavesSystem.OnSetFile -= Load;
		}

		private void Start()
		{
			CacheItemInstances().Forget();
			if (refreshStockOnStart)
			{
				DoRefreshStock();
				lastTimeRefreshedStock = DateTime.UtcNow.ToBinary();
			}
		}

		private async UniTask CacheItemInstances()
		{
			List<UniTask> list = new List<UniTask>();
			foreach (Entry entry in entries)
			{
				UniTask<Item> itemInstance = GetItemInstance(entry.ItemTypeID);
				list.Add(itemInstance);
			}
			await UniTask.WhenAll(list);
		}

		internal void RefreshIfNeeded()
		{
			TimeSpan timeSpan = TimeSpan.FromTicks(refreshAfterTimeSpan);
			DateTime dateTime = DateTime.FromBinary(lastTimeRefreshedStock);
			if (dateTime > DateTime.UtcNow)
			{
				dateTime = DateTime.UtcNow;
				lastTimeRefreshedStock = dateTime.ToBinary();
			}
			DateTime dateTime2 = DateTime.UtcNow - TimeSpan.FromDays(2.0);
			if (dateTime < dateTime2)
			{
				lastTimeRefreshedStock = dateTime2.ToBinary();
			}
			if (DateTime.UtcNow - dateTime > timeSpan)
			{
				DoRefreshStock();
				lastTimeRefreshedStock = DateTime.UtcNow.ToBinary();
			}
		}

		private void DoRefreshStock()
		{
			bool advancedDebuffMode = LevelManager.Rule.AdvancedDebuffMode;
			foreach (Entry entry in entries)
			{
				if (entry.Possibility > 0f && entry.Possibility < 1f && UnityEngine.Random.Range(0f, 1f) > entry.Possibility)
				{
					entry.Show = false;
					entry.CurrentStock = 0;
					continue;
				}
				ItemMetaData metaData = ItemAssetsCollection.GetMetaData(entry.ItemTypeID);
				if (!advancedDebuffMode && metaData.tags.Contains(GameplayDataSettings.Tags.AdvancedDebuffMode))
				{
					entry.Show = false;
					entry.CurrentStock = 0;
				}
				else
				{
					entry.Show = true;
					entry.CurrentStock = entry.MaxStock;
				}
			}
		}

		public async UniTask<bool> Buy(int itemTypeID, int amount = 1)
		{
			if (Busy)
			{
				return false;
			}
			buying = true;
			bool result = await BuyTask(itemTypeID, amount);
			buying = false;
			return result;
		}

		private async UniTask<bool> BuyTask(int itemTypeID, int amount = 1)
		{
			Entry found = entries.First((Entry e) => e != null && e.ItemTypeID == itemTypeID);
			if (found == null)
			{
				return false;
			}
			if (found.CurrentStock < 1)
			{
				return false;
			}
			Item itemInstanceDirect = GetItemInstanceDirect(itemTypeID);
			if (!itemInstanceDirect.Stackable)
			{
				amount = 1;
			}
			if (found.CurrentStock < amount)
			{
				return false;
			}
			if (itemInstanceDirect == null)
			{
				return false;
			}
			if (!EconomyManager.Pay(new Cost(ConvertPrice(itemInstanceDirect)), accountAvaliable))
			{
				return false;
			}
			Item item = await ItemAssetsCollection.InstantiateAsync(itemTypeID);
			if (!ItemUtilities.SendToPlayerCharacterInventory(item))
			{
				UnityEngine.Debug.Log("玩家身上没地儿了，发送到玩家仓储处");
				ItemUtilities.SendToPlayerStorage(item);
			}
			found.CurrentStock -= amount;
			StockShop.OnAfterItemSold?.Invoke(this);
			StockShop.OnItemPurchased?.Invoke(this, item);
			NotificationText.Push(PurchaseNotificationTextFormat.Format(new
			{
				itemDisplayName = item.DisplayName
			}));
			return true;
		}

		internal async UniTask Sell(Item target)
		{
			if (!Busy && !(target == null) && target.CanBeSold)
			{
				selling = true;
				int sellPrice = ConvertPrice(target, selling: true);
				target.Detach();
				target.DestroyTree();
				if (returnCash)
				{
					await new Cost((451, sellPrice)).Return(directToBuffer: false, toPlayerInventory: true);
				}
				else
				{
					EconomyManager.Add(sellPrice);
				}
				StockShop.OnItemSoldByPlayer?.Invoke(this, target, sellPrice);
				selling = false;
			}
		}

		public void ShowUI()
		{
			if ((bool)StockShopView.Instance)
			{
				RefreshIfNeeded();
				StockShopView.Instance.SetupAndShow(this);
			}
		}

		public int ConvertPrice(Item item, bool selling = false)
		{
			int num = item.GetTotalRawValue();
			if (!selling)
			{
				Entry entry = entries.Find((Entry e) => e != null && e.ItemTypeID == item.TypeID);
				if (entry != null)
				{
					num = Mathf.FloorToInt((float)num * entry.PriceFactor);
				}
			}
			if (selling)
			{
				float factor = sellFactor;
				OverrideSellingPriceEntry overrideSellingPriceEntry = overrideSellingPrice.Find((OverrideSellingPriceEntry e) => e.typeID == item.TypeID);
				if (overrideSellingPriceEntry != null)
				{
					factor = overrideSellingPriceEntry.factor;
				}
				return Mathf.FloorToInt((float)num * factor);
			}
			return num;
		}

		public object GenerateSaveData()
		{
			SaveData saveData = new SaveData();
			saveData.lastTimeRefreshedStock = lastTimeRefreshedStock;
			foreach (Entry entry in entries)
			{
				saveData.stockCounts.Add(new SaveData.StockCountEntry
				{
					itemTypeID = entry.ItemTypeID,
					stock = entry.CurrentStock
				});
			}
			return saveData;
		}

		public void SetupSaveData(object dataRaw)
		{
			if (!(dataRaw is SaveData saveData))
			{
				return;
			}
			lastTimeRefreshedStock = saveData.lastTimeRefreshedStock;
			foreach (Entry cur in entries)
			{
				SaveData.StockCountEntry stockCountEntry = saveData.stockCounts.Find((SaveData.StockCountEntry e) => e != null && e.itemTypeID == cur.ItemTypeID);
				if (stockCountEntry != null)
				{
					cur.Show = stockCountEntry.stock > 0;
					cur.CurrentStock = stockCountEntry.stock;
				}
			}
		}
	}
}
namespace Duckov.Economy.UI
{
	public class StockShopItemEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private string moneyFormat = "n0";

		[SerializeField]
		private ItemDisplay itemDisplay;

		[SerializeField]
		private TextMeshProUGUI priceText;

		[SerializeField]
		private GameObject selectionIndicator;

		[SerializeField]
		private GameObject lockedIndicator;

		[SerializeField]
		private GameObject waitingForUnlockIndicator;

		[SerializeField]
		private GameObject outOfStockIndicator;

		[SerializeField]
		[Range(0f, 1f)]
		private float punchDuration = 0.2f;

		[SerializeField]
		[Range(-1f, 1f)]
		private float selectionRingPunchScale = 0.1f;

		[SerializeField]
		[Range(-1f, 1f)]
		private float iconPunchScale = 0.1f;

		private StockShopView master;

		private StockShop.Entry target;

		private StockShop stockShop => master?.Target;

		public StockShop.Entry Target => target;

		private void Awake()
		{
			itemDisplay.onPointerClick += OnItemDisplayPointerClick;
		}

		private void OnItemDisplayPointerClick(ItemDisplay display, PointerEventData data)
		{
			OnPointerClick(data);
		}

		public Item GetItem()
		{
			return stockShop.GetItemInstanceDirect(target.ItemTypeID);
		}

		internal void Setup(StockShopView master, StockShop.Entry entry)
		{
			UnregisterEvents();
			this.master = master;
			target = entry;
			Item itemInstanceDirect = stockShop.GetItemInstanceDirect(target.ItemTypeID);
			itemDisplay.Setup(itemInstanceDirect);
			itemDisplay.ShowOperationButtons = false;
			itemDisplay.IsStockshopSample = true;
			_ = itemInstanceDirect.StackCount;
			int num = stockShop.ConvertPrice(itemInstanceDirect);
			priceText.text = num.ToString(moneyFormat);
			Refresh();
			RegisterEvents();
		}

		private void RegisterEvents()
		{
			if (master != null)
			{
				StockShopView stockShopView = master;
				stockShopView.onSelectionChanged = (Action)Delegate.Combine(stockShopView.onSelectionChanged, new Action(OnMasterSelectionChanged));
			}
			if (target != null)
			{
				target.onStockChanged += OnTargetStockChanged;
			}
		}

		private void UnregisterEvents()
		{
			if (master != null)
			{
				StockShopView stockShopView = master;
				stockShopView.onSelectionChanged = (Action)Delegate.Remove(stockShopView.onSelectionChanged, new Action(OnMasterSelectionChanged));
			}
			if (target != null)
			{
				target.onStockChanged -= OnTargetStockChanged;
			}
		}

		private void OnMasterSelectionChanged()
		{
			Refresh();
		}

		private void OnTargetStockChanged(StockShop.Entry entry)
		{
			Refresh();
		}

		public bool IsUnlocked()
		{
			if (target == null)
			{
				return false;
			}
			if (target.ForceUnlock)
			{
				return true;
			}
			return EconomyManager.IsUnlocked(target.ItemTypeID);
		}

		private void Refresh()
		{
			if (base.gameObject.activeSelf)
			{
				bool active = master.GetSelection() == this;
				selectionIndicator.SetActive(active);
				bool flag = EconomyManager.IsUnlocked(target.ItemTypeID);
				bool flag2 = EconomyManager.IsWaitingForUnlockConfirm(target.ItemTypeID);
				if (target.ForceUnlock)
				{
					flag = true;
					flag2 = false;
				}
				lockedIndicator.SetActive(!flag && !flag2);
				waitingForUnlockIndicator.SetActive(!flag && flag2);
				base.gameObject.SetActive(flag || flag2);
				outOfStockIndicator.SetActive(Target.CurrentStock <= 0);
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Punch();
			if (!(master == null))
			{
				eventData.Use();
				if (EconomyManager.IsWaitingForUnlockConfirm(target.ItemTypeID))
				{
					EconomyManager.ConfirmUnlock(target.ItemTypeID);
				}
				if (master.GetSelection() == this)
				{
					master.SetSelection(null);
				}
				else
				{
					master.SetSelection(this);
				}
			}
		}

		public void Punch()
		{
			selectionIndicator.transform.DOKill();
			selectionIndicator.transform.localScale = Vector3.one;
			selectionIndicator.transform.DOPunchScale(Vector3.one * selectionRingPunchScale, punchDuration);
		}

		private void OnEnable()
		{
			EconomyManager.OnItemUnlockStateChanged += OnItemUnlockStateChanged;
		}

		private void OnDisable()
		{
			EconomyManager.OnItemUnlockStateChanged -= OnItemUnlockStateChanged;
		}

		private void OnItemUnlockStateChanged(int itemTypeID)
		{
			if (target != null && itemTypeID == target.ItemTypeID)
			{
				Refresh();
			}
		}
	}
	public class StockShopView : View, ISingleSelectionMenu<StockShopItemEntry>
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private FadeGroup detailsFadeGroup;

		[SerializeField]
		private ItemDetailsDisplay details;

		[SerializeField]
		private InventoryDisplay playerInventoryDisplay;

		[SerializeField]
		private InventoryDisplay petInventoryDisplay;

		[SerializeField]
		private InventoryDisplay playerStorageDisplay;

		[SerializeField]
		private StockShopItemEntry entryTemplate;

		[SerializeField]
		private TextMeshProUGUI stockText;

		[SerializeField]
		[LocalizationKey("Default")]
		private string stockTextKey = "UI_Stock";

		[SerializeField]
		private string stockTextFormat = "{text} {current}/{max}";

		[SerializeField]
		private TextMeshProUGUI merchantNameText;

		[SerializeField]
		private UnityEngine.UI.Button interactionButton;

		[SerializeField]
		private UnityEngine.UI.Image interactionButtonImage;

		[SerializeField]
		private Color buttonColor_Interactable;

		[SerializeField]
		private Color buttonColor_NotInteractable;

		[SerializeField]
		private TextMeshProUGUI interactionText;

		[SerializeField]
		private GameObject cashOnlyIndicator;

		[SerializeField]
		private GameObject cannotSellIndicator;

		[LocalizationKey("Default")]
		[SerializeField]
		private string textBuy = "购买";

		[LocalizationKey("Default")]
		[SerializeField]
		private string textSoldOut = "已售罄";

		[LocalizationKey("Default")]
		[SerializeField]
		private string textSell = "出售";

		[LocalizationKey("Default")]
		[SerializeField]
		private string textUnlock = "解锁";

		[LocalizationKey("Default")]
		[SerializeField]
		private string textLocked = "已锁定";

		[SerializeField]
		private GameObject priceDisplay;

		[SerializeField]
		private TextMeshProUGUI priceText;

		[SerializeField]
		private GameObject lockDisplay;

		[SerializeField]
		private FadeGroup clickBlockerFadeGroup;

		[SerializeField]
		private TextMeshProUGUI refreshCountDown;

		private string sfx_Buy = "UI/buy";

		private string sfx_Sell = "UI/sell";

		private PrefabPool<StockShopItemEntry> _entryPool;

		private StockShop target;

		private StockShopItemEntry selectedItem;

		public Action onSelectionChanged;

		public static StockShopView Instance => View.GetViewInstance<StockShopView>();

		private string TextBuy => textBuy.ToPlainText();

		private string TextSoldOut => textSoldOut.ToPlainText();

		private string TextSell => textSell.ToPlainText();

		private string TextUnlock => textUnlock.ToPlainText();

		private string TextLocked => textLocked.ToPlainText();

		private PrefabPool<StockShopItemEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<StockShopItemEntry>(entryTemplate, entryTemplate.transform.parent);
					entryTemplate.gameObject.SetActive(value: false);
				}
				return _entryPool;
			}
		}

		private UnityEngine.Object Selection
		{
			get
			{
				if (ItemUIUtilities.SelectedItemDisplay != null)
				{
					return ItemUIUtilities.SelectedItemDisplay;
				}
				if (selectedItem != null)
				{
					return selectedItem;
				}
				return null;
			}
		}

		public StockShop Target => target;

		protected override void Awake()
		{
			base.Awake();
			interactionButton.onClick.AddListener(OnInteractionButtonClicked);
			UIInputManager.OnFastPick += OnFastPick;
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			UIInputManager.OnFastPick -= OnFastPick;
		}

		private void OnFastPick(UIInputEventData data)
		{
			if (base.isActiveAndEnabled)
			{
				OnInteractionButtonClicked();
			}
		}

		private void FixedUpdate()
		{
			RefreshCountDown();
		}

		private void RefreshCountDown()
		{
			if (target == null)
			{
				refreshCountDown.text = "-";
			}
			TimeSpan nextRefreshETA = target.NextRefreshETA;
			int days = nextRefreshETA.Days;
			int hours = nextRefreshETA.Hours;
			int minutes = nextRefreshETA.Minutes;
			int seconds = nextRefreshETA.Seconds;
			refreshCountDown.text = string.Format("{0}{1:00}:{2:00}:{3:00}", (days > 0) ? (days + " - ") : "", hours, minutes, seconds);
		}

		private void OnInteractionButtonClicked()
		{
			if (Selection == null)
			{
				return;
			}
			if (Selection is ItemDisplay itemDisplay)
			{
				Target.Sell(itemDisplay.Target).Forget();
				AudioManager.Post(sfx_Sell);
				ItemUIUtilities.Select(null);
				OnSelectionChanged();
			}
			else if (Selection is StockShopItemEntry stockShopItemEntry)
			{
				int itemTypeID = stockShopItemEntry.Target.ItemTypeID;
				if (stockShopItemEntry.IsUnlocked())
				{
					BuyTask(itemTypeID).Forget();
				}
				else if (EconomyManager.IsWaitingForUnlockConfirm(itemTypeID))
				{
					EconomyManager.ConfirmUnlock(itemTypeID);
				}
			}
		}

		private async UniTask BuyTask(int itemTypeID)
		{
			if (await Target.Buy(itemTypeID))
			{
				AudioManager.Post(sfx_Buy);
				clickBlockerFadeGroup.SkipShow();
				await UniTask.NextFrame();
				await clickBlockerFadeGroup.HideAndReturnTask();
			}
		}

		private void OnEnable()
		{
			ItemUIUtilities.OnSelectionChanged += OnItemUIUtilitiesSelectionChanged;
			EconomyManager.OnItemUnlockStateChanged += OnItemUnlockStateChanged;
			StockShop.OnAfterItemSold += OnAfterItemSold;
			UIInputManager.OnNextPage += OnNextPage;
			UIInputManager.OnPreviousPage += OnPreviousPage;
		}

		private void OnDisable()
		{
			ItemUIUtilities.OnSelectionChanged -= OnItemUIUtilitiesSelectionChanged;
			EconomyManager.OnItemUnlockStateChanged -= OnItemUnlockStateChanged;
			StockShop.OnAfterItemSold -= OnAfterItemSold;
			UIInputManager.OnNextPage -= OnNextPage;
			UIInputManager.OnPreviousPage -= OnPreviousPage;
		}

		private void OnNextPage(UIInputEventData data)
		{
			playerStorageDisplay.NextPage();
		}

		private void OnPreviousPage(UIInputEventData data)
		{
			playerStorageDisplay.PreviousPage();
		}

		private void OnAfterItemSold(StockShop shop)
		{
			RefreshInteractionButton();
			RefreshStockText();
		}

		private void OnItemUnlockStateChanged(int itemTypeID)
		{
			if (!(details.Target == null) && itemTypeID == details.Target.TypeID)
			{
				RefreshInteractionButton();
				RefreshStockText();
			}
		}

		private void OnItemUIUtilitiesSelectionChanged()
		{
			if (selectedItem != null && ItemUIUtilities.SelectedItemDisplay != null)
			{
				selectedItem = null;
			}
			OnSelectionChanged();
		}

		private void OnSelectionChanged()
		{
			onSelectionChanged?.Invoke();
			if (Selection == null)
			{
				detailsFadeGroup.Hide();
				return;
			}
			Item item = null;
			if (Selection is StockShopItemEntry stockShopItemEntry)
			{
				item = stockShopItemEntry.GetItem();
			}
			else if (Selection is ItemDisplay itemDisplay)
			{
				item = itemDisplay.Target;
			}
			if (item == null)
			{
				detailsFadeGroup.Hide();
				return;
			}
			details.Setup(item);
			RefreshStockText();
			RefreshInteractionButton();
			RefreshCountDown();
			detailsFadeGroup.Show();
		}

		private void RefreshStockText()
		{
			if (Selection is StockShopItemEntry stockShopItemEntry)
			{
				stockText.gameObject.SetActive(value: true);
				stockText.text = stockTextFormat.Format(new
				{
					text = stockTextKey.ToPlainText(),
					current = stockShopItemEntry.Target.CurrentStock,
					max = stockShopItemEntry.Target.MaxStock
				});
			}
			else if (Selection is ItemDisplay)
			{
				stockText.gameObject.SetActive(value: false);
			}
		}

		public StockShopItemEntry GetSelection()
		{
			return Selection as StockShopItemEntry;
		}

		public bool SetSelection(StockShopItemEntry selection)
		{
			if (ItemUIUtilities.SelectedItem != null)
			{
				ItemUIUtilities.Select(null);
			}
			selectedItem = selection;
			OnSelectionChanged();
			return true;
		}

		internal void Setup(StockShop target)
		{
			this.target = target;
			detailsFadeGroup.SkipHide();
			merchantNameText.text = target.DisplayName;
			Inventory inventory = LevelManager.Instance?.MainCharacter?.CharacterItem?.Inventory;
			playerInventoryDisplay.Setup(inventory, null, (Item e) => e == null || e.CanBeSold);
			if (PetProxy.PetInventory != null)
			{
				petInventoryDisplay.Setup(PetProxy.PetInventory, null, (Item e) => e == null || e.CanBeSold);
				petInventoryDisplay.gameObject.SetActive(value: true);
			}
			else
			{
				petInventoryDisplay.gameObject.SetActive(value: false);
			}
			Inventory inventory2 = PlayerStorage.Inventory;
			if (inventory2 != null)
			{
				playerStorageDisplay.gameObject.SetActive(value: true);
				playerStorageDisplay.Setup(inventory2, null, (Item e) => e == null || e.CanBeSold);
			}
			else
			{
				playerStorageDisplay.gameObject.SetActive(value: false);
			}
			EntryPool.ReleaseAll();
			Transform setParent = entryTemplate.transform.parent;
			foreach (StockShop.Entry entry in target.entries)
			{
				if (entry.Show)
				{
					StockShopItemEntry stockShopItemEntry = EntryPool.Get(setParent);
					stockShopItemEntry.Setup(this, entry);
					stockShopItemEntry.transform.SetAsLastSibling();
				}
			}
			TradingUIUtilities.ActiveMerchant = target;
		}

		private void RefreshInteractionButton()
		{
			cannotSellIndicator.SetActive(value: false);
			cashOnlyIndicator.SetActive(!Target.AccountAvaliable);
			if (Selection is ItemDisplay itemDisplay)
			{
				bool canBeSold = itemDisplay.Target.CanBeSold;
				interactionButton.interactable = canBeSold;
				priceDisplay.gameObject.SetActive(value: true);
				lockDisplay.gameObject.SetActive(value: false);
				interactionText.text = TextSell;
				interactionButtonImage.color = buttonColor_Interactable;
				priceText.text = GetPriceText(itemDisplay.Target, selling: true);
				cannotSellIndicator.SetActive(!itemDisplay.Target.CanBeSold);
			}
			else
			{
				if (!(Selection is StockShopItemEntry stockShopItemEntry))
				{
					return;
				}
				bool flag = stockShopItemEntry.IsUnlocked();
				bool flag2 = EconomyManager.IsWaitingForUnlockConfirm(stockShopItemEntry.Target.ItemTypeID);
				interactionButton.interactable = flag || flag2;
				priceDisplay.gameObject.SetActive(flag);
				lockDisplay.gameObject.SetActive(!flag);
				cannotSellIndicator.SetActive(value: false);
				if (flag)
				{
					Item item = stockShopItemEntry.GetItem();
					int num = GetPrice(item, selling: false);
					bool enough = new Cost(num).Enough;
					priceText.text = num.ToString("n0");
					if (stockShopItemEntry.Target.CurrentStock > 0)
					{
						interactionText.text = TextBuy;
						interactionButtonImage.color = (enough ? buttonColor_Interactable : buttonColor_NotInteractable);
					}
					else
					{
						interactionButton.interactable = false;
						interactionText.text = TextSoldOut;
						interactionButtonImage.color = buttonColor_NotInteractable;
					}
				}
				else if (flag2)
				{
					interactionText.text = TextUnlock;
					interactionButtonImage.color = buttonColor_Interactable;
				}
				else
				{
					interactionText.text = TextLocked;
					interactionButtonImage.color = buttonColor_NotInteractable;
				}
			}
			int GetPrice(Item item2, bool selling)
			{
				return Target.ConvertPrice(item2, selling);
			}
			string GetPriceText(Item item2, bool selling)
			{
				return GetPrice(item2, selling).ToString("n0");
			}
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		internal void SetupAndShow(StockShop stockShop)
		{
			ItemUIUtilities.Select(null);
			SetSelection(null);
			Setup(stockShop);
			Open();
		}
	}
}
namespace Duckov.Splines
{
	public class Bevel
	{
		public static Vector3[] Evaluate(Vector3 cur, Vector3 prev, Vector3 next, int step, float offset, out Vector3 o, out Vector3 axis, float protectionOffset = 0.1f, bool useProtectionOffset = false, float clipDistance = float.MaxValue)
		{
			if (offset > clipDistance)
			{
				offset = clipDistance;
			}
			Vector3 vector = cur + (prev - cur).normalized * offset;
			Vector3 vector2 = cur + (next - cur).normalized * offset;
			float num = offset;
			float num2 = (vector2 - vector).magnitude / 2f;
			Vector3 vector3 = (vector + vector2) / 2f - cur;
			float magnitude = vector3.magnitude;
			float num3 = Mathf.Asin(num2 / num);
			float num4 = MathF.PI / 2f - num3;
			float num5 = num2 / Mathf.Tan(num4);
			Vector3 vector4 = (o = cur + vector3.normalized * (num5 + magnitude));
			Vector3 vector5 = vector - vector4;
			Vector3 rhs = vector2 - vector4;
			_ = vector5.magnitude;
			axis = Vector3.Cross(vector5, rhs);
			int num6 = step + 2;
			float num7 = num4 * 2f / (float)(num6 - 1) / MathF.PI * 180f;
			Vector3[] array = new Vector3[num6];
			for (int i = 0; i < num6; i++)
			{
				Quaternion quaternion = Quaternion.AngleAxis(num7 * (float)i, axis);
				array[i] = vector4 + quaternion * vector5;
			}
			if (useProtectionOffset)
			{
				Vector3[] array2 = new Vector3[num6 + 2];
				array.CopyTo(array2, 1);
				array2[0] = vector + (vector - cur).normalized * protectionOffset;
				array2[^1] = vector2 + (vector2 - cur).normalized * protectionOffset;
				return array2;
			}
			return array;
		}
	}
	[RequireComponent(typeof(PipeRenderer))]
	public class BeveledLineShape : ShapeProvider
	{
		public PipeRenderer pipeRenderer;

		public Points pointsComponent;

		[UnityEngine.Header("Shape")]
		public float bevelSize = 0.5f;

		[UnityEngine.Header("Subdivide")]
		public int subdivision = 2;

		public bool subdivideByLength;

		public float subdivisionLength = 0.1f;

		[UnityEngine.Header("UV")]
		public float uvMultiplier = 1f;

		public float uvOffset;

		[UnityEngine.Header("Extra")]
		public bool useProtectionOffset;

		public float protectionOffset = 0.2f;

		public bool edit;

		[HideInInspector]
		public List<Vector3> points
		{
			get
			{
				if ((bool)pointsComponent)
				{
					return pointsComponent.points;
				}
				return null;
			}
		}

		public override PipeRenderer.OrientedPoint[] GenerateShape()
		{
			List<PipeRenderer.OrientedPoint> list = new List<PipeRenderer.OrientedPoint>();
			if (!pointsComponent || points.Count <= 1)
			{
				return list.ToArray();
			}
			if (pointsComponent.worldSpace)
			{
				pointsComponent.worldSpace = false;
			}
			int count = points.Count;
			for (int i = 0; i < count; i++)
			{
				Vector3 vector = points[i];
				if (i == 0 || i == count - 1)
				{
					PipeRenderer.OrientedPoint item = new PipeRenderer.OrientedPoint
					{
						position = vector,
						tangent = ((i == 0) ? (points[i + 1] - vector).normalized : (vector - points[i - 1]).normalized),
						normal = Vector3.up,
						rotationalAxisVector = Vector3.forward
					};
					list.Add(item);
					continue;
				}
				Vector3 vector2 = points[i - 1];
				Vector3 vector3 = points[i + 1];
				Vector3 vector4 = vector - vector2;
				Vector3 vector5 = vector3 - vector2;
				Vector3 vector6 = Vector3.Cross(vector3 - vector, vector2 - vector);
				if (vector4.magnitude == 0f || vector5.magnitude == 0f || vector4.normalized == vector5.normalized || vector4.normalized == -vector5.normalized)
				{
					Vector3 normalized = (vector3 - vector).normalized;
					PipeRenderer.OrientedPoint item2 = new PipeRenderer.OrientedPoint
					{
						position = vector,
						tangent = normalized,
						normal = vector6,
						rotationalAxisVector = Vector3.forward,
						rotation = Quaternion.LookRotation(normalized, vector6),
						uv = Vector2.zero
					};
					list.Add(item2);
					continue;
				}
				float a = ((i >= 2) ? ((vector - vector2).magnitude / 2f) : (vector - vector2).magnitude);
				float b = ((i < count - 2) ? ((vector - vector3).magnitude / 2f) : (vector - vector3).magnitude);
				float clipDistance = Mathf.Min(a, b);
				Vector3 o;
				Vector3 axis;
				Vector3[] array = Bevel.Evaluate(vector, vector2, vector3, subdivision, bevelSize, out o, out axis, protectionOffset, useProtectionOffset, clipDistance);
				for (int j = 0; j < array.Length; j++)
				{
					Vector3 vector7 = array[j];
					Vector3 vector8 = ((j < array.Length - 1) ? array[j + 1] : vector3) - vector7;
					Vector3 vector9 = o - vector7;
					Vector3 vector10 = ((useProtectionOffset && (j == 0 || j == array.Length - 1)) ? vector8.normalized : (Quaternion.AngleAxis(-90f, axis) * vector9));
					float num = 0.001f;
					if (!(vector8.magnitude < num))
					{
						Quaternion rotation = Quaternion.LookRotation(vector10, vector6);
						Vector3 forward = Vector3.forward;
						PipeRenderer.OrientedPoint item3 = new PipeRenderer.OrientedPoint
						{
							position = vector7,
							tangent = vector10,
							normal = vector6,
							rotationalAxisVector = forward,
							rotation = rotation,
							uv = Vector2.zero
						};
						list.Add(item3);
					}
				}
			}
			if (subdivideByLength && subdivisionLength > 0f)
			{
				for (int k = 0; k < list.Count - 1; k++)
				{
					PipeRenderer.OrientedPoint orientedPoint = list[k];
					PipeRenderer.OrientedPoint orientedPoint2 = list[k + 1];
					Vector3 vector11 = orientedPoint2.position - orientedPoint.position;
					Vector3 normalized2 = vector11.normalized;
					float magnitude = vector11.magnitude;
					if (!(magnitude > subdivisionLength))
					{
						continue;
					}
					int num2 = Mathf.FloorToInt(magnitude / subdivisionLength);
					for (int l = 1; l <= num2; l++)
					{
						Vector3 vector12 = orientedPoint.position + l * normalized2 * subdivisionLength;
						if ((vector12 - orientedPoint2.position).magnitude < subdivisionLength)
						{
							break;
						}
						PipeRenderer.OrientedPoint item4 = new PipeRenderer.OrientedPoint
						{
							position = vector12,
							normal = orientedPoint.normal,
							rotation = orientedPoint.rotation,
							rotationalAxisVector = orientedPoint.rotationalAxisVector,
							tangent = orientedPoint.tangent,
							uv = orientedPoint.uv
						};
						list.Insert(k + l, item4);
					}
				}
			}
			PipeRenderer.OrientedPoint[] array2 = list.ToArray();
			array2 = PipeHelperFunctions.RemoveDuplicates(array2);
			PipeHelperFunctions.RecalculateNormals(ref array2);
			PipeHelperFunctions.RecalculateUvs(ref array2, uvMultiplier, uvOffset);
			return array2;
		}
	}
}
namespace Duckov.Scenes
{
	public class MultiSceneCore : MonoBehaviour
	{
		[SerializeField]
		private string levelStateName = "None";

		[SerializeField]
		private string playStinger = "";

		[SerializeField]
		private bool playAfterLevelInit;

		[SerializeField]
		private List<SubSceneEntry> subScenes;

		private Scene activeSubScene;

		[HideInInspector]
		public List<int> usedCreatorIds = new List<int>();

		[HideInInspector]
		public Dictionary<int, object> inLevelData = new Dictionary<int, object>();

		[SerializeField]
		private bool teleportToRandomOnLevelInitialized;

		private Dictionary<int, GameObject> setActiveWithSceneObjects = new Dictionary<int, GameObject>();

		private bool isLoading;

		private SubSceneEntry cachedSubsceneEntry;

		public static MultiSceneCore Instance { get; private set; }

		public List<SubSceneEntry> SubScenes => subScenes;

		public static Scene? MainScene
		{
			get
			{
				if (Instance == null)
				{
					return null;
				}
				return Instance.gameObject.scene;
			}
		}

		public static string ActiveSubSceneID
		{
			get
			{
				if (!ActiveSubScene.HasValue)
				{
					return null;
				}
				if (Instance == null)
				{
					return null;
				}
				return Instance.SubScenes.Find((SubSceneEntry e) => e != null && ActiveSubScene.Value.buildIndex == e.Info.BuildIndex)?.sceneID;
			}
		}

		public static Scene? ActiveSubScene
		{
			get
			{
				if (Instance == null)
				{
					return null;
				}
				if (Instance.isLoading)
				{
					return null;
				}
				return Instance.activeSubScene;
			}
		}

		public SceneInfoEntry SceneInfo => SceneInfoCollection.GetSceneInfo(base.gameObject.scene.buildIndex);

		public string DisplayName
		{
			get
			{
				SceneInfoEntry sceneInfo = SceneInfoCollection.GetSceneInfo(base.gameObject.scene.buildIndex);
				if (sceneInfo == null)
				{
					return "?";
				}
				return sceneInfo.DisplayName;
			}
		}

		public string DisplaynameRaw
		{
			get
			{
				SceneInfoEntry sceneInfo = SceneInfoCollection.GetSceneInfo(base.gameObject.scene.buildIndex);
				if (sceneInfo == null)
				{
					return "?";
				}
				return sceneInfo.DisplayNameRaw;
			}
		}

		public bool IsLoading => isLoading;

		public static string MainSceneID => SceneInfoCollection.GetSceneID(MainScene.Value.buildIndex);

		public static event Action<MultiSceneCore, Scene> OnSubSceneWillBeUnloaded;

		public static event Action<MultiSceneCore, Scene> OnSubSceneLoaded;

		public static event Action<MultiSceneCore> OnInstanceAwake;

		public static event Action<MultiSceneCore> OnInstanceDestroy;

		public static event Action<string> OnSetSceneVisited;

		public static void MoveToActiveWithScene(GameObject go, int sceneBuildIndex)
		{
			if (!(Instance == null))
			{
				Transform setActiveWithSceneParent = Instance.GetSetActiveWithSceneParent(sceneBuildIndex);
				go.transform.SetParent(setActiveWithSceneParent);
			}
		}

		public static void MoveToActiveWithScene(GameObject go)
		{
			int buildIndex = go.scene.buildIndex;
			MoveToActiveWithScene(go, buildIndex);
		}

		public Transform GetSetActiveWithSceneParent(int sceneBuildIndex)
		{
			if (setActiveWithSceneObjects.TryGetValue(sceneBuildIndex, out var value))
			{
				return value.transform;
			}
			SceneInfoEntry sceneInfoEntry = SceneInfoCollection.GetSceneInfo(sceneBuildIndex);
			if (sceneInfoEntry == null)
			{
				sceneInfoEntry = new SceneInfoEntry();
				UnityEngine.Debug.LogWarning($"BuildIndex {sceneBuildIndex} 的sceneInfo不存在");
			}
			GameObject gameObject = new GameObject(sceneInfoEntry.ID);
			gameObject.transform.SetParent(base.transform);
			setActiveWithSceneObjects.Add(sceneBuildIndex, gameObject);
			gameObject.SetActive(sceneInfoEntry.IsLoaded);
			return gameObject.transform;
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			else
			{
				UnityEngine.Debug.LogError("Multiple Multi Scene Core detected!");
			}
			MultiSceneCore.OnInstanceAwake?.Invoke(this);
			if (playAfterLevelInit)
			{
				if (LevelManager.AfterInit)
				{
					PlayStinger();
				}
				else
				{
					LevelManager.OnAfterLevelInitialized += OnAfterLevelInitialized;
				}
			}
		}

		private void OnDestroy()
		{
			MultiSceneCore.OnInstanceDestroy?.Invoke(this);
			LevelManager.OnAfterLevelInitialized -= OnAfterLevelInitialized;
		}

		private void OnAfterLevelInitialized()
		{
			if (playAfterLevelInit)
			{
				PlayStinger();
			}
		}

		public void PlayStinger()
		{
			if (!string.IsNullOrWhiteSpace(playStinger))
			{
				AudioManager.PlayStringer(playStinger);
			}
		}

		private void Start()
		{
			CreatePointsOfInterestsForLocations();
			AudioManager.StopBGM();
			AudioManager.SetState("Level", levelStateName);
			if (SceneInfo != null && !string.IsNullOrEmpty(SceneInfo.ID))
			{
				SetVisited(SceneInfo.ID);
			}
		}

		public static void SetVisited(string sceneID)
		{
			SavesSystem.Save("MultiSceneCore_Visited_" + sceneID, value: true);
			MultiSceneCore.OnSetSceneVisited?.Invoke(sceneID);
		}

		public static bool GetVisited(string sceneID)
		{
			return SavesSystem.Load<bool>("MultiSceneCore_Visited_" + sceneID);
		}

		private void CreatePointsOfInterestsForLocations()
		{
			foreach (SubSceneEntry subScene in SubScenes)
			{
				foreach (SubSceneEntry.Location cachedLocation in subScene.cachedLocations)
				{
					if (cachedLocation.showInMap)
					{
						SimplePointOfInterest.Create(cachedLocation.position, subScene.sceneID, cachedLocation.DisplayNameRaw, null, hideIcon: true);
					}
				}
			}
		}

		private void CreatePointsOfInterestsForTeleporters()
		{
			foreach (SubSceneEntry subScene in SubScenes)
			{
				foreach (SubSceneEntry.TeleporterInfo cachedTeleporter in subScene.cachedTeleporters)
				{
					SimplePointOfInterest.Create(cachedTeleporter.position, subScene.sceneID, "", GameplayDataSettings.UIStyle.DefaultTeleporterIcon).ScaleFactor = GameplayDataSettings.UIStyle.TeleporterIconScale;
				}
			}
		}

		public void BeginLoadSubScene(SceneReference reference)
		{
			LoadSubScene(reference).Forget();
		}

		private SceneReference GetSubSceneReference(string sceneID)
		{
			return subScenes.Find((SubSceneEntry e) => e.sceneID == sceneID)?.SceneReference;
		}

		private async UniTask<bool> LoadSubScene(SceneReference targetScene, bool withBlackScreen = true)
		{
			if (SceneLoader.IsSceneLoading)
			{
				UnityEngine.Debug.LogWarning("已经在加载子场景了");
				return false;
			}
			if (isLoading)
			{
				UnityEngine.Debug.LogWarning("已经在加载子场景了");
				return false;
			}
			if (targetScene == null)
			{
				UnityEngine.Debug.LogWarning("目标场景为空");
				return false;
			}
			isLoading = true;
			if (withBlackScreen)
			{
				await BlackScreen.ShowAndReturnTask();
			}
			if (Cost.TaskPending)
			{
				UnityEngine.Debug.LogError("MultiSceneCore: 检测到正在返还物品");
			}
			_ = Time.unscaledTime;
			Scene currentMainScene = base.gameObject.scene;
			SceneManager.SetActiveScene(base.gameObject.scene);
			List<UniTask> list = new List<UniTask>();
			if (activeSubScene.isLoaded)
			{
				MultiSceneCore.OnSubSceneWillBeUnloaded?.Invoke(this, activeSubScene);
				LocalOnSubSceneWillBeUnloaded(activeSubScene);
				UniTask item = SceneManager.UnloadSceneAsync(activeSubScene).ToUniTask();
				list.Add(item);
			}
			UniTask item2 = SceneManager.LoadSceneAsync(targetScene.BuildIndex, LoadSceneMode.Additive).ToUniTask();
			list.Add(item2);
			await UniTask.WhenAll(list);
			if (currentMainScene != SceneManager.GetActiveScene())
			{
				UnityEngine.Debug.LogError("Sub-scene loading failed because the Active Scene has Changed during this process!");
				await SceneManager.UnloadSceneAsync(targetScene.BuildIndex);
				return false;
			}
			activeSubScene = targetScene.LoadedScene;
			cachedSubsceneEntry = GetSubSceneInfo(activeSubScene);
			AudioManager.SetState("GameStatus", "Playing");
			string sceneID = SceneInfoCollection.GetSceneID(targetScene.BuildIndex);
			if (!string.IsNullOrEmpty(sceneID))
			{
				SetVisited(sceneID);
			}
			LocalOnSubSceneLoaded(activeSubScene);
			SceneManager.SetActiveScene(activeSubScene);
			await UniTask.NextFrame();
			_ = AudioManager.PlayingBGM;
			BlackScreen.HideAndReturnTask().Forget();
			isLoading = false;
			MultiSceneCore.OnSubSceneLoaded?.Invoke(this, activeSubScene);
			return true;
		}

		private void LocalOnSubSceneWillBeUnloaded(Scene scene)
		{
			subScenes.Find((SubSceneEntry e) => e != null && e.Info.BuildIndex == scene.buildIndex);
			Transform setActiveWithSceneParent = GetSetActiveWithSceneParent(scene.buildIndex);
			UnityEngine.Debug.Log($"Setting Active False {setActiveWithSceneParent.name}  {scene.buildIndex}");
			setActiveWithSceneParent.gameObject.SetActive(value: false);
		}

		private void LocalOnSubSceneLoaded(Scene scene)
		{
			subScenes.Find((SubSceneEntry e) => e != null && e.Info.BuildIndex == scene.buildIndex);
			GetSetActiveWithSceneParent(scene.buildIndex).gameObject.SetActive(value: true);
		}

		public async UniTask<bool> LoadAndTeleport(MultiSceneLocation location)
		{
			if (!SubScenes.Any((SubSceneEntry e) => e.sceneID == location.SceneID))
			{
				return false;
			}
			if (!(await LoadSubScene(location.Scene)))
			{
				return false;
			}
			Transform locationTransform = location.GetLocationTransform();
			if (locationTransform == null)
			{
				UnityEngine.Debug.LogError("Location Not Found: " + location.Scene.Name + "/" + location.LocationName);
			}
			LevelManager.Instance.MainCharacter.SetPosition(locationTransform.position);
			return true;
		}

		public async UniTask<bool> LoadAndTeleport(string sceneID, Vector3 position, bool subSceneLocation = false)
		{
			if (!SubScenes.Any((SubSceneEntry e) => e.sceneID == sceneID))
			{
				return false;
			}
			SceneReference subSceneReference = GetSubSceneReference(sceneID);
			if (!(await LoadSubScene(subSceneReference)))
			{
				return false;
			}
			CharacterMainControl mainCharacter = LevelManager.Instance.MainCharacter;
			Vector3 result = position;
			if (subSceneLocation && !MiniMapSettings.TryGetWorldPosition(position, sceneID, out result))
			{
				return false;
			}
			mainCharacter.SetPosition(result);
			return true;
		}

		public static void MoveToMainScene(GameObject gameObject)
		{
			if (Instance == null)
			{
				UnityEngine.Debug.LogError("移动到主场景失败，因为MultiSceneCore不存在");
			}
			else
			{
				SceneManager.MoveGameObjectToScene(gameObject, MainScene.Value);
			}
		}

		public void CacheLocations()
		{
		}

		public void CacheTeleporters()
		{
		}

		private Vector3 GetClosestTeleporterPosition(Vector3 pos)
		{
			float num = float.MaxValue;
			Vector3 result = pos;
			foreach (SubSceneEntry subScene in subScenes)
			{
				foreach (SubSceneEntry.TeleporterInfo cachedTeleporter in subScene.cachedTeleporters)
				{
					float magnitude = (cachedTeleporter.position - pos).magnitude;
					if (magnitude < num)
					{
						num = magnitude;
						result = cachedTeleporter.position;
					}
				}
			}
			return result;
		}

		internal bool TryGetCachedPosition(MultiSceneLocation location, out Vector3 result)
		{
			return TryGetCachedPosition(location.SceneID, location.LocationName, out result);
		}

		internal bool TryGetCachedPosition(string sceneID, string locationName, out Vector3 result)
		{
			result = default(Vector3);
			SubSceneEntry subSceneEntry = subScenes.Find((SubSceneEntry e) => e != null && e.sceneID == sceneID);
			if (subSceneEntry == null)
			{
				return false;
			}
			if (subSceneEntry.TryGetCachedPosition(locationName, out result))
			{
				return true;
			}
			return false;
		}

		internal SubSceneEntry GetSubSceneInfo(Scene scene)
		{
			return subScenes.Find((SubSceneEntry e) => e != null && e.Info != null && e.Info.BuildIndex == scene.buildIndex);
		}

		public SubSceneEntry GetSubSceneInfo()
		{
			return cachedSubsceneEntry;
		}
	}
	[Serializable]
	public class SubSceneEntry
	{
		[Serializable]
		public class Location
		{
			public string path;

			public Vector3 position;

			public bool showInMap;

			[SerializeField]
			private string displayName;

			public string DisplayName => displayName;

			public string DisplayNameRaw
			{
				get
				{
					return displayName;
				}
				set
				{
					displayName = value;
				}
			}
		}

		[Serializable]
		public class TeleporterInfo
		{
			public Vector3 position;

			public MultiSceneLocation target;

			public Vector3 nearestTeleporterPositionToTarget;
		}

		[SceneID]
		public string sceneID;

		[SerializeField]
		private string overrideAmbientSound = "Default";

		[SerializeField]
		private bool isInDoor;

		public List<Location> cachedLocations = new List<Location>();

		public List<TeleporterInfo> cachedTeleporters = new List<TeleporterInfo>();

		public string AmbientSound => overrideAmbientSound;

		public bool IsInDoor => isInDoor;

		public SceneInfoEntry Info => SceneInfoCollection.GetSceneInfo(sceneID);

		public SceneReference SceneReference
		{
			get
			{
				SceneInfoEntry info = Info;
				if (info == null)
				{
					UnityEngine.Debug.LogWarning("未找到场景" + sceneID + "的相关信息，获取SceneReference失败。");
					return null;
				}
				return info.SceneReference;
			}
		}

		public string DisplayName
		{
			get
			{
				SceneInfoEntry info = Info;
				if (info == null)
				{
					return sceneID;
				}
				return info.DisplayName;
			}
		}

		internal bool TryGetCachedPosition(string locationPath, out Vector3 result)
		{
			result = default(Vector3);
			if (cachedLocations == null)
			{
				return false;
			}
			Location location = cachedLocations.Find((Location e) => e.path == locationPath);
			if (location == null)
			{
				return false;
			}
			result = location.position;
			return true;
		}
	}
	[Serializable]
	public struct MultiSceneLocation
	{
		[SerializeField]
		private string sceneID;

		[SerializeField]
		private string locationName;

		[SerializeField]
		private string displayName;

		public Transform LocationTransform
		{
			get
			{
				return GetLocationTransform();
			}
			private set
			{
			}
		}

		public string SceneID
		{
			get
			{
				return sceneID;
			}
			set
			{
				sceneID = value;
			}
		}

		public SceneReference Scene => SceneInfoCollection.GetSceneInfo(sceneID)?.SceneReference;

		public string LocationName
		{
			get
			{
				return locationName;
			}
			set
			{
				locationName = value;
			}
		}

		public string DisplayName => displayName.ToPlainText();

		public Transform GetLocationTransform()
		{
			if (Scene == null)
			{
				return null;
			}
			if (Scene.UnsafeReason != SceneReferenceUnsafeReason.None)
			{
				return null;
			}
			return SceneLocationsProvider.GetLocation(Scene, locationName);
		}

		public bool TryGetLocationPosition(out Vector3 result)
		{
			result = default(Vector3);
			if (MultiSceneCore.Instance == null)
			{
				return false;
			}
			if (MultiSceneCore.Instance.TryGetCachedPosition(sceneID, locationName, out result))
			{
				return true;
			}
			Transform location = SceneLocationsProvider.GetLocation(sceneID, locationName);
			if (location != null)
			{
				result = location.transform.position;
				return true;
			}
			return false;
		}

		internal string GetDisplayName()
		{
			return DisplayName;
		}
	}
	public class MultiSceneTeleporter : InteractableBase
	{
		[SerializeField]
		private MultiSceneLocation target;

		[SerializeField]
		private bool teleportOnTriggerEnter;

		private const float CoolDown = 1f;

		private static float timeWhenTeleportFinished;

		protected override bool ShowUnityEvents => false;

		[SerializeField]
		public MultiSceneLocation Target => target;

		private static float TimeSinceTeleportFinished => Time.time - timeWhenTeleportFinished;

		private static bool Teleportable => TimeSinceTeleportFinished > 1f;

		protected override void Awake()
		{
			base.Awake();
		}

		private void OnDrawGizmosSelected()
		{
			Transform locationTransform = target.LocationTransform;
			if ((bool)locationTransform)
			{
				Gizmos.DrawLine(base.transform.position, locationTransform.position);
				Gizmos.DrawWireSphere(locationTransform.position, 0.25f);
			}
		}

		public void DoTeleport()
		{
			if (!Teleportable)
			{
				UnityEngine.Debug.Log("not Teleportable");
			}
			else
			{
				TeleportTask().Forget();
			}
		}

		protected override bool IsInteractable()
		{
			return Teleportable;
		}

		private async UniTask TeleportTask()
		{
			timeWhenTeleportFinished = Time.time;
			await MultiSceneCore.Instance.LoadAndTeleport(target);
			timeWhenTeleportFinished = Time.time;
		}

		protected override void OnInteractStart(CharacterMainControl interactCharacter)
		{
			coolTime = 2f;
			finishWhenTimeOut = true;
		}

		protected override void OnInteractFinished()
		{
			DoTeleport();
			StopInteract();
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
	public class SceneIDAttribute : Attribute
	{
	}
	[ExecuteAlways]
	public class SceneLocationsProvider : MonoBehaviour
	{
		private static List<SceneLocationsProvider> activeProviders = new List<SceneLocationsProvider>();

		private static ReadOnlyCollection<SceneLocationsProvider> _activeProviders_ReadOnly;

		private StringBuilder sb = new StringBuilder();

		public static ReadOnlyCollection<SceneLocationsProvider> ActiveProviders
		{
			get
			{
				if (_activeProviders_ReadOnly == null)
				{
					_activeProviders_ReadOnly = new ReadOnlyCollection<SceneLocationsProvider>(activeProviders);
				}
				return _activeProviders_ReadOnly;
			}
		}

		public static SceneLocationsProvider GetProviderOfScene(SceneReference sceneReference)
		{
			if (sceneReference == null)
			{
				return null;
			}
			return ActiveProviders.FirstOrDefault((SceneLocationsProvider e) => e != null && e.gameObject.scene.buildIndex == sceneReference.BuildIndex);
		}

		public static SceneLocationsProvider GetProviderOfScene(Scene scene)
		{
			return ActiveProviders.FirstOrDefault((SceneLocationsProvider e) => e != null && e.gameObject.scene.buildIndex == scene.buildIndex);
		}

		internal static SceneLocationsProvider GetProviderOfScene(int sceneBuildIndex)
		{
			return ActiveProviders.FirstOrDefault((SceneLocationsProvider e) => e != null && e.gameObject.scene.buildIndex == sceneBuildIndex);
		}

		public static Transform GetLocation(SceneReference scene, string name)
		{
			if (scene.UnsafeReason != SceneReferenceUnsafeReason.None)
			{
				return null;
			}
			return GetLocation(scene.BuildIndex, name);
		}

		public static Transform GetLocation(int sceneBuildIndex, string name)
		{
			SceneLocationsProvider providerOfScene = GetProviderOfScene(sceneBuildIndex);
			if (providerOfScene == null)
			{
				return null;
			}
			return providerOfScene.GetLocation(name);
		}

		public static Transform GetLocation(string sceneID, string name)
		{
			SceneInfoEntry sceneInfo = SceneInfoCollection.GetSceneInfo(sceneID);
			if (sceneInfo == null)
			{
				return null;
			}
			return GetLocation(sceneInfo.BuildIndex, name);
		}

		private void Awake()
		{
			activeProviders.Add(this);
		}

		private void OnDestroy()
		{
			activeProviders.Remove(this);
		}

		public Transform GetLocation(string path)
		{
			string[] array = path.Split('/');
			Transform transform = base.transform;
			foreach (string text in array)
			{
				if (!string.IsNullOrEmpty(text))
				{
					transform = transform.Find(text);
					if (transform == null)
					{
						return null;
					}
				}
			}
			return transform;
		}

		public bool TryGetPath(Transform value, out string path)
		{
			path = "";
			Transform transform = value;
			List<Transform> list = new List<Transform>();
			while (transform != null && transform != base.transform)
			{
				list.Insert(0, transform);
				transform = transform.parent;
			}
			if (transform != base.transform)
			{
				return false;
			}
			sb.Clear();
			for (int i = 0; i < list.Count; i++)
			{
				if (i > 0)
				{
					sb.Append('/');
				}
				sb.Append(list[i].name);
			}
			path = sb.ToString();
			return true;
		}

		public List<(string path, Vector3 worldPosition, GameObject gameObject)> GetAllPathsAndItsPosition()
		{
			List<(string, Vector3, GameObject)> list = new List<(string, Vector3, GameObject)>();
			Stack<Transform> stack = new Stack<Transform>();
			stack.Push(base.transform);
			while (stack.Count > 0)
			{
				Transform transform = stack.Pop();
				int childCount = transform.childCount;
				for (int i = 0; i < childCount; i++)
				{
					Transform child = transform.GetChild(i);
					if (TryGetPath(child, out var path))
					{
						list.Add((path, child.transform.position, child.gameObject));
						stack.Push(child);
					}
				}
			}
			return list;
		}

		private void OnDrawGizmosSelected()
		{
			Gizmos.color = Color.yellow;
			Transform[] componentsInChildren = base.transform.GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				if (transform.childCount == 0)
				{
					Gizmos.DrawSphere(transform.position, 1.5f);
				}
			}
		}
	}
}
namespace Duckov.Quests
{
	public class Condition : MonoBehaviour
	{
		public virtual string DisplayText => "";

		public virtual bool Evaluate()
		{
			return false;
		}
	}
	public static class ConditionExtensions
	{
		public static bool Satisfied(this IEnumerable<Condition> conditions)
		{
			foreach (Condition condition in conditions)
			{
				if (!(condition == null) && !condition.Evaluate())
				{
					return false;
				}
			}
			return true;
		}
	}
	public class Quest : MonoBehaviour, ISaveDataProvider, INeedInspection
	{
		[Serializable]
		public struct SaveData
		{
			public int id;

			public bool complete;

			public bool needInspection;

			public QuestGiverID questGiverID;

			public List<(int id, object data)> taskStatus;

			public List<(int id, object data)> rewardStatus;
		}

		public struct QuestInfo
		{
			public int questId;

			public QuestInfo(Quest quest)
			{
				questId = quest.id;
			}
		}

		[SerializeField]
		private int id;

		[LocalizationKey("Quests")]
		[SerializeField]
		private string displayName;

		[LocalizationKey("Quests")]
		[SerializeField]
		private string description;

		[SerializeField]
		private int requireLevel;

		[SerializeField]
		private bool lockInDemo;

		[FormerlySerializedAs("requiredItem")]
		[SerializeField]
		[ItemTypeID]
		private int requiredItemID;

		[SerializeField]
		private int requiredItemCount = 1;

		[SceneID]
		[SerializeField]
		private string requireSceneID;

		[SerializeField]
		private QuestGiverID questGiverID;

		[SerializeField]
		internal List<Condition> prerequisit = new List<Condition>();

		[SerializeField]
		internal List<Task> tasks = new List<Task>();

		[SerializeField]
		internal List<Reward> rewards = new List<Reward>();

		private ReadOnlyCollection<Reward> _readonly_rewards;

		[SerializeField]
		[HideInInspector]
		private int nextTaskID;

		[SerializeField]
		[HideInInspector]
		private int nextRewardID;

		private ReadOnlyCollection<Condition> prerequisits_ReadOnly;

		[SerializeField]
		private bool complete;

		[SerializeField]
		private bool needInspection;

		public UnityEvent OnCompletedUnityEvent;

		public SceneInfoEntry RequireSceneInfo => SceneInfoCollection.GetSceneInfo(requireSceneID);

		public SceneReference RequireScene => RequireSceneInfo?.SceneReference;

		public List<Task> Tasks => tasks;

		public ReadOnlyCollection<Reward> Rewards
		{
			get
			{
				if (_readonly_rewards == null)
				{
					_readonly_rewards = new ReadOnlyCollection<Reward>(rewards);
				}
				return _readonly_rewards;
			}
		}

		public ReadOnlyCollection<Condition> Prerequisits
		{
			get
			{
				if (prerequisits_ReadOnly == null)
				{
					prerequisits_ReadOnly = new ReadOnlyCollection<Condition>(prerequisit);
				}
				return prerequisits_ReadOnly;
			}
		}

		public bool SceneRequirementSatisfied
		{
			get
			{
				SceneReference requireScene = RequireScene;
				if (requireScene == null)
				{
					return true;
				}
				if (requireScene.UnsafeReason == SceneReferenceUnsafeReason.Empty)
				{
					return true;
				}
				if (requireScene.UnsafeReason == SceneReferenceUnsafeReason.None)
				{
					return requireScene.LoadedScene.isLoaded;
				}
				return true;
			}
		}

		public int RequireLevel => requireLevel;

		public bool LockInDemo => lockInDemo;

		public bool Complete
		{
			get
			{
				return complete;
			}
			internal set
			{
				complete = value;
				this.onStatusChanged?.Invoke(this);
				Quest.onQuestStatusChanged?.Invoke(this);
				if (complete)
				{
					this.onCompleted?.Invoke(this);
					OnCompletedUnityEvent?.Invoke();
					Quest.onQuestCompleted?.Invoke(this);
				}
			}
		}

		public bool NeedInspection
		{
			get
			{
				if (!Active && !QuestManager.EverInspected(ID))
				{
					return true;
				}
				if (!Active)
				{
					return false;
				}
				if (Active && AreTasksFinished())
				{
					return true;
				}
				if (AnyTaskNeedInspection())
				{
					return true;
				}
				return needInspection;
			}
			set
			{
				needInspection = value;
				this.onNeedInspectionChanged?.Invoke(this);
				Quest.onQuestNeedInspectionChanged?.Invoke(this);
			}
		}

		public int ID
		{
			get
			{
				return id;
			}
			internal set
			{
				id = value;
			}
		}

		public bool Active => QuestManager.IsQuestActive(this);

		public int RequiredItemID => requiredItemID;

		public int RequiredItemCount => requiredItemCount;

		public string DisplayName => displayName.ToPlainText();

		public string Description => description.ToPlainText();

		public string DisplayNameRaw
		{
			get
			{
				return displayName;
			}
			set
			{
				displayName = value;
			}
		}

		public string DescriptionRaw
		{
			get
			{
				return description;
			}
			set
			{
				description = value;
			}
		}

		public QuestGiverID QuestGiverID
		{
			get
			{
				return questGiverID;
			}
			internal set
			{
				questGiverID = value;
			}
		}

		public object FinishedTaskCount => tasks.Count((Task e) => e.IsFinished());

		public event Action<Quest> onNeedInspectionChanged;

		internal event Action<Quest> onStatusChanged;

		internal event Action<Quest> onActivated;

		internal event Action<Quest> onCompleted;

		public static event Action<Quest> onQuestStatusChanged;

		public static event Action<Quest> onQuestNeedInspectionChanged;

		public static event Action<Quest> onQuestActivated;

		public static event Action<Quest> onQuestCompleted;

		private bool AnyTaskNeedInspection()
		{
			if (tasks != null)
			{
				foreach (Task task in tasks)
				{
					if (!(task == null) && task.NeedInspection)
					{
						return true;
					}
				}
			}
			return false;
		}

		public bool MeetsPrerequisit()
		{
			if (RequireLevel > EXPManager.Level)
			{
				return false;
			}
			if (LockInDemo && GameMetaData.Instance.IsDemo)
			{
				return false;
			}
			QuestRelationGraph questRelation = GameplayDataSettings.QuestRelation;
			if (questRelation.GetNode(id) != null)
			{
				if (!QuestManager.AreQuestFinished(questRelation.GetRequiredIDs(id)))
				{
					return false;
				}
				foreach (Condition item in prerequisit)
				{
					if (!item.Evaluate())
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		public bool AreTasksFinished()
		{
			foreach (Task task in tasks)
			{
				if (task == null)
				{
					UnityEngine.Debug.LogError($"存在空的Task，QuestID：{id}");
				}
				else if (!task.IsFinished())
				{
					return false;
				}
			}
			return true;
		}

		public void Initialize()
		{
		}

		public void OnValidate()
		{
			displayName = $"Quest_{id}";
			description = $"Quest_{id}_Desc";
		}

		public object GenerateSaveData()
		{
			SaveData saveData = new SaveData
			{
				id = id,
				complete = complete,
				needInspection = needInspection,
				taskStatus = new List<(int, object)>(),
				rewardStatus = new List<(int, object)>()
			};
			foreach (Task task in tasks)
			{
				int iD = task.ID;
				object item = task.GenerateSaveData();
				if (!(task == null))
				{
					saveData.taskStatus.Add((iD, item));
				}
			}
			foreach (Reward reward in rewards)
			{
				if (reward == null)
				{
					UnityEngine.Debug.LogError($"Null Reward detected in quest {id}");
					continue;
				}
				int iD2 = reward.ID;
				object item2 = reward.GenerateSaveData();
				saveData.rewardStatus.Add((iD2, item2));
			}
			return saveData;
		}

		public void SetupSaveData(object obj)
		{
			SaveData saveData = (SaveData)obj;
			if (saveData.id != id)
			{
				UnityEngine.Debug.LogError("任务ID不匹配，加载失败");
				return;
			}
			complete = saveData.complete;
			needInspection = saveData.needInspection;
			foreach (var cur in saveData.taskStatus)
			{
				Task task = tasks.Find((Task e) => e.ID == cur.id);
				if (task == null)
				{
					UnityEngine.Debug.LogWarning($"未找到Task {cur.id}");
				}
				else
				{
					task.SetupSaveData(cur.data);
				}
			}
			foreach (var cur2 in saveData.rewardStatus)
			{
				Reward reward = rewards.Find((Reward e) => e.ID == cur2.id);
				if (reward == null)
				{
					UnityEngine.Debug.LogWarning($"未找到Reward {cur2.id}");
					continue;
				}
				reward.SetupSaveData(cur2.data);
				reward.NotifyReload(this);
			}
			InitTasks();
			if (!complete)
			{
				return;
			}
			foreach (Reward reward2 in rewards)
			{
				if (!(reward2 == null) && !reward2.Claimed && reward2.AutoClaim)
				{
					reward2.Claim();
				}
			}
		}

		internal void NotifyTaskFinished(Task task)
		{
			if (task.Master != this)
			{
				UnityEngine.Debug.LogError("Task.Master 与 Quest不匹配");
				return;
			}
			Quest.onQuestStatusChanged?.Invoke(this);
			this.onStatusChanged?.Invoke(this);
			QuestManager.NotifyTaskFinished(this, task);
		}

		internal void NotifyRewardClaimed(Reward reward)
		{
			if (reward.Master != this)
			{
				UnityEngine.Debug.LogError("Reward.Master 与Quest 不匹配");
			}
			if (AreRewardsClaimed())
			{
				needInspection = false;
			}
			Quest.onQuestStatusChanged?.Invoke(this);
			this.onStatusChanged?.Invoke(this);
			Quest.onQuestNeedInspectionChanged?.Invoke(this);
		}

		internal bool AreRewardsClaimed()
		{
			foreach (Reward reward in rewards)
			{
				if (!reward.Claimed)
				{
					return false;
				}
			}
			return true;
		}

		internal void NotifyActivated()
		{
			InitTasks();
			this.onStatusChanged?.Invoke(this);
			this.onActivated?.Invoke(this);
			Quest.onQuestActivated?.Invoke(this);
		}

		private void InitTasks()
		{
			foreach (Task task in tasks)
			{
				task.Init();
			}
		}

		public bool TryComplete()
		{
			if (Complete)
			{
				return false;
			}
			if (!AreTasksFinished())
			{
				return false;
			}
			Complete = true;
			return true;
		}

		internal QuestInfo GetInfo()
		{
			return new QuestInfo(this);
		}
	}
	[CreateAssetMenu(menuName = "Quest Collection")]
	public class QuestCollection : ScriptableObject, IList<Quest>, ICollection<Quest>, IEnumerable<Quest>, IEnumerable, ISelfValidator
	{
		[SerializeField]
		private List<Quest> list;

		public static QuestCollection Instance => GameplayDataSettings.QuestCollection;

		public Quest this[int index]
		{
			get
			{
				return list[index];
			}
			set
			{
				list[index] = value;
			}
		}

		public int Count => list.Count;

		public bool IsReadOnly => true;

		public void Add(Quest item)
		{
			list.Add(item);
		}

		public void Clear()
		{
			list.Clear();
		}

		public bool Contains(Quest item)
		{
			return list.Contains(item);
		}

		public void CopyTo(Quest[] array, int arrayIndex)
		{
			list.CopyTo(array, arrayIndex);
		}

		public IEnumerator<Quest> GetEnumerator()
		{
			return list.GetEnumerator();
		}

		public int IndexOf(Quest item)
		{
			return list.IndexOf(item);
		}

		public void Insert(int index, Quest item)
		{
			list.Insert(index, item);
		}

		public bool Remove(Quest item)
		{
			return list.Remove(item);
		}

		public void RemoveAt(int index)
		{
			list.RemoveAt(index);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Collect()
		{
		}

		public void Validate(SelfValidationResult result)
		{
			_ = from e in list
				group e by (e == null) ? (-1) : e.ID;
			if ((from e in list
				group e by (e == null) ? (-1) : e.ID).Any((IGrouping<int, Quest> g) => g.Count() > 1))
			{
				result.AddError("存在冲突的QuestID。").WithFix("自动重新分配ID", AutoFixID);
			}
		}

		private void AutoFixID()
		{
			int num = list.Max((Quest e) => e.ID) + 1;
			foreach (IGrouping<int, Quest> item in from e in list
				group e by e.ID into g
				where g.Count() > 1
				select g)
			{
				int num2 = 0;
				foreach (Quest item2 in item)
				{
					if (!(item2 == null) && num2++ != 0)
					{
						item2.ID = num++;
					}
				}
			}
		}

		public Quest Get(int id)
		{
			return list.FirstOrDefault((Quest q) => q != null && q.ID == id);
		}
	}
	public class QuestGiver : InteractableBase
	{
		[SerializeField]
		private QuestGiverID questGiverID;

		private GameObject inspectionIndicator;

		private IEnumerable<Quest> _possibleQuests;

		private List<Quest> avaliableQuests = new List<Quest>();

		private IEnumerable<Quest> PossibleQuests
		{
			get
			{
				if (_possibleQuests == null && QuestManager.Instance != null)
				{
					_possibleQuests = QuestManager.Instance.GetAllQuestsByQuestGiverID(questGiverID);
				}
				return _possibleQuests;
			}
		}

		public QuestGiverID ID => questGiverID;

		protected override void Awake()
		{
			base.Awake();
			QuestManager.onQuestListsChanged += OnQuestListsChanged;
			BuildingManager.OnBuildingBuilt += OnBuildingBuilt;
			QuestManager.OnTaskFinishedEvent = (Action<Quest, Task>)Delegate.Combine(QuestManager.OnTaskFinishedEvent, new Action<Quest, Task>(OnTaskFinished));
			inspectionIndicator = UnityEngine.Object.Instantiate(GameplayDataSettings.Prefabs.QuestMarker);
			inspectionIndicator.transform.SetParent(base.transform);
			inspectionIndicator.transform.position = base.transform.TransformPoint(interactMarkerOffset + Vector3.up * 0.5f);
		}

		protected override void Start()
		{
			base.Start();
			RefreshInspectionIndicator();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			QuestManager.onQuestListsChanged -= OnQuestListsChanged;
			BuildingManager.OnBuildingBuilt -= OnBuildingBuilt;
			QuestManager.OnTaskFinishedEvent = (Action<Quest, Task>)Delegate.Remove(QuestManager.OnTaskFinishedEvent, new Action<Quest, Task>(OnTaskFinished));
		}

		private void OnTaskFinished(Quest quest, Task task)
		{
			RefreshInspectionIndicator();
		}

		private void OnBuildingBuilt(int buildingID)
		{
			RefreshInspectionIndicator();
		}

		private bool AnyQuestNeedsInspection()
		{
			return QuestManager.GetActiveQuestsFromGiver(questGiverID).Any((Quest e) => e != null && e.NeedInspection);
		}

		private bool AnyQuestAvaliable()
		{
			foreach (Quest possibleQuest in PossibleQuests)
			{
				if (QuestManager.IsQuestAvaliable(possibleQuest.ID))
				{
					return true;
				}
			}
			return false;
		}

		private void OnQuestListsChanged(QuestManager manager)
		{
			RefreshInspectionIndicator();
		}

		private void RefreshInspectionIndicator()
		{
			if ((bool)inspectionIndicator)
			{
				bool num = AnyQuestNeedsInspection();
				bool flag = AnyQuestAvaliable();
				bool active = num || flag;
				inspectionIndicator.gameObject.SetActive(active);
			}
		}

		public void ActivateQuest(Quest quest)
		{
			QuestManager.Instance.ActivateQuest(quest.ID, questGiverID);
		}

		internal List<Quest> GetAvaliableQuests()
		{
			List<Quest> list = new List<Quest>();
			foreach (Quest possibleQuest in PossibleQuests)
			{
				if (QuestManager.IsQuestAvaliable(possibleQuest.ID))
				{
					list.Add(possibleQuest);
				}
			}
			return list;
		}

		protected override void OnInteractStart(CharacterMainControl interactCharacter)
		{
			base.OnInteractStart(interactCharacter);
			QuestGiverView instance = QuestGiverView.Instance;
			if (instance == null)
			{
				StopInteract();
				return;
			}
			instance.Setup(this);
			instance.Open();
		}

		protected override void OnInteractStop()
		{
			base.OnInteractStop();
			if ((bool)QuestGiverView.Instance && QuestGiverView.Instance.open)
			{
				QuestGiverView.Instance?.Close();
			}
		}

		protected override void OnUpdate(CharacterMainControl _interactCharacter, float deltaTime)
		{
			base.OnUpdate(_interactCharacter, deltaTime);
			if (!QuestGiverView.Instance || !QuestGiverView.Instance.open)
			{
				StopInteract();
			}
		}
	}
	[Serializable]
	public enum QuestGiverID
	{
		None,
		Jeff,
		Xavier,
		Orange,
		Bob,
		Mud,
		DemoTrophy,
		Ming,
		Fo
	}
	public class QuestManager : MonoBehaviour, ISaveDataProvider, INeedInspection
	{
		[Serializable]
		public struct SaveData
		{
			public List<object> activeQuestsData;

			public List<object> historyQuestsData;

			public List<int> everInspectedQuest;
		}

		[SerializeField]
		private string taskFinishNotificationFormatKey = "UI_Quest_TaskFinishedNotification";

		private static QuestManager instance;

		public static Action<Quest, Task> OnTaskFinishedEvent;

		private List<Quest> activeQuests = new List<Quest>();

		private List<Quest> historyQuests = new List<Quest>();

		private List<int> everInspectedQuest = new List<int>();

		private const string savePrefix = "Quest";

		private const string saveKey = "Data";

		public string TaskFinishNotificationFormat => taskFinishNotificationFormatKey.ToPlainText();

		public static QuestManager Instance => instance;

		public static bool AnyQuestNeedsInspection
		{
			get
			{
				if (Instance == null)
				{
					return false;
				}
				return Instance.NeedInspection;
			}
		}

		public bool NeedInspection
		{
			get
			{
				if (activeQuests == null)
				{
					return false;
				}
				return activeQuests.Any((Quest e) => e != null && e.NeedInspection);
			}
		}

		private ICollection<Quest> QuestPrefabCollection => GameplayDataSettings.QuestCollection;

		private QuestRelationGraph QuestRelation => GameplayDataSettings.QuestRelation;

		public List<Quest> ActiveQuests
		{
			get
			{
				activeQuests.Sort(delegate(Quest a, Quest b)
				{
					int num = (a.AreTasksFinished() ? 1 : 0);
					return (b.AreTasksFinished() ? 1 : 0) - num;
				});
				return activeQuests;
			}
		}

		public List<Quest> HistoryQuests => historyQuests;

		public List<int> EverInspectedQuest => everInspectedQuest;

		public static event Action<QuestManager> onQuestListsChanged;

		public static IEnumerable<int> GetAllRequiredItems()
		{
			if (Instance == null)
			{
				yield break;
			}
			List<Quest> list = Instance.ActiveQuests;
			foreach (Quest item in list)
			{
				if (item.tasks == null)
				{
					continue;
				}
				foreach (Task task in item.tasks)
				{
					if (task is SubmitItems submitItems && !submitItems.IsFinished())
					{
						yield return submitItems.ItemTypeID;
					}
				}
			}
		}

		public static bool AnyActiveQuestNeedsInspection(QuestGiverID giverID)
		{
			if (Instance == null)
			{
				return false;
			}
			if (Instance.activeQuests == null)
			{
				return false;
			}
			return Instance.activeQuests.Any((Quest e) => e != null && e.QuestGiverID == giverID && e.NeedInspection);
		}

		public object GenerateSaveData()
		{
			SaveData saveData = new SaveData
			{
				activeQuestsData = new List<object>(),
				historyQuestsData = new List<object>(),
				everInspectedQuest = new List<int>()
			};
			foreach (Quest activeQuest in ActiveQuests)
			{
				saveData.activeQuestsData.Add(activeQuest.GenerateSaveData());
			}
			foreach (Quest historyQuest in HistoryQuests)
			{
				saveData.historyQuestsData.Add(historyQuest.GenerateSaveData());
			}
			saveData.everInspectedQuest.AddRange(EverInspectedQuest);
			return saveData;
		}

		public void SetupSaveData(object dataObj)
		{
			if (!(dataObj is SaveData saveData))
			{
				UnityEngine.Debug.LogError("错误的数据类型");
				return;
			}
			if (saveData.activeQuestsData != null)
			{
				foreach (object activeQuestsDatum in saveData.activeQuestsData)
				{
					int id = ((Quest.SaveData)activeQuestsDatum).id;
					Quest questPrefab = GetQuestPrefab(id);
					if (questPrefab == null)
					{
						UnityEngine.Debug.LogError($"未找到Quest {id}");
						continue;
					}
					Quest quest = UnityEngine.Object.Instantiate(questPrefab, base.transform);
					quest.SetupSaveData(activeQuestsDatum);
					activeQuests.Add(quest);
				}
			}
			if (saveData.historyQuestsData != null)
			{
				foreach (object historyQuestsDatum in saveData.historyQuestsData)
				{
					int id2 = ((Quest.SaveData)historyQuestsDatum).id;
					Quest questPrefab2 = GetQuestPrefab(id2);
					if (questPrefab2 == null)
					{
						UnityEngine.Debug.LogError($"未找到Quest {id2}");
						continue;
					}
					Quest quest2 = UnityEngine.Object.Instantiate(questPrefab2, base.transform);
					quest2.SetupSaveData(historyQuestsDatum);
					historyQuests.Add(quest2);
				}
			}
			if (saveData.everInspectedQuest != null)
			{
				EverInspectedQuest.Clear();
				EverInspectedQuest.AddRange(saveData.everInspectedQuest);
			}
		}

		private void Save()
		{
			SavesSystem.Save("Quest", "Data", GenerateSaveData());
		}

		private void Load()
		{
			try
			{
				SaveData saveData = SavesSystem.Load<SaveData>("Quest", "Data");
				SetupSaveData(saveData);
			}
			catch
			{
				UnityEngine.Debug.LogError("在加载Quest存档时出现了错误");
			}
		}

		public IEnumerable<Quest> GetAllQuestsByQuestGiverID(QuestGiverID questGiverID)
		{
			return QuestPrefabCollection.Where((Quest e) => e != null && e.QuestGiverID == questGiverID);
		}

		private Quest GetQuestPrefab(int id)
		{
			return QuestPrefabCollection.FirstOrDefault((Quest q) => q != null && q.ID == id);
		}

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Debug.LogError("侦测到多个QuestManager！");
				return;
			}
			RegisterEvents();
			Load();
		}

		private void OnDestroy()
		{
			UnregisterEvents();
		}

		private void RegisterEvents()
		{
			Quest.onQuestStatusChanged += OnQuestStatusChanged;
			Quest.onQuestCompleted += OnQuestCompleted;
			SavesSystem.OnCollectSaveData += Save;
			SavesSystem.OnSetFile += Load;
		}

		private void UnregisterEvents()
		{
			Quest.onQuestStatusChanged -= OnQuestStatusChanged;
			Quest.onQuestCompleted -= OnQuestCompleted;
			SavesSystem.OnCollectSaveData -= Save;
			SavesSystem.OnSetFile -= Load;
		}

		private void OnQuestCompleted(Quest quest)
		{
			if (!activeQuests.Remove(quest))
			{
				UnityEngine.Debug.LogWarning(quest.DisplayName + " 并不存在于活跃任务表中。已终止操作。");
				return;
			}
			historyQuests.Add(quest);
			QuestManager.onQuestListsChanged?.Invoke(this);
		}

		private void OnQuestStatusChanged(Quest quest)
		{
		}

		public void ActivateQuest(int id, QuestGiverID? overrideQuestGiverID = null)
		{
			Quest quest = UnityEngine.Object.Instantiate(GetQuestPrefab(id), base.transform);
			if (overrideQuestGiverID.HasValue)
			{
				quest.QuestGiverID = overrideQuestGiverID.Value;
			}
			activeQuests.Add(quest);
			quest.NotifyActivated();
			QuestManager.onQuestListsChanged?.Invoke(this);
		}

		internal static bool IsQuestAvaliable(int id)
		{
			if (Instance == null)
			{
				return false;
			}
			if (IsQuestFinished(id))
			{
				return false;
			}
			if (instance.activeQuests.Any((Quest e) => e.ID == id))
			{
				return false;
			}
			return Instance.GetQuestPrefab(id).MeetsPrerequisit();
		}

		internal static bool IsQuestFinished(int id)
		{
			if (instance == null)
			{
				return false;
			}
			return instance.historyQuests.Any((Quest e) => e.ID == id);
		}

		internal static bool AreQuestFinished(IEnumerable<int> requiredQuestIDs)
		{
			if (instance == null)
			{
				return false;
			}
			HashSet<int> hashSet = new HashSet<int>();
			hashSet.AddRange(requiredQuestIDs);
			foreach (Quest historyQuest in instance.historyQuests)
			{
				hashSet.Remove(historyQuest.ID);
			}
			return hashSet.Count <= 0;
		}

		internal static List<Quest> GetActiveQuestsFromGiver(QuestGiverID giverID)
		{
			List<Quest> result = new List<Quest>();
			if (instance == null)
			{
				return result;
			}
			return instance.ActiveQuests.Where((Quest e) => e.QuestGiverID == giverID).ToList();
		}

		internal static List<Quest> GetHistoryQuestsFromGiver(QuestGiverID giverID)
		{
			List<Quest> result = new List<Quest>();
			if (instance == null)
			{
				return result;
			}
			return instance.historyQuests.Where((Quest e) => e != null && e.QuestGiverID == giverID).ToList();
		}

		internal static bool IsQuestActive(Quest quest)
		{
			if (instance == null)
			{
				return false;
			}
			return instance.activeQuests.Contains(quest);
		}

		internal static bool IsQuestActive(int questID)
		{
			if (instance == null)
			{
				return false;
			}
			if (!instance.activeQuests.Any((Quest e) => e.ID == questID))
			{
				return false;
			}
			return true;
		}

		internal static bool AreQuestsActive(IEnumerable<int> requiredQuestIDs)
		{
			if (instance == null)
			{
				return false;
			}
			foreach (int id in requiredQuestIDs)
			{
				if (!instance.activeQuests.Any((Quest e) => e.ID == id))
				{
					return false;
				}
			}
			return true;
		}

		private void OnTaskFinished(Quest quest, Task task)
		{
			NotificationText.Push(TaskFinishNotificationFormat.Format(new
			{
				questDisplayName = quest.DisplayName,
				finishedTasks = quest.FinishedTaskCount,
				totalTasks = quest.tasks.Count
			}));
			OnTaskFinishedEvent?.Invoke(quest, task);
			AudioManager.Post("UI/mission_small");
		}

		internal static void NotifyTaskFinished(Quest quest, Task task)
		{
			instance?.OnTaskFinished(quest, task);
		}

		internal static bool EverInspected(int id)
		{
			if (Instance == null)
			{
				return false;
			}
			return Instance.EverInspectedQuest.Contains(id);
		}

		internal static void SetEverInspected(int id)
		{
			if (!EverInspected(id) && !(Instance == null))
			{
				Instance.EverInspectedQuest.Add(id);
			}
		}
	}
	public abstract class Reward : MonoBehaviour, ISelfValidator, ISaveDataProvider
	{
		[SerializeField]
		private int id;

		[SerializeField]
		private Quest master;

		public int ID
		{
			get
			{
				return id;
			}
			internal set
			{
				id = value;
			}
		}

		public bool Claimable => master.Complete;

		public virtual Sprite Icon => null;

		public virtual string Description => "未定义奖励描述";

		public abstract bool Claimed { get; }

		public virtual bool Claiming { get; }

		public virtual bool AutoClaim => false;

		public Quest Master
		{
			get
			{
				return master;
			}
			internal set
			{
				master = value;
			}
		}

		public static event Action<Reward> OnRewardClaimed;

		internal event Action onStatusChanged;

		public void Claim()
		{
			if (Claimable && !Claimed)
			{
				OnClaim();
				Master.NotifyRewardClaimed(this);
				Reward.OnRewardClaimed?.Invoke(this);
			}
		}

		public abstract void OnClaim();

		public virtual void Validate(SelfValidationResult result)
		{
			if (master == null)
			{
				result.AddWarning("Reward需要master(Quest)。").WithFix("设为父物体中的Quest。", delegate
				{
					master = GetComponent<Quest>();
					if (master == null)
					{
						master = GetComponentInParent<Quest>();
					}
				});
			}
			if (!(master != null))
			{
				return;
			}
			if (base.transform != master.transform && !base.transform.IsChildOf(master.transform))
			{
				result.AddError("Task需要存在于master子物体中。").WithFix("设为master子物体", delegate
				{
					base.transform.SetParent(master.transform);
				});
			}
			if (!master.rewards.Contains(this))
			{
				result.AddError("Master的Task列表中不包含本物体。").WithFix("将本物体添加至master的Task列表中", delegate
				{
					master.rewards.Add(this);
				});
			}
		}

		public abstract object GenerateSaveData();

		public abstract void SetupSaveData(object data);

		private void Awake()
		{
			Master.onStatusChanged += OnMasterStatusChanged;
		}

		private void OnDestroy()
		{
			Master.onStatusChanged -= OnMasterStatusChanged;
		}

		public void OnMasterStatusChanged(Quest quest)
		{
			this.onStatusChanged?.Invoke();
		}

		protected void ReportStatusChanged()
		{
			this.onStatusChanged?.Invoke();
		}

		public virtual void NotifyReload(Quest questInstance)
		{
		}
	}
	public class RewardItem : Reward
	{
		[ItemTypeID]
		public int itemTypeID;

		public int amount = 1;

		private bool claimed;

		private bool claiming;

		private ItemMetaData? _cachedMeta;

		public override bool Claimed => claimed;

		public override bool Claiming => claiming;

		private ItemMetaData CachedMeta
		{
			get
			{
				if (!_cachedMeta.HasValue)
				{
					_cachedMeta = ItemAssetsCollection.GetMetaData(itemTypeID);
				}
				return _cachedMeta.Value;
			}
		}

		public override Sprite Icon => CachedMeta.icon;

		public override string Description => $"{CachedMeta.DisplayName} x{amount}";

		public override object GenerateSaveData()
		{
			return claimed;
		}

		public override void SetupSaveData(object data)
		{
			claimed = (bool)data;
		}

		public override void OnClaim()
		{
			if (!claimed && !claiming)
			{
				claiming = true;
				GenerateAndGiveItems().Forget();
			}
		}

		private async UniTask GenerateAndGiveItems()
		{
			ItemMetaData meta = ItemAssetsCollection.GetMetaData(itemTypeID);
			if (meta.id <= 0)
			{
				return;
			}
			int remaining = amount;
			List<Item> generatedItems = new List<Item>();
			while (remaining > 0)
			{
				int batchAmount = Mathf.Min(remaining, meta.maxStackCount);
				if (batchAmount <= 0)
				{
					break;
				}
				remaining -= batchAmount;
				Item item = await ItemAssetsCollection.InstantiateAsync(itemTypeID);
				if (!(item == null))
				{
					if (batchAmount > 1)
					{
						item.StackCount = batchAmount;
					}
					generatedItems.Add(item);
				}
			}
			foreach (Item item2 in generatedItems)
			{
				SendItemToPlayerStorage(item2);
			}
			claimed = true;
			claiming = false;
			base.Master.NotifyRewardClaimed(this);
		}

		private void SendItemToPlayerStorage(Item item)
		{
			PlayerStorage.Push(item, toBufferDirectly: true);
		}
	}
	[Serializable]
	public abstract class Task : MonoBehaviour, ISaveDataProvider
	{
		[SerializeField]
		private Quest master;

		[SerializeField]
		private int id;

		[SerializeField]
		private bool forceFinish;

		public Quest Master
		{
			get
			{
				return master;
			}
			internal set
			{
				master = value;
			}
		}

		public int ID
		{
			get
			{
				return id;
			}
			internal set
			{
				id = value;
			}
		}

		public virtual string Description => "未定义Task描述。";

		public virtual string[] ExtraDescriptsions => new string[0];

		public virtual Sprite Icon => null;

		public virtual bool Interactable => false;

		public virtual bool PossibleValidInteraction => false;

		public virtual bool NeedInspection => false;

		public virtual string InteractText => "交互";

		public event Action<Task> onStatusChanged;

		public virtual void Interact()
		{
			UnityEngine.Debug.LogWarning($"{GetType()}可能未定义交互行为");
		}

		public bool IsFinished()
		{
			if (forceFinish)
			{
				return true;
			}
			return CheckFinished();
		}

		protected abstract bool CheckFinished();

		public abstract object GenerateSaveData();

		public abstract void SetupSaveData(object data);

		protected void ReportStatusChanged()
		{
			this.onStatusChanged?.Invoke(this);
			if (IsFinished())
			{
				Master?.NotifyTaskFinished(this);
			}
		}

		internal void Init()
		{
			if (IsFinished())
			{
				base.enabled = false;
			}
			else
			{
				OnInit();
			}
		}

		protected virtual void OnInit()
		{
		}

		internal void ForceFinish()
		{
			forceFinish = true;
			this.onStatusChanged?.Invoke(this);
		}
	}
	public class QuestTask_UnlockBeacon : Task
	{
		[SerializeField]
		private string beaconID;

		[SerializeField]
		private int beaconIndex;

		[LocalizationKey("Default")]
		private string DescriptionKey
		{
			get
			{
				return "Task_Beacon_" + beaconID;
			}
			set
			{
			}
		}

		public override string Description => DescriptionKey.ToPlainText();

		public override object GenerateSaveData()
		{
			return 0;
		}

		public override void SetupSaveData(object data)
		{
		}

		protected override bool CheckFinished()
		{
			return BeaconManager.GetBeaconUnlocked(beaconID, beaconIndex);
		}
	}
	public class MapElementForTask : MonoBehaviour
	{
		private bool visable;

		public new string name;

		public List<MultiSceneLocation> locations;

		public float range;

		private List<SimplePointOfInterest> pointsInstance;

		public Sprite icon;

		public Color iconColor = Color.white;

		public Color shadowColor = Color.white;

		public float shadowDistance;

		public void SetVisibility(bool _visable)
		{
			if (visable != _visable)
			{
				visable = _visable;
				if (MultiSceneCore.Instance == null)
				{
					LevelManager.OnLevelInitialized += OnLevelInitialized;
				}
				else
				{
					SyncVisibility();
				}
			}
		}

		private void OnLevelInitialized()
		{
			SyncVisibility();
		}

		private void OnDestroy()
		{
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void OnDisable()
		{
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void SyncVisibility()
		{
			if (visable)
			{
				if (pointsInstance != null && pointsInstance.Count > 0)
				{
					DespawnAll();
				}
				Spawn();
			}
			else
			{
				DespawnAll();
			}
		}

		private void Spawn()
		{
			foreach (MultiSceneLocation location in locations)
			{
				SpawnOnePoint(location, name);
			}
		}

		private void SpawnOnePoint(MultiSceneLocation _location, string name)
		{
			if (pointsInstance == null)
			{
				pointsInstance = new List<SimplePointOfInterest>();
			}
			if (!(MultiSceneCore.Instance == null) && _location.TryGetLocationPosition(out var _))
			{
				SimplePointOfInterest simplePointOfInterest = new GameObject("MapElement:" + name).AddComponent<SimplePointOfInterest>();
				UnityEngine.Debug.Log("Spawning " + simplePointOfInterest.name + " for task", this);
				simplePointOfInterest.Color = iconColor;
				simplePointOfInterest.ShadowColor = shadowColor;
				simplePointOfInterest.ShadowDistance = shadowDistance;
				if (range > 0f)
				{
					simplePointOfInterest.IsArea = true;
					simplePointOfInterest.AreaRadius = range;
				}
				simplePointOfInterest.Setup(icon, name);
				simplePointOfInterest.SetupMultiSceneLocation(_location);
				pointsInstance.Add(simplePointOfInterest);
			}
		}

		public void DespawnAll()
		{
			if (pointsInstance == null || pointsInstance.Count == 0)
			{
				return;
			}
			foreach (SimplePointOfInterest item in pointsInstance)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
			pointsInstance.Clear();
		}

		public void DespawnPoint(SimplePointOfInterest point)
		{
			if (pointsInstance != null && pointsInstance.Contains(point))
			{
				pointsInstance.Remove(point);
			}
			UnityEngine.Object.Destroy(point.gameObject);
		}
	}
	public class PlayDialogueGraphOnQuestActive : MonoBehaviour
	{
		[SerializeField]
		private Quest quest;

		[SerializeField]
		private DialogueTreeController dialogueTreeController;

		private void Awake()
		{
			if (quest == null)
			{
				quest = GetComponent<Quest>();
			}
			quest.onActivated += OnQuestActivated;
		}

		private void OnQuestActivated(Quest quest)
		{
			if (View.ActiveView != null)
			{
				View.ActiveView.Close();
			}
			SetupActors();
			PlayDialogue();
		}

		private void PlayDialogue()
		{
			dialogueTreeController.StartDialogue();
		}

		private void SetupActors()
		{
			if (dialogueTreeController.behaviour == null)
			{
				UnityEngine.Debug.LogError("Dialoguetree没有配置", dialogueTreeController);
				return;
			}
			foreach (DialogueTree.ActorParameter actorParameter in dialogueTreeController.behaviour.actorParameters)
			{
				string text = actorParameter.name;
				if (!string.IsNullOrEmpty(text))
				{
					DuckovDialogueActor duckovDialogueActor = DuckovDialogueActor.Get(text);
					if (duckovDialogueActor == null)
					{
						UnityEngine.Debug.LogError("未找到actor ID:" + text);
					}
					else
					{
						dialogueTreeController.SetActorReference(text, duckovDialogueActor);
					}
				}
			}
		}
	}
	public class ShowDialogueOnQuestActivate : MonoBehaviour
	{
		[Serializable]
		public class DialogueEntry
		{
			[TextArea]
			public string content;
		}

		[SerializeField]
		private Quest quest;

		[SerializeField]
		private List<DialogueEntry> dialogueEntries;

		private Transform cachedQuestGiverTransform;

		private void Awake()
		{
			if (quest == null)
			{
				quest = GetComponent<Quest>();
			}
			quest.onActivated += OnQuestActivated;
		}

		private void OnQuestActivated(Quest quest)
		{
			ShowDIalogue().Forget();
		}

		private async UniTask ShowDIalogue()
		{
			cachedQuestGiverTransform = null;
			await GameplayUIManager.TemporaryHide();
			cachedQuestGiverTransform = GetQuestGiverTransform(quest);
			if (cachedQuestGiverTransform == null)
			{
				UnityEngine.Debug.LogError("没找到QuestGiver " + quest.QuestGiverID.ToString() + " 的transform");
			}
			else
			{
				foreach (DialogueEntry dialogueEntry in dialogueEntries)
				{
					await ShowDialogueEntry(dialogueEntry);
				}
			}
			await GameplayUIManager.ReverseTemporaryHide();
		}

		private async UniTask ShowDialogueEntry(DialogueEntry cur)
		{
			await DialogueBubblesManager.Show(cur.content, cachedQuestGiverTransform, -1f, needInteraction: true, skippable: true);
		}

		private Transform GetQuestGiverTransform(Quest quest)
		{
			QuestGiverID id = quest.QuestGiverID;
			QuestGiver questGiver = UnityEngine.Object.FindObjectsByType<QuestGiver>(FindObjectsSortMode.None).FirstOrDefault((QuestGiver e) => e != null && e.ID == id);
			if (questGiver == null)
			{
				return null;
			}
			return questGiver.transform;
		}
	}
	public class SpawnItemForTask : MonoBehaviour
	{
		[SerializeField]
		private string componentID = "SpawnItemForTask";

		private Task _taskCache;

		[SerializeField]
		private List<MultiSceneLocation> locations;

		[ItemTypeID]
		[SerializeField]
		private int itemID = -1;

		[SerializeField]
		private MapElementForTask mapElement;

		private bool spawned;

		private Task task
		{
			get
			{
				if (_taskCache == null)
				{
					_taskCache = GetComponent<Task>();
				}
				return _taskCache;
			}
		}

		private int SpawnKey => string.Format("{0}/{1}/{2}/{3}", "SpawnPrefabForTask", task.Master.ID, task.ID, componentID).GetHashCode();

		private void Awake()
		{
			SceneLoader.onFinishedLoadingScene += OnFinishedLoadingScene;
			MultiSceneCore.OnSubSceneLoaded += OnSubSceneLoaded;
		}

		private void Start()
		{
			SpawnIfNeeded();
		}

		private void OnDestroy()
		{
			SceneLoader.onFinishedLoadingScene -= OnFinishedLoadingScene;
			MultiSceneCore.OnSubSceneLoaded -= OnSubSceneLoaded;
		}

		private void OnSubSceneLoaded(MultiSceneCore core, Scene scene)
		{
			LevelManager.LevelInitializingComment = "Spawning item for task";
			SpawnIfNeeded();
		}

		private void OnFinishedLoadingScene(SceneLoadingContext context)
		{
			SpawnIfNeeded();
		}

		private void SpawnIfNeeded()
		{
			if (itemID >= 0)
			{
				if (task == null)
				{
					UnityEngine.Debug.Log("spawn item task is null");
				}
				else if (!task.IsFinished() && !IsSpawned())
				{
					Spawn();
				}
			}
		}

		private bool IsSpawned()
		{
			if (spawned)
			{
				return true;
			}
			if (MultiSceneCore.Instance == null)
			{
				return false;
			}
			if (!MultiSceneCore.Instance.inLevelData.TryGetValue(SpawnKey, out var value))
			{
				return false;
			}
			if (value is bool)
			{
				return (bool)value;
			}
			return false;
		}

		private void Spawn()
		{
			MultiSceneLocation random = locations.GetRandom();
			if (random.TryGetLocationPosition(out var result))
			{
				if ((bool)MultiSceneCore.Instance)
				{
					MultiSceneCore.Instance.inLevelData[SpawnKey] = true;
				}
				spawned = true;
				SpawnItem(result, base.transform.gameObject.scene, random).Forget();
			}
		}

		private async UniTaskVoid SpawnItem(Vector3 pos, Scene scene, MultiSceneLocation location)
		{
			Item item = await ItemAssetsCollection.InstantiateAsync(itemID);
			if (item == null)
			{
				return;
			}
			item.Drop(pos, createRigidbody: false, Vector3.zero, 0f);
			if ((bool)mapElement)
			{
				mapElement.SetVisibility(_visable: false);
				mapElement.locations.Clear();
				mapElement.locations.Add(location);
				if ((bool)task)
				{
					mapElement.name = task.Master.DisplayName;
				}
				mapElement.SetVisibility(_visable: true);
				item.onItemTreeChanged += OnItemTreeChanged;
			}
		}

		private void OnItemTreeChanged(Item selfItem)
		{
			if ((bool)mapElement && (bool)selfItem.ParentItem)
			{
				mapElement.SetVisibility(_visable: false);
				selfItem.onItemTreeChanged -= OnItemTreeChanged;
			}
		}
	}
	public class SpawnPrefabForTask : MonoBehaviour
	{
		[SerializeField]
		private string componentID = "SpawnPrefabForTask";

		private Task _taskCache;

		[SerializeField]
		private List<MultiSceneLocation> locations;

		[SerializeField]
		private GameObject prefab;

		private bool spawned;

		private Task task
		{
			get
			{
				if (_taskCache == null)
				{
					_taskCache = GetComponent<Task>();
				}
				return _taskCache;
			}
		}

		private int SpawnKey => string.Format("{0}/{1}/{2}/{3}", "SpawnPrefabForTask", task.Master.ID, task.ID, componentID).GetHashCode();

		private void Awake()
		{
			SceneLoader.onFinishedLoadingScene += OnFinishedLoadingScene;
			MultiSceneCore.OnSubSceneLoaded += OnSubSceneLoaded;
		}

		private void Start()
		{
			SpawnIfNeeded();
		}

		private void OnDestroy()
		{
			SceneLoader.onFinishedLoadingScene -= OnFinishedLoadingScene;
			MultiSceneCore.OnSubSceneLoaded -= OnSubSceneLoaded;
		}

		private void OnSubSceneLoaded(MultiSceneCore core, Scene scene)
		{
			LevelManager.LevelInitializingComment = "Spawning prefabs for task";
			SpawnIfNeeded();
		}

		private void OnFinishedLoadingScene(SceneLoadingContext context)
		{
			SpawnIfNeeded();
		}

		private void SpawnIfNeeded()
		{
			if (!(prefab == null))
			{
				if (task == null)
				{
					UnityEngine.Debug.LogWarning("未配置Task");
				}
				else if (!task.IsFinished() && !IsSpawned())
				{
					Spawn();
				}
			}
		}

		private bool IsSpawned()
		{
			if (spawned)
			{
				return true;
			}
			if (MultiSceneCore.Instance == null)
			{
				return false;
			}
			if (!MultiSceneCore.Instance.inLevelData.TryGetValue(SpawnKey, out var value))
			{
				return false;
			}
			if (value is bool)
			{
				return (bool)value;
			}
			return false;
		}

		private void Spawn()
		{
			if (!locations.GetRandom().TryGetLocationPosition(out var result))
			{
				return;
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(prefab, result, Quaternion.identity);
			QuestTask_TaskEvent questTask_TaskEvent = task as QuestTask_TaskEvent;
			if ((bool)questTask_TaskEvent)
			{
				TaskEventEmitter component = gameObject.GetComponent<TaskEventEmitter>();
				if ((bool)component)
				{
					component.SetKey(questTask_TaskEvent.EventKey);
				}
			}
			if ((bool)MultiSceneCore.Instance)
			{
				MultiSceneCore.MoveToActiveWithScene(gameObject, base.transform.gameObject.scene.buildIndex);
				MultiSceneCore.Instance.inLevelData[SpawnKey] = true;
			}
			spawned = true;
		}
	}
	public class QuestTask_BubblePopper_Level : Task
	{
		[SerializeField]
		private int targetLevel;

		private bool finished;

		[LocalizationKey("Default")]
		private string descriptionKey
		{
			get
			{
				return "Task_BubblePopper_Level";
			}
			set
			{
			}
		}

		public override string Description => descriptionKey.ToPlainText().Format(new
		{
			level = targetLevel
		});

		public override object GenerateSaveData()
		{
			return finished;
		}

		public override void SetupSaveData(object data)
		{
		}

		protected override bool CheckFinished()
		{
			return BubblePopper.HighLevel >= targetLevel;
		}
	}
	public class QuestTask_GoldMiner_Level : Task
	{
		[SerializeField]
		private int targetLevel;

		private bool finished;

		[LocalizationKey("Default")]
		private string descriptionKey
		{
			get
			{
				return "Task_GoldMiner_Level";
			}
			set
			{
			}
		}

		public override string Description => descriptionKey.ToPlainText().Format(new
		{
			level = targetLevel
		});

		public override object GenerateSaveData()
		{
			return finished;
		}

		public override void SetupSaveData(object data)
		{
		}

		protected override bool CheckFinished()
		{
			return GoldMiner.HighLevel + 1 >= targetLevel;
		}
	}
	public class QuestTask_Snake_Score : Task
	{
		[SerializeField]
		private int targetScore;

		private bool finished;

		[LocalizationKey("Default")]
		private string descriptionKey
		{
			get
			{
				return "Task_Snake_Score";
			}
			set
			{
			}
		}

		public override string Description => descriptionKey.ToPlainText().Format(new
		{
			score = targetScore
		});

		public override object GenerateSaveData()
		{
			return finished;
		}

		public override void SetupSaveData(object data)
		{
		}

		protected override bool CheckFinished()
		{
			return SnakeForce.HighScore >= targetScore;
		}
	}
}
namespace Duckov.Quests.UI
{
	public class QuestCompletePanel : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup mainFadeGroup;

		[SerializeField]
		private TextMeshProUGUI questNameText;

		[SerializeField]
		private RewardEntry rewardEntryTemplate;

		[SerializeField]
		private UnityEngine.UI.Button skipButton;

		[SerializeField]
		private UnityEngine.UI.Button takeAllButton;

		private PrefabPool<RewardEntry> _rewardEntryPool;

		private Quest target;

		private bool skipClicked;

		private PrefabPool<RewardEntry> RewardEntryPool
		{
			get
			{
				if (_rewardEntryPool == null)
				{
					_rewardEntryPool = new PrefabPool<RewardEntry>(rewardEntryTemplate, rewardEntryTemplate.transform.parent);
					rewardEntryTemplate.gameObject.SetActive(value: false);
				}
				return _rewardEntryPool;
			}
		}

		public Quest Target => target;

		private void Awake()
		{
			skipButton.onClick.AddListener(Skip);
			takeAllButton.onClick.AddListener(TakeAll);
		}

		private void TakeAll()
		{
			if (target == null)
			{
				return;
			}
			foreach (Reward reward in target.rewards)
			{
				if (!reward.Claimed)
				{
					reward.Claim();
				}
			}
		}

		public void Skip()
		{
			skipClicked = true;
		}

		public async UniTask Show(Quest quest)
		{
			target = quest;
			SetupContent(quest);
			await mainFadeGroup.ShowAndReturnTask();
			await WaitForEndOfInteraction();
			if (target == null)
			{
				return;
			}
			foreach (Reward reward in target.rewards)
			{
				if (!reward.Claimed && reward.AutoClaim)
				{
					reward.Claim();
				}
			}
			await mainFadeGroup.HideAndReturnTask();
		}

		private async UniTask WaitForEndOfInteraction()
		{
			skipClicked = false;
			while (!(target == null) && !target.AreRewardsClaimed() && !skipClicked)
			{
				await UniTask.NextFrame();
			}
		}

		private void SetupContent(Quest quest)
		{
			target = quest;
			if (quest == null)
			{
				return;
			}
			questNameText.text = quest.DisplayName;
			RewardEntryPool.ReleaseAll();
			foreach (Reward reward in quest.rewards)
			{
				RewardEntry rewardEntry = RewardEntryPool.Get(rewardEntryTemplate.transform.parent);
				rewardEntry.Setup(reward);
				rewardEntry.transform.SetAsLastSibling();
			}
		}
	}
	public class QuestEntry : MonoBehaviour, Duckov.Utilities.IPoolable, IPointerClickHandler, IEventSystemHandler
	{
		private ISingleSelectionMenu<QuestEntry> menu;

		private Quest target;

		[SerializeField]
		private GameObject selectionIndicator;

		[SerializeField]
		private TextMeshProUGUI displayName;

		[SerializeField]
		private TextMeshProUGUI locationName;

		[SerializeField]
		[LocalizationKey("Default")]
		private string anyLocationKey;

		[SerializeField]
		private GameObject redDot;

		[SerializeField]
		private GameObject claimableIndicator;

		[SerializeField]
		private TextMeshProUGUI questIDDisplay;

		public Quest Target => target;

		public bool Selected => menu.GetSelection() == this;

		public event Action<QuestEntry, PointerEventData> onClick;

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			target = null;
		}

		private void OnDestroy()
		{
			UnregisterEvents();
		}

		internal void Setup(Quest quest)
		{
			UnregisterEvents();
			target = quest;
			RegisterEvents();
			Refresh();
		}

		internal void SetMenu(ISingleSelectionMenu<QuestEntry> menu)
		{
			this.menu = menu;
		}

		private void RegisterEvents()
		{
			if (target != null)
			{
				target.onStatusChanged += OnTargetStatusChanged;
				target.onNeedInspectionChanged += OnNeedInspectionChanged;
			}
		}

		private void UnregisterEvents()
		{
			if (target != null)
			{
				target.onStatusChanged -= OnTargetStatusChanged;
				target.onNeedInspectionChanged -= OnNeedInspectionChanged;
			}
		}

		private void OnNeedInspectionChanged(Quest obj)
		{
			Refresh();
		}

		private void OnTargetStatusChanged(Quest quest)
		{
			Refresh();
		}

		private void OnMasterSelectionChanged(QuestView view, Quest oldSelection, Quest newSelection)
		{
			Refresh();
		}

		private void Refresh()
		{
			selectionIndicator.SetActive(Selected);
			displayName.text = target.DisplayName;
			questIDDisplay.text = $"{target.ID:0000}";
			SceneInfoEntry requireSceneInfo = target.RequireSceneInfo;
			if (requireSceneInfo == null)
			{
				locationName.text = anyLocationKey.ToPlainText();
			}
			else
			{
				locationName.text = requireSceneInfo.DisplayName;
			}
			redDot.SetActive(target.NeedInspection);
			claimableIndicator.SetActive(target.Complete || target.AreTasksFinished());
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			this.onClick?.Invoke(this, eventData);
			menu.SetSelection(this);
		}

		public void NotifyRefresh()
		{
			Refresh();
		}
	}
	public class QuestGiverView : View, ISingleSelectionMenu<QuestEntry>
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private RectTransform questEntriesParent;

		[SerializeField]
		private QuestCompletePanel questCompletePanel;

		[SerializeField]
		private QuestGiverTabs tabs;

		[SerializeField]
		private QuestEntry entryPrefab;

		[SerializeField]
		private GameObject entryPlaceHolder;

		[SerializeField]
		private QuestViewDetails details;

		[SerializeField]
		private UnityEngine.UI.Button btn_Interact;

		[SerializeField]
		private TextMeshProUGUI btnText;

		[SerializeField]
		private UnityEngine.UI.Image btnImage;

		[SerializeField]
		private string btnText_AcceptQuest = "接受任务";

		[SerializeField]
		private string btnText_CompleteQuest = "完成任务";

		[SerializeField]
		private Color interactableBtnImageColor = Color.green;

		[SerializeField]
		private Color uninteractableBtnImageColor = Color.gray;

		[SerializeField]
		private GameObject uninspectedAvaliableRedDot;

		[SerializeField]
		private GameObject activeRedDot;

		private string sfx_AcceptQuest = "UI/mission_accept";

		private string sfx_CompleteQuest = "UI/mission_large";

		private PrefabPool<QuestEntry> _entryPool;

		private List<QuestEntry> activeEntries = new List<QuestEntry>();

		private QuestGiver target;

		private QuestEntry selectedQuestEntry;

		private UniTask completeUITask;

		private bool btnAcceptQuest;

		private bool btnCompleteQuest;

		public static QuestGiverView Instance => View.GetViewInstance<QuestGiverView>();

		public string BtnText_CompleteQuest => btnText_CompleteQuest.ToPlainText();

		public string BtnText_AcceptQuest => btnText_AcceptQuest.ToPlainText();

		private PrefabPool<QuestEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<QuestEntry>(entryPrefab, questEntriesParent, delegate(QuestEntry e)
					{
						activeEntries.Add(e);
					}, delegate(QuestEntry e)
					{
						activeEntries.Remove(e);
					});
				}
				return _entryPool;
			}
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
			RefreshList();
			RefreshDetails();
			QuestManager.onQuestListsChanged += OnQuestListChanged;
			Quest.onQuestStatusChanged += OnQuestStatusChanged;
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
			QuestManager.onQuestListsChanged -= OnQuestListChanged;
			Quest.onQuestStatusChanged -= OnQuestStatusChanged;
		}

		private void OnDisable()
		{
			if (details != null)
			{
				details.Setup(null);
			}
		}

		private void OnQuestStatusChanged(Quest quest)
		{
			if (quest == selectedQuestEntry?.Target)
			{
				RefreshDetails();
			}
		}

		protected override void Awake()
		{
			base.Awake();
			tabs.onSelectionChanged += OnTabChanged;
			btn_Interact.onClick.AddListener(OnInteractButtonClicked);
		}

		private void OnInteractButtonClicked()
		{
			if (btnAcceptQuest)
			{
				Quest quest = details.Target;
				if (quest != null && QuestManager.IsQuestAvaliable(quest.ID))
				{
					QuestManager.Instance.ActivateQuest(quest.ID, target.ID);
					AudioManager.Post(sfx_AcceptQuest);
				}
			}
			else if (btnCompleteQuest)
			{
				Quest quest2 = details.Target;
				if (!(quest2 == null) && quest2.TryComplete())
				{
					ShowCompleteUI(quest2);
					AudioManager.Post(sfx_CompleteQuest);
				}
			}
		}

		private void ShowCompleteUI(Quest quest)
		{
			completeUITask = questCompletePanel.Show(quest);
		}

		private void OnTabChanged(QuestGiverTabs tabs)
		{
			RefreshList();
			RefreshDetails();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			QuestManager.onQuestListsChanged -= OnQuestListChanged;
		}

		private void OnQuestListChanged(QuestManager manager)
		{
			RefreshList();
			SetSelection(null);
			RefreshDetails();
		}

		public void Setup(QuestGiver target)
		{
			this.target = target;
			RefreshList();
		}

		private void RefreshList()
		{
			Quest keepQuest = selectedQuestEntry?.Target;
			selectedQuestEntry = null;
			EntryPool.ReleaseAll();
			List<Quest> questsToShow = GetQuestsToShow();
			bool flag = questsToShow.Count > 0;
			entryPlaceHolder.SetActive(!flag);
			RefreshRedDots();
			if (!flag)
			{
				return;
			}
			foreach (Quest item in questsToShow)
			{
				QuestEntry questEntry = EntryPool.Get(questEntriesParent);
				questEntry.transform.SetAsLastSibling();
				questEntry.SetMenu(this);
				questEntry.Setup(item);
			}
			QuestEntry questEntry2 = activeEntries.Find((QuestEntry e) => e.Target == keepQuest);
			if (questEntry2 != null)
			{
				SetSelection(questEntry2);
			}
			else
			{
				SetSelection(null);
			}
		}

		private void RefreshRedDots()
		{
			uninspectedAvaliableRedDot.SetActive(AnyUninspectedAvaliableQuest());
			activeRedDot.SetActive(AnyUninspectedActiveQuest());
		}

		private bool AnyUninspectedActiveQuest()
		{
			if (target == null)
			{
				return false;
			}
			return QuestManager.AnyActiveQuestNeedsInspection(target.ID);
		}

		private bool AnyUninspectedAvaliableQuest()
		{
			if (target == null)
			{
				return false;
			}
			return target.GetAvaliableQuests().Any((Quest e) => e != null && e.NeedInspection);
		}

		private List<Quest> GetQuestsToShow()
		{
			List<Quest> list = new List<Quest>();
			if (target == null)
			{
				return list;
			}
			switch (tabs.GetStatus())
			{
			case QuestStatus.None:
				return list;
			case QuestStatus.Avaliable:
				list.AddRange(target.GetAvaliableQuests());
				break;
			case QuestStatus.Active:
				list.AddRange(QuestManager.GetActiveQuestsFromGiver(target.ID));
				break;
			case QuestStatus.Finished:
				list.AddRange(QuestManager.GetHistoryQuestsFromGiver(target.ID));
				break;
			}
			return list;
		}

		private void RefreshDetails()
		{
			Quest quest = selectedQuestEntry?.Target;
			details.Setup(quest);
			RefreshInteractButton();
			bool interactable = (bool)quest && (QuestManager.IsQuestActive(quest) || quest.Complete);
			details.Interactable = interactable;
			details.Refresh();
		}

		private void RefreshInteractButton()
		{
			btnAcceptQuest = false;
			btnCompleteQuest = false;
			Quest quest = selectedQuestEntry?.Target;
			if (quest == null)
			{
				btn_Interact.gameObject.SetActive(value: false);
				return;
			}
			QuestStatus status = tabs.GetStatus();
			bool active = false;
			switch (status)
			{
			case QuestStatus.Avaliable:
				active = true;
				btn_Interact.interactable = true;
				btnImage.color = interactableBtnImageColor;
				btnText.text = BtnText_AcceptQuest;
				btnAcceptQuest = true;
				break;
			case QuestStatus.Active:
			{
				active = true;
				bool flag = quest.AreTasksFinished();
				btn_Interact.interactable = flag;
				btnImage.color = (flag ? interactableBtnImageColor : uninteractableBtnImageColor);
				btnText.text = BtnText_CompleteQuest;
				btnCompleteQuest = true;
				break;
			}
			}
			btn_Interact.gameObject.SetActive(active);
		}

		public QuestEntry GetSelection()
		{
			return selectedQuestEntry;
		}

		public bool SetSelection(QuestEntry selection)
		{
			selectedQuestEntry = selection;
			if (selection != null)
			{
				QuestManager.SetEverInspected(selection.Target.ID);
			}
			RefreshDetails();
			RefreshEntries();
			RefreshRedDots();
			return true;
		}

		private void RefreshEntries()
		{
			foreach (QuestEntry activeEntry in activeEntries)
			{
				activeEntry.NotifyRefresh();
			}
		}

		internal override void TryQuit()
		{
			if (questCompletePanel.isActiveAndEnabled)
			{
				questCompletePanel.Skip();
			}
			else
			{
				Close();
			}
		}
	}
	public class QuestGiverTabButton : MonoBehaviour
	{
		[SerializeField]
		private UnityEngine.UI.Button button;

		[SerializeField]
		private GameObject selectedIndicator;

		[SerializeField]
		private QuestStatus status;

		private QuestGiverTabs master;

		public QuestStatus Status => status;

		private bool Selected
		{
			get
			{
				if (master == null)
				{
					return false;
				}
				return master.GetSelection() == this;
			}
		}

		internal void Setup(QuestGiverTabs questGiverTabs)
		{
			master = questGiverTabs;
			Refresh();
		}

		private void Awake()
		{
			button.onClick.AddListener(OnClick);
		}

		private void OnClick()
		{
			if (!(master == null))
			{
				master.SetSelection(this);
			}
		}

		internal void Refresh()
		{
			selectedIndicator.SetActive(Selected);
		}
	}
	[Flags]
	public enum QuestStatus
	{
		None = 0,
		Avaliable = 2,
		Active = 4,
		Finished = 8
	}
	public class QuestGiverTabs : MonoBehaviour, ISingleSelectionMenu<QuestGiverTabButton>
	{
		[SerializeField]
		private List<QuestGiverTabButton> buttons = new List<QuestGiverTabButton>();

		private QuestGiverTabButton selectedButton;

		private bool initialized;

		public event Action<QuestGiverTabs> onSelectionChanged;

		public QuestGiverTabButton GetSelection()
		{
			return selectedButton;
		}

		public QuestStatus GetStatus()
		{
			if (!initialized)
			{
				Initialize();
			}
			return selectedButton.Status;
		}

		public bool SetSelection(QuestGiverTabButton selection)
		{
			selectedButton = selection;
			RefreshAllButtons();
			this.onSelectionChanged?.Invoke(this);
			return true;
		}

		private void Initialize()
		{
			foreach (QuestGiverTabButton button in buttons)
			{
				button.Setup(this);
			}
			if (buttons.Count > 0)
			{
				SetSelection(buttons[0]);
			}
			initialized = true;
		}

		private void Awake()
		{
			if (!initialized)
			{
				Initialize();
			}
		}

		private void RefreshAllButtons()
		{
			foreach (QuestGiverTabButton button in buttons)
			{
				button.Refresh();
			}
		}
	}
	public class QuestView : View, ISingleSelectionMenu<QuestEntry>
	{
		[Flags]
		public enum ShowContent
		{
			Active = 1,
			History = 2
		}

		[SerializeField]
		private QuestEntry questEntry;

		[SerializeField]
		private Transform questEntryParent;

		[SerializeField]
		private GameObject entryListPlaceHolder;

		[SerializeField]
		private QuestViewDetails details;

		[SerializeField]
		private FadeGroup fadeGroup;

		private QuestManager target;

		[SerializeField]
		private ShowContent showingContentType;

		private PrefabPool<QuestEntry> _questEntryPool;

		private List<QuestEntry> activeEntries = new List<QuestEntry>();

		private QuestEntry selectedQuestEntry;

		public static QuestView Instance => View.GetViewInstance<QuestView>();

		public ShowContent ShowingContentType => showingContentType;

		public IList<Quest> ShowingContent
		{
			get
			{
				if (target == null)
				{
					return null;
				}
				return showingContentType switch
				{
					ShowContent.Active => target.ActiveQuests, 
					ShowContent.History => target.HistoryQuests, 
					_ => null, 
				};
			}
		}

		private PrefabPool<QuestEntry> QuestEntryPool
		{
			get
			{
				if (_questEntryPool == null)
				{
					_questEntryPool = new PrefabPool<QuestEntry>(questEntry, questEntryParent, delegate(QuestEntry e)
					{
						activeEntries.Add(e);
						e.SetMenu(this);
					}, delegate(QuestEntry e)
					{
						activeEntries.Remove(e);
					});
				}
				return _questEntryPool;
			}
		}

		private QuestEntry SelectedQuestEntry => selectedQuestEntry;

		public Quest SelectedQuest => selectedQuestEntry?.Target;

		internal event Action<QuestView, ShowContent> onShowingContentChanged;

		internal event Action<QuestView, QuestEntry> onSelectedEntryChanged;

		public void Setup()
		{
			Setup(QuestManager.Instance);
		}

		private void Setup(QuestManager target)
		{
			this.target = target;
			Quest oldSelection = SelectedQuest;
			RefreshEntryList();
			QuestEntry questEntry = activeEntries.Find((QuestEntry e) => e.Target == oldSelection);
			if (questEntry != null)
			{
				SetSelection(questEntry);
			}
			else
			{
				SetSelection(null);
			}
			RefreshDetails();
		}

		public static void Show()
		{
			Instance?.Open();
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			Setup();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		protected override void Awake()
		{
			base.Awake();
		}

		private void OnEnable()
		{
			RegisterStaticEvents();
			Setup(QuestManager.Instance);
		}

		private void OnDisable()
		{
			if (details != null)
			{
				details.Setup(null);
			}
			UnregisterStaticEvents();
		}

		private void RegisterStaticEvents()
		{
			QuestManager.onQuestListsChanged += Setup;
		}

		private void UnregisterStaticEvents()
		{
			QuestManager.onQuestListsChanged -= Setup;
		}

		private void RefreshEntryList()
		{
			QuestEntryPool.ReleaseAll();
			bool flag = target != null && ShowingContent != null && ShowingContent.Count > 0;
			entryListPlaceHolder.SetActive(!flag);
			if (!flag)
			{
				return;
			}
			foreach (Quest item in ShowingContent)
			{
				QuestEntry obj = QuestEntryPool.Get(questEntryParent);
				obj.Setup(item);
				obj.transform.SetAsLastSibling();
			}
		}

		private void RefreshDetails()
		{
			details.Setup(SelectedQuest);
		}

		public void SetShowingContent(ShowContent flags)
		{
			showingContentType = flags;
			RefreshEntryList();
			List<QuestEntry> list = activeEntries;
			if (list != null && list.Count > 0)
			{
				SetSelection(activeEntries[0]);
			}
			else
			{
				SetSelection(null);
			}
			RefreshDetails();
			foreach (QuestEntry activeEntry in activeEntries)
			{
				activeEntry.NotifyRefresh();
			}
			this.onShowingContentChanged?.Invoke(this, flags);
		}

		public void ShowActiveQuests()
		{
			SetShowingContent(ShowContent.Active);
		}

		public void ShowHistoryQuests()
		{
			SetShowingContent(ShowContent.History);
		}

		public QuestEntry GetSelection()
		{
			return selectedQuestEntry;
		}

		public bool SetSelection(QuestEntry selection)
		{
			selectedQuestEntry = selection;
			this.onSelectedEntryChanged?.Invoke(this, selectedQuestEntry);
			foreach (QuestEntry activeEntry in activeEntries)
			{
				activeEntry.NotifyRefresh();
			}
			RefreshDetails();
			return true;
		}
	}
	public class QuestViewDetails : MonoBehaviour
	{
		private Quest target;

		[SerializeField]
		private TaskEntry taskEntryPrefab;

		[SerializeField]
		private RewardEntry rewardEntry;

		[SerializeField]
		private GameObject placeHolder;

		[SerializeField]
		private FadeGroup contentFadeGroup;

		[SerializeField]
		private TextMeshProUGUI displayName;

		[SerializeField]
		private TextMeshProUGUI description;

		[SerializeField]
		private TextMeshProUGUI questGiverDisplayName;

		[SerializeField]
		private Transform tasksParent;

		[SerializeField]
		private Transform rewardsParent;

		[SerializeField]
		private QuestRequiredItem requiredItem;

		[SerializeField]
		private bool interactable;

		private PrefabPool<TaskEntry> _taskEntryPool;

		private PrefabPool<RewardEntry> _rewardEntryPool;

		private Quest showingQuest;

		private int activeTaskToken;

		public Quest Target => target;

		public bool Interactable
		{
			get
			{
				return interactable;
			}
			internal set
			{
				interactable = value;
			}
		}

		private PrefabPool<TaskEntry> TaskEntryPool
		{
			get
			{
				if (_taskEntryPool == null)
				{
					_taskEntryPool = new PrefabPool<TaskEntry>(taskEntryPrefab, tasksParent);
				}
				return _taskEntryPool;
			}
		}

		private PrefabPool<RewardEntry> RewardEntryPool
		{
			get
			{
				if (_rewardEntryPool == null)
				{
					_rewardEntryPool = new PrefabPool<RewardEntry>(rewardEntry, rewardsParent);
				}
				return _rewardEntryPool;
			}
		}

		private void Awake()
		{
			rewardEntry.gameObject.SetActive(value: false);
			taskEntryPrefab.gameObject.SetActive(value: false);
		}

		internal void Refresh()
		{
			RefreshAsync().Forget();
		}

		private int GetNewToken()
		{
			int num;
			for (num = activeTaskToken; num == activeTaskToken; num = UnityEngine.Random.Range(1, int.MaxValue))
			{
			}
			activeTaskToken = num;
			return activeTaskToken;
		}

		private async UniTask RefreshAsync()
		{
			int token = GetNewToken();
			UnregisterEvents();
			if (showingQuest != target)
			{
				if (target == null)
				{
					placeHolder.SetActive(value: true);
				}
				await contentFadeGroup.HideAndReturnTask();
				if (token != activeTaskToken)
				{
					return;
				}
			}
			showingQuest = target;
			if (target == null)
			{
				placeHolder.SetActive(value: true);
				contentFadeGroup.SkipHide();
				return;
			}
			placeHolder.SetActive(value: false);
			target.NeedInspection = false;
			displayName.text = target.DisplayName;
			questGiverDisplayName.text = GameplayDataSettings.Quests.GetDisplayName(target.QuestGiverID);
			description.text = target.Description;
			requiredItem.Set(target.RequiredItemID, target.RequiredItemCount);
			SetupTasks();
			SetupRewards();
			RegisterEvents();
			await contentFadeGroup.ShowAndReturnTask();
		}

		private void SetupTasks()
		{
			TaskEntryPool.ReleaseAll();
			if (target == null)
			{
				return;
			}
			foreach (Task task in target.tasks)
			{
				TaskEntry taskEntry = TaskEntryPool.Get(tasksParent);
				taskEntry.Interactable = Interactable;
				taskEntry.Setup(task);
				taskEntry.transform.SetAsLastSibling();
			}
		}

		private void SetupRewards()
		{
			RewardEntryPool.ReleaseAll();
			if (target == null)
			{
				return;
			}
			foreach (Reward reward in target.rewards)
			{
				if (reward == null)
				{
					UnityEngine.Debug.LogError($"任务 {target.ID} - {target.DisplayName} 中包含值为 null 的奖励。");
					continue;
				}
				RewardEntry obj = RewardEntryPool.Get(rewardsParent);
				obj.Interactable = Interactable;
				obj.Setup(reward);
				obj.transform.SetAsLastSibling();
			}
		}

		private void RegisterEvents()
		{
			if (!(target == null))
			{
				target.onStatusChanged += OnTargetStatusChanged;
			}
		}

		private void UnregisterEvents()
		{
			if (!(target == null))
			{
				target.onStatusChanged -= OnTargetStatusChanged;
			}
		}

		private void OnTargetStatusChanged(Quest quest)
		{
			Refresh();
		}

		internal void Setup(Quest quest)
		{
			target = quest;
			Refresh();
		}

		private void OnDestroy()
		{
			UnregisterEvents();
		}
	}
	public class QuestViewFlagButton : MonoBehaviour
	{
		[SerializeField]
		private QuestView master;

		[SerializeField]
		private UnityEngine.UI.Button button;

		[SerializeField]
		private QuestView.ShowContent content;

		[SerializeField]
		private GameObject selectionIndicator;

		private void Awake()
		{
			button.onClick.AddListener(OnButtonClicked);
			master.onShowingContentChanged += OnMasterShowingContentChanged;
			Refresh();
		}

		private void OnButtonClicked()
		{
			master.SetShowingContent(content);
		}

		private void OnMasterShowingContentChanged(QuestView view, QuestView.ShowContent content)
		{
			Refresh();
		}

		private void Refresh()
		{
			bool active = master.ShowingContentType == content;
			selectionIndicator.SetActive(active);
		}
	}
	public class RewardEntry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		[SerializeField]
		private UnityEngine.UI.Image rewardIcon;

		[SerializeField]
		private TextMeshProUGUI rewardText;

		[SerializeField]
		private UnityEngine.UI.Button claimButton;

		[SerializeField]
		private GameObject claimableIndicator;

		[SerializeField]
		private UnityEngine.UI.Image statusIcon;

		[SerializeField]
		private TextMeshProUGUI buttonText;

		[SerializeField]
		private GameObject claimingIcon;

		[SerializeField]
		private Sprite claimIcon;

		[LocalizationKey("Default")]
		[SerializeField]
		private string claimTextKey = "UI_Quest_RewardClaim";

		[SerializeField]
		private Sprite claimedIcon;

		[LocalizationKey("Default")]
		[SerializeField]
		private string claimedTextKey = "UI_Quest_RewardClaimed";

		[SerializeField]
		private bool interactable;

		private Reward target;

		public bool Interactable
		{
			get
			{
				return interactable;
			}
			internal set
			{
				interactable = value;
			}
		}

		private void Awake()
		{
			claimButton.onClick.AddListener(OnClaimButtonClicked);
		}

		private void OnClaimButtonClicked()
		{
			target?.Claim();
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
		}

		internal void Setup(Reward target)
		{
			UnregisterEvents();
			this.target = target;
			if (!(target == null))
			{
				Refresh();
				RegisterEvents();
			}
		}

		private void RegisterEvents()
		{
			if (!(target == null))
			{
				target.onStatusChanged += OnTargetStatusChanged;
			}
		}

		private void UnregisterEvents()
		{
			if (!(target == null))
			{
				target.onStatusChanged -= OnTargetStatusChanged;
			}
		}

		private void OnTargetStatusChanged()
		{
			Refresh();
		}

		private void Refresh()
		{
			if (target == null)
			{
				return;
			}
			rewardText.text = target.Description;
			Sprite icon = target.Icon;
			rewardIcon.gameObject.SetActive(icon);
			rewardIcon.sprite = icon;
			bool claimed = target.Claimed;
			bool claimable = target.Claimable;
			bool flag = Interactable && claimable;
			bool active = !Interactable && claimable && !claimed;
			claimButton.gameObject.SetActive(flag);
			if (claimableIndicator != null)
			{
				claimableIndicator.SetActive(active);
			}
			if (flag)
			{
				if ((bool)buttonText)
				{
					buttonText.text = (claimed ? claimedTextKey.ToPlainText() : claimTextKey.ToPlainText());
				}
				statusIcon.sprite = (claimed ? claimedIcon : claimIcon);
				claimButton.interactable = !claimed;
				statusIcon.gameObject.SetActive(!target.Claiming);
				claimingIcon.gameObject.SetActive(target.Claiming);
			}
		}
	}
	public class TaskEntry : MonoBehaviour, Duckov.Utilities.IPoolable, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private UnityEngine.UI.Image statusIcon;

		[SerializeField]
		private UnityEngine.UI.Image taskIcon;

		[SerializeField]
		private TextMeshProUGUI description;

		[SerializeField]
		private UnityEngine.UI.Button interactionButton;

		[SerializeField]
		private GameObject targetNotInteractablePlaceHolder;

		[SerializeField]
		private TextMeshProUGUI interactionText;

		[SerializeField]
		private TextMeshProUGUI interactionPlaceHolderText;

		[SerializeField]
		private Sprite unsatisfiedIcon;

		[SerializeField]
		private Sprite satisfiedIcon;

		[SerializeField]
		private bool interactable;

		private Task target;

		public bool Interactable
		{
			get
			{
				return interactable;
			}
			internal set
			{
				interactable = value;
			}
		}

		private void Awake()
		{
			interactionButton.onClick.AddListener(OnInteractionButtonClicked);
		}

		private void OnInteractionButtonClicked()
		{
			if (!(target == null))
			{
				target.Interact();
			}
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			target = null;
		}

		internal void Setup(Task target)
		{
			UnregisterEvents();
			this.target = target;
			RegisterEvents();
			Refresh();
		}

		private void Refresh()
		{
			if (!(target == null))
			{
				description.text = target.Description;
				string[] extraDescriptsions = target.ExtraDescriptsions;
				foreach (string text in extraDescriptsions)
				{
					TextMeshProUGUI textMeshProUGUI = description;
					textMeshProUGUI.text = textMeshProUGUI.text + "  \n- " + text;
				}
				Sprite icon = target.Icon;
				if ((bool)icon)
				{
					taskIcon.sprite = icon;
					taskIcon.gameObject.SetActive(value: true);
				}
				else
				{
					taskIcon.gameObject.SetActive(value: false);
				}
				bool flag = target.IsFinished();
				statusIcon.sprite = (flag ? satisfiedIcon : unsatisfiedIcon);
				if (Interactable && !flag && target.Interactable)
				{
					bool possibleValidInteraction = target.PossibleValidInteraction;
					interactionText.text = target.InteractText;
					interactionPlaceHolderText.text = target.InteractText;
					interactionButton.gameObject.SetActive(possibleValidInteraction);
					targetNotInteractablePlaceHolder.gameObject.SetActive(!possibleValidInteraction);
				}
				else
				{
					interactionButton.gameObject.SetActive(value: false);
					targetNotInteractablePlaceHolder.gameObject.SetActive(value: false);
				}
			}
		}

		private void RegisterEvents()
		{
			if (!(target == null))
			{
				target.onStatusChanged += OnTargetStatusChanged;
			}
		}

		private void UnregisterEvents()
		{
			if (!(target == null))
			{
				target.onStatusChanged -= OnTargetStatusChanged;
			}
		}

		private void OnTargetStatusChanged(Task task)
		{
			if (task != target)
			{
				UnityEngine.Debug.LogError("目标不匹配。");
			}
			else
			{
				Refresh();
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (!eventData.used && CheatMode.Active && UIInputManager.Ctrl && UIInputManager.Alt && UIInputManager.Shift)
			{
				target.ForceFinish();
				eventData.Use();
			}
		}
	}
}
namespace Duckov.Quests.Tasks
{
	public class QuestTask_CheckSaveData : Task
	{
		[SerializeField]
		private string saveDataKey;

		[SerializeField]
		[LocalizationKey("Quests")]
		private string description;

		public string SaveDataKey => saveDataKey;

		private bool SaveDataTrue
		{
			get
			{
				return SavesSystem.Load<bool>(saveDataKey);
			}
			set
			{
				SavesSystem.Save(saveDataKey, value);
			}
		}

		public override string Description => description.ToPlainText();

		protected override void OnInit()
		{
			base.OnInit();
		}

		private void OnDisable()
		{
		}

		protected override bool CheckFinished()
		{
			return SaveDataTrue;
		}

		public override object GenerateSaveData()
		{
			return SaveDataTrue;
		}

		public override void SetupSaveData(object data)
		{
		}
	}
	public class QuestTask_ConstructBuilding : Task
	{
		[SerializeField]
		private string buildingID;

		[LocalizationKey("Default")]
		private string descriptionFormatKey => "Task_ConstructBuilding";

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		public override string Description => DescriptionFormat.Format(new
		{
			BuildingName = Building.GetDisplayName(buildingID)
		});

		public override object GenerateSaveData()
		{
			return null;
		}

		protected override bool CheckFinished()
		{
			return BuildingManager.Any(buildingID);
		}

		public override void SetupSaveData(object data)
		{
		}
	}
	public class QuestTask_Evacuate : Task
	{
		[SerializeField]
		[SceneID]
		private string requireSceneID;

		[SerializeField]
		private bool finished;

		private SceneInfoEntry RequireSceneInfo => SceneInfoCollection.GetSceneInfo(requireSceneID);

		private SceneReference RequireScene => RequireSceneInfo?.SceneReference;

		private string descriptionFormatKey => "Task_Evacuate";

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		private string TargetDisplayName
		{
			get
			{
				if (RequireScene != null && RequireScene.UnsafeReason == SceneReferenceUnsafeReason.None)
				{
					return RequireSceneInfo.DisplayName;
				}
				if (base.Master.RequireScene != null && base.Master.RequireScene.UnsafeReason == SceneReferenceUnsafeReason.None)
				{
					return base.Master.RequireSceneInfo.DisplayName;
				}
				return "Scene_Any".ToPlainText();
			}
		}

		public override string Description => DescriptionFormat.Format(new { TargetDisplayName });

		private void OnEnable()
		{
			LevelManager.OnEvacuated += OnEvacuated;
		}

		private void OnDisable()
		{
			LevelManager.OnEvacuated -= OnEvacuated;
		}

		private void OnEvacuated(EvacuationInfo info)
		{
			if (finished)
			{
				return;
			}
			if (RequireScene == null || RequireScene.UnsafeReason == SceneReferenceUnsafeReason.Empty)
			{
				if (base.Master.SceneRequirementSatisfied)
				{
					finished = true;
					ReportStatusChanged();
				}
			}
			else if (RequireScene.UnsafeReason == SceneReferenceUnsafeReason.None && RequireScene.LoadedScene.isLoaded)
			{
				finished = true;
				ReportStatusChanged();
			}
		}

		public override object GenerateSaveData()
		{
			return finished;
		}

		protected override bool CheckFinished()
		{
			return finished;
		}

		public override void SetupSaveData(object data)
		{
			if (data is bool flag)
			{
				finished = flag;
			}
		}
	}
	public class QuestTask_KillCount : Task
	{
		[SerializeField]
		private int requireAmount = 1;

		[SerializeField]
		private bool resetOnLevelInitialized;

		[SerializeField]
		private int amount;

		[SerializeField]
		private bool withWeapon;

		[SerializeField]
		[ItemTypeID]
		private int weaponTypeID;

		[SerializeField]
		private bool requireHeadShot;

		[SerializeField]
		private bool withoutHeadShot;

		[SerializeField]
		private bool requireBuff;

		[SerializeField]
		private int requireBuffID;

		[SerializeField]
		private CharacterRandomPreset requireEnemyType;

		[SceneID]
		[SerializeField]
		private string requireSceneID;

		[LocalizationKey("TasksAndRewards")]
		private string defaultEnemyNameKey
		{
			get
			{
				return "Task_Desc_AnyEnemy";
			}
			set
			{
			}
		}

		[LocalizationKey("TasksAndRewards")]
		private string defaultWeaponNameKey
		{
			get
			{
				return "Task_Desc_AnyWeapon";
			}
			set
			{
			}
		}

		private string weaponName
		{
			get
			{
				if (withWeapon)
				{
					return ItemAssetsCollection.GetMetaData(weaponTypeID).DisplayName;
				}
				return defaultWeaponNameKey.ToPlainText();
			}
		}

		private string enemyName
		{
			get
			{
				if (requireEnemyType == null)
				{
					return defaultEnemyNameKey.ToPlainText();
				}
				return requireEnemyType.DisplayName;
			}
		}

		[LocalizationKey("TasksAndRewards")]
		private string descriptionFormatKey
		{
			get
			{
				return "Task_KillCount";
			}
			set
			{
			}
		}

		[LocalizationKey("TasksAndRewards")]
		private string withWeaponDescriptionFormatKey
		{
			get
			{
				return "Task_Desc_WithWeapon";
			}
			set
			{
			}
		}

		[LocalizationKey("TasksAndRewards")]
		private string requireSceneDescriptionFormatKey
		{
			get
			{
				return "Task_Desc_RequireScene";
			}
			set
			{
			}
		}

		[LocalizationKey("TasksAndRewards")]
		private string RequireHeadShotDescriptionKey
		{
			get
			{
				return "Task_Desc_RequireHeadShot";
			}
			set
			{
			}
		}

		[LocalizationKey("TasksAndRewards")]
		private string WithoutHeadShotDescriptionKey
		{
			get
			{
				return "Task_Desc_WithoutHeadShot";
			}
			set
			{
			}
		}

		[LocalizationKey("TasksAndRewards")]
		private string RequireBuffDescriptionFormatKey
		{
			get
			{
				return "Task_Desc_WithBuff";
			}
			set
			{
			}
		}

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		public override string[] ExtraDescriptsions
		{
			get
			{
				List<string> list = new List<string>();
				if (withWeapon)
				{
					list.Add(WithWeaponDescription);
				}
				if (!string.IsNullOrEmpty(requireSceneID))
				{
					list.Add(RequireSceneDescription);
				}
				if (requireHeadShot)
				{
					list.Add(RequireHeadShotDescription);
				}
				if (withoutHeadShot)
				{
					list.Add(WithoutHeadShotDescription);
				}
				if (requireBuff)
				{
					list.Add(RequireBuffDescription);
				}
				return list.ToArray();
			}
		}

		private string WithWeaponDescription => withWeaponDescriptionFormatKey.ToPlainText().Format(new { weaponName });

		private string RequireSceneDescription => requireSceneDescriptionFormatKey.ToPlainText().Format(new { requireSceneName });

		private string RequireHeadShotDescription => RequireHeadShotDescriptionKey.ToPlainText();

		private string WithoutHeadShotDescription => WithoutHeadShotDescriptionKey.ToPlainText();

		private string RequireBuffDescription
		{
			get
			{
				string buffDisplayName = GameplayDataSettings.Buffs.GetBuffDisplayName(requireBuffID);
				return RequireBuffDescriptionFormatKey.ToPlainText().Format(new
				{
					buffName = buffDisplayName
				});
			}
		}

		public override string Description => DescriptionFormat.Format(new { weaponName, enemyName, requireAmount, amount, requireSceneName });

		public SceneInfoEntry RequireSceneInfo => SceneInfoCollection.GetSceneInfo(requireSceneID);

		public SceneReference RequireScene => RequireSceneInfo?.SceneReference;

		public string requireSceneName
		{
			get
			{
				if (string.IsNullOrEmpty(requireSceneID))
				{
					return "Task_Desc_AnyScene".ToPlainText();
				}
				return RequireSceneInfo.DisplayName;
			}
		}

		public bool SceneRequirementSatisfied
		{
			get
			{
				if (string.IsNullOrEmpty(requireSceneID))
				{
					return true;
				}
				SceneReference requireScene = RequireScene;
				if (requireScene == null)
				{
					return true;
				}
				if (requireScene.UnsafeReason == SceneReferenceUnsafeReason.Empty)
				{
					return true;
				}
				if (requireScene.UnsafeReason == SceneReferenceUnsafeReason.None)
				{
					return requireScene.LoadedScene.isLoaded;
				}
				return true;
			}
		}

		private void OnEnable()
		{
			Health.OnDead += Health_OnDead;
			LevelManager.OnLevelInitialized += OnLevelInitialized;
		}

		private void OnDisable()
		{
			Health.OnDead -= Health_OnDead;
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void OnLevelInitialized()
		{
			if (resetOnLevelInitialized)
			{
				amount = 0;
			}
		}

		private void Health_OnDead(Health health, DamageInfo info)
		{
			if (health.team == Teams.player)
			{
				return;
			}
			bool flag = false;
			CharacterMainControl fromCharacter = info.fromCharacter;
			if (fromCharacter != null && info.fromCharacter.IsMainCharacter())
			{
				flag = true;
			}
			if (!flag || (withWeapon && info.fromWeaponItemID != weaponTypeID) || !SceneRequirementSatisfied || (requireHeadShot && info.crit <= 0) || (withoutHeadShot && info.crit > 0) || (requireBuff && !fromCharacter.HasBuff(requireBuffID)))
			{
				return;
			}
			if (requireEnemyType != null)
			{
				CharacterMainControl characterMainControl = health.TryGetCharacter();
				if (characterMainControl == null)
				{
					return;
				}
				CharacterRandomPreset characterPreset = characterMainControl.characterPreset;
				if (characterPreset == null || characterPreset.nameKey != requireEnemyType.nameKey)
				{
					return;
				}
			}
			AddCount();
		}

		private void AddCount()
		{
			if (amount < requireAmount)
			{
				amount++;
				ReportStatusChanged();
			}
		}

		public override object GenerateSaveData()
		{
			return amount;
		}

		protected override bool CheckFinished()
		{
			return amount >= requireAmount;
		}

		public override void SetupSaveData(object data)
		{
			if (data is int num)
			{
				amount = num;
			}
		}
	}
	public class QuestTask_ReachLocation : Task
	{
		[SerializeField]
		private MultiSceneLocation location;

		[SerializeField]
		private float radius = 1f;

		[SerializeField]
		private bool finished;

		[SerializeField]
		private Transform target;

		[SerializeField]
		private MapElementForTask mapElement;

		public string descriptionFormatkey => "Task_ReachLocation";

		public string DescriptionFormat => descriptionFormatkey.ToPlainText();

		public string TargetLocationDisplayName => location.GetDisplayName();

		public override string Description => DescriptionFormat.Format(new { TargetLocationDisplayName });

		private void OnEnable()
		{
			SceneLoader.onFinishedLoadingScene += OnFinishedLoadingScene;
			MultiSceneCore.OnSubSceneLoaded += OnSubSceneLoaded;
		}

		private void Start()
		{
			CacheLocation();
		}

		private void OnDisable()
		{
			SceneLoader.onFinishedLoadingScene -= OnFinishedLoadingScene;
			MultiSceneCore.OnSubSceneLoaded -= OnSubSceneLoaded;
		}

		protected override void OnInit()
		{
			base.OnInit();
			if (!IsFinished())
			{
				SetMapElementVisable(visable: true);
			}
		}

		private void OnFinishedLoadingScene(SceneLoadingContext context)
		{
			CacheLocation();
		}

		private void OnSubSceneLoaded(MultiSceneCore core, Scene scene)
		{
			LevelManager.LevelInitializingComment = "Reach location task caching";
			CacheLocation();
		}

		private void CacheLocation()
		{
			target = location.GetLocationTransform();
		}

		private void Update()
		{
			if (finished || target == null)
			{
				return;
			}
			CharacterMainControl main = CharacterMainControl.Main;
			if (!(main == null))
			{
				if ((main.transform.position - target.position).magnitude <= radius)
				{
					finished = true;
					SetMapElementVisable(visable: false);
				}
				ReportStatusChanged();
			}
		}

		public override object GenerateSaveData()
		{
			return finished;
		}

		protected override bool CheckFinished()
		{
			return finished;
		}

		public override void SetupSaveData(object data)
		{
			if (data is bool flag)
			{
				finished = flag;
			}
		}

		private void SetMapElementVisable(bool visable)
		{
			if ((bool)mapElement)
			{
				if (visable)
				{
					mapElement.locations.Clear();
					mapElement.locations.Add(location);
					mapElement.range = radius;
					mapElement.name = base.Master.DisplayName;
				}
				mapElement.SetVisibility(visable);
			}
		}
	}
	public class QuestTask_SubmitMoney : Task
	{
		[SerializeField]
		private int money;

		[SerializeField]
		[LocalizationKey("Default")]
		private string decriptionFormatKey = "QuestTask_SubmitMoney";

		[SerializeField]
		[LocalizationKey("Default")]
		private string interactTextKey = "QuestTask_SubmitMoney_Interact";

		private bool submitted;

		public string DescriptionFormat => decriptionFormatKey.ToPlainText();

		public override string Description => DescriptionFormat.Format(new { money });

		public override bool Interactable => true;

		public override bool PossibleValidInteraction => CheckMoneyEnough();

		public override string InteractText => interactTextKey.ToPlainText();

		public override void Interact()
		{
			if (new Cost(money).Pay())
			{
				submitted = true;
				ReportStatusChanged();
			}
		}

		private bool CheckMoneyEnough()
		{
			return EconomyManager.Money >= money;
		}

		public override object GenerateSaveData()
		{
			return submitted;
		}

		public override void SetupSaveData(object data)
		{
			if (data is bool flag)
			{
				submitted = flag;
			}
		}

		protected override bool CheckFinished()
		{
			return submitted;
		}
	}
	public class QuestTask_TaskEvent : Task
	{
		[SerializeField]
		private string eventKey;

		[SerializeField]
		[LocalizationKey("Quests")]
		private string description;

		private bool finished;

		[SerializeField]
		private MapElementForTask mapElement;

		public string EventKey => eventKey;

		public override string Description => description.ToPlainText();

		private void OnTaskEvent(string _key)
		{
			if (_key == eventKey)
			{
				finished = true;
				SetMapElementVisable(visable: false);
				ReportStatusChanged();
			}
		}

		protected override void OnInit()
		{
			base.OnInit();
			TaskEvent.OnTaskEvent += OnTaskEvent;
			SetMapElementVisable(!IsFinished());
		}

		private void OnDisable()
		{
			TaskEvent.OnTaskEvent -= OnTaskEvent;
		}

		protected override bool CheckFinished()
		{
			return finished;
		}

		public override object GenerateSaveData()
		{
			return finished;
		}

		public override void SetupSaveData(object data)
		{
			if (data is bool flag)
			{
				finished = flag;
			}
		}

		private void SetMapElementVisable(bool visable)
		{
			if ((bool)mapElement && mapElement.enabled)
			{
				if (visable)
				{
					mapElement.name = base.Master.DisplayName;
				}
				mapElement.SetVisibility(visable);
			}
		}
	}
	public class QuestTask_UnlockPerk : Task
	{
		[SerializeField]
		private string perkTreeID;

		[SerializeField]
		private string perkObjectName;

		private Perk perk;

		[NonSerialized]
		private bool unlocked;

		private string descriptionFormatKey = "Task_UnlockPerk";

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		private string PerkDisplayName
		{
			get
			{
				if (perk == null)
				{
					BindPerk();
				}
				if (perk == null)
				{
					return perkObjectName.ToPlainText();
				}
				return perk.DisplayName;
			}
		}

		public override string Description => DescriptionFormat.Format(new { PerkDisplayName });

		public override Sprite Icon
		{
			get
			{
				if (perk != null)
				{
					return perk.Icon;
				}
				return null;
			}
		}

		protected override void OnInit()
		{
			if (LevelManager.LevelInited)
			{
				BindPerk();
			}
			else
			{
				LevelManager.OnLevelInitialized += OnLevelInitialized;
			}
		}

		private bool BindPerk()
		{
			if ((bool)perk)
			{
				if (!unlocked && perk.Unlocked)
				{
					OnPerkUnlockStateChanged(perk, _unlocked: true);
				}
				return false;
			}
			PerkTree perkTree = PerkTreeManager.GetPerkTree(perkTreeID);
			if ((bool)perkTree)
			{
				foreach (Perk perk in perkTree.perks)
				{
					if (perk.gameObject.name == perkObjectName)
					{
						this.perk = perk;
						if (this.perk.Unlocked)
						{
							OnPerkUnlockStateChanged(this.perk, _unlocked: true);
						}
						this.perk.onUnlockStateChanged += OnPerkUnlockStateChanged;
						return true;
					}
				}
			}
			else
			{
				UnityEngine.Debug.LogError("PerkTree Not Found " + perkTreeID, base.gameObject);
			}
			UnityEngine.Debug.LogError("Perk Not Found: " + perkTreeID + "/" + perkObjectName, base.gameObject);
			return false;
		}

		private void OnPerkUnlockStateChanged(Perk _perk, bool _unlocked)
		{
			if (!base.Master.Complete && _unlocked)
			{
				unlocked = true;
				ReportStatusChanged();
			}
		}

		private void OnDestroy()
		{
			if ((bool)perk)
			{
				perk.onUnlockStateChanged -= OnPerkUnlockStateChanged;
			}
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void OnLevelInitialized()
		{
			BindPerk();
		}

		public override object GenerateSaveData()
		{
			return unlocked;
		}

		protected override bool CheckFinished()
		{
			return unlocked;
		}

		public override void SetupSaveData(object data)
		{
			if (data is bool flag)
			{
				unlocked = flag;
			}
		}
	}
	public class QuestTask_UseItem : Task
	{
		[SerializeField]
		private int requireAmount = 1;

		[ItemTypeID]
		[SerializeField]
		private int itemTypeID;

		[SerializeField]
		private bool resetOnLevelInitialized;

		[SerializeField]
		private int amount;

		private ItemMetaData? _cachedMeta;

		private ItemMetaData CachedMeta
		{
			get
			{
				if (!_cachedMeta.HasValue)
				{
					_cachedMeta = ItemAssetsCollection.GetMetaData(itemTypeID);
				}
				return _cachedMeta.Value;
			}
		}

		private string descriptionFormatKey => "Task_UseItem";

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		private string ItemDisplayName => CachedMeta.DisplayName;

		public override string Description => DescriptionFormat.Format(new { ItemDisplayName, amount, requireAmount });

		public override Sprite Icon => CachedMeta.icon;

		private void OnEnable()
		{
			Item.onUseStatic += OnItemUsed;
			LevelManager.OnLevelInitialized += OnLevelInitialized;
		}

		private void OnDisable()
		{
			Item.onUseStatic -= OnItemUsed;
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void OnLevelInitialized()
		{
			if (resetOnLevelInitialized)
			{
				amount = 0;
			}
		}

		private void OnItemUsed(Item item, object user)
		{
			if ((bool)LevelManager.Instance && user as CharacterMainControl == LevelManager.Instance.MainCharacter && item.TypeID == itemTypeID)
			{
				AddCount();
			}
		}

		private void AddCount()
		{
			if (amount < requireAmount)
			{
				amount++;
				ReportStatusChanged();
			}
		}

		public override object GenerateSaveData()
		{
			return amount;
		}

		protected override bool CheckFinished()
		{
			return amount >= requireAmount;
		}

		public override void SetupSaveData(object data)
		{
			if (data is int num)
			{
				amount = num;
			}
		}
	}
	public class SubmitItems : Task
	{
		[ItemTypeID]
		[SerializeField]
		private int itemTypeID;

		[Range(1f, 100f)]
		[SerializeField]
		private int requiredAmount = 1;

		[SerializeField]
		private int submittedAmount;

		private ItemMetaData? _cachedMeta;

		[SerializeField]
		private MapElementForTask mapElement;

		public int ItemTypeID => itemTypeID;

		private ItemMetaData CachedMeta
		{
			get
			{
				if (!_cachedMeta.HasValue || _cachedMeta.Value.id != itemTypeID)
				{
					_cachedMeta = ItemAssetsCollection.GetMetaData(itemTypeID);
				}
				return _cachedMeta.Value;
			}
		}

		private string descriptionFormatKey => "Task_SubmitItems";

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		private string havingAmountFormatKey => "Task_SubmitItems_HavingAmount";

		private string HavingAmountFormat => havingAmountFormatKey.ToPlainText();

		public override string Description
		{
			get
			{
				string text = DescriptionFormat.Format(new
				{
					ItemDisplayName = CachedMeta.DisplayName,
					submittedAmount = submittedAmount,
					requiredAmount = requiredAmount
				});
				if (!IsFinished())
				{
					text = text + " " + HavingAmountFormat.Format(new
					{
						amount = ItemUtilities.GetItemCount(itemTypeID)
					});
				}
				return text;
			}
		}

		public override Sprite Icon => CachedMeta.icon;

		public override bool Interactable => true;

		public override bool PossibleValidInteraction => CheckItemEnough();

		public override string InteractText => "Task_SubmitItems_Interact".ToPlainText();

		public override bool NeedInspection
		{
			get
			{
				if (!IsFinished())
				{
					return CheckItemEnough();
				}
				return false;
			}
		}

		public static event Action<SubmitItems> onItemEnough;

		protected override void OnInit()
		{
			base.OnInit();
			PlayerStorage.OnPlayerStorageChange += OnPlayerStorageChanged;
			CharacterMainControl.OnMainCharacterInventoryChangedEvent = (Action<CharacterMainControl, Inventory, int>)Delegate.Combine(CharacterMainControl.OnMainCharacterInventoryChangedEvent, new Action<CharacterMainControl, Inventory, int>(OnMainCharacterInventoryChanged));
			CheckItemEnough();
		}

		private void OnDestroy()
		{
			PlayerStorage.OnPlayerStorageChange -= OnPlayerStorageChanged;
			CharacterMainControl.OnMainCharacterInventoryChangedEvent = (Action<CharacterMainControl, Inventory, int>)Delegate.Remove(CharacterMainControl.OnMainCharacterInventoryChangedEvent, new Action<CharacterMainControl, Inventory, int>(OnMainCharacterInventoryChanged));
		}

		private void OnPlayerStorageChanged(PlayerStorage storage, Inventory inventory, int index)
		{
			if (!base.Master.Complete)
			{
				Item itemAt = inventory.GetItemAt(index);
				if (!(itemAt == null) && itemAt.TypeID == itemTypeID)
				{
					CheckItemEnough();
				}
			}
		}

		private void OnMainCharacterInventoryChanged(CharacterMainControl control, Inventory inventory, int index)
		{
			if (!base.Master.Complete)
			{
				Item itemAt = inventory.GetItemAt(index);
				if (!(itemAt == null) && itemAt.TypeID == itemTypeID)
				{
					CheckItemEnough();
				}
			}
		}

		private bool CheckItemEnough()
		{
			if (ItemUtilities.GetItemCount(itemTypeID) >= requiredAmount)
			{
				SubmitItems.onItemEnough?.Invoke(this);
				SetMapElementVisable(visable: false);
				return true;
			}
			SetMapElementVisable(visable: true);
			return false;
		}

		private void SetMapElementVisable(bool visable)
		{
			if ((bool)mapElement)
			{
				if (visable)
				{
					mapElement.name = base.Master.DisplayName;
				}
				mapElement.SetVisibility(visable);
			}
		}

		public void Submit(Item item)
		{
			if (item.TypeID != itemTypeID)
			{
				UnityEngine.Debug.LogError("提交的物品类型与需求不一致。");
				return;
			}
			int num = requiredAmount - submittedAmount;
			if (num <= 0)
			{
				UnityEngine.Debug.LogError("目标已达成，不需要继续提交物品");
				return;
			}
			int num2 = submittedAmount;
			if (num < item.StackCount)
			{
				item.StackCount -= num;
				submittedAmount += num;
			}
			else
			{
				foreach (Item allChild in item.GetAllChildren(includingGrandChildren: false, excludeSelf: true))
				{
					allChild.Detach();
					if (!ItemUtilities.SendToPlayerCharacter(allChild))
					{
						allChild.Drop(CharacterMainControl.Main, createRigidbody: true);
					}
				}
				item.Detach();
				item.DestroyTree();
				submittedAmount += item.StackCount;
			}
			UnityEngine.Debug.Log("submission done");
			if (num2 != submittedAmount)
			{
				base.Master.NotifyTaskFinished(this);
			}
			ReportStatusChanged();
		}

		protected override bool CheckFinished()
		{
			return submittedAmount >= requiredAmount;
		}

		public override object GenerateSaveData()
		{
			return submittedAmount;
		}

		public override void SetupSaveData(object data)
		{
			submittedAmount = (int)data;
		}

		public override void Interact()
		{
			if (base.Master == null)
			{
				return;
			}
			List<Item> list = ItemUtilities.FindAllBelongsToPlayer((Item e) => e != null && e.TypeID == itemTypeID);
			for (int num = 0; num < list.Count; num++)
			{
				Item item = list[num];
				Submit(item);
				if (IsFinished())
				{
					break;
				}
			}
		}
	}
}
namespace Duckov.Quests.Rewards
{
	public class QuestReward_EXP : Reward
	{
		[SerializeField]
		private int amount;

		[SerializeField]
		private bool claimed;

		public int Amount => amount;

		public override bool Claimed => claimed;

		private string descriptionFormatKey => "Reward_Exp";

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		public override string Description => DescriptionFormat.Format(new { amount });

		public override bool AutoClaim => true;

		public override object GenerateSaveData()
		{
			return claimed;
		}

		public override void OnClaim()
		{
			if (!Claimed && EXPManager.AddExp(amount))
			{
				claimed = true;
			}
		}

		public override void SetupSaveData(object data)
		{
			if (data is bool flag)
			{
				claimed = flag;
			}
		}
	}
	public class QuestReward_Money : Reward
	{
		[Min(0f)]
		[SerializeField]
		private int amount;

		[SerializeField]
		private bool claimed;

		public int Amount => amount;

		public override bool Claimed => claimed;

		[SerializeField]
		private string descriptionFormatKey => "Reward_Money";

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		public override bool AutoClaim => true;

		public override string Description => DescriptionFormat.Format(new { amount });

		public override object GenerateSaveData()
		{
			return claimed;
		}

		public override void OnClaim()
		{
			if (!Claimed && EconomyManager.Add(amount))
			{
				claimed = true;
			}
		}

		public override void SetupSaveData(object data)
		{
			if (data is bool flag)
			{
				claimed = flag;
			}
		}
	}
	public class QuestReward_UnlockStockItem : Reward
	{
		[SerializeField]
		[ItemTypeID]
		private int unlockItem;

		private bool claimed;

		public int UnlockItem => unlockItem;

		public override Sprite Icon => ItemAssetsCollection.GetMetaData(unlockItem).icon;

		private string descriptionFormatKey => "Reward_UnlockStockItem";

		private string DescriptionFormat => descriptionFormatKey.ToPlainText();

		private string ItemDisplayName => ItemAssetsCollection.GetMetaData(unlockItem).DisplayName;

		public override string Description => DescriptionFormat.Format(new { ItemDisplayName });

		public override bool Claimed => claimed;

		public override bool AutoClaim => true;

		private ItemMetaData GetItemMeta()
		{
			return ItemAssetsCollection.GetMetaData(unlockItem);
		}

		public override object GenerateSaveData()
		{
			return claimed;
		}

		public override void OnClaim()
		{
			EconomyManager.Unlock(unlockItem);
			claimed = true;
			ReportStatusChanged();
		}

		public override void SetupSaveData(object data)
		{
			if (data is bool flag)
			{
				claimed = flag;
			}
		}

		public override void NotifyReload(Quest questInstance)
		{
			if (questInstance.Complete)
			{
				EconomyManager.Unlock(unlockItem);
			}
		}
	}
}
namespace Duckov.Quests.Relations
{
	public class QuestRelationConnection : NodeCanvas.Framework.Connection
	{
	}
	[CreateAssetMenu(menuName = "Quests/Relations")]
	public class QuestRelationGraph : NodeCanvas.Framework.Graph
	{
		public static int selectedQuestID = -1;

		public override Type baseNodeType => typeof(QuestRelationNodeBase);

		public override bool requiresAgent => false;

		public override bool requiresPrimeNode => false;

		public override bool isTree => false;

		public override PlanarDirection flowDirection => PlanarDirection.Vertical;

		public override bool allowBlackboardOverrides => true;

		public override bool canAcceptVariableDrops => true;

		public QuestRelationNode GetNode(int questID)
		{
			return base.allNodes.Find((Node node) => node is QuestRelationNode questRelationNode && questRelationNode.questID == questID) as QuestRelationNode;
		}

		public List<int> GetRequiredIDs(int targetID)
		{
			List<int> list = new List<int>();
			QuestRelationNode node = GetNode(targetID);
			if (node == null)
			{
				return list;
			}
			foreach (NodeCanvas.Framework.Connection inConnection in node.inConnections)
			{
				if (inConnection.sourceNode is QuestRelationNode { questID: var questID })
				{
					list.Add(questID);
				}
				else if (inConnection.sourceNode is QuestRelationProxyNode { questID: var questID2 })
				{
					list.Add(questID2);
				}
			}
			return list;
		}

		protected override void OnGraphValidate()
		{
			CheckDuplicates();
		}

		internal void CheckDuplicates()
		{
		}
	}
	public class QuestRelationNodeBase : Node
	{
		public override int maxInConnections => 64;

		public override int maxOutConnections => 64;

		public override Type outConnectionType => typeof(QuestRelationConnection);

		public override bool allowAsPrime => true;

		public override bool canSelfConnect => false;

		public override Alignment2x2 commentsAlignment => Alignment2x2.Default;

		public override Alignment2x2 iconAlignment => Alignment2x2.Default;
	}
	public class QuestRelationNode : QuestRelationNodeBase
	{
		public int questID;

		private static QuestCollection _questCollection;

		internal bool isDuplicate;

		private static QuestCollection QuestCollection
		{
			get
			{
				if (_questCollection == null)
				{
					_questCollection = GameplayDataSettings.QuestCollection;
				}
				return _questCollection;
			}
		}

		private void SelectQuest()
		{
		}

		public List<int> GetParents()
		{
			List<int> list = new List<int>();
			foreach (NodeCanvas.Framework.Connection inConnection in base.inConnections)
			{
				if (inConnection.sourceNode is QuestRelationNode questRelationNode)
				{
					list.Add(questRelationNode.questID);
				}
				else if (inConnection.sourceNode is QuestRelationProxyNode questRelationProxyNode)
				{
					list.Add(questRelationProxyNode.questID);
				}
			}
			return list;
		}

		public List<int> GetChildren()
		{
			List<int> list = new List<int>();
			foreach (NodeCanvas.Framework.Connection outConnection in base.outConnections)
			{
				if (outConnection.sourceNode is QuestRelationNode questRelationNode)
				{
					list.Add(questRelationNode.questID);
				}
			}
			return list;
		}
	}
	public class QuestRelationProxyNode : QuestRelationNodeBase
	{
		private static QuestCollection _questCollection;

		public int questID;

		public override int maxInConnections => 0;

		private static QuestCollection QuestCollection
		{
			get
			{
				if (_questCollection == null)
				{
					_questCollection = GameplayDataSettings.QuestCollection;
				}
				return _questCollection;
			}
		}

		private void SelectQuest()
		{
		}
	}
}
namespace Duckov.Quests.Conditions
{
	public class RequireDemo : Condition
	{
		[SerializeField]
		private bool inverse;

		public override bool Evaluate()
		{
			if (inverse)
			{
				return !GameMetaData.Instance.IsDemo;
			}
			return GameMetaData.Instance.IsDemo;
		}
	}
	public class RequireFormulaUnlocked : Condition
	{
		[ItemTypeID]
		[SerializeField]
		private int itemID;

		[SerializeField]
		private string formulaID;

		public Item setFromItem;

		public override bool Evaluate()
		{
			return CraftingManager.IsFormulaUnlocked(formulaID);
		}
	}
	public class RequireGameobjectsActived : Condition
	{
		[SerializeField]
		private GameObject[] targets;

		public override bool Evaluate()
		{
			GameObject[] array = targets;
			foreach (GameObject gameObject in array)
			{
				if (gameObject == null || !gameObject.activeInHierarchy)
				{
					return false;
				}
			}
			return true;
		}
	}
	public class RequireHasFished : Condition
	{
		public override bool Evaluate()
		{
			return GetHasFished();
		}

		public static void SetHasFished()
		{
			SavesSystem.Save("HasFished", value: true);
		}

		public static bool GetHasFished()
		{
			return SavesSystem.Load<bool>("HasFished");
		}
	}
	public class RequirePerkUnlocked : Condition
	{
		[SerializeField]
		private string perkTreeID;

		[SerializeField]
		private string perkObjectName;

		private Perk perk;

		public override bool Evaluate()
		{
			return GetUnlocked();
		}

		private bool GetUnlocked()
		{
			if ((bool)perk)
			{
				return perk.Unlocked;
			}
			PerkTree perkTree = PerkTreeManager.GetPerkTree(perkTreeID);
			if ((bool)perkTree)
			{
				foreach (Perk perk in perkTree.perks)
				{
					if (perk.gameObject.name == perkObjectName)
					{
						this.perk = perk;
						return this.perk.Unlocked;
					}
				}
			}
			return false;
		}
	}
	public class RequireQuestsActive : Condition
	{
		[SerializeField]
		private int[] requiredQuestIDs;

		public int[] RequiredQuestIDs => requiredQuestIDs;

		public override bool Evaluate()
		{
			return QuestManager.AreQuestsActive(requiredQuestIDs);
		}
	}
	public class RequireQuestsFinished : Condition
	{
		[SerializeField]
		private int[] requiredQuestIDs;

		public int[] RequiredQuestIDs => requiredQuestIDs;

		public override bool Evaluate()
		{
			return QuestManager.AreQuestFinished(requiredQuestIDs);
		}
	}
}
namespace Duckov.ItemUsage
{
	public class AddBuff : UsageBehavior
	{
		public Buff buffPrefab;

		[Range(0.01f, 1f)]
		public float chance = 1f;

		[LocalizationKey("Default")]
		private string chanceKey = "UI_AddBuffChance";

		public override DisplaySettingsData DisplaySettings
		{
			get
			{
				DisplaySettingsData result = default(DisplaySettingsData);
				result.display = true;
				result.description = "";
				result.description = buffPrefab.DisplayName ?? "";
				if (buffPrefab.LimitedLifeTime)
				{
					result.description += $" : {buffPrefab.TotalLifeTime}s ";
				}
				if (chance < 1f)
				{
					result.description += $" ({chanceKey.ToPlainText()} : {Mathf.RoundToInt(chance * 100f)}%)";
				}
				return result;
			}
		}

		public override bool CanBeUsed(Item item, object user)
		{
			return true;
		}

		protected override void OnUse(Item item, object user)
		{
			CharacterMainControl characterMainControl = user as CharacterMainControl;
			if (!(characterMainControl == null) && !(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				characterMainControl.AddBuff(buffPrefab, characterMainControl);
			}
		}
	}
	[MenuPath("概率死亡")]
	public class DeadByChance : UsageBehavior
	{
		public int damageValue = 9999;

		public float chance;

		[LocalizationKey("Default")]
		public string descriptionKey = "Usage_DeadByChance";

		[LocalizationKey("Default")]
		public string popTextKey = "Usage_DeadByChance_PopText";

		public override DisplaySettingsData DisplaySettings => new DisplaySettingsData
		{
			display = true,
			description = $"{descriptionKey.ToPlainText()}:  {chance * 100f:0}%"
		};

		public override bool CanBeUsed(Item item, object user)
		{
			if (!(user as CharacterMainControl))
			{
				return false;
			}
			return true;
		}

		protected override void OnUse(Item item, object user)
		{
			CharacterMainControl characterMainControl = user as CharacterMainControl;
			if ((bool)characterMainControl && !(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				KillSelf(characterMainControl, item.TypeID).Forget();
			}
		}

		private async UniTaskVoid KillSelf(CharacterMainControl character, int weaponID)
		{
			DamageInfo dmgInfo = default(DamageInfo);
			dmgInfo.fromCharacter = character;
			dmgInfo.fromWeaponItemID = weaponID;
			dmgInfo.damageValue = 1f;
			dmgInfo.ignoreArmor = true;
			dmgInfo.isFromBuffOrEffect = true;
			dmgInfo.elementFactors = new List<ElementFactor>();
			dmgInfo.elementFactors.Add(new ElementFactor(ElementTypes.poison, 1f));
			await UniTask.WaitForSeconds(0.5f);
			if (!character)
			{
				return;
			}
			character.PopText(popTextKey.ToPlainText());
			await UniTask.WaitForSeconds(1f);
			if (!character)
			{
				return;
			}
			character.Health.Hurt(dmgInfo);
			await UniTask.WaitForSeconds(1f);
			if (!character)
			{
				return;
			}
			character.Health.Hurt(dmgInfo);
			character.PopText("????");
			await UniTask.WaitForSeconds(1f);
			if (!character)
			{
				return;
			}
			character.Health.Hurt(dmgInfo);
			await UniTask.WaitForSeconds(1f);
			if ((bool)character)
			{
				character.Health.Hurt(dmgInfo);
				await UniTask.WaitForSeconds(1f);
				if ((bool)character)
				{
					dmgInfo.damageValue = damageValue;
					character.Health.Hurt(dmgInfo);
				}
			}
		}
	}
	[MenuPath("医疗/药")]
	public class Drug : UsageBehavior
	{
		public int healValue;

		[LocalizationKey("Default")]
		public string healValueDescriptionKey = "Usage_HealValue";

		[LocalizationKey("Default")]
		public string durabilityUsageDescriptionKey = "Usage_Durability";

		public bool useDurability;

		public float durabilityUsage;

		public bool canUsePart;

		public override DisplaySettingsData DisplaySettings
		{
			get
			{
				DisplaySettingsData result = new DisplaySettingsData
				{
					display = true,
					description = $"{healValueDescriptionKey.ToPlainText()} : {healValue}"
				};
				if (useDurability)
				{
					result.description += $" ({durabilityUsageDescriptionKey.ToPlainText()} : {durabilityUsage})";
				}
				return result;
			}
		}

		public override bool CanBeUsed(Item item, object user)
		{
			CharacterMainControl characterMainControl = user as CharacterMainControl;
			if (!characterMainControl)
			{
				return false;
			}
			if (!CheckCanHeal(characterMainControl))
			{
				return false;
			}
			return true;
		}

		protected override void OnUse(Item item, object user)
		{
			CharacterMainControl characterMainControl = user as CharacterMainControl;
			if (!characterMainControl)
			{
				return;
			}
			float num = healValue;
			if (useDurability && item.UseDurability)
			{
				float num2 = durabilityUsage;
				if (canUsePart)
				{
					num = characterMainControl.Health.MaxHealth - characterMainControl.Health.CurrentHealth;
					if (num > (float)healValue)
					{
						num = healValue;
					}
					num2 = num / (float)healValue * durabilityUsage;
					if (num2 > item.Durability)
					{
						num2 = item.Durability;
						num = (float)healValue * item.Durability / durabilityUsage;
					}
					UnityEngine.Debug.Log($"治疗：{num}耐久消耗：{num2}");
					item.Durability -= num2;
				}
			}
			Heal(characterMainControl, item, num);
		}

		private bool CheckCanHeal(CharacterMainControl character)
		{
			if (healValue > 0 && character.Health.CurrentHealth >= character.Health.MaxHealth)
			{
				return false;
			}
			return true;
		}

		private void Heal(CharacterMainControl character, Item selfItem, float _healValue)
		{
			if (_healValue > 0f)
			{
				character.AddHealth(Mathf.CeilToInt(_healValue));
			}
			else if (_healValue < 0f)
			{
				DamageInfo damageInfo = new DamageInfo(null);
				damageInfo.damageValue = 0f - _healValue;
				damageInfo.damagePoint = character.transform.position;
				damageInfo.damageNormal = Vector3.up;
				character.Health.Hurt(damageInfo);
			}
		}
	}
	[MenuPath("食物/食物")]
	public class FoodDrink : UsageBehavior
	{
		public float energyValue;

		public float waterValue;

		[LocalizationKey("Default")]
		public string energyKey = "Usage_Energy";

		[LocalizationKey("Default")]
		public string waterKey = "Usage_Water";

		public float UseDurability;

		public override DisplaySettingsData DisplaySettings
		{
			get
			{
				DisplaySettingsData result = new DisplaySettingsData
				{
					display = true
				};
				if (energyValue != 0f && waterValue != 0f)
				{
					result.description = energyKey.ToPlainText() + ": " + energyValue + "  " + waterKey.ToPlainText() + ": " + waterValue;
				}
				else if (energyValue != 0f)
				{
					result.description = energyKey.ToPlainText() + ": " + energyValue;
				}
				else
				{
					result.description = waterKey.ToPlainText() + ": " + waterValue;
				}
				return result;
			}
		}

		public override bool CanBeUsed(Item item, object user)
		{
			if (!(user as CharacterMainControl))
			{
				return false;
			}
			return true;
		}

		protected override void OnUse(Item item, object user)
		{
			CharacterMainControl characterMainControl = user as CharacterMainControl;
			if ((bool)characterMainControl)
			{
				Eat(characterMainControl);
				if (UseDurability > 0f && item.UseDurability)
				{
					item.Durability -= UseDurability;
				}
			}
		}

		private void Eat(CharacterMainControl character)
		{
			if (energyValue != 0f)
			{
				character.AddEnergy(energyValue);
			}
			if (waterValue != 0f)
			{
				character.AddWater(waterValue);
			}
		}
	}
	public class RemoveBuff : UsageBehavior
	{
		public int buffID;

		[FormerlySerializedAs("removeOneLayer")]
		public bool litmitRemoveLayerCount;

		public int removeLayerCount = 2;

		public bool useDurability;

		public int durabilityUsage = 1;

		public override bool CanBeUsed(Item item, object user)
		{
			if (!item)
			{
				return false;
			}
			if (useDurability && item.Durability < (float)durabilityUsage)
			{
				return false;
			}
			CharacterMainControl characterMainControl = user as CharacterMainControl;
			if (characterMainControl == null)
			{
				return false;
			}
			return characterMainControl.HasBuff(buffID);
		}

		protected override void OnUse(Item item, object user)
		{
			CharacterMainControl characterMainControl = user as CharacterMainControl;
			if (!(characterMainControl == null))
			{
				if (!litmitRemoveLayerCount)
				{
					characterMainControl.RemoveBuff(buffID, removeOneLayer: false);
				}
				for (int i = 0; i < removeLayerCount; i++)
				{
					characterMainControl.RemoveBuff(buffID, litmitRemoveLayerCount);
				}
				if (useDurability && item.Durability > 0f)
				{
					item.Durability -= durabilityUsage;
				}
			}
		}
	}
	public class SpawnEgg : UsageBehavior
	{
		public Egg eggPrefab;

		public CharacterRandomPreset spawnCharacter;

		public float eggSpawnDelay = 2f;

		[LocalizationKey("Default")]
		public string descriptionKey = "Usage_SpawnEgg";

		public override DisplaySettingsData DisplaySettings => new DisplaySettingsData
		{
			display = true,
			description = (descriptionKey.ToPlainText() ?? "")
		};

		public override bool CanBeUsed(Item item, object user)
		{
			return true;
		}

		protected override void OnUse(Item item, object user)
		{
			CharacterMainControl characterMainControl = user as CharacterMainControl;
			if (!(characterMainControl == null))
			{
				Egg egg = UnityEngine.Object.Instantiate(eggPrefab, characterMainControl.transform.position, Quaternion.identity);
				Collider component = egg.GetComponent<Collider>();
				Collider component2 = characterMainControl.GetComponent<Collider>();
				if ((bool)component && (bool)component2)
				{
					UnityEngine.Debug.Log("关掉角色和蛋的碰撞");
					Physics.IgnoreCollision(component, component2, ignore: true);
				}
				egg.Init(characterMainControl.transform.position, characterMainControl.CurrentAimDirection * 1f, characterMainControl, spawnCharacter, eggSpawnDelay);
			}
		}
	}
}
namespace Duckov.Tasks
{
	public interface ITaskBehaviour
	{
		void Begin();

		bool IsPending();

		bool IsComplete();

		void Skip()
		{
		}
	}
	public class Startup : MonoBehaviour
	{
		public List<MonoBehaviour> beforeSequence = new List<MonoBehaviour>();

		public List<MonoBehaviour> waitForTasks = new List<MonoBehaviour>();

		private void Awake()
		{
			MoveOldSaves();
		}

		private void MoveOldSaves()
		{
			string fullPathToSavesFolder = SavesSystem.GetFullPathToSavesFolder();
			if (!Directory.Exists(fullPathToSavesFolder))
			{
				Directory.CreateDirectory(fullPathToSavesFolder);
			}
			for (int i = 1; i <= 3; i++)
			{
				string saveFileName = SavesSystem.GetSaveFileName(i);
				string text = System.IO.Path.Combine(Application.persistentDataPath, saveFileName);
				string text2 = System.IO.Path.Combine(fullPathToSavesFolder, saveFileName);
				if (File.Exists(text) && !File.Exists(text2))
				{
					UnityEngine.Debug.Log("Transporting:\n" + text + "\n->\n" + text2);
					SavesSystem.UpgradeSaveFileAssemblyInfo(text);
					File.Move(text, text2);
				}
			}
			string path = "Options.ES3";
			string text3 = System.IO.Path.Combine(Application.persistentDataPath, path);
			string text4 = System.IO.Path.Combine(fullPathToSavesFolder, path);
			if (File.Exists(text3) && !File.Exists(text4))
			{
				UnityEngine.Debug.Log("Transporting:\n" + text3 + "\n->\n" + text4);
				SavesSystem.UpgradeSaveFileAssemblyInfo(text3);
				File.Move(text3, text4);
			}
			string globalSaveDataFileName = SavesSystem.GlobalSaveDataFileName;
			string text5 = System.IO.Path.Combine(Application.persistentDataPath, globalSaveDataFileName);
			string text6 = System.IO.Path.Combine(fullPathToSavesFolder, globalSaveDataFileName);
			if (!File.Exists(text5))
			{
				text5 = System.IO.Path.Combine(Application.persistentDataPath, "Global.csv");
			}
			if (File.Exists(text5) && !File.Exists(text6))
			{
				UnityEngine.Debug.Log("Transporting:\n" + text5 + "\n->\n" + text6);
				SavesSystem.UpgradeSaveFileAssemblyInfo(text5);
				File.Move(text5, text6);
			}
		}

		private void Start()
		{
			StartupFlow().Forget();
		}

		private async UniTask StartupFlow()
		{
			foreach (MonoBehaviour item in beforeSequence)
			{
				if (!(item == null) && item is ITaskBehaviour task)
				{
					task.Begin();
					while (task.IsPending())
					{
						await UniTask.Yield();
					}
				}
			}
			while (!EvaluateWaitList())
			{
				await UniTask.Yield();
			}
			SceneLoader.StaticLoadSingle(GameplayDataSettings.SceneManagement.MainMenuScene);
		}

		private bool EvaluateWaitList()
		{
			foreach (MonoBehaviour waitForTask in waitForTasks)
			{
				if (!(waitForTask == null) && waitForTask is ITaskBehaviour taskBehaviour && !taskBehaviour.IsComplete())
				{
					return false;
				}
			}
			return true;
		}
	}
	public class Credits : MonoBehaviour, ITaskBehaviour
	{
		private RectTransform rectTransform;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private RectTransform content;

		[SerializeField]
		private float scrollSpeed;

		[SerializeField]
		private float holdForSeconds;

		[SerializeField]
		private bool fadeOut;

		[SerializeField]
		private bool mute;

		private UniTask task;

		private bool skip;

		private void Awake()
		{
			rectTransform = base.transform as RectTransform;
		}

		public void Begin()
		{
			if (task.Status != UniTaskStatus.Pending)
			{
				skip = false;
				fadeGroup.SkipHide();
				fadeGroup.gameObject.SetActive(value: true);
				task = Task();
			}
		}

		public bool IsPending()
		{
			return task.Status == UniTaskStatus.Pending;
		}

		public bool IsComplete()
		{
			return !IsPending();
		}

		private async UniTask Task()
		{
			if (!mute)
			{
				AudioManager.PlayBGM("mus_main_theme");
			}
			fadeGroup.Show();
			await UniTask.Yield();
			content.anchoredPosition = Vector3.zero;
			float height = rectTransform.rect.height;
			float height2 = content.rect.height;
			float yMax = height * 0.5f + height2;
			float y = 0f;
			while (y < yMax)
			{
				y += Time.deltaTime * scrollSpeed * (skip ? 20f : 1f);
				content.anchoredPosition = Vector3.up * y;
				await UniTask.Yield();
			}
			float holdBuffer = 0f;
			while (!skip)
			{
				await UniTask.Yield();
				holdBuffer += Time.unscaledDeltaTime;
				if (holdBuffer > holdForSeconds)
				{
					break;
				}
			}
			if (fadeOut)
			{
				await fadeGroup.HideAndReturnTask();
			}
			if (AchievementManager.Instance != null)
			{
				AchievementManager.Instance.Unlock("Escape_From_Duckov");
			}
			if (!mute)
			{
				AudioManager.StopBGM();
			}
		}

		public void Skip()
		{
			skip = true;
			if (fadeOut && fadeGroup.IsFading)
			{
				fadeGroup.SkipHide();
			}
			if (!mute)
			{
				AudioManager.StopBGM();
			}
		}
	}
	[Obsolete]
	public class EndingFlow : MonoBehaviour
	{
		[SerializeField]
		private List<MonoBehaviour> taskBehaviours = new List<MonoBehaviour>();

		[SerializeField]
		private UnityEvent onBegin;

		[SerializeField]
		private UnityEvent onEnd;

		private void Start()
		{
			Task().Forget();
		}

		private async UniTask Task()
		{
			onBegin.Invoke();
			UnityEngine.Debug.Log("Ending begin!");
			foreach (MonoBehaviour taskBehaviour in taskBehaviours)
			{
				await WaitForTaskBehaviour(taskBehaviour);
			}
			UnityEngine.Debug.Log("Ending end!");
			onEnd.Invoke();
		}

		private async UniTask WaitForTaskBehaviour(MonoBehaviour mono)
		{
			if (mono is ITaskBehaviour task)
			{
				task.Begin();
				while (task.IsPending())
				{
					await UniTask.Yield();
				}
			}
		}
	}
	public class TaskList : MonoBehaviour, ITaskBehaviour
	{
		[SerializeField]
		private bool beginOnStart;

		[SerializeField]
		private List<MonoBehaviour> tasks;

		[SerializeField]
		private UnityEvent onBegin;

		[SerializeField]
		private UnityEvent onComplete;

		[SerializeField]
		private bool listenToSkipSignal;

		private bool running;

		private bool complete;

		private int currentTaskIndex;

		private ITaskBehaviour currentTask;

		private bool skip;

		private void Start()
		{
			if (beginOnStart)
			{
				Begin();
			}
		}

		private async UniTask MainTask()
		{
			for (int i = 0; i < tasks.Count; i++)
			{
				currentTaskIndex = i;
				MonoBehaviour monoBehaviour = tasks[currentTaskIndex];
				if (monoBehaviour == null || !(monoBehaviour is ITaskBehaviour taskBehaviour))
				{
					continue;
				}
				currentTask = taskBehaviour;
				currentTask.Begin();
				while (currentTask != null && currentTask.IsPending() && !currentTask.IsComplete())
				{
					if (this == null)
					{
						return;
					}
					if (skip)
					{
						currentTask.Skip();
					}
					await UniTask.Yield();
				}
			}
			complete = true;
			running = false;
			onComplete?.Invoke();
		}

		public void Begin()
		{
			if (!running)
			{
				skip = false;
				running = true;
				complete = false;
				onBegin?.Invoke();
				MainTask().Forget();
			}
		}

		public bool IsComplete()
		{
			return complete;
		}

		public bool IsPending()
		{
			return running;
		}

		public void Skip()
		{
			skip = true;
		}
	}
	public class ParallelTask : MonoBehaviour, ITaskBehaviour
	{
		[SerializeField]
		private bool beginOnStart;

		[SerializeField]
		private List<MonoBehaviour> tasks;

		[SerializeField]
		private UnityEvent onBegin;

		[SerializeField]
		private UnityEvent onComplete;

		private bool running;

		private bool complete;

		private void Start()
		{
			if (beginOnStart)
			{
				Begin();
			}
		}

		private async UniTask MainTask()
		{
			foreach (MonoBehaviour task in tasks)
			{
				if (!(task == null) && task is ITaskBehaviour taskBehaviour)
				{
					taskBehaviour.Begin();
				}
			}
			bool anyTaskPending = false;
			while (anyTaskPending)
			{
				if (this == null)
				{
					return;
				}
				anyTaskPending = false;
				foreach (MonoBehaviour task2 in tasks)
				{
					if (!(task2 == null) && task2 is ITaskBehaviour taskBehaviour2 && taskBehaviour2.IsPending())
					{
						anyTaskPending = true;
						break;
					}
				}
				if (!anyTaskPending)
				{
					break;
				}
				await UniTask.Yield();
			}
			running = false;
			complete = true;
			onComplete?.Invoke();
		}

		public void Begin()
		{
			if (!running)
			{
				running = true;
				complete = false;
				onBegin?.Invoke();
				MainTask().Forget();
			}
		}

		public bool IsComplete()
		{
			return complete;
		}

		public bool IsPending()
		{
			return running;
		}
	}
	public class PlayTimelineTask : MonoBehaviour, ITaskBehaviour
	{
		[SerializeField]
		private PlayableDirector timeline;

		private bool running;

		private void Awake()
		{
			timeline.stopped += OnTimelineStopped;
		}

		private void OnDestroy()
		{
			if (timeline != null)
			{
				timeline.stopped -= OnTimelineStopped;
			}
		}

		private void OnTimelineStopped(PlayableDirector director)
		{
			running = false;
		}

		public void Begin()
		{
			running = true;
			timeline.Play();
		}

		public bool IsComplete()
		{
			if (timeline.time > timeline.duration - 0.009999999776482582)
			{
				return true;
			}
			return timeline.state != PlayState.Playing;
		}

		public bool IsPending()
		{
			if (timeline.time > timeline.duration - 0.009999999776482582)
			{
				return false;
			}
			return timeline.state == PlayState.Playing;
		}

		public void Skip()
		{
			timeline.Stop();
		}
	}
}
namespace Duckov.UI
{
	[CreateAssetMenu]
	public class UIPrefabsReference : ScriptableObject
	{
		[SerializeField]
		private ItemDisplay itemDisplay;

		[SerializeField]
		private SlotIndicator slotIndicator;

		[SerializeField]
		private SlotDisplay slotDisplay;

		[SerializeField]
		private InventoryEntry inventoryEntry;

		public ItemDisplay ItemDisplay => itemDisplay;

		public SlotIndicator SlotIndicator => slotIndicator;

		public SlotDisplay SlotDisplay => slotDisplay;

		public InventoryEntry InventoryEntry => inventoryEntry;
	}
	public class BuffDetailsOverlay : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private TextMeshProUGUI text_BuffName;

		[SerializeField]
		private TextMeshProUGUI text_BuffDescription;

		[SerializeField]
		private TextMeshProUGUI text_CountDown;

		[SerializeField]
		private PunchReceiver punchReceiver;

		[SerializeField]
		private float disappearAfterSeconds = 5f;

		private RectTransform rectTransform;

		private Buff target;

		private float timeWhenShowStarted;

		public Buff Target => target;

		private float TimeSinceShowStarted => Time.unscaledTime - timeWhenShowStarted;

		private void Awake()
		{
			rectTransform = base.transform as RectTransform;
			BuffsDisplayEntry.OnBuffsDisplayEntryClicked += OnBuffsDisplayEntryClicked;
		}

		private void OnDestroy()
		{
			BuffsDisplayEntry.OnBuffsDisplayEntryClicked -= OnBuffsDisplayEntryClicked;
		}

		private void OnBuffsDisplayEntryClicked(BuffsDisplayEntry entry, PointerEventData eventData)
		{
			if (fadeGroup.IsShown && target == entry.Target)
			{
				fadeGroup.Hide();
				punchReceiver.Punch();
			}
			else
			{
				Setup(entry);
				Show();
				punchReceiver.Punch();
			}
		}

		public void Setup(Buff target)
		{
			this.target = target;
			if (!(target == null))
			{
				text_BuffName.text = target.DisplayName;
				text_BuffDescription.text = target.Description;
				RefreshCountDown();
			}
		}

		private void Update()
		{
			if (fadeGroup.IsShown || fadeGroup.IsShowingInProgress)
			{
				if (target != null)
				{
					RefreshCountDown();
				}
				else
				{
					fadeGroup.Hide();
				}
				if (TimeSinceShowStarted > disappearAfterSeconds)
				{
					fadeGroup.Hide();
				}
			}
		}

		public void Setup(BuffsDisplayEntry target)
		{
			if (!(target == null))
			{
				Setup(target?.Target);
				RectTransform obj = target.Icon.rectTransform;
				Vector3 position = obj.TransformPoint(obj.rect.max);
				rectTransform.pivot = Vector2.up;
				rectTransform.position = position;
				rectTransform.SetAsLastSibling();
			}
		}

		private void RefreshCountDown()
		{
			if (!(target == null))
			{
				if (target.LimitedLifeTime)
				{
					float remainingTime = target.RemainingTime;
					text_CountDown.text = $"{remainingTime:0.0}s";
				}
				else
				{
					text_CountDown.text = "";
				}
			}
		}

		public void Show()
		{
			fadeGroup.Show();
			timeWhenShowStarted = Time.unscaledTime;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (fadeGroup.IsShown || fadeGroup.IsShowingInProgress)
			{
				punchReceiver.Punch();
				fadeGroup.Hide();
			}
		}
	}
	public class BuffsDisplay : MonoBehaviour
	{
		[SerializeField]
		private BuffsDisplayEntry prefab;

		private PrefabPool<BuffsDisplayEntry> _entryPool;

		private List<BuffsDisplayEntry> activeEntries = new List<BuffsDisplayEntry>();

		private CharacterBuffManager buffManager;

		private PrefabPool<BuffsDisplayEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<BuffsDisplayEntry>(prefab, base.transform, delegate(BuffsDisplayEntry e)
					{
						activeEntries.Add(e);
					}, delegate(BuffsDisplayEntry e)
					{
						activeEntries.Remove(e);
					});
				}
				return _entryPool;
			}
		}

		public void ReleaseEntry(BuffsDisplayEntry entry)
		{
			EntryPool.Release(entry);
		}

		private void Awake()
		{
			LevelManager.OnLevelInitialized += OnLevelInitialized;
			if (LevelManager.LevelInited)
			{
				OnLevelInitialized();
			}
		}

		private void OnDestroy()
		{
			UnregisterEvents();
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void OnLevelInitialized()
		{
			UnregisterEvents();
			buffManager = LevelManager.Instance.MainCharacter.GetBuffManager();
			foreach (Buff buff in buffManager.Buffs)
			{
				OnAddBuff(buffManager, buff);
			}
			RegisterEvents();
		}

		private void RegisterEvents()
		{
			if (!(buffManager == null))
			{
				buffManager.onAddBuff += OnAddBuff;
				buffManager.onRemoveBuff += OnRemoveBuff;
			}
		}

		private void UnregisterEvents()
		{
			if (!(buffManager == null))
			{
				buffManager.onAddBuff -= OnAddBuff;
				buffManager.onRemoveBuff -= OnRemoveBuff;
			}
		}

		private void OnAddBuff(CharacterBuffManager manager, Buff buff)
		{
			if (!buff.Hide)
			{
				EntryPool.Get().Setup(this, buff);
			}
		}

		private void OnRemoveBuff(CharacterBuffManager manager, Buff buff)
		{
			BuffsDisplayEntry buffsDisplayEntry = activeEntries.Find((BuffsDisplayEntry e) => e.Target == buff);
			if (!(buffsDisplayEntry == null))
			{
				buffsDisplayEntry.Release();
			}
		}
	}
	public class BuffsDisplayEntry : MonoBehaviour, Duckov.Utilities.IPoolable, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TextMeshProUGUI remainingTimeText;

		[SerializeField]
		private TextMeshProUGUI layersText;

		[SerializeField]
		private TextMeshProUGUI displayName;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private PunchReceiver punchReceiver;

		[SerializeField]
		private string timeFormat = "{0:0}s";

		private BuffsDisplay master;

		private Buff target;

		private bool releasing;

		private bool pooled;

		public UnityEngine.UI.Image Icon => icon;

		public Buff Target => target;

		public static event Action<BuffsDisplayEntry, PointerEventData> OnBuffsDisplayEntryClicked;

		public void Setup(BuffsDisplay master, Buff target)
		{
			this.master = master;
			this.target = target;
			icon.sprite = target.Icon;
			if ((bool)displayName)
			{
				displayName.text = target.DisplayName;
			}
			fadeGroup.Show();
		}

		private void Update()
		{
			Refresh();
		}

		private void Refresh()
		{
			if (target == null)
			{
				Release();
				return;
			}
			if (target.LimitedLifeTime)
			{
				remainingTimeText.text = string.Format(timeFormat, target.RemainingTime);
			}
			else
			{
				remainingTimeText.text = "";
			}
			if (target.MaxLayers > 1)
			{
				layersText.text = target.CurrentLayers.ToString();
			}
			else
			{
				layersText.text = "";
			}
		}

		public void Release()
		{
			if (!releasing)
			{
				releasing = true;
				ReleaseTask().Forget();
			}
		}

		private async UniTask ReleaseTask()
		{
			await fadeGroup.HideAndReturnTask();
			if (pooled)
			{
				master.ReleaseEntry(this);
			}
		}

		public void NotifyPooled()
		{
			pooled = true;
			releasing = false;
		}

		public void NotifyReleased()
		{
			pooled = false;
			target = null;
			releasing = false;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			punchReceiver?.Punch();
			BuffsDisplayEntry.OnBuffsDisplayEntryClicked?.Invoke(this, eventData);
		}
	}
	public class NotificationText : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private float duration = 1.2f;

		[SerializeField]
		private float durationIfPending = 0.65f;

		private static Queue<string> pendingTexts = new Queue<string>();

		private bool showing;

		private int PendingCount => pendingTexts.Count;

		public static void Push(string text)
		{
			if (pendingTexts.Count <= 0 || !(pendingTexts.Peek() == text))
			{
				pendingTexts.Enqueue(text);
			}
		}

		private static string Pop()
		{
			return pendingTexts.Dequeue();
		}

		private void Update()
		{
			if (!showing && PendingCount > 0)
			{
				ShowNext().Forget();
			}
		}

		private async UniTask ShowNext()
		{
			if (PendingCount != 0)
			{
				showing = true;
				string text = Pop();
				this.text.text = text;
				fadeGroup.Show();
				await UniTask.WaitForSeconds((PendingCount > 0) ? durationIfPending : duration, ignoreTimeScale: true);
				await fadeGroup.HideAndReturnTask();
				showing = false;
			}
		}
	}
	public class BlackScreen : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private MaterialPropertyFade fadeElement;

		[SerializeField]
		private UnityEngine.UI.Image fadeImage;

		[SerializeField]
		private float defaultDuration = 0.5f;

		[SerializeField]
		private AnimationCurve defaultShowCurve;

		[SerializeField]
		private AnimationCurve defaultHideCurve;

		private int taskCounter;

		public static BlackScreen Instance => GameManager.BlackScreen;

		private void Awake()
		{
			if (Instance != this)
			{
				UnityEngine.Debug.LogError("检测到应当删除的BlackScreen实例", base.gameObject);
			}
		}

		private void SetFadeCurve(AnimationCurve curve)
		{
			fadeElement.ShowCurve = curve;
			fadeElement.HideCurve = curve;
		}

		private void SetCircleFade(float circleFade)
		{
			fadeImage.material.SetFloat("_CircleFade", circleFade);
		}

		private UniTask LShowAndReturnTask(AnimationCurve animationCurve = null, float circleFade = 0f, float duration = -1f)
		{
			taskCounter++;
			if (taskCounter > 1)
			{
				return UniTask.CompletedTask;
			}
			fadeElement.Duration = ((duration > 0f) ? duration : defaultDuration);
			if (animationCurve == null)
			{
				SetFadeCurve(defaultShowCurve);
			}
			else
			{
				SetFadeCurve(animationCurve);
			}
			SetCircleFade(circleFade);
			return fadeGroup.ShowAndReturnTask();
		}

		private UniTask LHideAndReturnTask(AnimationCurve animationCurve = null, float circleFade = 0f, float duration = -1f)
		{
			if (--taskCounter > 0)
			{
				return UniTask.CompletedTask;
			}
			fadeElement.Duration = ((duration > 0f) ? duration : defaultDuration);
			if (animationCurve == null)
			{
				SetFadeCurve(defaultHideCurve);
			}
			else
			{
				SetFadeCurve(animationCurve);
			}
			SetCircleFade(circleFade);
			return fadeGroup.HideAndReturnTask();
		}

		public static UniTask ShowAndReturnTask(AnimationCurve animationCurve = null, float circleFade = 0f, float duration = 0.5f)
		{
			if (Instance == null)
			{
				return UniTask.CompletedTask;
			}
			return Instance.LShowAndReturnTask(animationCurve, circleFade, duration);
		}

		public static UniTask HideAndReturnTask(AnimationCurve animationCurve = null, float circleFade = 0f, float duration = 0.5f)
		{
			if (Instance == null)
			{
				return UniTask.CompletedTask;
			}
			return Instance.LHideAndReturnTask(animationCurve, circleFade, duration);
		}
	}
	public class ItemHoveringUI : MonoBehaviour
	{
		[SerializeField]
		private RectTransform rectTransform;

		[SerializeField]
		private RectTransform layoutParent;

		[SerializeField]
		private RectTransform contents;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private TextMeshProUGUI itemName;

		[SerializeField]
		private TextMeshProUGUI weightDisplay;

		[SerializeField]
		private TextMeshProUGUI itemDescription;

		[SerializeField]
		private TextMeshProUGUI itemID;

		[SerializeField]
		private ItemPropertiesDisplay itemProperties;

		[SerializeField]
		private BulletTypeDisplay bulletTypeDisplay;

		[SerializeField]
		private UsageUtilitiesDisplay usageUtilitiesDisplay;

		[SerializeField]
		private GameObject interactionIndicatorsContainer;

		[SerializeField]
		private GameObject interactionIndicator_Move;

		[SerializeField]
		private GameObject interactionIndicator_Menu;

		[SerializeField]
		private GameObject interactionIndicator_Drop;

		[SerializeField]
		private GameObject interactionIndicator_Use;

		[SerializeField]
		private GameObject interactionIndicator_Split;

		[SerializeField]
		private GameObject interactionIndicator_LockSort;

		[SerializeField]
		private GameObject interactionIndicator_Shortcut;

		[SerializeField]
		private GameObject wishlistInfoParent;

		[SerializeField]
		private GameObject wishlistIndicator;

		[SerializeField]
		private GameObject buildingIndicator;

		[SerializeField]
		private GameObject questIndicator;

		[SerializeField]
		private GameObject registeredIndicator;

		private MonoBehaviour target;

		public static ItemHoveringUI Instance { get; private set; }

		public RectTransform LayoutParent => layoutParent;

		public static int DisplayingItemID { get; private set; }

		public static bool Shown
		{
			get
			{
				if (Instance == null)
				{
					return false;
				}
				return Instance.fadeGroup.IsShown;
			}
		}

		public static event Action<ItemHoveringUI, ItemMetaData> onSetupMeta;

		public static event Action<ItemHoveringUI, Item> onSetupItem;

		private void Awake()
		{
			Instance = this;
			if (rectTransform == null)
			{
				rectTransform = GetComponent<RectTransform>();
			}
			ItemDisplay.OnPointerEnterItemDisplay += OnPointerEnterItemDisplay;
			ItemDisplay.OnPointerExitItemDisplay += OnPointerExitItemDisplay;
			ItemAmountDisplay.OnMouseEnter += OnMouseEnterItemAmountDisplay;
			ItemAmountDisplay.OnMouseExit += OnMouseExitItemAmountDisplay;
			ItemMetaDisplay.OnMouseEnter += OnMouseEnterMetaDisplay;
			ItemMetaDisplay.OnMouseExit += OnMouseExitMetaDisplay;
		}

		private void OnDestroy()
		{
			ItemDisplay.OnPointerEnterItemDisplay -= OnPointerEnterItemDisplay;
			ItemDisplay.OnPointerExitItemDisplay -= OnPointerExitItemDisplay;
			ItemAmountDisplay.OnMouseEnter -= OnMouseEnterItemAmountDisplay;
			ItemAmountDisplay.OnMouseExit -= OnMouseExitItemAmountDisplay;
			ItemMetaDisplay.OnMouseEnter -= OnMouseEnterMetaDisplay;
			ItemMetaDisplay.OnMouseExit -= OnMouseExitMetaDisplay;
		}

		private void OnMouseExitMetaDisplay(ItemMetaDisplay display)
		{
			if (target == display)
			{
				Hide();
			}
		}

		private void OnMouseEnterMetaDisplay(ItemMetaDisplay display)
		{
			SetupAndShowMeta(display);
		}

		private void OnMouseExitItemAmountDisplay(ItemAmountDisplay display)
		{
			if (target == display)
			{
				Hide();
			}
		}

		private void OnMouseEnterItemAmountDisplay(ItemAmountDisplay display)
		{
			SetupAndShowMeta(display);
		}

		private void OnPointerExitItemDisplay(ItemDisplay display)
		{
			if (target == display)
			{
				Hide();
			}
		}

		private void OnPointerEnterItemDisplay(ItemDisplay display)
		{
			SetupAndShow(display);
		}

		private void SetupAndShow(ItemDisplay display)
		{
			if (display == null)
			{
				return;
			}
			Item item = display.Target;
			if (!(item == null) && !item.NeedInspection)
			{
				registeredIndicator.SetActive(value: false);
				target = display;
				itemName.text = item.DisplayName ?? "";
				itemDescription.text = item.Description ?? "";
				weightDisplay.gameObject.SetActive(value: true);
				weightDisplay.text = $"{item.TotalWeight:0.#} kg";
				itemID.text = $"#{item.TypeID}";
				DisplayingItemID = item.TypeID;
				itemProperties.gameObject.SetActive(value: true);
				itemProperties.Setup(item);
				interactionIndicatorsContainer.SetActive(value: true);
				interactionIndicator_Menu.SetActive(display.ShowOperationButtons);
				interactionIndicator_Move.SetActive(display.Movable);
				interactionIndicator_Drop.SetActive(display.CanDrop);
				interactionIndicator_Use.SetActive(display.CanUse);
				interactionIndicator_Split.SetActive(display.CanSplit);
				interactionIndicator_LockSort.SetActive(display.CanLockSort);
				interactionIndicator_Shortcut.SetActive(display.CanSetShortcut);
				usageUtilitiesDisplay.Setup(item);
				SetupWishlistInfos(item.TypeID);
				SetupBulletDisplay();
				try
				{
					ItemHoveringUI.onSetupItem?.Invoke(this, item);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				RefreshPosition();
				SetupRegisteredInfo(item);
				fadeGroup.Show();
			}
		}

		private void SetupRegisteredInfo(Item item)
		{
			if (!(item == null) && item.IsRegistered())
			{
				registeredIndicator.SetActive(value: true);
			}
		}

		private void SetupAndShowMeta<T>(T dataProvider) where T : MonoBehaviour, IItemMetaDataProvider
		{
			if (!(dataProvider == null))
			{
				registeredIndicator.SetActive(value: false);
				target = dataProvider;
				ItemMetaData metaData = dataProvider.GetMetaData();
				itemName.text = metaData.DisplayName;
				itemID.text = $"{metaData.id}";
				DisplayingItemID = metaData.id;
				itemDescription.text = metaData.Description;
				interactionIndicatorsContainer.SetActive(value: true);
				weightDisplay.gameObject.SetActive(value: false);
				bulletTypeDisplay.gameObject.SetActive(value: false);
				itemProperties.gameObject.SetActive(value: false);
				interactionIndicator_Menu.gameObject.SetActive(value: false);
				interactionIndicator_Move.gameObject.SetActive(value: false);
				interactionIndicator_Drop.gameObject.SetActive(value: false);
				interactionIndicator_Use.gameObject.SetActive(value: false);
				usageUtilitiesDisplay.gameObject.SetActive(value: false);
				interactionIndicator_Split.SetActive(value: false);
				interactionIndicator_Shortcut.SetActive(value: false);
				SetupWishlistInfos(metaData.id);
				try
				{
					ItemHoveringUI.onSetupMeta?.Invoke(this, metaData);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
				}
				RefreshPosition();
				fadeGroup.Show();
			}
		}

		private void SetupBulletDisplay()
		{
			ItemDisplay itemDisplay = target as ItemDisplay;
			if (!(itemDisplay == null))
			{
				ItemSetting_Gun component = itemDisplay.Target.GetComponent<ItemSetting_Gun>();
				if (component == null)
				{
					bulletTypeDisplay.gameObject.SetActive(value: false);
					return;
				}
				bulletTypeDisplay.gameObject.SetActive(value: true);
				bulletTypeDisplay.Setup(component.TargetBulletID);
			}
		}

		private void RefreshPosition()
		{
			Vector2 value = Mouse.current.position.value;
			RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, value, null, out var localPoint);
			float xMax = contents.rect.xMax;
			float yMin = contents.rect.yMin;
			float b = rectTransform.rect.xMax - xMax;
			float b2 = rectTransform.rect.yMin - yMin;
			localPoint.x = Mathf.Min(localPoint.x, b);
			localPoint.y = Mathf.Max(localPoint.y, b2);
			contents.anchoredPosition = localPoint;
		}

		private void Hide()
		{
			fadeGroup.Hide();
			DisplayingItemID = -1;
		}

		private void Update()
		{
			if (fadeGroup.IsShown)
			{
				if (target == null || !target.isActiveAndEnabled)
				{
					Hide();
				}
				if (target is ItemDisplay itemDisplay && itemDisplay.Target == null)
				{
					Hide();
				}
			}
			RefreshPosition();
		}

		private void SetupWishlistInfos(int itemTypeID)
		{
			ItemWishlist.WishlistInfo wishlistInfo = ItemWishlist.GetWishlistInfo(itemTypeID);
			bool isManuallyWishlisted = wishlistInfo.isManuallyWishlisted;
			bool isBuildingRequired = wishlistInfo.isBuildingRequired;
			bool isQuestRequired = wishlistInfo.isQuestRequired;
			bool active = isManuallyWishlisted || isBuildingRequired || isQuestRequired;
			wishlistIndicator.SetActive(isManuallyWishlisted);
			buildingIndicator.SetActive(isBuildingRequired);
			questIndicator.SetActive(isQuestRequired);
			wishlistInfoParent.SetActive(active);
		}

		internal static void NotifyRefreshWishlistInfo()
		{
			if (!(Instance == null))
			{
				Instance.SetupWishlistInfos(DisplayingItemID);
			}
		}
	}
	public class ItemPicker : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private ItemPickerEntry entryPrefab;

		[SerializeField]
		private Transform contentParent;

		[SerializeField]
		private UnityEngine.UI.Button confirmButton;

		[SerializeField]
		private UnityEngine.UI.Button cancelButton;

		private PrefabPool<ItemPickerEntry> _entryPool;

		private bool picking;

		private bool canceled;

		private bool confirmed;

		private Item pickedItem;

		public static ItemPicker Instance { get; private set; }

		private PrefabPool<ItemPickerEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<ItemPickerEntry>(entryPrefab, contentParent ? contentParent : base.transform, OnGetEntry);
				}
				return _entryPool;
			}
		}

		public bool Picking => picking;

		private void OnGetEntry(ItemPickerEntry entry)
		{
		}

		private async UniTask<Item> WaitForUserPick(ICollection<Item> candidates)
		{
			if (picking)
			{
				UnityEngine.Debug.LogError("选择UI已被占用");
				return null;
			}
			picking = true;
			confirmed = false;
			canceled = false;
			pickedItem = null;
			base.gameObject.SetActive(value: true);
			fadeGroup.gameObject.SetActive(value: true);
			SetupUI(candidates);
			RectTransform obj = base.transform as RectTransform;
			obj.ForceUpdateRectTransforms();
			LayoutRebuilder.ForceRebuildLayoutImmediate(obj);
			await UniTask.NextFrame();
			fadeGroup.Show();
			do
			{
				await UniTask.NextFrame();
			}
			while (!confirmed && !canceled);
			picking = false;
			fadeGroup.Hide();
			if (confirmed)
			{
				if (!candidates.Contains(pickedItem))
				{
					UnityEngine.Debug.LogError("选出了意料之外的物品。");
				}
				return pickedItem;
			}
			_ = canceled;
			return null;
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			else
			{
				UnityEngine.Debug.LogError("场景中存在两个ItemPicker，请检查。");
			}
			confirmButton.onClick.AddListener(OnConfirmButtonClicked);
			cancelButton.onClick.AddListener(OnCancelButtonClicked);
		}

		private void OnCancelButtonClicked()
		{
			Cancel();
		}

		private void OnConfirmButtonClicked()
		{
			ConfirmPick(pickedItem);
		}

		private void OnDestroy()
		{
		}

		private void Update()
		{
			if (!picking && fadeGroup.IsShown)
			{
				fadeGroup.Hide();
			}
		}

		public static async UniTask<Item> Pick(ICollection<Item> candidates)
		{
			if (Instance == null)
			{
				return null;
			}
			return await Instance.WaitForUserPick(candidates);
		}

		public void ConfirmPick(Item item)
		{
			confirmed = true;
			pickedItem = item;
		}

		public void Cancel()
		{
			canceled = true;
		}

		private void SetupUI(ICollection<Item> candidates)
		{
			EntryPool.ReleaseAll();
			foreach (Item candidate in candidates)
			{
				if (!(candidate == null))
				{
					ItemPickerEntry itemPickerEntry = EntryPool.Get();
					itemPickerEntry.Setup(this, candidate);
					itemPickerEntry.transform.SetAsLastSibling();
				}
			}
		}

		internal void NotifyEntryClicked(ItemPickerEntry itemPickerEntry, Item target)
		{
			pickedItem = target;
		}
	}
	public class ItemPickerEntry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		[SerializeField]
		private ItemDisplay itemDisplay;

		private ItemPicker master;

		private Item target;

		private void Awake()
		{
			itemDisplay.onPointerClick += OnItemDisplayClicked;
		}

		private void OnDestroy()
		{
			itemDisplay.onPointerClick -= OnItemDisplayClicked;
		}

		private void OnItemDisplayClicked(ItemDisplay display, PointerEventData eventData)
		{
			master.NotifyEntryClicked(this, target);
		}

		public void Setup(ItemPicker master, Item item)
		{
			this.master = master;
			target = item;
			if (target != null)
			{
				itemDisplay.Setup(target);
			}
			else
			{
				UnityEngine.Debug.LogError("Item Picker不应当展示空的Item。");
			}
			itemDisplay.ShowOperationButtons = false;
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
		}
	}
	public class MoneyDisplay : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private string format = "n0";

		private void Awake()
		{
			EconomyManager.OnMoneyChanged += OnMoneyChanged;
			SavesSystem.OnSetFile += OnSaveFileChanged;
			Refresh();
		}

		private void OnDestroy()
		{
			EconomyManager.OnMoneyChanged -= OnMoneyChanged;
			SavesSystem.OnSetFile -= OnSaveFileChanged;
		}

		private void OnEnable()
		{
			Refresh();
		}

		private void Refresh()
		{
			text.text = EconomyManager.Money.ToString(format);
		}

		private void OnMoneyChanged(long arg1, long arg2)
		{
			Refresh();
		}

		private void OnSaveFileChanged()
		{
			Refresh();
		}
	}
	public interface ITooltipsProvider
	{
		string GetTooltipsText();
	}
	public class Tooltips : MonoBehaviour
	{
		[SerializeField]
		private RectTransform rectTransform;

		[SerializeField]
		private RectTransform contents;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private TextMeshProUGUI text;

		private static Action<ITooltipsProvider> OnEnterProvider;

		private static Action<ITooltipsProvider> OnExitProvider;

		public static ITooltipsProvider CurrentProvider { get; private set; }

		public static void NotifyEnterTooltipsProvider(ITooltipsProvider provider)
		{
			CurrentProvider = provider;
			OnEnterProvider?.Invoke(provider);
		}

		public static void NotifyExitTooltipsProvider(ITooltipsProvider provider)
		{
			if (CurrentProvider == provider)
			{
				CurrentProvider = null;
				OnExitProvider?.Invoke(provider);
			}
		}

		private void Awake()
		{
			if (rectTransform == null)
			{
				rectTransform = GetComponent<RectTransform>();
			}
			OnEnterProvider = (Action<ITooltipsProvider>)Delegate.Combine(OnEnterProvider, new Action<ITooltipsProvider>(DoOnEnterProvider));
			OnExitProvider = (Action<ITooltipsProvider>)Delegate.Combine(OnExitProvider, new Action<ITooltipsProvider>(DoOnExitProvider));
		}

		private void OnDestroy()
		{
			OnEnterProvider = (Action<ITooltipsProvider>)Delegate.Remove(OnEnterProvider, new Action<ITooltipsProvider>(DoOnEnterProvider));
			OnExitProvider = (Action<ITooltipsProvider>)Delegate.Remove(OnExitProvider, new Action<ITooltipsProvider>(DoOnExitProvider));
		}

		private void Update()
		{
			if (contents.gameObject.activeSelf)
			{
				RefreshPosition();
			}
		}

		private void DoOnExitProvider(ITooltipsProvider provider)
		{
			fadeGroup.Hide();
		}

		private void DoOnEnterProvider(ITooltipsProvider provider)
		{
			text.text = provider.GetTooltipsText();
			fadeGroup.Show();
		}

		private void RefreshPosition()
		{
			Vector2 value = Mouse.current.position.value;
			RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, value, null, out var localPoint);
			contents.localPosition = localPoint;
		}
	}
	public class TooltipsProvider : MonoBehaviour, ITooltipsProvider, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public string text;

		public string GetTooltipsText()
		{
			return text;
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (!string.IsNullOrEmpty(text))
			{
				Tooltips.NotifyEnterTooltipsProvider(this);
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			Tooltips.NotifyExitTooltipsProvider(this);
		}

		private void OnDisable()
		{
			Tooltips.NotifyExitTooltipsProvider(this);
		}
	}
	public class DebugKontextMenuInvoker : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private KontextMenu kontextMenu;

		public void OnPointerClick(PointerEventData eventData)
		{
			Show(eventData.position);
		}

		public void Show(Vector2 point)
		{
			kontextMenu.InstanceShow(this, point, new KontextMenuDataEntry
			{
				text = "你好",
				action = delegate
				{
					UnityEngine.Debug.Log("好");
				}
			}, new KontextMenuDataEntry
			{
				text = "你好2",
				action = delegate
				{
					UnityEngine.Debug.Log("好好");
				}
			}, new KontextMenuDataEntry
			{
				text = "你好3",
				action = delegate
				{
					UnityEngine.Debug.Log("好好好");
				}
			}, new KontextMenuDataEntry
			{
				text = "你好4",
				action = delegate
				{
					UnityEngine.Debug.Log("好好好好");
				}
			}, new KontextMenuDataEntry
			{
				text = "你好5",
				action = delegate
				{
					UnityEngine.Debug.Log("好好好好好");
				}
			});
		}
	}
	public class FormulasIndexEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private TextMeshProUGUI displayNameText;

		[SerializeField]
		private UnityEngine.UI.Image image;

		[SerializeField]
		private string lockedText = "???";

		[SerializeField]
		private Sprite lockedImage;

		private FormulasIndexView master;

		private CraftingFormula formula;

		public CraftingFormula Formula => formula;

		private int ItemID => formula.result.id;

		private ItemMetaData Meta => ItemAssetsCollection.GetMetaData(ItemID);

		private bool Unlocked => CraftingManager.IsFormulaUnlocked(formula.id);

		public bool Valid => ItemID >= 0;

		public void OnPointerClick(PointerEventData eventData)
		{
			master.OnEntryClicked(this);
		}

		internal void Setup(FormulasIndexView master, CraftingFormula formula)
		{
			this.master = master;
			this.formula = formula;
			Refresh();
		}

		public void Refresh()
		{
			ItemMetaData meta = Meta;
			if (!Valid)
			{
				displayNameText.text = "! " + formula.id + " !";
				image.sprite = lockedImage;
			}
			else if (Unlocked)
			{
				displayNameText.text = $"{meta.DisplayName} x{formula.result.amount}";
				image.sprite = meta.icon;
			}
			else
			{
				displayNameText.text = lockedText;
				image.sprite = lockedImage;
			}
		}
	}
	public class FormulasIndexView : View, ISingleSelectionMenu<FormulasIndexEntry>
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private FormulasIndexEntry entryTemplate;

		[SerializeField]
		private FormulasDetailsDisplay detailsDisplay;

		private PrefabPool<FormulasIndexEntry> _pool;

		private FormulasIndexEntry selectedEntry;

		private PrefabPool<FormulasIndexEntry> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<FormulasIndexEntry>(entryTemplate);
				}
				return _pool;
			}
		}

		public static FormulasIndexView Instance => View.GetViewInstance<FormulasIndexView>();

		public FormulasIndexEntry GetSelection()
		{
			return selectedEntry;
		}

		protected override void Awake()
		{
			base.Awake();
		}

		public static void Show()
		{
			if (!(Instance == null))
			{
				Instance.Open();
			}
		}

		public bool SetSelection(FormulasIndexEntry selection)
		{
			selectedEntry = selection;
			return true;
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			selectedEntry = null;
			Pool.ReleaseAll();
			foreach (CraftingFormula entry in CraftingFormulaCollection.Instance.Entries)
			{
				if (!entry.hideInIndex && (!GameMetaData.Instance.IsDemo || !entry.lockInDemo))
				{
					Pool.Get().Setup(this, entry);
				}
			}
			RefreshDetails();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		internal void OnEntryClicked(FormulasIndexEntry entry)
		{
			FormulasIndexEntry formulasIndexEntry = selectedEntry;
			selectedEntry = entry;
			selectedEntry.Refresh();
			if ((bool)formulasIndexEntry)
			{
				formulasIndexEntry.Refresh();
			}
			RefreshDetails();
		}

		private void RefreshDetails()
		{
			if ((bool)selectedEntry && selectedEntry.Valid)
			{
				detailsDisplay.Setup(selectedEntry.Formula);
			}
			else
			{
				detailsDisplay.Setup(null);
			}
		}
	}
	public class FormulasRegisterView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private InventoryDisplay inventoryDisplay;

		[SerializeField]
		private InventoryDisplay playerStorageInventoryDisplay;

		[SerializeField]
		private ItemDetailsDisplay detailsDisplay;

		[SerializeField]
		private FadeGroup detailsFadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button submitButton;

		[SerializeField]
		private Tag formulaTag;

		[SerializeField]
		private Item keySlotItem;

		[SerializeField]
		private string slotKey = "SubmitItem";

		[SerializeField]
		private SlotDisplay registerSlotDisplay;

		[SerializeField]
		private GameObject recordExistsIndicator;

		[SerializeField]
		private FadeGroup succeedIndicator;

		[SerializeField]
		private float successIndicationTime = 1.5f;

		private string sfx_Register = "UI/register";

		[LocalizationKey("Default")]
		[SerializeField]
		private string formulaUnlockedFormatKey = "UI_Formulas_RegisterSucceedFormat";

		public static FormulasRegisterView Instance => View.GetViewInstance<FormulasRegisterView>();

		private string FormulaUnlockedNotificationFormat => formulaUnlockedFormatKey.ToPlainText();

		private Item CharacterItem => LevelManager.Instance?.MainCharacter?.CharacterItem;

		private Slot SubmitItemSlot
		{
			get
			{
				if (keySlotItem == null)
				{
					return null;
				}
				if (keySlotItem.Slots == null)
				{
					return null;
				}
				return keySlotItem.Slots[slotKey];
			}
		}

		protected override void Awake()
		{
			base.Awake();
			submitButton.onClick.AddListener(OnSubmitButtonClicked);
			succeedIndicator.SkipHide();
			detailsFadeGroup.SkipHide();
			registerSlotDisplay.onSlotDisplayDoubleClicked += OnSlotDoubleClicked;
			inventoryDisplay.onDisplayDoubleClicked += OnInventoryItemDoubleClicked;
			playerStorageInventoryDisplay.onDisplayDoubleClicked += OnInventoryItemDoubleClicked;
		}

		private void OnInventoryItemDoubleClicked(InventoryDisplay display, InventoryEntry entry, PointerEventData data)
		{
			if (!entry.Editable)
			{
				return;
			}
			Item item = entry.Item;
			if (!(item == null) && SubmitItemSlot.CanPlug(item))
			{
				item.Detach();
				SubmitItemSlot.Plug(item, out var unpluggedItem);
				if (unpluggedItem != null)
				{
					ItemUtilities.SendToPlayer(unpluggedItem);
				}
			}
		}

		private void OnSlotDoubleClicked(SlotDisplay display)
		{
			Item item = display.GetItem();
			if (!(item == null))
			{
				item.Detach();
				ItemUtilities.SendToPlayer(item);
			}
		}

		private void OnSubmitButtonClicked()
		{
			if (SubmitItemSlot == null || !(SubmitItemSlot.Content != null))
			{
				return;
			}
			Item content = SubmitItemSlot.Content;
			string formulaID = GetFormulaID(content);
			if (!string.IsNullOrEmpty(formulaID) && !CraftingManager.IsFormulaUnlocked(formulaID))
			{
				CraftingManager.UnlockFormula(formulaID);
				CraftingFormula formula = CraftingManager.GetFormula(formulaID);
				if (formula.IDValid)
				{
					ItemMetaData metaData = ItemAssetsCollection.GetMetaData(formula.result.id);
					string mainText = FormulaUnlockedNotificationFormat.Format(new
					{
						itemDisplayName = metaData.DisplayName
					});
					Sprite icon = metaData.icon;
					StrongNotification.Push(new StrongNotificationContent(mainText, "", icon));
				}
				content.Detach();
				content.DestroyTreeImmediate();
				IndicateSuccess();
			}
		}

		private void IndicateSuccess()
		{
			SuccessIndicationTask().Forget();
		}

		private async UniTask SuccessIndicationTask()
		{
			succeedIndicator.Show();
			AudioManager.Post(sfx_Register);
			await UniTask.WaitForSeconds(successIndicationTime, ignoreTimeScale: true);
			succeedIndicator.Hide();
		}

		private void HideSuccessIndication()
		{
			succeedIndicator.Hide();
		}

		private bool EntryFunc_ShouldHighligh(Item e)
		{
			if (e == null)
			{
				return false;
			}
			if (!SubmitItemSlot.CanPlug(e))
			{
				return false;
			}
			if (CraftingManager.IsFormulaUnlocked(GetFormulaID(e)))
			{
				return false;
			}
			return true;
		}

		private bool EntryFunc_CanOperate(Item e)
		{
			if (e == null)
			{
				return true;
			}
			return SubmitItemSlot.CanPlug(e);
		}

		protected override void OnOpen()
		{
			UnregisterEvents();
			base.OnOpen();
			Item characterItem = CharacterItem;
			if (characterItem == null)
			{
				UnityEngine.Debug.LogError("物品栏开启失败，角色物体不存在");
				Close();
				return;
			}
			base.gameObject.SetActive(value: true);
			inventoryDisplay.ShowOperationButtons = false;
			inventoryDisplay.Setup(characterItem.Inventory, EntryFunc_ShouldHighligh, EntryFunc_CanOperate, movable: true);
			if (PlayerStorage.Inventory != null)
			{
				playerStorageInventoryDisplay.ShowOperationButtons = false;
				playerStorageInventoryDisplay.gameObject.SetActive(value: true);
				playerStorageInventoryDisplay.Setup(PlayerStorage.Inventory, EntryFunc_ShouldHighligh, EntryFunc_CanOperate, movable: true);
			}
			else
			{
				playerStorageInventoryDisplay.gameObject.SetActive(value: false);
			}
			registerSlotDisplay.Setup(SubmitItemSlot);
			RefreshRecordExistsIndicator();
			RegisterEvents();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			UnregisterEvents();
			base.OnClose();
			fadeGroup.Hide();
			detailsFadeGroup.Hide();
			if (SubmitItemSlot != null && SubmitItemSlot.Content != null)
			{
				Item content = SubmitItemSlot.Content;
				content.Detach();
				ItemUtilities.SendToPlayerCharacterInventory(content);
			}
		}

		private void RegisterEvents()
		{
			SubmitItemSlot.onSlotContentChanged += OnSlotContentChanged;
			ItemUIUtilities.OnSelectionChanged += OnItemSelectionChanged;
		}

		private void UnregisterEvents()
		{
			SubmitItemSlot.onSlotContentChanged -= OnSlotContentChanged;
			ItemUIUtilities.OnSelectionChanged -= OnItemSelectionChanged;
		}

		private void OnSlotContentChanged(Slot slot)
		{
			RefreshRecordExistsIndicator();
			HideSuccessIndication();
			if (slot?.Content != null)
			{
				AudioManager.PlayPutItemSFX(slot.Content);
			}
		}

		private void RefreshRecordExistsIndicator()
		{
			Item content = SubmitItemSlot.Content;
			if (content == null)
			{
				recordExistsIndicator.SetActive(value: false);
				return;
			}
			bool active = CraftingManager.IsFormulaUnlocked(GetFormulaID(content));
			recordExistsIndicator.SetActive(active);
		}

		private bool IsFormulaItem(Item item)
		{
			if (item == null)
			{
				return false;
			}
			return item.GetComponent<ItemSetting_Formula>() != null;
		}

		public static string GetFormulaID(Item item)
		{
			if (item == null)
			{
				return null;
			}
			ItemSetting_Formula component = item.GetComponent<ItemSetting_Formula>();
			if (component == null)
			{
				return null;
			}
			return component.formulaID;
		}

		private void OnItemSelectionChanged()
		{
			if (ItemUIUtilities.SelectedItem != null)
			{
				detailsDisplay.Setup(ItemUIUtilities.SelectedItem);
				detailsFadeGroup.Show();
			}
			else
			{
				detailsFadeGroup.Hide();
			}
		}

		public static void Show(ICollection<Tag> requireTags = null)
		{
			if (!(Instance == null))
			{
				SetupTags(requireTags);
				Instance.Open();
			}
		}

		private static void SetupTags(ICollection<Tag> requireTags = null)
		{
			if (Instance == null)
			{
				return;
			}
			Slot submitItemSlot = Instance.SubmitItemSlot;
			if (submitItemSlot != null)
			{
				submitItemSlot.requireTags.Clear();
				submitItemSlot.requireTags.Add(Instance.formulaTag);
				if (requireTags != null)
				{
					submitItemSlot.requireTags.AddRange(requireTags);
				}
			}
		}
	}
	public class SleepView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private UnityEngine.UI.Slider slider;

		[SerializeField]
		private TextMeshProUGUI willWakeUpAtText;

		[SerializeField]
		private TextMeshProUGUI sleepTimeSpanText;

		[SerializeField]
		private GameObject nextDayIndicator;

		[SerializeField]
		private UnityEngine.UI.Button confirmButton;

		private int sleepForMinuts;

		public static Action OnAfterSleep;

		private bool sleeping;

		public static SleepView Instance => View.GetViewInstance<SleepView>();

		private TimeSpan SleepTimeSpan => TimeSpan.FromMinutes(sleepForMinuts);

		private TimeSpan WillWakeUpAt => GameClock.TimeOfDay + SleepTimeSpan;

		private bool WillWakeUpNextDay => WillWakeUpAt.Days > 0;

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		protected override void Awake()
		{
			base.Awake();
			slider.onValueChanged.AddListener(OnSliderValueChanged);
			confirmButton.onClick.AddListener(OnConfirmButtonClicked);
		}

		private void OnConfirmButtonClicked()
		{
			Sleep(sleepForMinuts).Forget();
		}

		private async UniTask Sleep(float minuts)
		{
			if (!sleeping)
			{
				sleeping = true;
				float seconds = minuts * 60f;
				await BlackScreen.ShowAndReturnTask();
				GameClock.Step(seconds);
				await UniTask.WaitForSeconds(0.5f, ignoreTimeScale: true);
				OnAfterSleep?.Invoke();
				if (View.ActiveView == this)
				{
					Close();
				}
				await BlackScreen.HideAndReturnTask();
				sleeping = false;
			}
		}

		private void OnGameClockStep()
		{
			Refresh();
		}

		private void OnEnable()
		{
			InitializeUI();
			GameClock.OnGameClockStep += OnGameClockStep;
		}

		private void OnDisable()
		{
			GameClock.OnGameClockStep -= OnGameClockStep;
		}

		private void OnSliderValueChanged(float newValue)
		{
			sleepForMinuts = Mathf.RoundToInt(newValue);
			Refresh();
		}

		private void InitializeUI()
		{
			slider.SetValueWithoutNotify(sleepForMinuts);
		}

		private void Update()
		{
			Refresh();
		}

		private void Refresh()
		{
			TimeSpan willWakeUpAt = WillWakeUpAt;
			willWakeUpAtText.text = $"{willWakeUpAt.Hours:00}:{willWakeUpAt.Minutes:00}";
			TimeSpan sleepTimeSpan = SleepTimeSpan;
			sleepTimeSpanText.text = $"{(int)sleepTimeSpan.TotalHours:00} h {sleepTimeSpan.Minutes:00} min";
			nextDayIndicator.gameObject.SetActive(willWakeUpAt.Days > 0);
		}

		public static void Show()
		{
			if (!(Instance == null))
			{
				Instance.Open();
			}
		}
	}
	public class NoteIndexView : View
	{
		[SerializeField]
		private FadeGroup mainFadeGroup;

		[SerializeField]
		private GameObject noEntryIndicator;

		[SerializeField]
		private NoteIndexView_Entry entryTemplate;

		[SerializeField]
		private NoteIndexView_Inspector inspector;

		[SerializeField]
		private TextMeshProUGUI noteCountText;

		[SerializeField]
		private ScrollRect indexScrollView;

		private PrefabPool<NoteIndexView_Entry> _pool;

		private string displayingNote;

		private bool needFocus;

		private PrefabPool<NoteIndexView_Entry> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<NoteIndexView_Entry>(entryTemplate);
				}
				return _pool;
			}
		}

		private void OnEnable()
		{
			NoteIndex.onNoteStatusChanged = (Action<string>)Delegate.Combine(NoteIndex.onNoteStatusChanged, new Action<string>(OnNoteStatusChanged));
		}

		private void OnDisable()
		{
			NoteIndex.onNoteStatusChanged = (Action<string>)Delegate.Remove(NoteIndex.onNoteStatusChanged, new Action<string>(OnNoteStatusChanged));
		}

		private void Update()
		{
			if (needFocus)
			{
				needFocus = false;
				MoveScrollViewToActiveEntry();
			}
		}

		private void OnNoteStatusChanged(string noteKey)
		{
			RefreshEntries();
		}

		public void DoOpen()
		{
			Open();
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			mainFadeGroup.Show();
			RefreshEntries();
			SetDisplayTargetNote(displayingNote);
		}

		protected override void OnClose()
		{
			base.OnClose();
			mainFadeGroup.Hide();
		}

		protected override void OnCancel()
		{
			Close();
		}

		private void RefreshNoteCount()
		{
			int totalNoteCount = NoteIndex.GetTotalNoteCount();
			int unlockedNoteCount = NoteIndex.GetUnlockedNoteCount();
			noteCountText.text = $"{unlockedNoteCount} / {totalNoteCount}";
		}

		private void RefreshEntries()
		{
			RefreshNoteCount();
			Pool.ReleaseAll();
			if (NoteIndex.Instance == null)
			{
				return;
			}
			int num = 0;
			foreach (string allNote in NoteIndex.GetAllNotes(unlockedOnly: false))
			{
				Note note = NoteIndex.GetNote(allNote);
				if (note != null)
				{
					NoteIndexView_Entry noteIndexView_Entry = Pool.Get();
					num++;
					noteIndexView_Entry.Setup(note, OnEntryClicked, GetDisplayingNote, num);
				}
			}
			noEntryIndicator.SetActive(num <= 0);
		}

		private string GetDisplayingNote()
		{
			return displayingNote;
		}

		public void SetDisplayTargetNote(string noteKey)
		{
			Note note = null;
			if (!string.IsNullOrWhiteSpace(noteKey))
			{
				note = NoteIndex.GetNote(noteKey);
			}
			if (note == null)
			{
				displayingNote = null;
			}
			else
			{
				displayingNote = note.key;
			}
			foreach (NoteIndexView_Entry activeEntry in Pool.ActiveEntries)
			{
				activeEntry.NotifySelectedDisplayingNoteChanged(displayingNote);
			}
			inspector.Setup(note);
		}

		private void OnEntryClicked(NoteIndexView_Entry entry)
		{
			string key = entry.key;
			if (!NoteIndex.GetNoteUnlocked(key))
			{
				SetDisplayTargetNote("");
			}
			else
			{
				SetDisplayTargetNote(key);
			}
		}

		public static void ShowNote(string noteKey, bool unlock = true)
		{
			NoteIndexView viewInstance = View.GetViewInstance<NoteIndexView>();
			if (!(viewInstance == null))
			{
				if (unlock)
				{
					NoteIndex.SetNoteUnlocked(noteKey);
				}
				if (!(View.ActiveView is NoteIndexView))
				{
					viewInstance.Open();
				}
				viewInstance.SetDisplayTargetNote(noteKey);
				viewInstance.needFocus = true;
			}
		}

		private void MoveScrollViewToActiveEntry()
		{
			NoteIndexView_Entry displayingEntry = GetDisplayingEntry();
			if (!(displayingEntry == null))
			{
				RectTransform rectTransform = displayingEntry.transform as RectTransform;
				if (!(rectTransform == null))
				{
					float num = 0f - rectTransform.anchoredPosition.y;
					float height = indexScrollView.content.rect.height;
					float verticalNormalizedPosition = 1f - num / height;
					indexScrollView.verticalNormalizedPosition = verticalNormalizedPosition;
				}
			}
		}

		private NoteIndexView_Entry GetDisplayingEntry()
		{
			foreach (NoteIndexView_Entry activeEntry in Pool.ActiveEntries)
			{
				if (activeEntry.key == displayingNote)
				{
					return activeEntry;
				}
			}
			return null;
		}
	}
	public class NoteIndexView_Entry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private GameObject highlightIndicator;

		[SerializeField]
		private TextMeshProUGUI titleText;

		[SerializeField]
		private TextMeshProUGUI indexText;

		[SerializeField]
		private GameObject notReadIndicator;

		private Note note;

		private Action<NoteIndexView_Entry> onClicked;

		private Func<string> getDisplayingNote;

		public string key => note.key;

		private void OnEnable()
		{
			NoteIndex.onNoteStatusChanged = (Action<string>)Delegate.Combine(NoteIndex.onNoteStatusChanged, new Action<string>(OnNoteStatusChanged));
		}

		private void OnDisable()
		{
			NoteIndex.onNoteStatusChanged = (Action<string>)Delegate.Remove(NoteIndex.onNoteStatusChanged, new Action<string>(OnNoteStatusChanged));
		}

		private void OnNoteStatusChanged(string key)
		{
			if (!(key != note.key))
			{
				RefreshNotReadIndicator();
			}
		}

		private void RefreshNotReadIndicator()
		{
			notReadIndicator.SetActive(NoteIndex.GetNoteUnlocked(key) && !NoteIndex.GetNoteRead(key));
		}

		internal void NotifySelectedDisplayingNoteChanged(string displayingNote)
		{
			RefreshHighlight();
		}

		private void RefreshHighlight()
		{
			bool active = false;
			if (getDisplayingNote != null)
			{
				active = getDisplayingNote?.Invoke() == key;
			}
			highlightIndicator.SetActive(active);
		}

		internal void Setup(Note note, Action<NoteIndexView_Entry> onClicked, Func<string> getDisplayingNote, int index)
		{
			bool noteUnlocked = NoteIndex.GetNoteUnlocked(note.key);
			this.note = note;
			titleText.text = (noteUnlocked ? note.Title : "???");
			this.onClicked = onClicked;
			this.getDisplayingNote = getDisplayingNote;
			if (index > 0)
			{
				indexText.text = index.ToString("000");
			}
			RefreshNotReadIndicator();
			RefreshHighlight();
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			onClicked?.Invoke(this);
		}
	}
	public class NoteIndexView_Inspector : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup placeHolder;

		[SerializeField]
		private FadeGroup content;

		[SerializeField]
		private TextMeshProUGUI textTitle;

		[SerializeField]
		private TextMeshProUGUI textContent;

		[SerializeField]
		private UnityEngine.UI.Image image;

		private Note note;

		private void Awake()
		{
			placeHolder.Show();
			content.SkipHide();
		}

		internal void Setup(Note value)
		{
			if (value == null)
			{
				placeHolder.Show();
				content.Hide();
				return;
			}
			note = value;
			SetupContent(note);
			placeHolder.Hide();
			content.Show();
			NoteIndex.SetNoteRead(value.key);
		}

		private void SetupContent(Note value)
		{
			textTitle.text = value.Title;
			textContent.text = value.Content;
			image.sprite = value.image;
			image.gameObject.SetActive(value.image == null);
		}
	}
	public class SliderWithTextField : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI label;

		[SerializeField]
		private UnityEngine.UI.Slider slider;

		[SerializeField]
		private TMP_InputField valueField;

		[SerializeField]
		private string valueFormat = "0";

		[SerializeField]
		private bool isPercentage;

		[SerializeField]
		private string _labelKey = "?";

		[SerializeField]
		private float value;

		public Action<float> onValueChanged;

		[LocalizationKey("Default")]
		public string LabelKey
		{
			get
			{
				return _labelKey;
			}
			set
			{
			}
		}

		public float Value
		{
			get
			{
				return GetValue();
			}
			set
			{
				SetValue(value);
			}
		}

		public void SetValueWithoutNotify(float value)
		{
			this.value = value;
			RefreshValues();
		}

		public void SetValue(float value)
		{
			SetValueWithoutNotify(value);
			onValueChanged?.Invoke(value);
		}

		public float GetValue()
		{
			return value;
		}

		private void Awake()
		{
			slider.onValueChanged.AddListener(OnSliderValueChanged);
			valueField.onEndEdit.AddListener(OnFieldEndEdit);
			RefreshLable();
			LocalizationManager.OnSetLanguage += OnLanguageChanged;
		}

		private void OnDestroy()
		{
			LocalizationManager.OnSetLanguage -= OnLanguageChanged;
		}

		private void OnLanguageChanged(SystemLanguage language)
		{
			RefreshLable();
		}

		private void RefreshLable()
		{
			if ((bool)label)
			{
				label.text = LabelKey.ToPlainText();
			}
		}

		private void OnFieldEndEdit(string arg0)
		{
			if (float.TryParse(arg0, out var result))
			{
				if (isPercentage)
				{
					result /= 100f;
				}
				result = Mathf.Clamp(result, slider.minValue, slider.maxValue);
				Value = result;
			}
			RefreshValues();
		}

		private void OnEnable()
		{
			RefreshValues();
		}

		private void OnSliderValueChanged(float value)
		{
			Value = value;
			RefreshValues();
		}

		private void RefreshValues()
		{
			valueField.SetTextWithoutNotify(Value.ToString(valueFormat));
			slider.SetValueWithoutNotify(Value);
		}

		private void OnValidate()
		{
			RefreshLable();
		}
	}
	public class PunchReceiver : MonoBehaviour
	{
		[SerializeField]
		private RectTransform rectTransform;

		[SerializeField]
		private ParticleSystem particle;

		[Min(0.0001f)]
		[SerializeField]
		private float duration = 0.01f;

		public int vibrato = 10;

		public float elasticity = 1f;

		[SerializeField]
		private Vector2 punchAnchorPosition;

		[SerializeField]
		[Range(-1f, 1f)]
		private float punchScaleUniform;

		[SerializeField]
		[Range(-180f, 180f)]
		private float punchRotationZ;

		[SerializeField]
		private Vector2 randomAnchorPosition;

		[SerializeField]
		[Range(0f, 180f)]
		private float randomRotationZ;

		[SerializeField]
		private AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		[SerializeField]
		private bool cacheWhenPunched;

		[SerializeField]
		private string sfx;

		private Vector2 cachedAnchorPosition;

		private Vector2 cachedScale;

		private Vector2 cachedRotation;

		private float PunchAnchorPositionDuration => duration;

		private float PunchScaleDuration => duration;

		private float PunchRotationDuration => duration;

		private bool ShouldPunchPosition
		{
			get
			{
				if (randomAnchorPosition.magnitude > 0.001f)
				{
					return punchAnchorPosition.magnitude > 0.001f;
				}
				return false;
			}
		}

		private void Awake()
		{
			if (rectTransform == null)
			{
				rectTransform = GetComponent<RectTransform>();
			}
			CachePose();
		}

		private void Start()
		{
		}

		[ContextMenu("Punch")]
		public void Punch()
		{
			if (base.enabled && !(rectTransform == null))
			{
				if (particle != null)
				{
					particle.Play();
				}
				rectTransform.DOKill();
				if (cacheWhenPunched)
				{
					CachePose();
				}
				Vector2 punch = punchAnchorPosition + new Vector2(UnityEngine.Random.Range(0f - randomAnchorPosition.x, randomAnchorPosition.x), UnityEngine.Random.Range(0f - randomAnchorPosition.y, randomAnchorPosition.y));
				float num = punchScaleUniform;
				float num2 = punchRotationZ + UnityEngine.Random.Range(0f - randomRotationZ, randomRotationZ);
				if (ShouldPunchPosition)
				{
					rectTransform.DOPunchAnchorPos(punch, PunchAnchorPositionDuration, vibrato, elasticity).SetEase(animationCurve).OnKill(RestorePose);
				}
				rectTransform.DOPunchScale(Vector3.one * num, PunchScaleDuration, vibrato, elasticity).SetEase(animationCurve).OnKill(RestorePose);
				rectTransform.DOPunchRotation(Vector3.forward * num2, PunchRotationDuration, vibrato, elasticity).SetEase(animationCurve).OnKill(RestorePose);
				if (!string.IsNullOrWhiteSpace(sfx))
				{
					AudioManager.Post(sfx);
				}
			}
		}

		private void CachePose()
		{
			if (!(rectTransform == null))
			{
				cachedAnchorPosition = rectTransform.anchoredPosition;
				cachedScale = rectTransform.localScale;
				cachedRotation = rectTransform.localRotation.eulerAngles;
			}
		}

		private void RestorePose()
		{
			if (!(rectTransform == null))
			{
				if (ShouldPunchPosition)
				{
					rectTransform.anchoredPosition = cachedAnchorPosition;
				}
				rectTransform.localScale = cachedScale;
				rectTransform.localRotation = Quaternion.Euler(cachedRotation);
			}
		}

		private void OnDestroy()
		{
			rectTransform?.DOKill();
		}
	}
	public class BarDisplay : MonoBehaviour
	{
		[SerializeField]
		private string labelText;

		[SerializeField]
		private Color color = Color.red;

		[SerializeField]
		private float animateDuration = 0.25f;

		[SerializeField]
		private TextMeshProUGUI text_Label;

		[SerializeField]
		private TextMeshProUGUI text_Current;

		[SerializeField]
		private TextMeshProUGUI text_Max;

		[SerializeField]
		private UnityEngine.UI.Image fill;

		private void Awake()
		{
			fill.fillAmount = 0f;
			ApplyLook();
		}

		public void Setup(string labelText, Color color, float current, float max, string format = "0.#", float min = 0f)
		{
			SetupLook(labelText, color);
			SetValue(current, max, format, min);
		}

		public void Setup(string labelText, Color color, int current, int max, int min = 0)
		{
			SetupLook(labelText, color);
			SetValue(current, max, min);
		}

		public void SetupLook(string labelText, Color color)
		{
			this.labelText = labelText;
			this.color = color;
			ApplyLook();
		}

		private void ApplyLook()
		{
			text_Label.text = labelText.ToPlainText();
			fill.color = color;
		}

		public void SetValue(float current, float max, string format = "0.#", float min = 0f)
		{
			text_Current.text = current.ToString(format);
			text_Max.text = max.ToString(format);
			float num = max - min;
			float endValue = 1f;
			if (num > 0f)
			{
				endValue = (current - min) / num;
			}
			fill.DOKill();
			fill.DOFillAmount(endValue, animateDuration).SetEase(Ease.OutCubic);
		}

		public void SetValue(int current, int max, int min = 0)
		{
			text_Current.text = current.ToString();
			text_Max.text = max.ToString();
			int num = max - min;
			float endValue = 1f;
			if (num > 0)
			{
				endValue = (float)(current - min) / (float)num;
			}
			fill.DOKill();
			fill.DOFillAmount(endValue, animateDuration).SetEase(Ease.OutCubic);
		}
	}
	public class GenericButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler, IPointerDownHandler, IPointerUpHandler
	{
		public List<ToggleAnimation> toggleAnimations = new List<ToggleAnimation>();

		public UnityEvent onPointerClick;

		public UnityEvent onPointerDown;

		public UnityEvent onPointerUp;

		public void OnPointerClick(PointerEventData eventData)
		{
			onPointerClick?.Invoke();
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			foreach (ToggleAnimation toggleAnimation in toggleAnimations)
			{
				toggleAnimation.SetToggle(value: true);
			}
			onPointerDown?.Invoke();
		}

		public void OnPointerUp(PointerEventData eventData)
		{
			foreach (ToggleAnimation toggleAnimation in toggleAnimations)
			{
				toggleAnimation.SetToggle(value: false);
			}
			onPointerUp?.Invoke();
		}
	}
	public class InventoryDisplay : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		[SerializeField]
		private InventoryEntry entryPrefab;

		[SerializeField]
		private TextMeshProUGUI displayNameText;

		[SerializeField]
		private TextMeshProUGUI capacityText;

		[SerializeField]
		private string capacityTextFormat = "({1}/{0})";

		[SerializeField]
		private FadeGroup loadingIndcator;

		[SerializeField]
		private FadeGroup contentFadeGroup;

		[SerializeField]
		private GridLayoutGroup contentLayout;

		[SerializeField]
		private LayoutElement gridLayoutElement;

		[SerializeField]
		private GameObject placeHolder;

		[SerializeField]
		private Transform entriesParent;

		[SerializeField]
		private UnityEngine.UI.Button sortButton;

		[SerializeField]
		private Vector2Int shortcutsRange = new Vector2Int(0, 3);

		[SerializeField]
		private bool editable = true;

		[SerializeField]
		private bool showOperationButtons = true;

		[SerializeField]
		private bool showSortButton;

		[SerializeField]
		private bool usePages;

		[SerializeField]
		private int itemsEachPage = 30;

		public Func<Item, bool> filter;

		[SerializeField]
		private List<InventoryEntry> entries = new List<InventoryEntry>();

		private PrefabPool<InventoryEntry> _entryPool;

		private Func<Item, bool> _func_ShouldHighlight;

		private Func<Item, bool> _func_CanOperate;

		private int cachedCapacity = -1;

		private int activeTaskToken;

		private int cachedMaxPage = 1;

		private int cachedSelectedPage;

		private List<int> cachedIndexesToDisplay = new List<int>();

		private bool shortcuts => false;

		public bool UsePages => usePages;

		public bool Editable
		{
			get
			{
				return editable;
			}
			internal set
			{
				editable = value;
			}
		}

		public bool ShowOperationButtons
		{
			get
			{
				return showOperationButtons;
			}
			internal set
			{
				showOperationButtons = value;
			}
		}

		public bool Movable { get; private set; }

		public Inventory Target { get; private set; }

		private PrefabPool<InventoryEntry> EntryPool
		{
			get
			{
				if (_entryPool == null && entryPrefab != null)
				{
					_entryPool = new PrefabPool<InventoryEntry>(entryPrefab, contentLayout.transform);
				}
				return _entryPool;
			}
		}

		public Func<Item, bool> Func_ShouldHighlight => _func_ShouldHighlight;

		public Func<Item, bool> Func_CanOperate => _func_CanOperate;

		public bool ShowSortButton
		{
			get
			{
				return showSortButton;
			}
			internal set
			{
				showSortButton = value;
			}
		}

		public int MaxPage => cachedMaxPage;

		public int SelectedPage => cachedSelectedPage;

		public event Action<InventoryDisplay, InventoryEntry, PointerEventData> onDisplayDoubleClicked;

		public event Action onPageInfoRefreshed;

		private void RegisterEvents()
		{
			if (!(Target == null))
			{
				UnregisterEvents();
				Target.onContentChanged += OnTargetContentChanged;
				Target.onInventorySorted += OnTargetSorted;
				Target.onSetIndexLock += OnTargetSetIndexLock;
			}
		}

		private void UnregisterEvents()
		{
			if (!(Target == null))
			{
				Target.onContentChanged -= OnTargetContentChanged;
				Target.onInventorySorted -= OnTargetSorted;
				Target.onSetIndexLock -= OnTargetSetIndexLock;
			}
		}

		private void OnTargetSetIndexLock(Inventory inventory, int index)
		{
			foreach (InventoryEntry entry in entries)
			{
				if (!(entry == null) && entry.isActiveAndEnabled && entry.Index == index)
				{
					entry.Refresh();
				}
			}
		}

		private void OnTargetSorted(Inventory inventory)
		{
			if (filter == null)
			{
				foreach (InventoryEntry entry in entries)
				{
					entry.Refresh();
				}
				return;
			}
			LoadEntriesTask().Forget();
		}

		private void OnTargetContentChanged(Inventory inventory, int position)
		{
			if (Target.Loading)
			{
				return;
			}
			if (filter != null)
			{
				RefreshCapacityText();
				LoadEntriesTask().Forget();
				return;
			}
			RefreshCapacityText();
			InventoryEntry inventoryEntry = entries.Find((InventoryEntry e) => e != null && e.Index == position);
			if ((bool)inventoryEntry)
			{
				inventoryEntry.Refresh();
				inventoryEntry.Punch();
			}
		}

		private void RefreshCapacityText()
		{
			if (!(Target == null) && (bool)capacityText)
			{
				capacityText.text = string.Format(capacityTextFormat, Target.Capacity, Target.GetItemCount());
			}
		}

		public void Setup(Inventory target, Func<Item, bool> funcShouldHighLight = null, Func<Item, bool> funcCanOperate = null, bool movable = false, Func<Item, bool> filter = null)
		{
			UnregisterEvents();
			Target = target;
			Clear();
			if (Target == null || Target.Loading)
			{
				return;
			}
			if (funcShouldHighLight == null)
			{
				_func_ShouldHighlight = (Item e) => false;
			}
			else
			{
				_func_ShouldHighlight = funcShouldHighLight;
			}
			if (funcCanOperate == null)
			{
				_func_CanOperate = (Item e) => true;
			}
			else
			{
				_func_CanOperate = funcCanOperate;
			}
			displayNameText.text = target.DisplayName;
			Movable = movable;
			cachedCapacity = target.Capacity;
			this.filter = filter;
			RefreshCapacityText();
			RegisterEvents();
			sortButton.gameObject.SetActive(editable && showSortButton);
			LoadEntriesTask().Forget();
		}

		private void RefreshGridLayoutPreferredHeight()
		{
			if (Target == null)
			{
				placeHolder.gameObject.SetActive(value: true);
				return;
			}
			int num = cachedIndexesToDisplay.Count;
			if (usePages && num > 0)
			{
				int num2 = cachedSelectedPage * itemsEachPage;
				int num3 = Mathf.Min(num2 + itemsEachPage, cachedIndexesToDisplay.Count);
				num = Mathf.Max(0, num3 - num2);
			}
			float preferredHeight = (float)Mathf.CeilToInt((float)num / (float)contentLayout.constraintCount) * contentLayout.cellSize.y + (float)contentLayout.padding.top + (float)contentLayout.padding.bottom;
			gridLayoutElement.preferredHeight = preferredHeight;
			placeHolder.gameObject.SetActive(num <= 0);
		}

		public void SetPage(int page)
		{
			cachedSelectedPage = page;
			this.onPageInfoRefreshed?.Invoke();
			LoadEntriesTask().Forget();
		}

		public void NextPage()
		{
			int num = cachedSelectedPage + 1;
			if (num >= cachedMaxPage)
			{
				num = 0;
			}
			SetPage(num);
		}

		public void PreviousPage()
		{
			int num = cachedSelectedPage - 1;
			if (num < 0)
			{
				num = cachedMaxPage - 1;
			}
			SetPage(num);
		}

		private void CacheIndexesToDisplay()
		{
			cachedIndexesToDisplay.Clear();
			for (int i = 0; i < Target.Capacity; i++)
			{
				if (filter != null)
				{
					Item itemAt = Target.GetItemAt(i);
					if (!filter(itemAt))
					{
						continue;
					}
				}
				cachedIndexesToDisplay.Add(i);
			}
			int count = cachedIndexesToDisplay.Count;
			cachedMaxPage = count / itemsEachPage + ((count % itemsEachPage > 0) ? 1 : 0);
			if (cachedSelectedPage >= cachedMaxPage)
			{
				cachedSelectedPage = Mathf.Max(0, cachedMaxPage - 1);
			}
			this.onPageInfoRefreshed?.Invoke();
		}

		private async UniTask LoadEntriesTask()
		{
			placeHolder.gameObject.SetActive(value: false);
			int token = ++activeTaskToken;
			EntryPool.ReleaseAll();
			entries.Clear();
			int batchCount = 5;
			int num = 0;
			CacheIndexesToDisplay();
			RefreshGridLayoutPreferredHeight();
			contentFadeGroup.SkipHide();
			loadingIndcator.Show();
			List<int> indexes;
			if (usePages)
			{
				int num2 = cachedSelectedPage * itemsEachPage;
				int num3 = Mathf.Min(num2 + itemsEachPage, cachedIndexesToDisplay.Count);
				if (num2 >= cachedIndexesToDisplay.Count || num2 >= num3)
				{
					indexes = new List<int>();
				}
				else
				{
					indexes = GetRange(num2, num3, cachedIndexesToDisplay);
				}
			}
			else
			{
				indexes = cachedIndexesToDisplay;
			}
			foreach (int index in indexes)
			{
				if (num >= batchCount)
				{
					await UniTask.Yield();
					if (!TaskValid())
					{
						return;
					}
					num = 0;
				}
				InventoryEntry newInventoryEntry = GetNewInventoryEntry();
				newInventoryEntry.gameObject.SetActive(value: true);
				newInventoryEntry.Setup(this, index);
				entries.Add(newInventoryEntry);
				newInventoryEntry.transform.SetParent(entriesParent, worldPositionStays: false);
				num++;
			}
			loadingIndcator.Hide();
			contentFadeGroup.Show();
			List<int> GetRange(int begin, int end_exclusive, List<int> list)
			{
				if (begin < 0)
				{
					begin = 0;
				}
				if (end_exclusive < 0)
				{
					end_exclusive = 0;
				}
				indexes = new List<int>();
				if (end_exclusive > list.Count)
				{
					end_exclusive = list.Count;
				}
				if (begin >= end_exclusive)
				{
					return indexes;
				}
				for (int i = begin; i < end_exclusive; i++)
				{
					indexes.Add(list[i]);
				}
				return indexes;
			}
			bool TaskValid()
			{
				if (!Application.isPlaying)
				{
					return false;
				}
				return token == activeTaskToken;
			}
		}

		public void SetFilter(Func<Item, bool> filter)
		{
			this.filter = filter;
			cachedSelectedPage = 0;
			LoadEntriesTask().Forget();
		}

		private void Clear()
		{
			EntryPool.ReleaseAll();
			entries.Clear();
		}

		private void Awake()
		{
			sortButton.onClick.AddListener(OnSortButtonClicked);
		}

		private void OnSortButtonClicked()
		{
			if (Editable && (bool)Target && !Target.Loading)
			{
				Target.Sort();
			}
		}

		private void OnEnable()
		{
			RegisterEvents();
		}

		private void OnDisable()
		{
			UnregisterEvents();
			activeTaskToken++;
		}

		private void Update()
		{
			if ((bool)Target && cachedCapacity != Target.Capacity)
			{
				OnCapacityChanged();
			}
		}

		private void OnCapacityChanged()
		{
			if (!(Target == null))
			{
				cachedCapacity = Target.Capacity;
				RefreshCapacityText();
				LoadEntriesTask().Forget();
			}
		}

		public bool IsShortcut(int index)
		{
			if (!shortcuts)
			{
				return false;
			}
			if (index >= shortcutsRange.x)
			{
				return index <= shortcutsRange.y;
			}
			return false;
		}

		private InventoryEntry GetNewInventoryEntry()
		{
			return EntryPool.Get();
		}

		internal void NotifyItemDoubleClicked(InventoryEntry inventoryEntry, PointerEventData data)
		{
			this.onDisplayDoubleClicked?.Invoke(this, inventoryEntry, data);
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
		}

		public void DisableItem(Item item)
		{
			foreach (InventoryEntry item2 in entries.Where((InventoryEntry e) => e.Content == item))
			{
				item2.Disabled = true;
			}
		}

		internal bool EvaluateShouldHighlight(Item content)
		{
			if (Func_ShouldHighlight != null && Func_ShouldHighlight(content))
			{
				return true;
			}
			_ = content == null;
			return false;
		}
	}
	public class InventoryEntry : MonoBehaviour, Duckov.Utilities.IPoolable, IPointerClickHandler, IEventSystemHandler, IDropHandler, IItemDragSource, IBeginDragHandler, IEndDragHandler, IDragHandler, IPointerEnterHandler, IPointerExitHandler
	{
		[SerializeField]
		private ItemDisplay itemDisplay;

		[SerializeField]
		private GameObject shortcutIndicator;

		[SerializeField]
		private GameObject disabledIndicator;

		[SerializeField]
		private GameObject hoveringIndicator;

		[SerializeField]
		private GameObject highlightIndicator;

		[SerializeField]
		private GameObject lockIndicator;

		[SerializeField]
		private int index;

		[SerializeField]
		private bool disabled;

		private bool cacheContentIsGun;

		private ItemMetaData cachedMeta;

		public const float doubleClickTimeThreshold = 0.3f;

		private float lastClickTime;

		private bool hovering;

		public InventoryDisplay Master { get; private set; }

		public int Index => index;

		public bool Disabled
		{
			get
			{
				return disabled;
			}
			set
			{
				disabled = value;
				Refresh();
			}
		}

		public Item Content
		{
			get
			{
				Inventory inventory = Master?.Target;
				if (inventory == null)
				{
					return null;
				}
				if (index < inventory.Capacity)
				{
					return Master?.Target?.GetItemAt(index);
				}
				return null;
			}
		}

		public bool ShouldHighlight
		{
			get
			{
				if (Master == null)
				{
					return false;
				}
				if (Content == null)
				{
					return false;
				}
				if (Master.EvaluateShouldHighlight(Content))
				{
					return true;
				}
				if (Editable && ItemUIUtilities.IsGunSelected && !cacheContentIsGun)
				{
					return IsCaliberMatchItemSelected();
				}
				return false;
			}
		}

		public bool CanOperate
		{
			get
			{
				if (Master == null)
				{
					return false;
				}
				return Master.Func_CanOperate(Content);
			}
		}

		public bool Editable
		{
			get
			{
				if (Master == null)
				{
					return false;
				}
				if (!Master.Editable)
				{
					return false;
				}
				return CanOperate;
			}
		}

		public bool Movable
		{
			get
			{
				if (Master == null)
				{
					return false;
				}
				return Master.Movable;
			}
		}

		public static PrefabPool<InventoryEntry> Pool => GameplayUIManager.Instance.InventoryEntryPool;

		public Item Item
		{
			get
			{
				if (itemDisplay != null && itemDisplay.isActiveAndEnabled)
				{
					return itemDisplay.Target;
				}
				return null;
			}
		}

		public event Action<InventoryEntry> onRefresh;

		private bool IsCaliberMatchItemSelected()
		{
			if (Content == null)
			{
				return false;
			}
			return ItemUIUtilities.SelectedItemCaliber == cachedMeta.caliber;
		}

		private void Awake()
		{
			itemDisplay.onPointerClick += OnItemDisplayPointerClicked;
			itemDisplay.onDoubleClicked += OnDisplayDoubleClicked;
			itemDisplay.onReceiveDrop += OnDrop;
			hoveringIndicator?.SetActive(value: false);
			UIInputManager.OnFastPick += OnFastPick;
			UIInputManager.OnDropItem += OnDropItemButton;
			UIInputManager.OnUseItem += OnUseItemButton;
		}

		private void OnEnable()
		{
			ItemUIUtilities.OnSelectionChanged += OnSelectionChanged;
			UIInputManager.OnLockInventoryIndex += OnInputLockInventoryIndex;
			UIInputManager.OnShortcutInput += OnShortcutInput;
		}

		private void OnDisable()
		{
			hovering = false;
			hoveringIndicator?.SetActive(value: false);
			ItemUIUtilities.OnSelectionChanged -= OnSelectionChanged;
			UIInputManager.OnLockInventoryIndex -= OnInputLockInventoryIndex;
			UIInputManager.OnShortcutInput -= OnShortcutInput;
		}

		private void OnShortcutInput(UIInputEventData data, int shortcutIndex)
		{
			if (hovering && !(Item == null))
			{
				ItemShortcut.Set(shortcutIndex, Item);
				ItemUIUtilities.NotifyPutItem(Item);
			}
		}

		private void OnInputLockInventoryIndex(UIInputEventData data)
		{
			if (hovering)
			{
				ToggleLock();
			}
		}

		private void OnSelectionChanged()
		{
			highlightIndicator.SetActive(ShouldHighlight);
			if (ItemUIUtilities.SelectedItemDisplay == itemDisplay)
			{
				Refresh();
			}
		}

		private void OnDestroy()
		{
			UIInputManager.OnFastPick -= OnFastPick;
			UIInputManager.OnDropItem -= OnDropItemButton;
			UIInputManager.OnUseItem -= OnUseItemButton;
			if (itemDisplay != null)
			{
				itemDisplay.onPointerClick -= OnItemDisplayPointerClicked;
				itemDisplay.onDoubleClicked -= OnDisplayDoubleClicked;
				itemDisplay.onReceiveDrop -= OnDrop;
			}
		}

		private void OnFastPick(UIInputEventData data)
		{
			if (!data.Used && base.isActiveAndEnabled && hovering)
			{
				Master.NotifyItemDoubleClicked(this, new PointerEventData(EventSystem.current));
				data.Use();
			}
		}

		private void OnDropItemButton(UIInputEventData data)
		{
			if (base.isActiveAndEnabled && hovering && !(Item == null) && Item.CanDrop && CanOperate)
			{
				Item.Drop(CharacterMainControl.Main, createRigidbody: true);
			}
		}

		private void OnUseItemButton(UIInputEventData data)
		{
			if (base.isActiveAndEnabled && hovering && !(Item == null) && Item.IsUsable(CharacterMainControl.Main) && CanOperate)
			{
				CharacterMainControl.Main.UseItem(Item);
			}
		}

		private void OnItemDisplayPointerClicked(ItemDisplay display, PointerEventData data)
		{
			if (!base.isActiveAndEnabled)
			{
				return;
			}
			if (disabled || !CanOperate)
			{
				data.Use();
			}
			else
			{
				if (!Editable)
				{
					return;
				}
				if (data.button == PointerEventData.InputButton.Left)
				{
					if (Content == null)
					{
						return;
					}
					if (Keyboard.current != null && Keyboard.current.altKey.isPressed)
					{
						data.Use();
						if (ItemUIUtilities.SelectedItem != null)
						{
							ItemUIUtilities.SelectedItem.TryPlug(Content);
						}
						CharacterMainControl.Main.CharacterItem.TryPlug(Content);
					}
					else if (!(ItemUIUtilities.SelectedItem == null) && Content.Stackable && ItemUIUtilities.SelectedItem != Content && ItemUIUtilities.SelectedItem.TypeID == Content.TypeID)
					{
						ItemUIUtilities.SelectedItem.CombineInto(Content);
					}
				}
				else if (data.button == PointerEventData.InputButton.Right && Editable && Content != null)
				{
					ItemOperationMenu.Show(itemDisplay);
				}
			}
		}

		private void OnDisplayDoubleClicked(ItemDisplay display, PointerEventData data)
		{
			Master.NotifyItemDoubleClicked(this, data);
		}

		public void Setup(InventoryDisplay master, int index, bool disabled = false)
		{
			Master = master;
			this.index = index;
			this.disabled = disabled;
			Refresh();
		}

		internal void Refresh()
		{
			Item content = Content;
			if (content != null)
			{
				cachedMeta = ItemAssetsCollection.GetMetaData(content.TypeID);
				cacheContentIsGun = content.Tags.Contains("Gun");
			}
			else
			{
				cacheContentIsGun = false;
				cachedMeta = default(ItemMetaData);
			}
			itemDisplay.Setup(content);
			itemDisplay.CanDrop = CanOperate;
			itemDisplay.Movable = Movable;
			itemDisplay.Editable = Editable && CanOperate;
			itemDisplay.CanLockSort = true;
			if (!Master.Target.NeedInspection && content != null)
			{
				content.Inspected = true;
			}
			itemDisplay.ShowOperationButtons = Master.ShowOperationButtons;
			shortcutIndicator.gameObject.SetActive(Master.IsShortcut(index));
			disabledIndicator.SetActive(disabled || !CanOperate);
			highlightIndicator.SetActive(ShouldHighlight);
			bool active = Master.Target.IsIndexLocked(Index);
			lockIndicator.SetActive(active);
			this.onRefresh?.Invoke(this);
		}

		public static InventoryEntry Get()
		{
			return Pool.Get();
		}

		public static void Release(InventoryEntry item)
		{
			Pool.Release(item);
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			Master = null;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Punch();
			if (eventData.button != PointerEventData.InputButton.Left)
			{
				return;
			}
			lastClickTime = eventData.clickTime;
			if (Editable)
			{
				Item selectedItem = ItemUIUtilities.SelectedItem;
				if (!(selectedItem == null))
				{
					if (Content != null)
					{
						UnityEngine.Debug.Log($"{Master.Target.name}(Inventory) 的 {index} 已经有物品。操作已取消。");
					}
					else
					{
						eventData.Use();
						selectedItem.Detach();
						Master.Target.AddAt(selectedItem, index);
						ItemUIUtilities.NotifyPutItem(selectedItem);
					}
				}
			}
			lastClickTime = eventData.clickTime;
		}

		internal void Punch()
		{
			itemDisplay.Punch();
		}

		public void OnDrag(PointerEventData eventData)
		{
		}

		public void OnDrop(PointerEventData eventData)
		{
			if (eventData.used || !Editable || eventData.button != PointerEventData.InputButton.Left)
			{
				return;
			}
			IItemDragSource component = eventData.pointerDrag.gameObject.GetComponent<IItemDragSource>();
			if (component == null || !component.IsEditable())
			{
				return;
			}
			Item item = component.GetItem();
			if (item == null || (item.Sticky && !Master.Target.AcceptSticky))
			{
				return;
			}
			if (Keyboard.current != null && Keyboard.current.ctrlKey.isPressed)
			{
				if (Content != null)
				{
					NotificationText.Push("UI_Inventory_TargetOccupiedCannotSplit".ToPlainText());
					return;
				}
				UnityEngine.Debug.Log("SPLIT");
				SplitDialogue.SetupAndShow(item, Master.Target, index);
				return;
			}
			ItemUIUtilities.NotifyPutItem(item);
			if (Content == null)
			{
				item.Detach();
				Master.Target.AddAt(item, index);
				return;
			}
			if (Content.TypeID == item.TypeID && Content.Stackable)
			{
				Content.Combine(item);
				return;
			}
			Inventory inInventory = item.InInventory;
			Inventory target = Master.Target;
			if (inInventory != null)
			{
				int atPosition = inInventory.GetIndex(item);
				int atPosition2 = index;
				Item content = Content;
				if (content != item)
				{
					item.Detach();
					content.Detach();
					inInventory.AddAt(content, atPosition);
					target.AddAt(item, atPosition2);
				}
			}
		}

		public bool IsEditable()
		{
			if (Content == null)
			{
				return false;
			}
			if (Content.NeedInspection)
			{
				return false;
			}
			return Editable;
		}

		public Item GetItem()
		{
			return Content;
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			hovering = true;
			hoveringIndicator?.SetActive(Editable);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			hovering = false;
			hoveringIndicator?.SetActive(value: false);
		}

		public void ToggleLock()
		{
			Master.Target.ToggleLockIndex(Index);
		}
	}
	public class ItemDetailsDisplay : MonoBehaviour
	{
		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TrueShadow iconShadow;

		[SerializeField]
		private TextMeshProUGUI displayName;

		[SerializeField]
		private TextMeshProUGUI itemID;

		[SerializeField]
		private TextMeshProUGUI description;

		[SerializeField]
		private GameObject countContainer;

		[SerializeField]
		private TextMeshProUGUI count;

		[SerializeField]
		private GameObject durabilityContainer;

		[SerializeField]
		private TextMeshProUGUI durabilityText;

		[SerializeField]
		private TooltipsProvider durabilityToolTips;

		[SerializeField]
		[LocalizationKey("Default")]
		private string durabilityToolTipsFormatKey = "UI_DurabilityToolTips";

		[SerializeField]
		private UnityEngine.UI.Image durabilityFill;

		[SerializeField]
		private UnityEngine.UI.Image durabilityLoss;

		[SerializeField]
		private Gradient durabilityColorOverT;

		[SerializeField]
		private TextMeshProUGUI weightText;

		[SerializeField]
		private ItemSlotCollectionDisplay slotCollectionDisplay;

		[SerializeField]
		private RectTransform propertiesParent;

		[SerializeField]
		private BulletTypeDisplay bulletTypeDisplay;

		[SerializeField]
		private TagsDisplay tagsDisplay;

		[SerializeField]
		private GameObject usableIndicator;

		[SerializeField]
		private UsageUtilitiesDisplay usageUtilitiesDisplay;

		[SerializeField]
		private GameObject registeredIndicator;

		[SerializeField]
		private ItemVariableEntry variableEntryPrefab;

		[SerializeField]
		private ItemStatEntry statEntryPrefab;

		[SerializeField]
		private ItemModifierEntry modifierEntryPrefab;

		[SerializeField]
		private ItemEffectEntry effectEntryPrefab;

		[SerializeField]
		private string weightFormat = "{0:0.#} kg";

		private Item target;

		private PrefabPool<ItemVariableEntry> _variablePool;

		private PrefabPool<ItemStatEntry> _statPool;

		private PrefabPool<ItemModifierEntry> _modifierPool;

		private PrefabPool<ItemEffectEntry> _effectPool;

		private string DurabilityToolTipsFormat => durabilityToolTipsFormatKey.ToPlainText();

		public ItemSlotCollectionDisplay SlotCollectionDisplay => slotCollectionDisplay;

		private PrefabPool<ItemVariableEntry> VariablePool
		{
			get
			{
				if (_variablePool == null)
				{
					_variablePool = new PrefabPool<ItemVariableEntry>(variableEntryPrefab, propertiesParent);
				}
				return _variablePool;
			}
		}

		private PrefabPool<ItemStatEntry> StatPool
		{
			get
			{
				if (_statPool == null)
				{
					_statPool = new PrefabPool<ItemStatEntry>(statEntryPrefab, propertiesParent);
				}
				return _statPool;
			}
		}

		private PrefabPool<ItemModifierEntry> ModifierPool
		{
			get
			{
				if (_modifierPool == null)
				{
					_modifierPool = new PrefabPool<ItemModifierEntry>(modifierEntryPrefab, propertiesParent);
				}
				return _modifierPool;
			}
		}

		private PrefabPool<ItemEffectEntry> EffectPool
		{
			get
			{
				if (_effectPool == null)
				{
					_effectPool = new PrefabPool<ItemEffectEntry>(effectEntryPrefab, propertiesParent);
				}
				return _effectPool;
			}
		}

		public Item Target => target;

		internal void Setup(Item target)
		{
			UnregisterEvents();
			Clear();
			if (!(target == null))
			{
				this.target = target;
				icon.sprite = target.Icon;
				(float, Color, bool) shadowOffsetAndColorOfQuality = GameplayDataSettings.UIStyle.GetShadowOffsetAndColorOfQuality(target.DisplayQuality);
				iconShadow.IgnoreCasterColor = true;
				iconShadow.OffsetDistance = shadowOffsetAndColorOfQuality.Item1;
				iconShadow.Color = shadowOffsetAndColorOfQuality.Item2;
				iconShadow.Inset = shadowOffsetAndColorOfQuality.Item3;
				displayName.text = target.DisplayName;
				itemID.text = $"#{target.TypeID}";
				description.text = target.Description;
				countContainer.SetActive(target.Stackable);
				count.text = target.StackCount.ToString();
				tagsDisplay.Setup(target);
				usageUtilitiesDisplay.Setup(target);
				usableIndicator.gameObject.SetActive(target.UsageUtilities != null);
				RefreshDurability();
				slotCollectionDisplay.Setup(target);
				registeredIndicator.SetActive(target.IsRegistered());
				RefreshWeightText();
				SetupGunDisplays();
				SetupVariables();
				SetupConstants();
				SetupStats();
				SetupModifiers();
				SetupEffects();
				RegisterEvents();
			}
		}

		private void Awake()
		{
			SlotCollectionDisplay.onElementDoubleClicked += OnElementDoubleClicked;
		}

		private void OnElementDoubleClicked(ItemSlotCollectionDisplay collectionDisplay, SlotDisplay slotDisplay)
		{
			if (collectionDisplay.Editable)
			{
				Item item = slotDisplay.GetItem();
				if (!(item == null))
				{
					ItemUtilities.SendToPlayer(item, dontMerge: false, PlayerStorage.Instance != null);
				}
			}
		}

		private void OnDestroy()
		{
			UnregisterEvents();
		}

		private void Clear()
		{
			tagsDisplay.Clear();
			VariablePool.ReleaseAll();
			StatPool.ReleaseAll();
			ModifierPool.ReleaseAll();
			EffectPool.ReleaseAll();
		}

		private void SetupGunDisplays()
		{
			ItemSetting_Gun itemSetting_Gun = Target?.GetComponent<ItemSetting_Gun>();
			if (itemSetting_Gun == null)
			{
				bulletTypeDisplay.gameObject.SetActive(value: false);
				return;
			}
			bulletTypeDisplay.gameObject.SetActive(value: true);
			bulletTypeDisplay.Setup(itemSetting_Gun.TargetBulletID);
		}

		private void SetupVariables()
		{
			if (target.Variables == null)
			{
				return;
			}
			foreach (CustomData variable in target.Variables)
			{
				if (variable.Display)
				{
					ItemVariableEntry itemVariableEntry = VariablePool.Get(propertiesParent);
					itemVariableEntry.Setup(variable);
					itemVariableEntry.transform.SetAsLastSibling();
				}
			}
		}

		private void SetupConstants()
		{
			if (target.Constants == null)
			{
				return;
			}
			foreach (CustomData constant in target.Constants)
			{
				if (constant.Display)
				{
					ItemVariableEntry itemVariableEntry = VariablePool.Get(propertiesParent);
					itemVariableEntry.Setup(constant);
					itemVariableEntry.transform.SetAsLastSibling();
				}
			}
		}

		private void SetupStats()
		{
			if (target.Stats == null)
			{
				return;
			}
			foreach (Stat stat in target.Stats)
			{
				if (stat.Display)
				{
					ItemStatEntry itemStatEntry = StatPool.Get(propertiesParent);
					itemStatEntry.Setup(stat);
					itemStatEntry.transform.SetAsLastSibling();
				}
			}
		}

		private void SetupModifiers()
		{
			if (target.Modifiers == null)
			{
				return;
			}
			foreach (ModifierDescription modifier in target.Modifiers)
			{
				if (modifier.Display)
				{
					ItemModifierEntry itemModifierEntry = ModifierPool.Get(propertiesParent);
					itemModifierEntry.Setup(modifier);
					itemModifierEntry.transform.SetAsLastSibling();
				}
			}
		}

		private void SetupEffects()
		{
			foreach (Effect effect in target.Effects)
			{
				if (effect.Display)
				{
					ItemEffectEntry itemEffectEntry = EffectPool.Get(propertiesParent);
					itemEffectEntry.Setup(effect);
					itemEffectEntry.transform.SetAsLastSibling();
				}
			}
		}

		private void RegisterEvents()
		{
			if (!(target == null))
			{
				target.onDestroy += OnTargetDestroy;
				target.onChildChanged += OnTargetChildChanged;
				target.onSetStackCount += OnTargetSetStackCount;
				target.onDurabilityChanged += OnTargetDurabilityChanged;
			}
		}

		private void RefreshWeightText()
		{
			weightText.text = string.Format(weightFormat, target.TotalWeight);
		}

		private void OnTargetSetStackCount(Item item)
		{
			RefreshWeightText();
		}

		private void OnTargetChildChanged(Item obj)
		{
			RefreshWeightText();
		}

		internal void UnregisterEvents()
		{
			if (!(target == null))
			{
				target.onDestroy -= OnTargetDestroy;
				target.onChildChanged -= OnTargetChildChanged;
				target.onSetStackCount -= OnTargetSetStackCount;
				target.onDurabilityChanged -= OnTargetDurabilityChanged;
			}
		}

		private void OnTargetDurabilityChanged(Item item)
		{
			RefreshDurability();
		}

		private void RefreshDurability()
		{
			bool useDurability = target.UseDurability;
			durabilityContainer.SetActive(useDurability);
			if (useDurability)
			{
				float durability = target.Durability;
				float maxDurability = target.MaxDurability;
				float maxDurabilityWithLoss = target.MaxDurabilityWithLoss;
				string lossPercentage = $"{target.DurabilityLoss * 100f:0}%";
				float num = durability / maxDurability;
				durabilityText.text = $"{durability:0} / {maxDurabilityWithLoss:0}";
				durabilityToolTips.text = DurabilityToolTipsFormat.Format(new
				{
					curDurability = durability,
					maxDurability = maxDurability,
					maxDurabilityWithLoss = maxDurabilityWithLoss,
					lossPercentage = lossPercentage
				});
				durabilityFill.fillAmount = num;
				durabilityFill.color = durabilityColorOverT.Evaluate(num);
				durabilityLoss.fillAmount = target.DurabilityLoss;
			}
		}

		private void OnTargetDestroy(Item item)
		{
		}
	}
	public class ItemDetailsPanel : ManagedUIElement
	{
		private static ItemDetailsPanel instance;

		private Item target;

		[SerializeField]
		private ItemDetailsDisplay display;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button closeButton;

		private ManagedUIElement source;

		protected override void Awake()
		{
			base.Awake();
			if (instance == null)
			{
				instance = this;
			}
			closeButton.onClick.AddListener(OnCloseButtonClicked);
		}

		private void OnCloseButtonClicked()
		{
			Close();
		}

		public static void Show(Item target, ManagedUIElement source = null)
		{
			if (!(instance == null))
			{
				instance.Open(target, source);
			}
		}

		public void Open(Item target, ManagedUIElement source)
		{
			this.target = target;
			this.source = source;
			Open(source);
		}

		protected override void OnOpen()
		{
			if (!(target == null))
			{
				base.gameObject.SetActive(value: true);
				Setup(target);
				fadeGroup.Show();
			}
		}

		protected override void OnClose()
		{
			UnregisterEvents();
			target = null;
			fadeGroup.Hide();
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		internal void Setup(Item target)
		{
			display.Setup(target);
		}

		private void UnregisterEvents()
		{
			display.UnregisterEvents();
		}
	}
	public class ItemEffectEntry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		private Effect target;

		[SerializeField]
		private TextMeshProUGUI text;

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			target = null;
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		public void Setup(Effect target)
		{
			this.target = target;
			Refresh();
			RegisterEvents();
		}

		private void Refresh()
		{
			text.text = target.GetDisplayString();
		}

		private void RegisterEvents()
		{
		}

		private void UnregisterEvents()
		{
		}
	}
	public class ItemModifierEntry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		private ModifierDescription target;

		[SerializeField]
		private TextMeshProUGUI displayName;

		[SerializeField]
		private TextMeshProUGUI value;

		[SerializeField]
		private Color color_Neutral;

		[SerializeField]
		private Color color_Positive;

		[SerializeField]
		private Color color_Negative;

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
		}

		internal void Setup(ModifierDescription target)
		{
			UnregisterEvents();
			this.target = target;
			Refresh();
			RegisterEvents();
		}

		private void Refresh()
		{
			displayName.text = target.DisplayName;
			StatInfoDatabase.Entry entry = StatInfoDatabase.Get(target.Key);
			value.text = target.GetDisplayValueString(entry.DisplayFormat);
			Color color = color_Neutral;
			Polarity polarity = entry.polarity;
			if (target.Value != 0f)
			{
				switch (polarity)
				{
				case Polarity.Negative:
					color = ((target.Value < 0f) ? color_Positive : color_Negative);
					break;
				case Polarity.Positive:
					color = ((target.Value > 0f) ? color_Positive : color_Negative);
					break;
				}
			}
			value.color = color;
		}

		private void RegisterEvents()
		{
			_ = target;
		}

		private void UnregisterEvents()
		{
			_ = target;
		}
	}
	public class ItemStatEntry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		private Stat target;

		[SerializeField]
		private TextMeshProUGUI displayName;

		[SerializeField]
		private TextMeshProUGUI value;

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			target = null;
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		internal void Setup(Stat target)
		{
			UnregisterEvents();
			this.target = target;
			RegisterEvents();
			Refresh();
		}

		private void Refresh()
		{
			StatInfoDatabase.Entry entry = StatInfoDatabase.Get(target.Key);
			displayName.text = target.DisplayName;
			value.text = target.Value.ToString(entry.DisplayFormat);
		}

		private void RegisterEvents()
		{
			if (target != null)
			{
				target.OnSetDirty += OnTargetSetDirty;
			}
		}

		private void UnregisterEvents()
		{
			if (target != null)
			{
				target.OnSetDirty -= OnTargetSetDirty;
			}
		}

		private void OnTargetSetDirty(Stat stat)
		{
			if (stat != target)
			{
				UnityEngine.Debug.LogError("ItemStatEntry.target与事件触发者不匹配。");
			}
			else
			{
				Refresh();
			}
		}
	}
	public class ItemVariableEntry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		private CustomData target;

		[SerializeField]
		private TextMeshProUGUI displayName;

		[SerializeField]
		private TextMeshProUGUI value;

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			target = null;
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		internal void Setup(CustomData target)
		{
			UnregisterEvents();
			this.target = target;
			Refresh();
			RegisterEvents();
		}

		private void Refresh()
		{
			displayName.text = target.DisplayName;
			value.text = target.GetValueDisplayString();
		}

		private void RegisterEvents()
		{
			if (target != null)
			{
				target.OnSetData += OnTargetSetData;
			}
		}

		private void UnregisterEvents()
		{
			if (target != null)
			{
				target.OnSetData -= OnTargetSetData;
			}
		}

		private void OnTargetSetData(CustomData data)
		{
			Refresh();
		}
	}
	[CreateAssetMenu(menuName = "Duckov/Stat Info Database")]
	public class StatInfoDatabase : ScriptableObject
	{
		[Serializable]
		public struct Entry
		{
			public string statName;

			public Polarity polarity;

			public string displayFormat;

			public string DisplayFormat
			{
				get
				{
					if (string.IsNullOrEmpty(displayFormat))
					{
						return "0.##";
					}
					return displayFormat;
				}
			}
		}

		[SerializeField]
		private Entry[] entries = new Entry[0];

		private Dictionary<string, Entry> _dic;

		public static StatInfoDatabase Instance => GameplayDataSettings.StatInfo;

		private static Dictionary<string, Entry> Dic => Instance._dic;

		public static Entry Get(string statName)
		{
			if (!(Instance == null))
			{
				if (Dic == null)
				{
					RebuildDic();
				}
				if (Dic.TryGetValue(statName, out var value))
				{
					return value;
				}
			}
			return new Entry
			{
				statName = statName,
				polarity = Polarity.Neutral,
				displayFormat = "0.##"
			};
		}

		public static Polarity GetPolarity(string statName)
		{
			return Get(statName).polarity;
		}

		[ContextMenu("Rebuild Dic")]
		private static void RebuildDic()
		{
			if (Instance == null)
			{
				return;
			}
			Instance._dic = new Dictionary<string, Entry>();
			Entry[] array = Instance.entries;
			for (int i = 0; i < array.Length; i++)
			{
				Entry value = array[i];
				if (Instance._dic.ContainsKey(value.statName))
				{
					UnityEngine.Debug.LogError("Stat Info 中有重复的 key: " + value.statName);
				}
				else
				{
					Instance._dic[value.statName] = value;
				}
			}
		}
	}
	public class UsageUtilitiesDisplay : MonoBehaviour
	{
		[SerializeField]
		private UsageUtilitiesDisplay_Entry entryTemplate;

		private PrefabPool<UsageUtilitiesDisplay_Entry> _entryPool;

		public UsageUtilities Target { get; private set; }

		private PrefabPool<UsageUtilitiesDisplay_Entry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<UsageUtilitiesDisplay_Entry>(entryTemplate);
				}
				return _entryPool;
			}
		}

		public void Setup(Item item)
		{
			if (!(item == null))
			{
				UsageUtilities component = item.GetComponent<UsageUtilities>();
				if (!(component == null))
				{
					Target = component;
					base.gameObject.SetActive(value: true);
					Refresh();
					return;
				}
			}
			base.gameObject.SetActive(value: false);
		}

		private void Refresh()
		{
			EntryPool.ReleaseAll();
			foreach (UsageBehavior behavior in Target.behaviors)
			{
				if (!(behavior == null) && behavior.DisplaySettings.display)
				{
					EntryPool.Get().Setup(behavior);
				}
			}
			if (EntryPool.ActiveEntries.Count <= 0)
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class UsageUtilitiesDisplay_Entry : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI text;

		public UsageBehavior Target { get; private set; }

		internal void Setup(UsageBehavior cur)
		{
			text.text = cur.DisplaySettings.Description;
		}
	}
	public class ItemDisplay : MonoBehaviour, Duckov.Utilities.IPoolable, IPointerClickHandler, IEventSystemHandler, IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler, IDropHandler
	{
		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TrueShadow displayQualityShadow;

		[SerializeField]
		private GameObject countGameObject;

		[SerializeField]
		private TextMeshProUGUI countText;

		[SerializeField]
		private GameObject selectionIndicator;

		[SerializeField]
		private Graphic interactionEventReceiver;

		[SerializeField]
		private GameObject backgroundRing;

		[SerializeField]
		private GameObject inspectionElementRoot;

		[SerializeField]
		private GameObject inspectingElement;

		[SerializeField]
		private GameObject notInspectingElement;

		[SerializeField]
		private GameObject nameContainer;

		[SerializeField]
		private TextMeshProUGUI nameText;

		[SerializeField]
		private GameObject durabilityGameObject;

		[SerializeField]
		private UnityEngine.UI.Image durabilityFill;

		[SerializeField]
		private Gradient durabilityFillColorOverT;

		[SerializeField]
		private GameObject durabilityZeroIndicator;

		[SerializeField]
		private UnityEngine.UI.Image durabilityLoss;

		[SerializeField]
		private GameObject slotIndicatorContainer;

		[SerializeField]
		private SlotIndicator slotIndicatorTemplate;

		[SerializeField]
		private GameObject wishlistedIndicator;

		[SerializeField]
		private GameObject questRequiredIndicator;

		[SerializeField]
		private GameObject buildingRequiredIndicator;

		[SerializeField]
		[Range(0f, 1f)]
		private float punchDuration = 0.2f;

		[SerializeField]
		[Range(-1f, 1f)]
		private float selectionRingPunchScale = 0.1f;

		[SerializeField]
		[Range(-1f, 1f)]
		private float backgroundRingPunchScale = 0.2f;

		[SerializeField]
		[Range(-1f, 1f)]
		private float iconPunchScale = 0.1f;

		public const float doubleClickTimeThreshold = 0.3f;

		private PrefabPool<SlotIndicator> _slotIndicatorPool;

		private bool mainContentShown = true;

		private bool isBeingDestroyed;

		[SerializeField]
		private bool showOperationButtons = true;

		private float lastClickTime;

		private bool doubleClickInvoked;

		private Sprite FallbackIcon => GameplayDataSettings.UIStyle.FallbackItemIcon;

		public Item Target { get; private set; }

		internal Action releaseAction { get; set; }

		public bool Selected => ItemUIUtilities.SelectedItemDisplay == this;

		private PrefabPool<SlotIndicator> SlotIndicatorPool
		{
			get
			{
				if (_slotIndicatorPool == null)
				{
					if (slotIndicatorTemplate == null)
					{
						UnityEngine.Debug.LogError("SI is null", base.gameObject);
					}
					_slotIndicatorPool = new PrefabPool<SlotIndicator>(slotIndicatorTemplate);
				}
				return _slotIndicatorPool;
			}
		}

		public static PrefabPool<ItemDisplay> Pool => GameplayUIManager.Instance.ItemDisplayPool;

		public bool ShowOperationButtons
		{
			get
			{
				return showOperationButtons;
			}
			internal set
			{
				showOperationButtons = value;
			}
		}

		public bool Editable { get; set; }

		public bool Movable { get; set; }

		public bool CanDrop { get; set; }

		public bool IsStockshopSample { get; set; }

		public bool CanUse
		{
			get
			{
				if (Target == null)
				{
					return false;
				}
				if (!Editable)
				{
					return false;
				}
				if (Target.IsUsable(CharacterMainControl.Main))
				{
					return true;
				}
				return false;
			}
		}

		public bool CanSplit
		{
			get
			{
				if (Target == null)
				{
					return false;
				}
				if (!Editable)
				{
					return false;
				}
				if (Movable && Target.StackCount > 1)
				{
					return true;
				}
				return false;
			}
		}

		public bool CanLockSort { get; internal set; }

		public bool CanSetShortcut
		{
			get
			{
				if (Target == null)
				{
					return false;
				}
				if (!showOperationButtons)
				{
					return false;
				}
				if (!ItemShortcut.IsItemValid(Target))
				{
					return false;
				}
				return true;
			}
		}

		internal event Action<ItemDisplay, PointerEventData> onDoubleClicked;

		public event Action<PointerEventData> onReceiveDrop;

		public static event Action<ItemDisplay> OnPointerEnterItemDisplay;

		public static event Action<ItemDisplay> OnPointerExitItemDisplay;

		public event Action<ItemDisplay, PointerEventData> onPointerClick;

		public void Setup(Item target)
		{
			UnregisterEvents();
			Target = target;
			Clear();
			slotIndicatorTemplate.gameObject.SetActive(value: false);
			if (target == null)
			{
				SetupEmpty();
			}
			else
			{
				icon.color = Color.white;
				icon.sprite = target.Icon;
				if (icon.sprite == null)
				{
					icon.sprite = FallbackIcon;
				}
				icon.gameObject.SetActive(value: true);
				(float, Color, bool) shadowOffsetAndColorOfQuality = GameplayDataSettings.UIStyle.GetShadowOffsetAndColorOfQuality(target.DisplayQuality);
				displayQualityShadow.OffsetDistance = shadowOffsetAndColorOfQuality.Item1;
				displayQualityShadow.Color = shadowOffsetAndColorOfQuality.Item2;
				displayQualityShadow.Inset = shadowOffsetAndColorOfQuality.Item3;
				bool stackable = Target.Stackable;
				countGameObject.SetActive(stackable);
				nameText.text = Target.DisplayName;
				if (target.Slots != null)
				{
					foreach (Slot slot in target.Slots)
					{
						SlotIndicatorPool.Get().Setup(slot);
					}
				}
			}
			Refresh();
			if (base.isActiveAndEnabled)
			{
				RegisterEvents();
			}
		}

		private void RegisterEvents()
		{
			UnregisterEvents();
			ItemUIUtilities.OnSelectionChanged += OnItemUtilitiesSelectionChanged;
			ItemWishlist.OnWishlistChanged += OnWishlistChanged;
			if (!(Target == null))
			{
				Target.onDestroy += OnTargetDestroy;
				Target.onSetStackCount += OnTargetSetStackCount;
				Target.onInspectionStateChanged += OnTargetInspectionStateChanged;
				Target.onDurabilityChanged += OnTargetDurabilityChanged;
			}
		}

		private void UnregisterEvents()
		{
			ItemUIUtilities.OnSelectionChanged -= OnItemUtilitiesSelectionChanged;
			ItemWishlist.OnWishlistChanged -= OnWishlistChanged;
			if (!(Target == null))
			{
				Target.onDestroy -= OnTargetDestroy;
				Target.onSetStackCount -= OnTargetSetStackCount;
				Target.onInspectionStateChanged -= OnTargetInspectionStateChanged;
				Target.onDurabilityChanged -= OnTargetDurabilityChanged;
			}
		}

		private void OnWishlistChanged(int type)
		{
			if (!(Target == null) && Target.TypeID == type)
			{
				RefreshWishlistInfo();
			}
		}

		private void OnTargetDurabilityChanged(Item item)
		{
			Refresh();
		}

		private void OnTargetDestroy(Item item)
		{
		}

		private void OnTargetSetStackCount(Item item)
		{
			if (item != Target)
			{
				UnityEngine.Debug.LogError("触发事件的Item不匹配!");
			}
			Refresh();
		}

		private void OnItemUtilitiesSelectionChanged()
		{
			Refresh();
		}

		private void OnTargetInspectionStateChanged(Item item)
		{
			Refresh();
			Punch();
		}

		private void Clear()
		{
			SlotIndicatorPool.ReleaseAll();
		}

		private void SetupEmpty()
		{
			icon.sprite = EmptySprite.Get();
			icon.color = Color.clear;
			countText.text = string.Empty;
			nameText.text = string.Empty;
			durabilityFill.fillAmount = 0f;
			durabilityLoss.fillAmount = 0f;
			durabilityZeroIndicator.gameObject.SetActive(value: false);
		}

		private void Refresh()
		{
			if (this == null)
			{
				UnityEngine.Debug.Log("NULL");
			}
			else
			{
				if (isBeingDestroyed)
				{
					return;
				}
				if (Target == null)
				{
					HideMainContentAndDisableControl();
					HideInspectionElements();
					if (ItemUIUtilities.SelectedItemDisplayRaw == this)
					{
						ItemUIUtilities.Select(null);
					}
				}
				else if (Target.NeedInspection)
				{
					HideMainContentAndDisableControl();
					ShowInspectionElements();
				}
				else
				{
					HideInspectionElements();
					ShowMainContentAndEnableControl();
				}
				selectionIndicator.gameObject.SetActive(Selected);
				RefreshWishlistInfo();
			}
		}

		private void RefreshWishlistInfo()
		{
			if (Target == null || Target.NeedInspection)
			{
				wishlistedIndicator.SetActive(value: false);
				questRequiredIndicator.SetActive(value: false);
				buildingRequiredIndicator.SetActive(value: false);
			}
			else
			{
				ItemWishlist.WishlistInfo wishlistInfo = ItemWishlist.GetWishlistInfo(Target.TypeID);
				wishlistedIndicator.SetActive(wishlistInfo.isManuallyWishlisted);
				questRequiredIndicator.SetActive(wishlistInfo.isQuestRequired);
				buildingRequiredIndicator.SetActive(wishlistInfo.isBuildingRequired);
			}
		}

		private void HideMainContentAndDisableControl()
		{
			mainContentShown = false;
			if (mainContentShown && ItemUIUtilities.SelectedItemDisplay == this)
			{
				ItemUIUtilities.Select(null);
			}
			interactionEventReceiver.raycastTarget = false;
			icon.gameObject.SetActive(value: false);
			countGameObject.SetActive(value: false);
			durabilityGameObject.SetActive(value: false);
			durabilityZeroIndicator.gameObject.SetActive(value: false);
			nameContainer.SetActive(value: false);
			slotIndicatorContainer.SetActive(value: false);
		}

		private void ShowMainContentAndEnableControl()
		{
			mainContentShown = true;
			interactionEventReceiver.raycastTarget = true;
			icon.gameObject.SetActive(value: true);
			nameContainer.SetActive(value: true);
			countText.text = (Target.Stackable ? Target.StackCount.ToString() : string.Empty);
			bool useDurability = Target.UseDurability;
			if (useDurability)
			{
				float num = Target.Durability / Target.MaxDurability;
				durabilityFill.fillAmount = num;
				durabilityFill.color = durabilityFillColorOverT.Evaluate(num);
				durabilityZeroIndicator.SetActive(Target.Durability <= 0f);
				durabilityLoss.fillAmount = Target.DurabilityLoss;
			}
			else
			{
				durabilityZeroIndicator.gameObject.SetActive(value: false);
			}
			countGameObject.SetActive(Target.Stackable);
			durabilityGameObject.SetActive(useDurability);
			slotIndicatorContainer.SetActive(value: true);
		}

		private void ShowInspectionElements()
		{
			inspectionElementRoot.gameObject.SetActive(value: true);
			bool inspecting = Target.Inspecting;
			if ((bool)inspectingElement)
			{
				inspectingElement.SetActive(inspecting);
			}
			if ((bool)notInspectingElement)
			{
				notInspectingElement.SetActive(!inspecting);
			}
		}

		private void HideInspectionElements()
		{
			inspectionElementRoot.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			RegisterEvents();
		}

		private void OnDisable()
		{
			ItemUIUtilities.OnSelectionChanged -= OnItemUtilitiesSelectionChanged;
			if (Selected)
			{
				ItemUIUtilities.Select(null);
			}
			UnregisterEvents();
		}

		private void OnDestroy()
		{
			UnregisterEvents();
			ItemUIUtilities.OnSelectionChanged -= OnItemUtilitiesSelectionChanged;
			isBeingDestroyed = true;
		}

		public static ItemDisplay Get()
		{
			return Pool.Get();
		}

		public static void Release(ItemDisplay item)
		{
			Pool.Release(item);
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			Target = null;
			SetupEmpty();
		}

		[ContextMenu("Select")]
		private void Select()
		{
			ItemUIUtilities.Select(this);
		}

		public void NotifySelected()
		{
		}

		public void NotifyUnselected()
		{
			KontextMenu.Hide(this);
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			this.onPointerClick?.Invoke(this, eventData);
			if (!eventData.used && eventData.button == PointerEventData.InputButton.Left)
			{
				if (eventData.clickTime - lastClickTime <= 0.3f && !doubleClickInvoked)
				{
					doubleClickInvoked = true;
					this.onDoubleClicked?.Invoke(this, eventData);
				}
				if (!eventData.used && (!Target || !Target.NeedInspection))
				{
					if (ItemUIUtilities.SelectedItemDisplay != this)
					{
						Select();
						eventData.Use();
					}
					else
					{
						ItemUIUtilities.Select(null);
						eventData.Use();
					}
				}
			}
			if (eventData.clickTime - lastClickTime > 0.3f)
			{
				doubleClickInvoked = false;
			}
			lastClickTime = eventData.clickTime;
			Punch();
		}

		public void Punch()
		{
			selectionIndicator.transform.DOKill();
			icon.transform.DOKill();
			backgroundRing.transform.DOKill();
			selectionIndicator.transform.localScale = Vector3.one;
			icon.transform.localScale = Vector3.one;
			backgroundRing.transform.localScale = Vector3.one;
			selectionIndicator.transform.DOPunchScale(Vector3.one * selectionRingPunchScale, punchDuration);
			icon.transform.DOPunchScale(Vector3.one * iconPunchScale, punchDuration);
			backgroundRing.transform.DOPunchScale(Vector3.one * backgroundRingPunchScale, punchDuration);
		}

		public void OnPointerDown(PointerEventData eventData)
		{
		}

		public void OnPointerUp(PointerEventData eventData)
		{
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if (!(Target == null))
			{
				ItemDisplay.OnPointerExitItemDisplay?.Invoke(this);
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (!(Target == null))
			{
				ItemDisplay.OnPointerEnterItemDisplay?.Invoke(this);
			}
		}

		public void OnDrop(PointerEventData eventData)
		{
			HandleDirectDrop(eventData);
			if (!eventData.used)
			{
				this.onReceiveDrop?.Invoke(eventData);
			}
		}

		private void HandleDirectDrop(PointerEventData eventData)
		{
			if (Target == null || eventData.button != PointerEventData.InputButton.Left || IsStockshopSample)
			{
				return;
			}
			IItemDragSource component = eventData.pointerDrag.gameObject.GetComponent<IItemDragSource>();
			if (component != null && component.IsEditable())
			{
				Item item = component.GetItem();
				if (Target.TryPlug(item))
				{
					ItemUIUtilities.NotifyPutItem(item);
					eventData.Use();
				}
			}
		}
	}
	public class ItemOperationMenu : ManagedUIElement
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private RectTransform rectTransform;

		[SerializeField]
		private RectTransform contentRectTransform;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TextMeshProUGUI nameText;

		[SerializeField]
		private TextMeshProUGUI weightText;

		[SerializeField]
		private string weightTextFormat = "{0:0.#}kg";

		[SerializeField]
		private UnityEngine.UI.Button btn_Use;

		[SerializeField]
		private UnityEngine.UI.Button btn_Split;

		[SerializeField]
		private UnityEngine.UI.Button btn_Dump;

		[SerializeField]
		private UnityEngine.UI.Button btn_Equip;

		[SerializeField]
		private UnityEngine.UI.Button btn_Modify;

		[SerializeField]
		private UnityEngine.UI.Button btn_Unload;

		[SerializeField]
		private UnityEngine.UI.Button btn_Wishlist;

		[SerializeField]
		private bool alwaysModifyable;

		private View targetView;

		private ItemDisplay TargetDisplay;

		private Item displayingItem;

		public static ItemOperationMenu Instance { get; private set; }

		private Item TargetItem => TargetDisplay?.Target;

		private bool Usable => TargetItem.UsageUtilities != null;

		private bool UseButtonInteractable
		{
			get
			{
				if ((bool)TargetItem)
				{
					return TargetItem.IsUsable(LevelManager.Instance?.MainCharacter);
				}
				return false;
			}
		}

		private bool Splittable
		{
			get
			{
				CharacterMainControl main = CharacterMainControl.Main;
				if ((object)main != null && main.CharacterItem.Inventory.GetFirstEmptyPosition() < 0)
				{
					return false;
				}
				if ((bool)TargetItem && TargetItem.Stackable)
				{
					return TargetItem.StackCount > 1;
				}
				return false;
			}
		}

		private bool Dumpable
		{
			get
			{
				if (!TargetItem.CanDrop)
				{
					return false;
				}
				Item item = LevelManager.Instance?.MainCharacter?.CharacterItem;
				if (TargetItem.GetRoot() == item)
				{
					return true;
				}
				return false;
			}
		}

		private bool Equipable
		{
			get
			{
				if (TargetItem == null)
				{
					return false;
				}
				if (TargetItem.PluggedIntoSlot != null)
				{
					return false;
				}
				bool? flag = LevelManager.Instance?.MainCharacter?.CharacterItem?.Slots.Any((Slot e) => e.CanPlug(TargetItem));
				if (!flag.HasValue)
				{
					return false;
				}
				return flag.Value;
			}
		}

		private bool Modifyable
		{
			get
			{
				if (alwaysModifyable)
				{
					return true;
				}
				return false;
			}
		}

		private bool Unloadable
		{
			get
			{
				if (TargetItem == null)
				{
					return false;
				}
				if (!TargetItem.GetComponent<ItemSetting_Gun>())
				{
					return false;
				}
				return true;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			Instance = this;
			if (rectTransform == null)
			{
				rectTransform = GetComponent<RectTransform>();
			}
			Initialize();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
		}

		private void Update()
		{
			if (!fadeGroup.IsHidingInProgress && fadeGroup.IsShown && (Mouse.current.leftButton.wasReleasedThisFrame || targetView == null || !targetView.open || (!fadeGroup.IsShowingInProgress && Mouse.current.rightButton.wasReleasedThisFrame)))
			{
				Close();
			}
		}

		private void Initialize()
		{
			btn_Use.onClick.AddListener(Use);
			btn_Split.onClick.AddListener(Split);
			btn_Dump.onClick.AddListener(Dump);
			btn_Equip.onClick.AddListener(Equip);
			btn_Modify.onClick.AddListener(Modify);
			btn_Unload.onClick.AddListener(Unload);
			btn_Wishlist.onClick.AddListener(Wishlist);
		}

		private void Wishlist()
		{
			if (!(TargetItem == null))
			{
				int typeID = TargetItem.TypeID;
				if (ItemWishlist.GetWishlistInfo(typeID).isManuallyWishlisted)
				{
					ItemWishlist.RemoveFromWishlist(typeID);
				}
				else
				{
					ItemWishlist.AddToWishList(TargetItem.TypeID);
				}
			}
		}

		private void Use()
		{
			LevelManager.Instance?.MainCharacter?.UseItem(TargetItem);
			InventoryView.Hide();
			Close();
		}

		private void Split()
		{
			SplitDialogue.SetupAndShow(TargetItem);
			Close();
		}

		private void Dump()
		{
			if ((bool)LevelManager.Instance?.MainCharacter)
			{
				TargetItem.Drop(LevelManager.Instance.MainCharacter, createRigidbody: true);
			}
			Close();
		}

		private void Modify()
		{
			if (TargetItem == null)
			{
				return;
			}
			ItemCustomizeView instance = ItemCustomizeView.Instance;
			if (!(instance == null))
			{
				List<Inventory> list = new List<Inventory>();
				Inventory inventory = LevelManager.Instance?.MainCharacter?.CharacterItem?.Inventory;
				if ((bool)inventory)
				{
					list.Add(inventory);
				}
				instance.Setup(TargetItem, list);
				instance.Open();
				Close();
			}
		}

		private void Equip()
		{
			LevelManager.Instance?.MainCharacter?.CharacterItem?.TryPlug(TargetItem);
			Close();
		}

		private void Unload()
		{
			ItemSetting_Gun itemSetting_Gun = TargetItem?.GetComponent<ItemSetting_Gun>();
			if (!(itemSetting_Gun == null))
			{
				AudioManager.Post("SFX/Combat/Gun/unload");
				itemSetting_Gun.TakeOutAllBullets();
			}
		}

		protected override void OnOpen()
		{
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			fadeGroup.Hide();
			displayingItem = null;
		}

		public static void Show(ItemDisplay id)
		{
			if (!(Instance == null))
			{
				Instance.MShow(id);
			}
		}

		private void MShow(ItemDisplay targetDisplay)
		{
			if (!(targetDisplay == null))
			{
				TargetDisplay = targetDisplay;
				targetView = targetDisplay.GetComponentInParent<View>();
				Setup();
				Open();
			}
		}

		private void Setup()
		{
			if (!(TargetItem == null))
			{
				displayingItem = TargetItem;
				icon.sprite = TargetItem.Icon;
				nameText.text = TargetItem.DisplayName;
				btn_Use.gameObject.SetActive(Usable);
				btn_Use.interactable = UseButtonInteractable;
				btn_Split.gameObject.SetActive(Splittable);
				btn_Dump.gameObject.SetActive(Dumpable);
				btn_Equip.gameObject.SetActive(Equipable);
				btn_Modify.gameObject.SetActive(Modifyable);
				btn_Unload.gameObject.SetActive(Unloadable);
				RefreshWeightText();
				RefreshPosition();
			}
		}

		private void RefreshPosition()
		{
			RectTransform obj = TargetDisplay.transform as RectTransform;
			Rect rect = obj.rect;
			Vector2 min = rect.min;
			Vector2 max = rect.max;
			Vector3 point = obj.localToWorldMatrix.MultiplyPoint(min);
			Vector3 point2 = obj.localToWorldMatrix.MultiplyPoint(max);
			Vector3 vector = rectTransform.worldToLocalMatrix.MultiplyPoint(point);
			Vector3 vector2 = rectTransform.worldToLocalMatrix.MultiplyPoint(point2);
			Vector2[] array = new Vector2[4]
			{
				new Vector2(vector.x, vector.y),
				new Vector2(vector.x, vector2.y),
				new Vector2(vector2.x, vector.y),
				new Vector2(vector2.x, vector2.y)
			};
			int num = 0;
			float num2 = float.MaxValue;
			Vector2 center = rectTransform.rect.center;
			for (int i = 0; i < array.Length; i++)
			{
				float sqrMagnitude = (array[i] - center).sqrMagnitude;
				if (sqrMagnitude < num2)
				{
					num = i;
					num2 = sqrMagnitude;
				}
			}
			bool flag = (num & 2) > 0;
			bool flag2 = (num & 1) > 0;
			float x = (flag ? vector2.x : vector.x);
			float y = (flag2 ? vector.y : vector2.y);
			contentRectTransform.pivot = new Vector2((!flag) ? 1 : 0, (!flag2) ? 1 : 0);
			contentRectTransform.localPosition = new Vector2(x, y);
		}

		private void RefreshWeightText()
		{
			if (!(displayingItem == null))
			{
				weightText.text = string.Format(weightTextFormat, displayingItem.TotalWeight);
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Close();
		}
	}
	public class ItemSlotCollectionDisplay : MonoBehaviour
	{
		[SerializeField]
		private Transform entriesParent;

		[SerializeField]
		private UnityEngine.CanvasGroup notEditableIndicator;

		[SerializeField]
		private bool editable = true;

		[SerializeField]
		private bool contentSelectable = true;

		[SerializeField]
		private bool showOperationMenu = true;

		[SerializeField]
		private bool notifyNotEditable;

		[SerializeField]
		private float fadeDuration = 1f;

		[SerializeField]
		private float sustainDuration = 1f;

		private List<SlotDisplay> slots = new List<SlotDisplay>();

		private int currentToken;

		public bool Editable
		{
			get
			{
				return editable;
			}
			internal set
			{
				editable = value;
			}
		}

		public bool ContentSelectable
		{
			get
			{
				return contentSelectable;
			}
			set
			{
				contentSelectable = value;
			}
		}

		public bool ShowOperationMenu => showOperationMenu;

		public bool Movable { get; private set; }

		public Item Target { get; private set; }

		public event Action<ItemSlotCollectionDisplay, SlotDisplay> onElementClicked;

		public event Action<ItemSlotCollectionDisplay, SlotDisplay> onElementDoubleClicked;

		public void Setup(Item target, bool movable = false)
		{
			Target = target;
			Clear();
			if (Target == null || Target.Slots == null)
			{
				return;
			}
			Movable = movable;
			for (int i = 0; i < Target.Slots.Count; i++)
			{
				Slot slot = Target.Slots[i];
				if (slot != null)
				{
					SlotDisplay slotDisplay = SlotDisplay.Get();
					slotDisplay.onSlotDisplayClicked += OnSlotDisplayClicked;
					slotDisplay.onSlotDisplayDoubleClicked += OnSlotDisplayDoubleClicked;
					slotDisplay.ShowOperationMenu = ShowOperationMenu;
					slotDisplay.Setup(slot);
					slotDisplay.Editable = editable;
					slotDisplay.ContentSelectable = contentSelectable;
					slotDisplay.transform.SetParent(entriesParent, worldPositionStays: false);
					slotDisplay.Movable = Movable;
					slots.Add(slotDisplay);
				}
			}
		}

		private void OnSlotDisplayDoubleClicked(SlotDisplay display)
		{
			this.onElementDoubleClicked?.Invoke(this, display);
		}

		private void Clear()
		{
			foreach (SlotDisplay slot in slots)
			{
				slot.onSlotDisplayClicked -= OnSlotDisplayClicked;
				SlotDisplay.Release(slot);
			}
			slots.Clear();
			entriesParent.DestroyAllChildren();
		}

		private void OnSlotDisplayClicked(SlotDisplay display)
		{
			this.onElementClicked?.Invoke(this, display);
			if (!editable && notifyNotEditable)
			{
				ShowNotEditableIndicator().Forget();
			}
		}

		private async UniTask ShowNotEditableIndicator()
		{
			int token = UnityEngine.Random.Range(int.MinValue, int.MaxValue);
			currentToken = token;
			notEditableIndicator.DOKill();
			await notEditableIndicator.DOFade(1f, fadeDuration);
			if (!TokenChanged())
			{
				await UniTask.WaitForSeconds(sustainDuration, ignoreTimeScale: true);
				if (!TokenChanged())
				{
					await notEditableIndicator.DOFade(0f, fadeDuration);
				}
			}
			bool TokenChanged()
			{
				return token != currentToken;
			}
		}
	}
	public class SlotDisplay : MonoBehaviour, Duckov.Utilities.IPoolable, IPointerClickHandler, IEventSystemHandler, IItemDragSource, IBeginDragHandler, IEndDragHandler, IDragHandler, IDropHandler, IPointerEnterHandler, IPointerExitHandler
	{
		[SerializeField]
		private Sprite defaultSlotIcon;

		[SerializeField]
		private TextMeshProUGUI label;

		[SerializeField]
		private ItemDisplay itemDisplay;

		[SerializeField]
		private UnityEngine.UI.Image slotIcon;

		[SerializeField]
		private FadeGroup pluggableIndicator;

		[SerializeField]
		private GameObject hoveringIndicator;

		[SerializeField]
		private bool editable = true;

		[SerializeField]
		private bool showOperationMenu = true;

		[SerializeField]
		private bool contentSelectable = true;

		[SerializeField]
		[Range(0f, 1f)]
		private float punchDuration = 0.1f;

		[SerializeField]
		[Range(-1f, 1f)]
		private float slotIconPunchScale = -0.1f;

		[SerializeField]
		[Range(0f, 1f)]
		private float denialPunchDuration = 0.2f;

		[SerializeField]
		private Color slotIconDenialColor = Color.red;

		private Color iconInitialColor;

		private bool hovering;

		public bool Editable
		{
			get
			{
				return editable;
			}
			internal set
			{
				editable = value;
			}
		}

		public bool ContentSelectable
		{
			get
			{
				return contentSelectable;
			}
			internal set
			{
				contentSelectable = value;
			}
		}

		public bool ShowOperationMenu
		{
			get
			{
				return showOperationMenu;
			}
			internal set
			{
				showOperationMenu = value;
			}
		}

		public Slot Target { get; private set; }

		public static PrefabPool<SlotDisplay> Pool => GameplayUIManager.Instance.SlotDisplayPool;

		public bool Movable
		{
			get
			{
				return itemDisplay.Movable;
			}
			set
			{
				itemDisplay.Movable = value;
			}
		}

		internal event Action<SlotDisplay> onSlotDisplayClicked;

		internal event Action<SlotDisplay> onSlotDisplayDoubleClicked;

		public static event Action<SlotDisplayOperationContext> onOperation;

		private void RegisterEvents()
		{
			UnregisterEvents();
			if (base.isActiveAndEnabled)
			{
				if (Target != null)
				{
					Target.onSlotContentChanged += OnTargetContentChanged;
				}
				ItemUIUtilities.OnSelectionChanged += OnItemSelectionChanged;
				itemDisplay.onPointerClick += OnItemDisplayClicked;
				itemDisplay.onDoubleClicked += OnItemDisplayDoubleClicked;
				IItemDragSource.OnStartDragItem += OnStartDragItem;
				IItemDragSource.OnEndDragItem += OnEndDragItem;
				UIInputManager.OnFastPick += OnFastPick;
				UIInputManager.OnDropItem += OnFastDrop;
				UIInputManager.OnUseItem += OnFastUse;
			}
		}

		private void UnregisterEvents()
		{
			if (Target != null)
			{
				Target.onSlotContentChanged -= OnTargetContentChanged;
			}
			ItemUIUtilities.OnSelectionChanged -= OnItemSelectionChanged;
			itemDisplay.onPointerClick -= OnItemDisplayClicked;
			itemDisplay.onDoubleClicked -= OnItemDisplayDoubleClicked;
			IItemDragSource.OnStartDragItem -= OnStartDragItem;
			IItemDragSource.OnEndDragItem -= OnEndDragItem;
			UIInputManager.OnFastPick -= OnFastPick;
			UIInputManager.OnDropItem -= OnFastDrop;
			UIInputManager.OnUseItem -= OnFastUse;
		}

		private void OnFastDrop(UIInputEventData data)
		{
			if (base.isActiveAndEnabled && hovering && Target != null && !(Target.Content == null) && Target.Content.CanDrop && Editable)
			{
				Target.Content.Drop(CharacterMainControl.Main, createRigidbody: true);
			}
		}

		private void OnFastUse(UIInputEventData data)
		{
			if (base.isActiveAndEnabled && hovering && Target != null && !(Target.Content == null) && Target.Content.IsUsable(CharacterMainControl.Main))
			{
				CharacterMainControl.Main.UseItem(Target.Content);
			}
		}

		private void OnFastPick(UIInputEventData data)
		{
			if (base.isActiveAndEnabled && hovering)
			{
				OnItemDisplayDoubleClicked(itemDisplay, new PointerEventData(EventSystem.current));
			}
		}

		private void OnEndDragItem(Item item)
		{
			pluggableIndicator.Hide();
		}

		private void OnStartDragItem(Item item)
		{
			if (base.isActiveAndEnabled && Editable)
			{
				if (item != Target.Content && Target.CanPlug(item))
				{
					pluggableIndicator.Show();
				}
				else
				{
					pluggableIndicator.Hide();
				}
			}
		}

		private void OnItemDisplayDoubleClicked(ItemDisplay arg1, PointerEventData arg2)
		{
			this.onSlotDisplayDoubleClicked?.Invoke(this);
			if (!ContentSelectable)
			{
				arg2.Use();
			}
		}

		private void OnItemDisplayClicked(ItemDisplay display, PointerEventData data)
		{
			this.onSlotDisplayClicked?.Invoke(this);
			if (data.button == PointerEventData.InputButton.Left)
			{
				if (Keyboard.current != null && Keyboard.current.altKey.isPressed)
				{
					if (!Editable || !(Target.Content != null))
					{
						return;
					}
					Item content = Target.Content;
					content.Detach();
					if (!ItemUtilities.SendToPlayerCharacterInventory(content))
					{
						if (PlayerStorage.IsAccessableAndNotFull())
						{
							ItemUtilities.SendToPlayerStorage(content);
						}
						else
						{
							ItemUtilities.SendToPlayer(content, dontMerge: false, sendToStorage: false);
						}
					}
					data.Use();
				}
				else if (!ContentSelectable)
				{
					data.Use();
				}
			}
			else if (data.button == PointerEventData.InputButton.Right && Editable && Target?.Content != null)
			{
				ItemOperationMenu.Show(itemDisplay);
			}
		}

		private void OnTargetContentChanged(Slot slot)
		{
			Refresh();
			Punch();
		}

		private void OnItemSelectionChanged()
		{
		}

		public void Setup(Slot target)
		{
			UnregisterEvents();
			Target = target;
			label.text = target.DisplayName;
			Refresh();
			RegisterEvents();
			pluggableIndicator.Hide();
		}

		private void Refresh()
		{
			if (Target.Content == null)
			{
				slotIcon.gameObject.SetActive(value: true);
				if (Target.SlotIcon != null)
				{
					slotIcon.sprite = Target.SlotIcon;
				}
				else
				{
					slotIcon.sprite = defaultSlotIcon;
				}
			}
			else
			{
				slotIcon.gameObject.SetActive(value: false);
			}
			itemDisplay.ShowOperationButtons = showOperationMenu;
			itemDisplay.Setup(Target.Content);
		}

		public static SlotDisplay Get()
		{
			return Pool.Get();
		}

		public static void Release(SlotDisplay item)
		{
			Pool.Release(item);
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			Target = null;
		}

		private void Awake()
		{
			itemDisplay.onReceiveDrop += OnDrop;
		}

		private void OnEnable()
		{
			RegisterEvents();
			iconInitialColor = slotIcon.color;
			hoveringIndicator?.SetActive(value: false);
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			this.onSlotDisplayClicked?.Invoke(this);
			if (!Editable)
			{
				Punch();
				eventData.Use();
			}
			else
			{
				if (eventData.button != PointerEventData.InputButton.Left)
				{
					return;
				}
				Item selectedItem = ItemUIUtilities.SelectedItem;
				if (selectedItem == null)
				{
					Punch();
					return;
				}
				if (Target.Content != null)
				{
					UnityEngine.Debug.Log("槽位 " + Target.DisplayName + " 中已经有物品。操作已取消。");
					DenialPunch();
					return;
				}
				if (!Target.CanPlug(selectedItem))
				{
					UnityEngine.Debug.Log("物品 " + selectedItem.DisplayName + " 未通过槽位 " + Target.DisplayName + " 安装检测。操作已取消。");
					DenialPunch();
					return;
				}
				eventData.Use();
				selectedItem.Detach();
				Target.Plug(selectedItem, out var unpluggedItem);
				ItemUIUtilities.NotifyPutItem(selectedItem);
				if (unpluggedItem != null)
				{
					ItemUIUtilities.RaiseOrphan(unpluggedItem);
				}
				Punch();
			}
		}

		public void Punch()
		{
			if (slotIcon != null)
			{
				slotIcon.transform.DOKill();
				slotIcon.color = iconInitialColor;
				slotIcon.transform.localScale = Vector3.one;
				slotIcon.transform.DOPunchScale(Vector3.one * slotIconPunchScale, punchDuration);
			}
			if (itemDisplay != null)
			{
				itemDisplay.Punch();
			}
		}

		public void DenialPunch()
		{
			if (!(slotIcon == null))
			{
				slotIcon.transform.DOKill();
				slotIcon.color = iconInitialColor;
				slotIcon.DOColor(slotIconDenialColor, denialPunchDuration).From();
				SlotDisplay.onOperation?.Invoke(new SlotDisplayOperationContext(this, SlotDisplayOperationContext.Operation.Deny, succeed: false));
			}
		}

		public bool IsEditable()
		{
			return Editable;
		}

		public Item GetItem()
		{
			return Target?.Content;
		}

		public void OnDrop(PointerEventData eventData)
		{
			if (!Editable || eventData.used || eventData.button != PointerEventData.InputButton.Left)
			{
				return;
			}
			IItemDragSource component = eventData.pointerDrag.gameObject.GetComponent<IItemDragSource>();
			if (component == null || !component.IsEditable())
			{
				return;
			}
			Item item = component.GetItem();
			if (item == null || SetAmmo(item))
			{
				return;
			}
			if (!Target.CanPlug(item))
			{
				UnityEngine.Debug.Log("物品 " + item.DisplayName + " 未通过槽位 " + Target.DisplayName + " 安装检测。操作已取消。");
				DenialPunch();
				return;
			}
			Inventory inInventory = item.InInventory;
			Slot pluggedIntoSlot = item.PluggedIntoSlot;
			if (pluggedIntoSlot == Target)
			{
				return;
			}
			ItemUIUtilities.NotifyPutItem(item);
			bool flag = false;
			flag = Target.Plug(item, out var unpluggedItem);
			if (unpluggedItem != null && (!(inInventory != null) || !inInventory.AddAndMerge(unpluggedItem)))
			{
				if (pluggedIntoSlot != null && pluggedIntoSlot.CanPlug(unpluggedItem) && pluggedIntoSlot.Plug(unpluggedItem, out var unpluggedItem2))
				{
					if ((bool)unpluggedItem2)
					{
						UnityEngine.Debug.LogError("Source slot spit out an unplugged item! " + unpluggedItem2.DisplayName);
					}
				}
				else if (!ItemUtilities.SendToPlayerCharacter(unpluggedItem) && (!(View.ActiveView is LootView lootView) || !(lootView.TargetInventory != null) || !lootView.TargetInventory.AddAndMerge(unpluggedItem)))
				{
					if (PlayerStorage.IsAccessableAndNotFull())
					{
						ItemUtilities.SendToPlayerStorage(unpluggedItem);
					}
					else
					{
						unpluggedItem.Drop(CharacterMainControl.Main, createRigidbody: true);
					}
				}
			}
			SlotDisplay.onOperation?.Invoke(new SlotDisplayOperationContext(this, SlotDisplayOperationContext.Operation.Equip, flag));
		}

		public void OnDrag(PointerEventData eventData)
		{
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			hovering = true;
			hoveringIndicator?.SetActive(Editable);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			hovering = false;
			hoveringIndicator?.SetActive(value: false);
		}

		private bool SetAmmo(Item incomming)
		{
			ItemSetting_Gun itemSetting_Gun = Target?.Content?.GetComponent<ItemSetting_Gun>();
			if (itemSetting_Gun == null)
			{
				return false;
			}
			if (!itemSetting_Gun.IsValidBullet(incomming))
			{
				return false;
			}
			if (View.ActiveView is InventoryView || View.ActiveView is LootView)
			{
				View.ActiveView.Close();
			}
			return itemSetting_Gun.LoadSpecificBullet(incomming);
		}
	}
	public struct SlotDisplayOperationContext
	{
		public enum Operation
		{
			None,
			Equip,
			Unequip,
			Deny
		}

		public SlotDisplay slotDisplay;

		public Operation operation;

		public bool succeed;

		public SlotDisplayOperationContext(SlotDisplay slotDisplay, Operation operation, bool succeed)
		{
			this.slotDisplay = slotDisplay;
			this.operation = operation;
			this.succeed = succeed;
		}
	}
	public class SlotIndicator : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		[SerializeField]
		private GameObject contentIndicator;

		public Slot Target { get; private set; }

		public void Setup(Slot target)
		{
			UnregisterEvents();
			Target = target;
			RegisterEvents();
			Refresh();
		}

		private void RegisterEvents()
		{
			if (Target != null)
			{
				UnregisterEvents();
				Target.onSlotContentChanged += OnSlotContentChanged;
			}
		}

		private void UnregisterEvents()
		{
			if (Target != null)
			{
				Target.onSlotContentChanged -= OnSlotContentChanged;
			}
		}

		private void OnSlotContentChanged(Slot slot)
		{
			if (slot != Target)
			{
				UnityEngine.Debug.LogError("Slot内容改变事件触发了，但它来自别的Slot。这说明Slot Indicator注册的事件发生了泄露，请检查代码。");
			}
			else
			{
				Refresh();
			}
		}

		private void Refresh()
		{
			if (!(contentIndicator == null) && Target != null)
			{
				contentIndicator.SetActive(Target.Content);
			}
		}

		public void NotifyPooled()
		{
			RegisterEvents();
			Refresh();
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			Target = null;
			contentIndicator.SetActive(value: false);
		}

		private void OnEnable()
		{
			RegisterEvents();
			Refresh();
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}
	}
	public class TagsDisplay : MonoBehaviour
	{
		[SerializeField]
		private TagsDisplayEntry entryTemplate;

		private PrefabPool<TagsDisplayEntry> _entryPool;

		private PrefabPool<TagsDisplayEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<TagsDisplayEntry>(entryTemplate);
				}
				return _entryPool;
			}
		}

		private void Awake()
		{
			entryTemplate.gameObject.SetActive(value: false);
		}

		public void Setup(Item item)
		{
			EntryPool.ReleaseAll();
			if (item == null)
			{
				return;
			}
			foreach (Tag tag in item.Tags)
			{
				if (!(tag == null) && tag.Show)
				{
					EntryPool.Get().Setup(tag);
				}
			}
		}

		internal void Clear()
		{
			EntryPool.ReleaseAll();
		}
	}
	public class TagsDisplayEntry : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, ITooltipsProvider
	{
		[SerializeField]
		private UnityEngine.UI.Image background;

		[SerializeField]
		private TextMeshProUGUI text;

		private Tag target;

		public string GetTooltipsText()
		{
			if (target == null)
			{
				return "";
			}
			return target.Description;
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (!(target == null) && target.ShowDescription)
			{
				Tooltips.NotifyEnterTooltipsProvider(this);
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			Tooltips.NotifyExitTooltipsProvider(this);
		}

		private void OnDisable()
		{
			Tooltips.NotifyExitTooltipsProvider(this);
		}

		public void Setup(Tag tag)
		{
			target = tag;
			background.color = tag.Color;
			text.text = tag.DisplayName;
		}
	}
	public class InventoryEntryTradingPriceDisplay : MonoBehaviour
	{
		[SerializeField]
		private InventoryEntry master;

		[SerializeField]
		private UnityEngine.CanvasGroup canvasGroup;

		[SerializeField]
		private TextMeshProUGUI priceText;

		[SerializeField]
		private bool selling = true;

		[SerializeField]
		private string moneyFormat = "n0";

		public bool Selling
		{
			get
			{
				return selling;
			}
			set
			{
				selling = value;
			}
		}

		private void Awake()
		{
			master.onRefresh += OnRefresh;
			TradingUIUtilities.OnActiveMerchantChanged += OnActiveMerchantChanged;
		}

		private void OnActiveMerchantChanged(IMerchant merchant)
		{
			Refresh();
		}

		private void Start()
		{
			Refresh();
		}

		private void OnDestroy()
		{
			if (master != null)
			{
				master.onRefresh -= OnRefresh;
			}
			TradingUIUtilities.OnActiveMerchantChanged -= OnActiveMerchantChanged;
		}

		private void OnRefresh(InventoryEntry entry)
		{
			Refresh();
		}

		private void Refresh()
		{
			Item item = master?.Content;
			if (item != null)
			{
				canvasGroup.alpha = 1f;
				string text = GetPrice(item).ToString(moneyFormat);
				priceText.text = text;
			}
			else
			{
				canvasGroup.alpha = 0f;
			}
		}

		private int GetPrice(Item content)
		{
			if (content == null)
			{
				return 0;
			}
			int value = content.Value;
			if (TradingUIUtilities.ActiveMerchant == null)
			{
				return value;
			}
			return TradingUIUtilities.ActiveMerchant.ConvertPrice(content, selling);
		}
	}
	public class WeaponButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private string targetSlotKey = "PrimaryWeapon";

		[SerializeField]
		private GameObject displayParent;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TrueShadow iconShadow;

		[SerializeField]
		private GameObject selectionFrame;

		public UnityEvent<WeaponButton> onClick;

		public UnityEvent<WeaponButton> onRefresh;

		public UnityEvent<WeaponButton> onSelected;

		private CharacterMainControl _character;

		private Slot _targetSlot;

		private bool isBeingDestroyed;

		private CharacterMainControl Character => _character;

		private Slot TargetSlot => _targetSlot;

		private Item TargetItem => TargetSlot?.Content;

		private bool IsSelected
		{
			get
			{
				if (TargetItem?.ActiveAgent != null)
				{
					return TargetItem.ActiveAgent == _character.agentHolder?.CurrentHoldItemAgent;
				}
				return false;
			}
		}

		public static event Action<WeaponButton> OnWeaponButtonSelected;

		private void Awake()
		{
			RegisterStaticEvents();
			if (LevelManager.Instance?.MainCharacter != null)
			{
				Initialize(LevelManager.Instance.MainCharacter);
			}
		}

		private void OnDestroy()
		{
			UnregisterStaticEvents();
			isBeingDestroyed = true;
		}

		private void RegisterStaticEvents()
		{
			LevelManager.OnLevelInitialized += OnLevelInitialized;
			CharacterMainControl.OnMainCharacterChangeHoldItemAgentEvent = (Action<CharacterMainControl, DuckovItemAgent>)Delegate.Combine(CharacterMainControl.OnMainCharacterChangeHoldItemAgentEvent, new Action<CharacterMainControl, DuckovItemAgent>(OnMainCharacterChangeHoldItemAgent));
		}

		private void UnregisterStaticEvents()
		{
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
			CharacterMainControl.OnMainCharacterChangeHoldItemAgentEvent = (Action<CharacterMainControl, DuckovItemAgent>)Delegate.Remove(CharacterMainControl.OnMainCharacterChangeHoldItemAgentEvent, new Action<CharacterMainControl, DuckovItemAgent>(OnMainCharacterChangeHoldItemAgent));
		}

		private void OnMainCharacterChangeHoldItemAgent(CharacterMainControl control, DuckovItemAgent agent)
		{
			if ((bool)_character && control == _character)
			{
				Refresh();
			}
		}

		private void OnLevelInitialized()
		{
			Initialize(LevelManager.Instance?.MainCharacter);
		}

		private void Initialize(CharacterMainControl character)
		{
			UnregisterEvents();
			_character = character;
			if (character == null)
			{
				UnityEngine.Debug.LogError("Character 不存在，初始化失败");
			}
			if (character.CharacterItem == null)
			{
				UnityEngine.Debug.LogError("Character item 不存在，初始化失败");
			}
			_targetSlot = character.CharacterItem.Slots.GetSlot(targetSlotKey);
			if (_targetSlot == null)
			{
				UnityEngine.Debug.LogError("Slot " + targetSlotKey + " 不存在，初始化失败");
			}
			RegisterEvents();
			Refresh();
		}

		private void RegisterEvents()
		{
			if (_targetSlot != null)
			{
				_targetSlot.onSlotContentChanged += OnSlotContentChanged;
			}
		}

		private void UnregisterEvents()
		{
			if (_targetSlot != null)
			{
				_targetSlot.onSlotContentChanged -= OnSlotContentChanged;
			}
		}

		private void OnSlotContentChanged(Slot slot)
		{
			Refresh();
		}

		private void Refresh()
		{
			if (!isBeingDestroyed)
			{
				displayParent.SetActive(TargetItem);
				bool isSelected = IsSelected;
				if ((bool)TargetItem)
				{
					icon.sprite = TargetItem.Icon;
					(float, Color, bool) shadowOffsetAndColorOfQuality = GameplayDataSettings.UIStyle.GetShadowOffsetAndColorOfQuality(TargetItem.DisplayQuality);
					iconShadow.Inset = shadowOffsetAndColorOfQuality.Item3;
					iconShadow.Color = shadowOffsetAndColorOfQuality.Item2;
					iconShadow.OffsetDistance = shadowOffsetAndColorOfQuality.Item1;
					selectionFrame.SetActive(isSelected);
				}
				onRefresh?.Invoke(this);
				if (isSelected)
				{
					onSelected?.Invoke(this);
					WeaponButton.OnWeaponButtonSelected?.Invoke(this);
				}
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (!(Character == null))
			{
				onClick?.Invoke(this);
			}
		}
	}
	public class HealthBar : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		private RectTransform rectTransform;

		[SerializeField]
		private GameObject background;

		[SerializeField]
		private UnityEngine.UI.Image fill;

		[SerializeField]
		private UnityEngine.UI.Image followFill;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private GameObject deathIndicator;

		[SerializeField]
		private PunchReceiver deathIndicatorPunchReceiver;

		[SerializeField]
		private UnityEngine.UI.Image hurtBlink;

		[SerializeField]
		private HealthBar_DamageBar damageBarTemplate;

		[SerializeField]
		private Gradient colorOverAmount = new Gradient();

		[SerializeField]
		private float followFillDuration = 0.5f;

		[SerializeField]
		private float blinkDuration = 0.1f;

		[SerializeField]
		private Color blinkColor = Color.white;

		private Vector3 displayOffset = Vector3.zero;

		[SerializeField]
		private float releaseAfterOutOfFrame = 1f;

		[SerializeField]
		private float disappearDelay = 0.2f;

		[SerializeField]
		private UnityEngine.UI.Image levelIcon;

		[SerializeField]
		private TextMeshProUGUI nameText;

		[SerializeField]
		private UnityEvent onHurt;

		[SerializeField]
		private UnityEvent onDead;

		private Action releaseAction;

		private float lastTimeInFrame = float.MinValue;

		private float screenYOffset = 0.02f;

		private PrefabPool<HealthBar_DamageBar> _damageBarPool;

		private bool pooled;

		private Vector3[] cornersBuffer = new Vector3[4];

		public Health target { get; private set; }

		private PrefabPool<HealthBar_DamageBar> DamageBarPool
		{
			get
			{
				if (_damageBarPool == null)
				{
					_damageBarPool = new PrefabPool<HealthBar_DamageBar>(damageBarTemplate);
				}
				return _damageBarPool;
			}
		}

		public void NotifyPooled()
		{
			pooled = true;
		}

		public void NotifyReleased()
		{
			UnregisterEvents();
			target = null;
			pooled = false;
		}

		private void Awake()
		{
			rectTransform = base.transform as RectTransform;
		}

		private void OnDestroy()
		{
			UnregisterEvents();
			followFill?.DOKill();
			hurtBlink?.DOKill();
		}

		private void LateUpdate()
		{
			if (target == null || !target.isActiveAndEnabled || target.Hidden)
			{
				Release();
			}
			else
			{
				UpdatePosition();
			}
		}

		private bool CheckInFrame()
		{
			rectTransform.GetWorldCorners(cornersBuffer);
			Vector3[] array = cornersBuffer;
			for (int i = 0; i < array.Length; i++)
			{
				Vector3 vector = array[i];
				if (vector.x > 0f && vector.x < (float)Screen.width && vector.y > 0f && vector.y < (float)Screen.height)
				{
					return true;
				}
			}
			return false;
		}

		private void UpdateFrame()
		{
			if (CheckInFrame())
			{
				lastTimeInFrame = Time.unscaledTime;
			}
			if (Time.unscaledTime - lastTimeInFrame > releaseAfterOutOfFrame)
			{
				Release();
			}
		}

		private void UpdatePosition()
		{
			Vector3 position = target.transform.position + displayOffset;
			Vector3 position2 = Camera.main.WorldToScreenPoint(position);
			position2.y += screenYOffset * (float)Screen.height;
			base.transform.position = position2;
		}

		public void Setup(Health target, DamageInfo? damage = null, Action releaseAction = null)
		{
			this.releaseAction = releaseAction;
			UnregisterEvents();
			if (target == null)
			{
				Release();
				return;
			}
			if (target.IsDead)
			{
				Release();
				return;
			}
			background.SetActive(value: true);
			deathIndicator.SetActive(value: false);
			fill.gameObject.SetActive(value: true);
			followFill.gameObject.SetActive(value: true);
			this.target = target;
			RefreshOffset();
			RegisterEvents();
			Refresh();
			lastTimeInFrame = Time.unscaledTime;
			damageBarTemplate.gameObject.SetActive(value: false);
			if (damage.HasValue)
			{
				OnTargetHurt(damage.Value);
			}
			UpdatePosition();
		}

		public void RefreshOffset()
		{
			if (!target)
			{
				return;
			}
			displayOffset = Vector3.up * 1.5f;
			CharacterMainControl characterMainControl = target.TryGetCharacter();
			if ((bool)characterMainControl && (bool)characterMainControl.characterModel)
			{
				Transform helmatSocket = characterMainControl.characterModel.HelmatSocket;
				if ((bool)helmatSocket)
				{
					displayOffset = Vector3.up * (Vector3.Distance(characterMainControl.transform.position, helmatSocket.position) + 0.5f);
				}
			}
		}

		private void RegisterEvents()
		{
			if (!(target == null))
			{
				RefreshCharacterIcon();
				target.OnMaxHealthChange.AddListener(OnTargetMaxHealthChange);
				target.OnHealthChange.AddListener(OnTargetHealthChange);
				target.OnHurtEvent.AddListener(OnTargetHurt);
				target.OnDeadEvent.AddListener(OnTargetDead);
			}
		}

		private void RefreshCharacterIcon()
		{
			if (!target)
			{
				levelIcon.gameObject.SetActive(value: false);
				nameText.gameObject.SetActive(value: false);
				return;
			}
			CharacterMainControl characterMainControl = target.TryGetCharacter();
			if (!characterMainControl)
			{
				levelIcon.gameObject.SetActive(value: false);
				nameText.gameObject.SetActive(value: false);
				return;
			}
			CharacterRandomPreset characterPreset = characterMainControl.characterPreset;
			if (!characterPreset)
			{
				levelIcon.gameObject.SetActive(value: false);
				nameText.gameObject.SetActive(value: false);
				return;
			}
			Sprite characterIcon = characterPreset.GetCharacterIcon();
			if (!characterIcon)
			{
				levelIcon.gameObject.SetActive(value: false);
			}
			else
			{
				levelIcon.sprite = characterIcon;
				levelIcon.gameObject.SetActive(value: true);
			}
			if (!characterPreset.showName)
			{
				nameText.gameObject.SetActive(value: false);
				return;
			}
			nameText.text = characterPreset.DisplayName;
			nameText.gameObject.SetActive(value: true);
		}

		private void UnregisterEvents()
		{
			if (!(target == null))
			{
				target.OnMaxHealthChange.RemoveListener(OnTargetMaxHealthChange);
				target.OnHealthChange.RemoveListener(OnTargetHealthChange);
				target.OnHurtEvent.RemoveListener(OnTargetHurt);
				target.OnDeadEvent.RemoveListener(OnTargetDead);
			}
		}

		private void OnTargetMaxHealthChange(Health obj)
		{
			Refresh();
		}

		private void OnTargetHealthChange(Health obj)
		{
			Refresh();
		}

		private void OnTargetHurt(DamageInfo damage)
		{
			Color blinkEndColor = blinkColor;
			blinkEndColor.a = 0f;
			if (hurtBlink != null)
			{
				hurtBlink.DOColor(blinkColor, blinkDuration).From().OnKill(delegate
				{
					if (hurtBlink != null)
					{
						hurtBlink.color = blinkEndColor;
					}
				});
			}
			onHurt?.Invoke();
			ShowDamageBar(damage.finalDamage);
		}

		private void OnTargetDead(DamageInfo damage)
		{
			UnregisterEvents();
			onDead?.Invoke();
			if ((bool)damage.toDamageReceiver && (bool)damage.toDamageReceiver.health)
			{
				DeathTask(damage.toDamageReceiver.health).Forget();
			}
		}

		internal void Release()
		{
			if (pooled && (!(target != null) || !target.IsMainCharacterHealth || target.IsDead || !target.gameObject.activeInHierarchy))
			{
				UnregisterEvents();
				_ = target != null;
				target = null;
				releaseAction?.Invoke();
			}
		}

		private void Refresh()
		{
			float currentHealth = target.CurrentHealth;
			float maxHealth = target.MaxHealth;
			float num = 0f;
			if (maxHealth > 0f)
			{
				num = currentHealth / maxHealth;
			}
			fill.fillAmount = num;
			fill.color = colorOverAmount.Evaluate(num);
			if (followFill != null)
			{
				followFill.DOKill();
				followFill.DOFillAmount(num, followFillDuration);
			}
		}

		private void ShowDamageBar(float damageAmount)
		{
			float num = Mathf.Clamp01(damageAmount / target.MaxHealth);
			float num2 = Mathf.Clamp01(target.CurrentHealth / target.MaxHealth);
			float width = fill.rectTransform.rect.width;
			float damageBarWidth = width * num;
			float damageBarPostion = width * num2;
			HealthBar_DamageBar damageBar = DamageBarPool.Get();
			damageBar.Animate(damageBarPostion, damageBarWidth, delegate
			{
				DamageBarPool.Release(damageBar);
			}).Forget();
		}

		private async UniTask DeathTask(Health health)
		{
			background?.SetActive(value: false);
			deathIndicator?.SetActive(value: true);
			fill?.gameObject.SetActive(value: false);
			followFill?.gameObject.SetActive(value: false);
			deathIndicatorPunchReceiver?.Punch();
			await UniTask.WaitForSeconds(disappearDelay, ignoreTimeScale: true);
			if (health == target)
			{
				Release();
			}
		}
	}
	public class HealthBarManager : MonoBehaviour
	{
		private static HealthBarManager _instance;

		[SerializeField]
		public HealthBar healthBarPrefab;

		private PrefabPool<HealthBar> _prefabPool;

		public static HealthBarManager Instance => _instance;

		private PrefabPool<HealthBar> PrefabPool
		{
			get
			{
				if (_prefabPool == null)
				{
					_prefabPool = new PrefabPool<HealthBar>(healthBarPrefab, base.transform);
				}
				return _prefabPool;
			}
		}

		private void Awake()
		{
			if (_instance == null)
			{
				_instance = this;
			}
			UnregisterStaticEvents();
			RegisterStaticEvents();
		}

		private void OnDestroy()
		{
			UnregisterStaticEvents();
		}

		private void RegisterStaticEvents()
		{
			Health.OnRequestHealthBar += Health_OnRequestHealthBar;
		}

		private void UnregisterStaticEvents()
		{
			Health.OnRequestHealthBar -= Health_OnRequestHealthBar;
		}

		private HealthBar GetActiveHealthBar(Health health)
		{
			if (health == null)
			{
				return null;
			}
			return PrefabPool.ActiveEntries.FirstOrDefault((HealthBar e) => e.target == health);
		}

		private HealthBar CreateHealthBarFor(Health health, DamageInfo? damage = null)
		{
			if (health == null)
			{
				return null;
			}
			if ((bool)PrefabPool.ActiveEntries.FirstOrDefault((HealthBar e) => e.target == health))
			{
				UnityEngine.Debug.Log("Health bar for " + health.name + " already exists");
				return null;
			}
			HealthBar newBar = PrefabPool.Get();
			newBar.Setup(health, damage, delegate
			{
				PrefabPool.Release(newBar);
			});
			return newBar;
		}

		private void Health_OnRequestHealthBar(Health health)
		{
			HealthBar activeHealthBar = GetActiveHealthBar(health);
			if (activeHealthBar != null)
			{
				activeHealthBar.RefreshOffset();
			}
			else
			{
				CreateHealthBarFor(health);
			}
		}

		public static void RequestHealthBar(Health health, DamageInfo? damage = null)
		{
			if (!(Instance == null))
			{
				Instance.CreateHealthBarFor(health, damage);
			}
		}
	}
	public static class ItemUIUtilities
	{
		private static ItemDisplay selectedItemDisplay;

		private static bool cacheGunSelected;

		private static int selectedItemTypeID;

		private static ItemMetaData cachedSelectedItemMeta;

		public static ItemDisplay SelectedItemDisplayRaw => selectedItemDisplay;

		public static ItemDisplay SelectedItemDisplay
		{
			get
			{
				if (selectedItemDisplay == null)
				{
					return null;
				}
				if (selectedItemDisplay.Target == null)
				{
					return null;
				}
				return selectedItemDisplay;
			}
			private set
			{
				selectedItemDisplay?.NotifyUnselected();
				selectedItemDisplay = value;
				Item selectedItem = SelectedItem;
				if (selectedItem == null)
				{
					selectedItemTypeID = -1;
				}
				else
				{
					selectedItemTypeID = selectedItem.TypeID;
					cachedSelectedItemMeta = ItemAssetsCollection.GetMetaData(selectedItemTypeID);
					cacheGunSelected = selectedItem.Tags.Contains("Gun");
				}
				selectedItemDisplay?.NotifySelected();
				ItemUIUtilities.OnSelectionChanged?.Invoke();
			}
		}

		public static Item SelectedItem
		{
			get
			{
				if (SelectedItemDisplay == null)
				{
					return null;
				}
				return SelectedItemDisplay.Target;
			}
		}

		public static bool IsGunSelected
		{
			get
			{
				if (SelectedItem == null)
				{
					return false;
				}
				return cacheGunSelected;
			}
		}

		public static string SelectedItemCaliber => cachedSelectedItemMeta.caliber;

		public static event Action OnSelectionChanged;

		public static event Action<Item> OnOrphanRaised;

		public static event Action<Item, bool> OnPutItem;

		public static void Select(ItemDisplay itemDisplay)
		{
			SelectedItemDisplay = itemDisplay;
		}

		public static void RaiseOrphan(Item orphan)
		{
			if (!(orphan == null))
			{
				ItemUIUtilities.OnOrphanRaised?.Invoke(orphan);
				UnityEngine.Debug.LogWarning($"游戏中出现了孤儿Item {orphan}。");
			}
		}

		public static void NotifyPutItem(Item item, bool pickup = false)
		{
			ItemUIUtilities.OnPutItem?.Invoke(item, pickup);
		}

		public static string GetPropertiesDisplayText(this Item item)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if (item.Variables != null)
			{
				foreach (CustomData variable in item.Variables)
				{
					if (variable.Display)
					{
						stringBuilder.AppendLine(variable.DisplayName + "\t" + variable.GetValueDisplayString());
					}
				}
			}
			if (item.Constants != null)
			{
				foreach (CustomData constant in item.Constants)
				{
					if (constant.Display)
					{
						stringBuilder.AppendLine(constant.DisplayName + "\t" + constant.GetValueDisplayString());
					}
				}
			}
			if (item.Stats != null)
			{
				foreach (Stat stat in item.Stats)
				{
					if (stat.Display)
					{
						stringBuilder.AppendLine($"{stat.DisplayName}\t{stat.Value}");
					}
				}
			}
			if (item.Modifiers != null)
			{
				foreach (ModifierDescription modifier in item.Modifiers)
				{
					if (modifier.Display)
					{
						stringBuilder.AppendLine(modifier.DisplayName + "\t" + modifier.GetDisplayValueString());
					}
				}
			}
			return stringBuilder.ToString();
		}

		public static List<(string name, string value, Polarity polarity)> GetPropertyValueTextPair(this Item item)
		{
			List<(string, string, Polarity)> list = new List<(string, string, Polarity)>();
			if (item.Variables != null)
			{
				foreach (CustomData variable in item.Variables)
				{
					if (variable.Display)
					{
						list.Add((variable.DisplayName, variable.GetValueDisplayString(), Polarity.Neutral));
					}
				}
			}
			if (item.Constants != null)
			{
				foreach (CustomData constant in item.Constants)
				{
					if (constant.Display)
					{
						list.Add((constant.DisplayName, constant.GetValueDisplayString(), Polarity.Neutral));
					}
				}
			}
			if (item.Stats != null)
			{
				foreach (Stat stat in item.Stats)
				{
					if (stat.Display)
					{
						list.Add((stat.DisplayName, stat.Value.ToString(), Polarity.Neutral));
					}
				}
			}
			if (item.Modifiers != null)
			{
				foreach (ModifierDescription modifier in item.Modifiers)
				{
					if (modifier.Display)
					{
						Polarity polarity = StatInfoDatabase.GetPolarity(modifier.Key);
						if (modifier.Value < 0f)
						{
							polarity = (Polarity)(0 - polarity);
						}
						list.Add((modifier.DisplayName, modifier.GetDisplayValueString(), polarity));
					}
				}
			}
			return list;
		}
	}
	public abstract class ManagedUIElement : MonoBehaviour
	{
		[SerializeField]
		private ManagedUIElement parent;

		public bool open { get; private set; }

		protected virtual bool ShowOpenCloseButtons => true;

		public static event Action<ManagedUIElement> onOpen;

		public static event Action<ManagedUIElement> onClose;

		protected virtual void Awake()
		{
			RegisterEvents();
		}

		protected virtual void OnDestroy()
		{
			UnregisterEvents();
			if (open)
			{
				Close();
			}
		}

		public void Open(ManagedUIElement parent = null)
		{
			open = true;
			this.parent = parent;
			ManagedUIElement.onOpen?.Invoke(this);
			OnOpen();
		}

		public void Close()
		{
			open = false;
			parent = null;
			ManagedUIElement.onClose?.Invoke(this);
			OnClose();
		}

		private void RegisterEvents()
		{
			onOpen += OnManagedUIBehaviorOpen;
			onClose += OnManagedUIBehaviorClose;
		}

		private void UnregisterEvents()
		{
			onOpen -= OnManagedUIBehaviorOpen;
			onClose -= OnManagedUIBehaviorClose;
		}

		private void OnManagedUIBehaviorClose(ManagedUIElement obj)
		{
			if (obj != null && obj == parent)
			{
				Close();
			}
		}

		private void OnManagedUIBehaviorOpen(ManagedUIElement obj)
		{
		}

		protected virtual void OnOpen()
		{
		}

		protected virtual void OnClose()
		{
		}
	}
	public class DialogueCanvas : MonoBehaviour
	{
	}
	public class GameplayUIManager : MonoBehaviour
	{
		private static GameplayUIManager instance;

		[SerializeField]
		private UnityEngine.CanvasGroup canvasGroup;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private List<View> views = new List<View>();

		[SerializeField]
		private List<GameObject> setActiveOnAwake;

		private Dictionary<Type, View> viewDic = new Dictionary<Type, View>();

		private PrefabPool<ItemDisplay> itemDisplayPool;

		private PrefabPool<SlotDisplay> slotDisplayPool;

		private PrefabPool<InventoryEntry> inventoryEntryPool;

		[SerializeField]
		private SplitDialogue _splitDialogue;

		public static GameplayUIManager Instance => instance;

		public View ActiveView => View.ActiveView;

		public PrefabPool<ItemDisplay> ItemDisplayPool
		{
			get
			{
				if (itemDisplayPool == null)
				{
					itemDisplayPool = new PrefabPool<ItemDisplay>(GameplayDataSettings.UIPrefabs.ItemDisplay, base.transform);
				}
				return itemDisplayPool;
			}
		}

		public PrefabPool<SlotDisplay> SlotDisplayPool
		{
			get
			{
				if (slotDisplayPool == null)
				{
					slotDisplayPool = new PrefabPool<SlotDisplay>(GameplayDataSettings.UIPrefabs.SlotDisplay, base.transform);
				}
				return slotDisplayPool;
			}
		}

		public PrefabPool<InventoryEntry> InventoryEntryPool
		{
			get
			{
				if (inventoryEntryPool == null)
				{
					inventoryEntryPool = new PrefabPool<InventoryEntry>(GameplayDataSettings.UIPrefabs.InventoryEntry, base.transform);
				}
				return inventoryEntryPool;
			}
		}

		public SplitDialogue SplitDialogue => _splitDialogue;

		public static T GetViewInstance<T>() where T : View
		{
			if (Instance == null)
			{
				return null;
			}
			if (Instance.viewDic.TryGetValue(typeof(T), out var value))
			{
				return value as T;
			}
			View view = Instance.views.Find((View e) => e is T);
			if (view == null)
			{
				return null;
			}
			Instance.viewDic[typeof(T)] = view;
			return view as T;
		}

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Debug.LogWarning("Duplicate Gameplay UI Manager detected!");
			}
			foreach (View view in views)
			{
				view.gameObject.SetActive(value: true);
			}
			foreach (GameObject item in setActiveOnAwake)
			{
				if (!(item == null))
				{
					item.gameObject.SetActive(value: true);
				}
			}
		}

		public static UniTask TemporaryHide()
		{
			if (Instance == null)
			{
				return UniTask.CompletedTask;
			}
			Instance.canvasGroup.blocksRaycasts = false;
			return Instance.fadeGroup.HideAndReturnTask();
		}

		public static UniTask ReverseTemporaryHide()
		{
			if (Instance == null)
			{
				return UniTask.CompletedTask;
			}
			Instance.canvasGroup.blocksRaycasts = true;
			return Instance.fadeGroup.ShowAndReturnTask();
		}
	}
	public class ItemShortcutButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private ItemDisplay itemDisplay;

		[SerializeField]
		private GameObject usingIndicator;

		[SerializeField]
		private GameObject notInteractableIndicator;

		[SerializeField]
		private UnityEngine.UI.Image denialIndicator;

		[SerializeField]
		private Color denialColor;

		private bool isBeingDestroyed;

		private bool requireRefresh;

		private bool lastFrameUsing;

		public int Index { get; private set; }

		public ItemShortcutPanel Master { get; private set; }

		public Inventory Inventory { get; private set; }

		public CharacterMainControl Character { get; private set; }

		public Item TargetItem { get; private set; }

		private bool Interactable
		{
			get
			{
				if ((bool)TargetItem?.UsageUtilities)
				{
					return true;
				}
				if ((bool)TargetItem && TargetItem.HasHandHeldAgent)
				{
					return true;
				}
				if ((bool)TargetItem && TargetItem.GetBool("IsSkill"))
				{
					return true;
				}
				return false;
			}
		}

		private static event Action<int> OnRequireAnimateDenial;

		private Item GetTargetItem()
		{
			return ItemShortcut.Get(Index);
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (!Interactable)
			{
				denialIndicator.color = denialColor;
				denialIndicator.DOColor(Color.clear, 0.1f);
			}
			else if ((bool)Character && (bool)TargetItem && (bool)TargetItem.UsageUtilities && TargetItem.UsageUtilities.IsUsable(TargetItem, Character))
			{
				Character.UseItem(TargetItem);
			}
			else if ((bool)Character && (bool)TargetItem && TargetItem.GetBool("IsSkill"))
			{
				Character.ChangeHoldItem(TargetItem);
			}
			else if ((bool)Character && (bool)TargetItem && TargetItem.HasHandHeldAgent)
			{
				Character.ChangeHoldItem(TargetItem);
			}
			else
			{
				AnimateDenial();
			}
		}

		public void AnimateDenial()
		{
			denialIndicator.DOKill();
			denialIndicator.color = denialColor;
			denialIndicator.DOColor(Color.clear, 0.1f);
		}

		private void Awake()
		{
			OnRequireAnimateDenial += OnStaticAnimateDenial;
		}

		private void OnDestroy()
		{
			OnRequireAnimateDenial -= OnStaticAnimateDenial;
			isBeingDestroyed = true;
			UnregisterEvents();
		}

		private void OnStaticAnimateDenial(int index)
		{
			if (base.isActiveAndEnabled && index == Index)
			{
				AnimateDenial();
			}
		}

		public static void AnimateDenial(int index)
		{
			ItemShortcutButton.OnRequireAnimateDenial?.Invoke(index);
		}

		internal void Initialize(ItemShortcutPanel itemShortcutPanel, int index)
		{
			UnregisterEvents();
			Master = itemShortcutPanel;
			Inventory = Master.Target;
			Index = index;
			Character = Master.Character;
			Refresh();
			RegisterEvents();
		}

		private void Refresh()
		{
			if (!isBeingDestroyed)
			{
				UnregisterEvents();
				TargetItem = GetTargetItem();
				if (TargetItem == null)
				{
					SetupEmpty();
				}
				else
				{
					SetupItem(TargetItem);
				}
				RegisterEvents();
				requireRefresh = false;
			}
		}

		private void SetupItem(Item targetItem)
		{
			if ((bool)notInteractableIndicator)
			{
				notInteractableIndicator.gameObject.SetActive(value: false);
			}
			itemDisplay.Setup(targetItem);
			itemDisplay.gameObject.SetActive(value: true);
			notInteractableIndicator.gameObject.SetActive(!Interactable);
		}

		private void SetupEmpty()
		{
			itemDisplay.gameObject.SetActive(value: false);
		}

		private void RegisterEvents()
		{
			ItemShortcut.OnSetItem += OnItemShortcutSetItem;
			if (Inventory != null)
			{
				Inventory.onContentChanged += OnContentChanged;
			}
			if (TargetItem != null)
			{
				TargetItem.onSetStackCount += OnItemStackCountChanged;
			}
		}

		private void UnregisterEvents()
		{
			ItemShortcut.OnSetItem -= OnItemShortcutSetItem;
			if (Inventory != null)
			{
				Inventory.onContentChanged -= OnContentChanged;
			}
			if (TargetItem != null)
			{
				TargetItem.onSetStackCount -= OnItemStackCountChanged;
			}
		}

		private void OnItemShortcutSetItem(int obj)
		{
			Refresh();
		}

		private void OnItemStackCountChanged(Item item)
		{
			if (!(item != TargetItem))
			{
				requireRefresh = true;
			}
		}

		private void OnContentChanged(Inventory inventory, int index)
		{
			requireRefresh = true;
		}

		private void Update()
		{
			if (requireRefresh)
			{
				Refresh();
			}
			bool flag = TargetItem != null && Character.CurrentHoldItemAgent != null && TargetItem == Character.CurrentHoldItemAgent.Item;
			if (flag && !lastFrameUsing)
			{
				OnStartedUsing();
			}
			else if (!flag && lastFrameUsing)
			{
				OnStoppedUsing();
			}
			usingIndicator.gameObject.SetActive(flag);
		}

		private void OnStartedUsing()
		{
		}

		private void OnStoppedUsing()
		{
		}
	}
	public class ItemShortcutEditorEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler, IDropHandler, IPointerEnterHandler, IPointerExitHandler, IItemDragSource, IBeginDragHandler, IEndDragHandler, IDragHandler
	{
		[SerializeField]
		private ItemDisplay itemDisplay;

		[SerializeField]
		private GameObject hoveringIndicator;

		[SerializeField]
		private int index;

		[SerializeField]
		private InputIndicator indicator;

		private Item displayingItem;

		private bool dirty;

		private Item TargetItem => ItemShortcut.Get(index);

		private void Awake()
		{
			itemDisplay.onPointerClick += OnItemDisplayClicked;
			itemDisplay.onReceiveDrop += OnDrop;
			ItemShortcut.OnSetItem += OnSetItem;
			hoveringIndicator.SetActive(value: false);
		}

		private void OnSetItem(int index)
		{
			if (index == this.index)
			{
				Refresh();
			}
		}

		private void OnItemDisplayClicked(ItemDisplay display, PointerEventData data)
		{
			OnPointerClick(data);
			data.Use();
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (ItemUIUtilities.SelectedItem != null && ItemShortcut.Set(index, ItemUIUtilities.SelectedItem))
			{
				Refresh();
			}
		}

		internal void Refresh()
		{
			UnregisterEvents();
			if (displayingItem != TargetItem)
			{
				itemDisplay.Punch();
			}
			displayingItem = TargetItem;
			itemDisplay.Setup(displayingItem);
			itemDisplay.ShowOperationButtons = false;
			RegisterEvents();
		}

		private void RegisterEvents()
		{
			if (displayingItem != null)
			{
				displayingItem.onParentChanged += OnTargetParentChanged;
				displayingItem.onSetStackCount += OnTargetStackCountChanged;
			}
		}

		private void UnregisterEvents()
		{
			if (displayingItem != null)
			{
				displayingItem.onParentChanged -= OnTargetParentChanged;
				displayingItem.onSetStackCount -= OnTargetStackCountChanged;
			}
		}

		private void OnTargetStackCountChanged(Item item)
		{
			SetDirty();
		}

		private void OnTargetParentChanged(Item item)
		{
			SetDirty();
		}

		private void SetDirty()
		{
			dirty = true;
		}

		private void Update()
		{
			if (dirty)
			{
				Refresh();
			}
		}

		private void OnDestroy()
		{
			UnregisterEvents();
			ItemShortcut.OnSetItem -= OnSetItem;
		}

		internal void Setup(int i)
		{
			index = i;
			Refresh();
			InputActionReference inputActionRef = InputActionReference.Create(GameplayDataSettings.InputActions[$"Character/ItemShortcut{i + 3}"]);
			indicator.Setup(inputActionRef);
		}

		public void OnDrop(PointerEventData eventData)
		{
			eventData.Use();
			IItemDragSource component = eventData.pointerDrag.gameObject.GetComponent<IItemDragSource>();
			if (component == null || !component.IsEditable())
			{
				return;
			}
			Item item = component.GetItem();
			if (!(item == null))
			{
				if (!item.IsInPlayerCharacter())
				{
					ItemUtilities.SendToPlayer(item, dontMerge: false, sendToStorage: false);
				}
				if (ItemShortcut.Set(index, item))
				{
					Refresh();
					AudioManager.Post("UI/click");
				}
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			hoveringIndicator.SetActive(value: true);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			hoveringIndicator.SetActive(value: false);
		}

		public bool IsEditable()
		{
			return TargetItem != null;
		}

		public Item GetItem()
		{
			return TargetItem;
		}

		public void OnDrag(PointerEventData eventData)
		{
		}
	}
	public class ItemShortcutEditorPanel : MonoBehaviour
	{
		[SerializeField]
		private ItemShortcutEditorEntry entryTemplate;

		private PrefabPool<ItemShortcutEditorEntry> _entryPool;

		private PrefabPool<ItemShortcutEditorEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<ItemShortcutEditorEntry>(entryTemplate, entryTemplate.transform.parent);
					entryTemplate.gameObject.SetActive(value: false);
				}
				return _entryPool;
			}
		}

		private void OnEnable()
		{
			Setup();
		}

		private void Setup()
		{
			EntryPool.ReleaseAll();
			for (int i = 0; i <= ItemShortcut.MaxIndex; i++)
			{
				ItemShortcutEditorEntry itemShortcutEditorEntry = EntryPool.Get(entryTemplate.transform.parent);
				itemShortcutEditorEntry.Setup(i);
				itemShortcutEditorEntry.transform.SetAsLastSibling();
			}
		}
	}
	public class ItemShortcutPanel : MonoBehaviour
	{
		[SerializeField]
		private ItemShortcutButton[] buttons;

		private bool initialized;

		public Inventory Target { get; private set; }

		public CharacterMainControl Character { get; internal set; }

		private void Awake()
		{
			LevelManager.OnLevelInitialized += OnLevelInitialized;
			if (LevelManager.LevelInited)
			{
				Initialize();
			}
		}

		private void OnDestroy()
		{
			LevelManager.OnLevelInitialized -= OnLevelInitialized;
		}

		private void OnLevelInitialized()
		{
			Initialize();
		}

		private void Initialize()
		{
			Character = LevelManager.Instance?.MainCharacter;
			if (Character == null)
			{
				return;
			}
			Target = LevelManager.Instance?.MainCharacter?.CharacterItem?.Inventory;
			if (Target == null)
			{
				return;
			}
			for (int i = 0; i < buttons.Length; i++)
			{
				ItemShortcutButton itemShortcutButton = buttons[i];
				if (!(itemShortcutButton == null))
				{
					itemShortcutButton.Initialize(this, i);
				}
			}
			initialized = true;
		}
	}
	public class StorageDock : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private StorageDockEntry entryTemplate;

		[SerializeField]
		private GameObject placeHolder;

		private PrefabPool<StorageDockEntry> _entryPool;

		public static StorageDock Instance => View.GetViewInstance<StorageDock>();

		private PrefabPool<StorageDockEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<StorageDockEntry>(entryTemplate);
				}
				return _entryPool;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			entryTemplate.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			PlayerStorage.OnTakeBufferItem += OnTakeBufferItem;
		}

		private void OnDisable()
		{
			PlayerStorage.OnTakeBufferItem -= OnTakeBufferItem;
		}

		private void OnTakeBufferItem()
		{
			Refresh();
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			if (PlayerStorage.Instance == null)
			{
				Close();
				return;
			}
			fadeGroup.Show();
			Setup();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		private void Setup()
		{
			Refresh();
		}

		private void Refresh()
		{
			EntryPool.ReleaseAll();
			List<ItemTreeData> incomingItemBuffer = PlayerStorage.IncomingItemBuffer;
			for (int i = 0; i < incomingItemBuffer.Count; i++)
			{
				ItemTreeData itemTreeData = incomingItemBuffer[i];
				if (itemTreeData != null)
				{
					EntryPool.Get().Setup(i, itemTreeData);
				}
			}
			placeHolder.gameObject.SetActive(incomingItemBuffer.Count <= 0);
		}

		internal static void Show()
		{
			if (!(Instance == null))
			{
				Instance.Open();
			}
		}
	}
	public class StorageDockEntry : MonoBehaviour
	{
		[SerializeField]
		private ItemMetaDisplay itemDisplay;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private GameObject countDisplay;

		[SerializeField]
		private TextMeshProUGUI countText;

		[SerializeField]
		private UnityEngine.UI.Image bgImage;

		[SerializeField]
		private UnityEngine.UI.Button button;

		[SerializeField]
		private GameObject loadingIndicator;

		[SerializeField]
		private Color colorNormal;

		[SerializeField]
		private Color colorFull;

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKeyNormal;

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKeyInventoryFull;

		private int index;

		private ItemTreeData item;

		private void Awake()
		{
			button.onClick.AddListener(OnButtonClick);
		}

		private void OnButtonClick()
		{
			if (PlayerStorage.IsAccessableAndNotFull())
			{
				TakeTask().Forget();
			}
		}

		private async UniTask TakeTask()
		{
			if (!PlayerStorage.TakingItem)
			{
				loadingIndicator.SetActive(value: true);
				text.gameObject.SetActive(value: false);
				await PlayerStorage.TakeBufferItem(index);
			}
		}

		public void Setup(int index, ItemTreeData item)
		{
			this.index = index;
			this.item = item;
			ItemTreeData.DataEntry rootData = item.RootData;
			itemDisplay.Setup(rootData.typeID);
			int stackCount = rootData.StackCount;
			if (stackCount > 1)
			{
				countText.text = stackCount.ToString();
				countDisplay.SetActive(value: true);
			}
			else
			{
				countDisplay.SetActive(value: false);
			}
			if (PlayerStorage.IsAccessableAndNotFull())
			{
				bgImage.color = colorNormal;
				text.text = textKeyNormal.ToPlainText();
			}
			else
			{
				bgImage.color = colorFull;
				text.text = textKeyInventoryFull.ToPlainText();
			}
			text.gameObject.SetActive(value: true);
			loadingIndicator.SetActive(value: false);
		}
	}
	public static class TradingUIUtilities
	{
		private static UnityEngine.Object activeMerchant;

		public static IMerchant ActiveMerchant
		{
			get
			{
				return activeMerchant as IMerchant;
			}
			set
			{
				activeMerchant = value as UnityEngine.Object;
				TradingUIUtilities.OnActiveMerchantChanged?.Invoke(value);
			}
		}

		public static event Action<IMerchant> OnActiveMerchantChanged;
	}
	public class ClosureView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private FadeGroup contentFadeGroup;

		[SerializeField]
		private TextMeshProUGUI titleText;

		[SerializeField]
		[LocalizationKey("Default")]
		private string evacuatedTitleTextKey = "UI_Closure_Escaped";

		[SerializeField]
		private Color evacuatedTitleTextColor = Color.white;

		[SerializeField]
		[LocalizationKey("Default")]
		private string failedTitleTextKey = "UI_Closure_Dead";

		[SerializeField]
		private Color failedTitleTextColor = Color.red;

		[SerializeField]
		private GameObject damageInfoContainer;

		[SerializeField]
		private TextMeshProUGUI damageSourceText;

		[SerializeField]
		private UnityEngine.UI.Image expBar_OldFill;

		[SerializeField]
		private UnityEngine.UI.Image expBar_CurrentFill;

		[SerializeField]
		private AnimationCurve expBarAnimationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		[SerializeField]
		private float expBarAnimationTime = 3f;

		[SerializeField]
		private TextMeshProUGUI expDisplay;

		[SerializeField]
		private string expFormat = "{0}/<sub>{1}</sub>";

		[SerializeField]
		private TextMeshProUGUI levelDisplay;

		[SerializeField]
		private string levelFormat = "Lv.{0}";

		[SerializeField]
		private PunchReceiver levelDisplayPunchReceiver;

		[SerializeField]
		private PunchReceiver barPunchReceiver;

		[SerializeField]
		private UnityEngine.UI.Button continueButton;

		[SerializeField]
		private PunchReceiver continueButtonPunchReceiver;

		private string sfx_Pop = "UI/pop";

		private string sfx_ExpUp = "UI/exp_up";

		private string sfx_LvUp = "UI/level_up";

		private bool continueButtonClicked;

		private bool canContinue;

		private float lastTimeExpUpSfxPlayed = float.MinValue;

		private const float minIntervalForExpUpSfx = 0.05f;

		private int cachedLevel = -1;

		private (long from, long to) cachedLevelRange;

		private long cachedLevelLength;

		private int displayingLevel = -1;

		public static ClosureView Instance => View.GetViewInstance<ClosureView>();

		private string EvacuatedTitleText => evacuatedTitleTextKey.ToPlainText();

		private string FailedTitleText => failedTitleTextKey.ToPlainText();

		protected override void Awake()
		{
			base.Awake();
			continueButton.onClick.AddListener(OnContinueButtonClicked);
		}

		private void OnContinueButtonClicked()
		{
			if (canContinue)
			{
				continueButtonClicked = true;
				contentFadeGroup.Hide();
			}
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
			contentFadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		public static async UniTask ShowAndReturnTask(float duration = 0.5f)
		{
			if (!(Instance == null))
			{
				Instance.canContinue = false;
				await BlackScreen.ShowAndReturnTask(null, 1f, duration);
				if ((bool)MultiSceneCore.Instance)
				{
					MultiSceneCore.Instance.PlayStinger();
				}
				Instance.Open();
				Instance.SetupTitle(dead: false);
				Instance.SetupBeginning();
				Instance.damageInfoContainer.SetActive(value: false);
				await BlackScreen.HideAndReturnTask(null, 0f, duration);
				Instance.canContinue = true;
				await Instance.ClosureTask();
			}
		}

		public static async UniTask ShowAndReturnTask(DamageInfo dmgInfo, float duration = 0.5f)
		{
			if (Instance == null)
			{
				return;
			}
			Instance.canContinue = false;
			await BlackScreen.ShowAndReturnTask(null, 1f, duration);
			if (!(Instance == null))
			{
				Instance.Open();
				Instance.SetupTitle(dead: true);
				Instance.SetupBeginning();
				Instance.SetupDamageInfo(dmgInfo);
				await BlackScreen.HideAndReturnTask(null, 0f, duration);
				if (!(Instance == null))
				{
					Instance.canContinue = true;
					await Instance.ClosureTask();
				}
			}
		}

		private void SetupDamageInfo(DamageInfo dmgInfo)
		{
			damageSourceText.text = dmgInfo.GenerateDescription();
			damageInfoContainer.gameObject.SetActive(value: true);
		}

		private async UniTask ClosureTask()
		{
			continueButtonClicked = false;
			long cachedExp = EXPManager.CachedExp;
			long eXP = EXPManager.EXP;
			await AnimateExpBar(cachedExp, eXP);
			continueButton.gameObject.SetActive(value: true);
			continueButtonPunchReceiver.Punch();
			AudioManager.Post(sfx_Pop);
			while (!continueButtonClicked)
			{
				await UniTask.NextFrame();
			}
			AudioManager.Post("UI/confirm");
		}

		private void SetupBeginning()
		{
			long cachedExp = EXPManager.CachedExp;
			long eXP = EXPManager.EXP;
			Refresh(0f, cachedExp, eXP);
			continueButton.gameObject.SetActive(value: false);
		}

		private void SetupTitle(bool dead)
		{
			if (dead)
			{
				titleText.color = failedTitleTextColor;
				titleText.text = FailedTitleText;
			}
			else
			{
				titleText.color = evacuatedTitleTextColor;
				titleText.text = EvacuatedTitleText;
			}
		}

		private async UniTask AnimateExpBar(long fromExp, long toExp)
		{
			if (fromExp != toExp)
			{
				float time = 0f;
				long displayingExp = fromExp;
				while (time < expBarAnimationTime && fromExp != toExp)
				{
					float time2 = time / expBarAnimationTime;
					long num = Refresh(expBarAnimationCurve.Evaluate(time2), fromExp, toExp);
					if (num != displayingExp)
					{
						SpitExpUpSfx((float)(num - fromExp) / (float)(toExp - fromExp));
					}
					displayingExp = num;
					time += Time.unscaledDeltaTime;
					await UniTask.NextFrame();
				}
				SpitExpUpSfx(1f);
			}
			SetExpDisplay(toExp, fromExp);
			SetLevelDisplay(cachedLevel);
		}

		private void SpitExpUpSfx(float expDelta)
		{
			float unscaledTime = Time.unscaledTime;
			if (!(unscaledTime - lastTimeExpUpSfxPlayed < 0.05f))
			{
				lastTimeExpUpSfxPlayed = unscaledTime;
				AudioManager.SetRTPC("ExpDelta", expDelta);
				AudioManager.Post(sfx_ExpUp);
			}
		}

		private long Refresh(float t, long fromExp, long toExp)
		{
			long num = LongLerp(fromExp, toExp, t);
			SetExpDisplay(num, fromExp);
			SetLevelDisplay(cachedLevel);
			return num;
		}

		private long LongLerp(long from, long to, float t)
		{
			return (long)((float)(to - from) * t) + from;
		}

		private void CacheLevelInfo(int level)
		{
			if (level != cachedLevel)
			{
				cachedLevel = level;
				cachedLevelRange = EXPManager.Instance.GetLevelExpRange(level);
				cachedLevelLength = cachedLevelRange.to - cachedLevelRange.from;
			}
		}

		private void SetExpDisplay(long currentExp, long oldExp)
		{
			int level = EXPManager.Instance.LevelFromExp(currentExp);
			CacheLevelInfo(level);
			float fillAmount = 0f;
			if (oldExp >= cachedLevelRange.from && oldExp <= cachedLevelRange.to)
			{
				fillAmount = (float)(oldExp - cachedLevelRange.from) / (float)cachedLevelLength;
			}
			float fillAmount2 = (float)(currentExp - cachedLevelRange.from) / (float)cachedLevelLength;
			expBar_OldFill.fillAmount = fillAmount;
			expBar_CurrentFill.fillAmount = fillAmount2;
			expDisplay.text = string.Format(expFormat, currentExp, cachedLevelRange.to);
		}

		private void SetLevelDisplay(int level)
		{
			if (displayingLevel > 0 && level != displayingLevel)
			{
				LevelUpPunch();
			}
			displayingLevel = level;
			levelDisplay.text = string.Format(levelFormat, level);
		}

		private void LevelUpPunch()
		{
			levelDisplayPunchReceiver?.Punch();
			barPunchReceiver?.Punch();
			AudioManager.Post(sfx_LvUp);
		}

		internal override void TryQuit()
		{
		}
	}
	public class InventoryView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private ItemSlotCollectionDisplay slotDisplay;

		[SerializeField]
		private InventoryDisplay inventoryDisplay;

		[SerializeField]
		private ItemDetailsDisplay detailsDisplay;

		[SerializeField]
		private FadeGroup itemDetailsFadeGroup;

		private static InventoryView Instance => View.GetViewInstance<InventoryView>();

		private Item CharacterItem => LevelManager.Instance?.MainCharacter?.CharacterItem;

		protected override void Awake()
		{
			base.Awake();
		}

		private void Update()
		{
			bool editable = true;
			inventoryDisplay.Editable = editable;
			slotDisplay.Editable = editable;
		}

		protected override void OnOpen()
		{
			UnregisterEvents();
			base.OnOpen();
			Item characterItem = CharacterItem;
			if (characterItem == null)
			{
				UnityEngine.Debug.LogError("物品栏开启失败，角色物体不存在");
				Close();
				return;
			}
			base.gameObject.SetActive(value: true);
			slotDisplay.Setup(characterItem);
			inventoryDisplay.Setup(characterItem.Inventory);
			RegisterEvents();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			UnregisterEvents();
			base.OnClose();
			fadeGroup.Hide();
			itemDetailsFadeGroup.Hide();
			if ((bool)SplitDialogue.Instance && SplitDialogue.Instance.isActiveAndEnabled)
			{
				SplitDialogue.Instance.Cancel();
			}
		}

		private void RegisterEvents()
		{
			ItemUIUtilities.OnSelectionChanged += OnItemSelectionChanged;
		}

		private void OnItemSelectionChanged()
		{
			if (ItemUIUtilities.SelectedItem != null)
			{
				detailsDisplay.Setup(ItemUIUtilities.SelectedItem);
				itemDetailsFadeGroup.Show();
			}
			else
			{
				itemDetailsFadeGroup.Hide();
			}
		}

		private void UnregisterEvents()
		{
			ItemUIUtilities.OnSelectionChanged -= OnItemSelectionChanged;
		}

		public static void Show()
		{
			if (LevelManager.LevelInited)
			{
				LootView.Instance?.Show();
				if (LootView.Instance == null)
				{
					UnityEngine.Debug.Log("LOOTVIEW INSTANCE IS NULL");
				}
			}
		}

		public static void Hide()
		{
			LootView.Instance?.Close();
		}
	}
	public class ItemCustomizeSelectionView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private ItemSlotCollectionDisplay slotDisplay;

		[SerializeField]
		private InventoryDisplay inventoryDisplay;

		[SerializeField]
		private ItemDetailsDisplay detailsDisplay;

		[SerializeField]
		private FadeGroup itemDetailsFadeGroup;

		[SerializeField]
		private FadeGroup customizeButtonFadeGroup;

		[SerializeField]
		private FadeGroup placeHolderFadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button beginCustomizeButton;

		[SerializeField]
		private TextMeshProUGUI selectedItemName;

		[SerializeField]
		private UnityEngine.UI.Image selectedItemIcon;

		[SerializeField]
		private TrueShadow selectedItemShadow;

		[SerializeField]
		private GameObject customizableIndicator;

		[SerializeField]
		private GameObject uncustomizableIndicator;

		[SerializeField]
		private string noItemSelectedNameText = "-";

		[SerializeField]
		private Sprite noItemSelectedIconSprite;

		private List<Inventory> avaliableInventories = new List<Inventory>();

		public static ItemCustomizeSelectionView Instance => View.GetViewInstance<ItemCustomizeSelectionView>();

		private Item CharacterItem => LevelManager.Instance?.MainCharacter?.CharacterItem;

		private bool CanCustomize
		{
			get
			{
				Item selectedItem = ItemUIUtilities.SelectedItem;
				if (selectedItem == null)
				{
					return false;
				}
				if (selectedItem.Slots == null)
				{
					return false;
				}
				if (selectedItem.Slots.Count < 1)
				{
					return false;
				}
				return true;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			beginCustomizeButton.onClick.AddListener(OnBeginCustomizeButtonClicked);
		}

		private void OnBeginCustomizeButtonClicked()
		{
			_ = ItemUIUtilities.SelectedItem;
			ItemCustomizeView instance = ItemCustomizeView.Instance;
			if (!(instance == null))
			{
				instance.Setup(ItemUIUtilities.SelectedItem, GetAvaliableInventories());
				instance.Open();
			}
		}

		private List<Inventory> GetAvaliableInventories()
		{
			avaliableInventories.Clear();
			Inventory inventory = LevelManager.Instance?.MainCharacter?.CharacterItem?.Inventory;
			if (inventory != null)
			{
				avaliableInventories.Add(inventory);
			}
			Inventory inventory2 = PlayerStorage.Inventory;
			if (inventory2 != null)
			{
				avaliableInventories.Add(inventory2);
			}
			return avaliableInventories;
		}

		protected override void OnOpen()
		{
			UnregisterEvents();
			base.OnOpen();
			Item characterItem = CharacterItem;
			if (characterItem == null)
			{
				UnityEngine.Debug.LogError("物品栏开启失败，角色物体不存在");
				return;
			}
			base.gameObject.SetActive(value: true);
			slotDisplay.Setup(characterItem);
			inventoryDisplay.Setup(characterItem.Inventory);
			RegisterEvents();
			fadeGroup.Show();
			customizeButtonFadeGroup.SkipHide();
			placeHolderFadeGroup.SkipHide();
			ItemUIUtilities.Select(null);
			RefreshSelectedItemInfo();
		}

		protected override void OnClose()
		{
			UnregisterEvents();
			base.OnClose();
			fadeGroup.Hide();
			itemDetailsFadeGroup.Hide();
		}

		private void RegisterEvents()
		{
			ItemUIUtilities.OnSelectionChanged += OnItemSelectionChanged;
		}

		private void OnItemSelectionChanged()
		{
			if (ItemUIUtilities.SelectedItem != null)
			{
				detailsDisplay.Setup(ItemUIUtilities.SelectedItem);
				itemDetailsFadeGroup.Show();
			}
			else
			{
				itemDetailsFadeGroup.Hide();
			}
			if (CanCustomize)
			{
				placeHolderFadeGroup.Hide();
				customizeButtonFadeGroup.Show();
			}
			else
			{
				customizeButtonFadeGroup.Hide();
				placeHolderFadeGroup.Show();
			}
			RefreshSelectedItemInfo();
		}

		private void UnregisterEvents()
		{
			ItemUIUtilities.OnSelectionChanged -= OnItemSelectionChanged;
		}

		public static void Show()
		{
			if (!(Instance == null))
			{
				Instance.Open();
			}
		}

		public static void Hide()
		{
			if (!(Instance == null))
			{
				Instance.Close();
			}
		}

		private void RefreshSelectedItemInfo()
		{
			Item selectedItem = ItemUIUtilities.SelectedItem;
			if (selectedItem == null)
			{
				selectedItemName.text = noItemSelectedNameText;
				selectedItemIcon.sprite = noItemSelectedIconSprite;
				selectedItemShadow.enabled = false;
				customizableIndicator.SetActive(value: false);
				uncustomizableIndicator.SetActive(value: false);
				selectedItemIcon.color = Color.clear;
			}
			else
			{
				selectedItemShadow.enabled = true;
				selectedItemIcon.color = Color.white;
				selectedItemName.text = selectedItem.DisplayName;
				selectedItemIcon.sprite = selectedItem.Icon;
				GameplayDataSettings.UIStyle.GetDisplayQualityLook(selectedItem.DisplayQuality).Apply(selectedItemShadow);
				customizableIndicator.SetActive(CanCustomize);
				uncustomizableIndicator.SetActive(!CanCustomize);
			}
		}
	}
	public class ItemCustomizeView : View, ISingleSelectionMenu<SlotDisplay>
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button equipButton;

		[SerializeField]
		private UnityEngine.UI.Button unequipButton;

		[SerializeField]
		private ItemDetailsDisplay customizingTargetDisplay;

		[SerializeField]
		private ItemDetailsDisplay selectedItemDisplay;

		[SerializeField]
		private FadeGroup selectedItemDisplayFadeGroup;

		[SerializeField]
		private RectTransform slotSelectionIndicator;

		[SerializeField]
		private GameObject selectSlotPlaceHolder;

		[SerializeField]
		private GameObject avaliableItemsContainer;

		[SerializeField]
		private GameObject noAvaliableItemPlaceHolder;

		[SerializeField]
		private ItemDisplay itemDisplayTemplate;

		private PrefabPool<ItemDisplay> _itemDisplayPool;

		private Item target;

		private SlotDisplay selectedSlotDisplay;

		private List<Inventory> avaliableInventories = new List<Inventory>();

		private List<Item> avaliableItems = new List<Item>();

		public static ItemCustomizeView Instance => View.GetViewInstance<ItemCustomizeView>();

		private PrefabPool<ItemDisplay> ItemDisplayPool
		{
			get
			{
				if (_itemDisplayPool == null)
				{
					itemDisplayTemplate.gameObject.SetActive(value: false);
					_itemDisplayPool = new PrefabPool<ItemDisplay>(itemDisplayTemplate, itemDisplayTemplate.transform.parent);
				}
				return _itemDisplayPool;
			}
		}

		public Item Target => target;

		private void OnGetInventoryDisplay(InventoryDisplay display)
		{
			display.onDisplayDoubleClicked += OnInventoryDoubleClicked;
			display.ShowOperationButtons = false;
		}

		private void OnReleaseInventoryDisplay(InventoryDisplay display)
		{
			display.onDisplayDoubleClicked -= OnInventoryDoubleClicked;
		}

		private void OnInventoryDoubleClicked(InventoryDisplay display, InventoryEntry entry, PointerEventData data)
		{
			if (entry.Item != null)
			{
				target.TryPlug(entry.Item, emptyOnly: false, entry.Master.Target);
				data.Use();
			}
		}

		public void Setup(Item target, List<Inventory> avaliableInventories)
		{
			this.target = target;
			customizingTargetDisplay.Setup(target);
			this.avaliableInventories.Clear();
			this.avaliableInventories.AddRange(avaliableInventories);
		}

		public void DebugSetup(Item target, Inventory inventory1, Inventory inventory2)
		{
			Setup(target, new List<Inventory> { inventory1, inventory2 });
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			ItemUIUtilities.Select(null);
			ItemUIUtilities.OnSelectionChanged += OnItemSelectionChanged;
			fadeGroup.Show();
			SetSelection(null);
			RefreshDetails();
		}

		protected override void OnClose()
		{
			ItemUIUtilities.OnSelectionChanged -= OnItemSelectionChanged;
			base.OnClose();
			fadeGroup.Hide();
			selectedItemDisplayFadeGroup.Hide();
		}

		private void OnItemSelectionChanged()
		{
			RefreshDetails();
		}

		private void RefreshDetails()
		{
			if (ItemUIUtilities.SelectedItem != null)
			{
				selectedItemDisplayFadeGroup.Show();
				selectedItemDisplay.Setup(ItemUIUtilities.SelectedItem);
				Item item = selectedItemDisplay.Target;
				bool flag = selectedSlotDisplay.Target.Content != item;
				equipButton.gameObject.SetActive(flag);
				unequipButton.gameObject.SetActive(!flag);
			}
			else
			{
				selectedItemDisplayFadeGroup.Hide();
				equipButton.gameObject.SetActive(value: false);
				unequipButton.gameObject.SetActive(value: false);
			}
		}

		protected override void Awake()
		{
			base.Awake();
			equipButton.onClick.AddListener(OnEquipButtonClicked);
			unequipButton.onClick.AddListener(OnUnequipButtonClicked);
			customizingTargetDisplay.SlotCollectionDisplay.onElementClicked += OnSlotElementClicked;
		}

		private void OnUnequipButtonClicked()
		{
			if (!(selectedSlotDisplay == null) && !(selectedItemDisplay == null))
			{
				Slot slot = selectedSlotDisplay.Target;
				if (slot.Content != null)
				{
					Item item = slot.Unplug();
					HandleUnpluggledItem(item);
				}
				RefreshAvaliableItems();
			}
		}

		private void OnEquipButtonClicked()
		{
			if (selectedSlotDisplay == null || selectedItemDisplay == null)
			{
				return;
			}
			Slot slot = selectedSlotDisplay.Target;
			Item item = selectedItemDisplay.Target;
			if (slot != null && !(item == null))
			{
				if (slot.Content != null)
				{
					Item item2 = slot.Unplug();
					HandleUnpluggledItem(item2);
				}
				item.Detach();
				if (!slot.Plug(item, out var _))
				{
					UnityEngine.Debug.LogError("装备失败！");
					HandleUnpluggledItem(item);
				}
				RefreshAvaliableItems();
			}
		}

		private void HandleUnpluggledItem(Item item)
		{
			if ((bool)PlayerStorage.Inventory)
			{
				ItemUtilities.SendToPlayerStorage(item);
			}
			else if (!ItemUtilities.SendToPlayerCharacterInventory(item))
			{
				ItemUtilities.SendToPlayerStorage(item);
			}
		}

		private void OnSlotElementClicked(ItemSlotCollectionDisplay collection, SlotDisplay slot)
		{
			SetSelection(slot);
		}

		public SlotDisplay GetSelection()
		{
			return selectedSlotDisplay;
		}

		public bool SetSelection(SlotDisplay selection)
		{
			selectedSlotDisplay = selection;
			RefreshSelectionIndicator();
			OnSlotSelectionChanged();
			return true;
		}

		private void RefreshSelectionIndicator()
		{
			slotSelectionIndicator.gameObject.SetActive(selectedSlotDisplay);
			if (selectedSlotDisplay != null)
			{
				slotSelectionIndicator.position = selectedSlotDisplay.transform.position;
			}
		}

		private void OnSlotSelectionChanged()
		{
			ItemUIUtilities.Select(null);
			RefreshAvaliableItems();
		}

		private void RefreshAvaliableItems()
		{
			avaliableItems.Clear();
			if (!(selectedSlotDisplay == null))
			{
				Slot slot = selectedSlotDisplay.Target;
				if (!(selectedSlotDisplay == null))
				{
					foreach (Inventory avaliableInventory in avaliableInventories)
					{
						foreach (Item item in avaliableInventory)
						{
							if (!(item == null) && slot.CanPlug(item))
							{
								avaliableItems.Add(item);
							}
						}
					}
				}
			}
			RefreshItemListGraphics();
		}

		private void RefreshItemListGraphics()
		{
			UnityEngine.Debug.Log("Refreshing Item List Graphics");
			bool flag = selectedSlotDisplay != null;
			bool flag2 = avaliableItems.Count > 0;
			selectSlotPlaceHolder.SetActive(!flag);
			noAvaliableItemPlaceHolder.SetActive(flag && !flag2);
			avaliableItemsContainer.SetActive(flag2);
			ItemDisplayPool.ReleaseAll();
			if (!flag2)
			{
				return;
			}
			foreach (Item avaliableItem in avaliableItems)
			{
				if (!(avaliableItem == null))
				{
					ItemDisplay itemDisplay = ItemDisplayPool.Get();
					itemDisplay.ShowOperationButtons = false;
					itemDisplay.Setup(avaliableItem);
				}
			}
		}
	}
	public class ItemDecomposeView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private InventoryDisplay characterInventoryDisplay;

		[SerializeField]
		private InventoryDisplay storageDisplay;

		[SerializeField]
		private FadeGroup detailsFadeGroup;

		[SerializeField]
		private ItemDetailsDisplay detailsDisplay;

		[SerializeField]
		private DecomposeSlider countSlider;

		[SerializeField]
		private TextMeshProUGUI targetNameDisplay;

		[SerializeField]
		private CostDisplay resultDisplay;

		[SerializeField]
		private GameObject cannotDecomposeIndicator;

		[SerializeField]
		private GameObject noItemSelectedIndicator;

		[SerializeField]
		private UnityEngine.UI.Button decomposeButton;

		[SerializeField]
		private GameObject busyIndicator;

		private bool decomposing;

		public static ItemDecomposeView Instance => View.GetViewInstance<ItemDecomposeView>();

		private Item SelectedItem => ItemUIUtilities.SelectedItem;

		protected override void Awake()
		{
			base.Awake();
			decomposeButton.onClick.AddListener(OnDecomposeButtonClick);
			countSlider.OnValueChangedEvent += OnSliderValueChanged;
			SetupEmpty();
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			countSlider.OnValueChangedEvent -= OnSliderValueChanged;
		}

		private void OnDecomposeButtonClick()
		{
			if (!decomposing && !(SelectedItem == null))
			{
				int value = countSlider.Value;
				DecomposeTask(SelectedItem, value).Forget();
			}
		}

		private void OnFastPick(UIInputEventData data)
		{
			OnDecomposeButtonClick();
			data.Use();
		}

		private async UniTask DecomposeTask(Item item, int count)
		{
			decomposing = true;
			busyIndicator.SetActive(value: true);
			if (item != null)
			{
				AudioManager.PlayPutItemSFX(item);
			}
			await DecomposeDatabase.Decompose(item, count);
			busyIndicator.SetActive(value: false);
			decomposing = false;
			Refresh();
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
			ItemUIUtilities.Select(null);
			detailsFadeGroup.SkipHide();
			if (CharacterMainControl.Main != null)
			{
				characterInventoryDisplay.gameObject.SetActive(value: true);
				characterInventoryDisplay.Setup(CharacterMainControl.Main.CharacterItem.Inventory, null, (Item e) => e == null || DecomposeDatabase.CanDecompose(e.TypeID));
			}
			else
			{
				characterInventoryDisplay.gameObject.SetActive(value: false);
			}
			if (PlayerStorage.Inventory != null)
			{
				storageDisplay.gameObject.SetActive(value: true);
				storageDisplay.Setup(PlayerStorage.Inventory, null, (Item e) => e == null || DecomposeDatabase.CanDecompose(e.TypeID));
			}
			else
			{
				storageDisplay.gameObject.SetActive(value: false);
			}
			Refresh();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		private void OnEnable()
		{
			ItemUIUtilities.OnSelectionChanged += OnSelectionChanged;
			UIInputManager.OnFastPick += OnFastPick;
		}

		private void OnDisable()
		{
			ItemUIUtilities.OnSelectionChanged -= OnSelectionChanged;
			UIInputManager.OnFastPick -= OnFastPick;
		}

		private void OnSelectionChanged()
		{
			Refresh();
		}

		private void OnSliderValueChanged(float value)
		{
			RefreshResult(SelectedItem, Mathf.RoundToInt(value));
		}

		private void Refresh()
		{
			if (SelectedItem == null)
			{
				SetupEmpty();
			}
			else
			{
				Setup(SelectedItem);
			}
		}

		private void SetupEmpty()
		{
			detailsFadeGroup.Hide();
			targetNameDisplay.text = "-";
			resultDisplay.Clear();
			cannotDecomposeIndicator.SetActive(value: false);
			decomposeButton.gameObject.SetActive(value: false);
			noItemSelectedIndicator.SetActive(value: true);
			busyIndicator.SetActive(value: false);
			countSlider.SetMinMax(1, 1);
			countSlider.Value = 1;
		}

		private void Setup(Item selectedItem)
		{
			if (!(selectedItem == null))
			{
				noItemSelectedIndicator.SetActive(value: false);
				detailsDisplay.Setup(selectedItem);
				detailsFadeGroup.Show();
				targetNameDisplay.text = selectedItem.DisplayName;
				bool valid = DecomposeDatabase.GetDecomposeFormula(selectedItem.TypeID).valid;
				decomposeButton.gameObject.SetActive(valid);
				cannotDecomposeIndicator.gameObject.SetActive(!valid);
				SetupSlider(selectedItem);
				RefreshResult(selectedItem, Mathf.RoundToInt(countSlider.Value));
				busyIndicator.SetActive(decomposing);
			}
		}

		private void SetupSlider(Item selectedItem)
		{
			if (selectedItem.Stackable)
			{
				countSlider.SetMinMax(1, selectedItem.StackCount);
				countSlider.Value = selectedItem.StackCount;
			}
			else
			{
				countSlider.SetMinMax(1, 1);
				countSlider.Value = 1;
			}
		}

		private void RefreshResult(Item selectedItem, int count)
		{
			if (selectedItem == null)
			{
				countSlider.SetMinMax(1, 1);
				countSlider.Value = 1;
				return;
			}
			DecomposeFormula decomposeFormula = DecomposeDatabase.GetDecomposeFormula(selectedItem.TypeID);
			if (decomposeFormula.valid)
			{
				_ = selectedItem.Stackable;
				resultDisplay.Setup(decomposeFormula.result, count);
			}
			else
			{
				resultDisplay.Clear();
			}
		}

		internal static void Show()
		{
			ItemDecomposeView instance = Instance;
			if (!(instance == null))
			{
				instance.Open();
			}
		}
	}
	public class ItemRepairView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private ItemSlotCollectionDisplay slotDisplay;

		[SerializeField]
		private InventoryDisplay inventoryDisplay;

		[SerializeField]
		private ItemDetailsDisplay detailsDisplay;

		[SerializeField]
		private FadeGroup itemDetailsFadeGroup;

		[SerializeField]
		private ItemRepair_RepairAllPanel repairAllPanel;

		[SerializeField]
		private FadeGroup repairButtonFadeGroup;

		[SerializeField]
		private FadeGroup placeHolderFadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button repairButton;

		[SerializeField]
		private TextMeshProUGUI repairPriceText;

		[SerializeField]
		private TextMeshProUGUI selectedItemName;

		[SerializeField]
		private UnityEngine.UI.Image selectedItemIcon;

		[SerializeField]
		private TrueShadow selectedItemShadow;

		[SerializeField]
		private string noItemSelectedNameText = "-";

		[SerializeField]
		private Sprite noItemSelectedIconSprite;

		[SerializeField]
		private GameObject noNeedToRepairIndicator;

		[SerializeField]
		private GameObject brokenIndicator;

		[SerializeField]
		private GameObject cannotRepairIndicator;

		[SerializeField]
		private TextMeshProUGUI durabilityText;

		[SerializeField]
		private TextMeshProUGUI willLoseDurabilityText;

		[SerializeField]
		private UnityEngine.UI.Image barFill;

		[SerializeField]
		private UnityEngine.UI.Image lossBarFill;

		[SerializeField]
		private Gradient barFillColorOverT;

		private List<Inventory> avaliableInventories = new List<Inventory>();

		public static ItemRepairView Instance => View.GetViewInstance<ItemRepairView>();

		private Item CharacterItem => LevelManager.Instance?.MainCharacter?.CharacterItem;

		private bool CanRepair
		{
			get
			{
				Item selectedItem = ItemUIUtilities.SelectedItem;
				if (selectedItem == null)
				{
					return false;
				}
				if (!selectedItem.UseDurability)
				{
					return false;
				}
				if (selectedItem.MaxDurabilityWithLoss < 1f)
				{
					return false;
				}
				if (!selectedItem.Tags.Contains("Repairable"))
				{
					UnityEngine.Debug.Log(selectedItem.DisplayName + " 不包含tag Repairable");
					return false;
				}
				return selectedItem.Durability < selectedItem.MaxDurabilityWithLoss;
			}
		}

		private bool NoNeedToRepair
		{
			get
			{
				Item selectedItem = ItemUIUtilities.SelectedItem;
				if (selectedItem == null)
				{
					return false;
				}
				if (!selectedItem.UseDurability)
				{
					return false;
				}
				return selectedItem.Durability >= selectedItem.MaxDurabilityWithLoss;
			}
		}

		private bool Broken
		{
			get
			{
				Item selectedItem = ItemUIUtilities.SelectedItem;
				if (selectedItem == null)
				{
					return false;
				}
				if (!selectedItem.UseDurability)
				{
					return false;
				}
				return selectedItem.MaxDurabilityWithLoss < 1f;
			}
		}

		public static event Action OnRepaireOptionDone;

		protected override void Awake()
		{
			base.Awake();
			repairButton.onClick.AddListener(OnRepairButtonClicked);
			itemDetailsFadeGroup.SkipHide();
		}

		private List<Inventory> GetAvaliableInventories()
		{
			avaliableInventories.Clear();
			Inventory inventory = LevelManager.Instance?.MainCharacter?.CharacterItem?.Inventory;
			if (inventory != null)
			{
				avaliableInventories.Add(inventory);
			}
			Inventory inventory2 = PlayerStorage.Inventory;
			if (inventory2 != null)
			{
				avaliableInventories.Add(inventory2);
			}
			return avaliableInventories;
		}

		protected override void OnOpen()
		{
			UnregisterEvents();
			base.OnOpen();
			Item characterItem = CharacterItem;
			if (characterItem == null)
			{
				UnityEngine.Debug.LogError("物品栏开启失败，角色物体不存在");
				return;
			}
			base.gameObject.SetActive(value: true);
			slotDisplay.Setup(characterItem);
			inventoryDisplay.Setup(characterItem.Inventory);
			RegisterEvents();
			fadeGroup.Show();
			repairButtonFadeGroup.SkipHide();
			placeHolderFadeGroup.SkipHide();
			ItemUIUtilities.Select(null);
			RefreshSelectedItemInfo();
			repairAllPanel.Setup(this);
		}

		protected override void OnClose()
		{
			UnregisterEvents();
			base.OnClose();
			fadeGroup.Hide();
			itemDetailsFadeGroup.Hide();
		}

		private void RegisterEvents()
		{
			ItemUIUtilities.OnSelectionChanged += OnItemSelectionChanged;
		}

		private void OnItemSelectionChanged()
		{
			RefreshSelectedItemInfo();
		}

		private void UnregisterEvents()
		{
			ItemUIUtilities.OnSelectionChanged -= OnItemSelectionChanged;
		}

		public static void Show()
		{
			if (!(Instance == null))
			{
				Instance.Open();
			}
		}

		public static void Hide()
		{
			if (!(Instance == null))
			{
				Instance.Close();
			}
		}

		private void RefreshSelectedItemInfo()
		{
			if (ItemUIUtilities.SelectedItem != null)
			{
				detailsDisplay.Setup(ItemUIUtilities.SelectedItem);
				itemDetailsFadeGroup.Show();
			}
			else
			{
				itemDetailsFadeGroup.Hide();
			}
			if (CanRepair)
			{
				placeHolderFadeGroup.Hide();
				repairButtonFadeGroup.Show();
			}
			else
			{
				repairButtonFadeGroup.Hide();
				placeHolderFadeGroup.Show();
			}
			Item selectedItem = ItemUIUtilities.SelectedItem;
			willLoseDurabilityText.text = "";
			if (selectedItem == null)
			{
				selectedItemName.text = noItemSelectedNameText;
				selectedItemIcon.sprite = noItemSelectedIconSprite;
				selectedItemShadow.enabled = false;
				noNeedToRepairIndicator.SetActive(value: false);
				brokenIndicator.SetActive(value: false);
				cannotRepairIndicator.SetActive(value: false);
				selectedItemIcon.color = Color.clear;
				barFill.fillAmount = 0f;
				lossBarFill.fillAmount = 0f;
				durabilityText.text = "-";
				return;
			}
			selectedItemShadow.enabled = true;
			selectedItemIcon.color = Color.white;
			selectedItemName.text = selectedItem.DisplayName;
			selectedItemIcon.sprite = selectedItem.Icon;
			GameplayDataSettings.UIStyle.GetDisplayQualityLook(selectedItem.DisplayQuality).Apply(selectedItemShadow);
			noNeedToRepairIndicator.SetActive(!Broken && NoNeedToRepair && selectedItem.Repairable);
			cannotRepairIndicator.SetActive(selectedItem.UseDurability && !selectedItem.Repairable && !Broken);
			brokenIndicator.SetActive(Broken);
			if (CanRepair)
			{
				float repairAmount;
				float lostAmount;
				float lostPercentage;
				int num = CalculateRepairPrice(selectedItem, out repairAmount, out lostAmount, out lostPercentage);
				repairPriceText.text = num.ToString();
				willLoseDurabilityText.text = "UI_MaxDurability".ToPlainText() + " -" + lostAmount.ToString("0.#");
				repairButton.interactable = EconomyManager.Money >= num;
			}
			if (selectedItem.UseDurability)
			{
				float durability = selectedItem.Durability;
				float maxDurability = selectedItem.MaxDurability;
				float maxDurabilityWithLoss = selectedItem.MaxDurabilityWithLoss;
				float num2 = durability / maxDurability;
				barFill.fillAmount = num2;
				lossBarFill.fillAmount = selectedItem.DurabilityLoss;
				durabilityText.text = string.Format("{0:0.#} / {1} ", durability, maxDurabilityWithLoss.ToString("0.#"));
				barFill.color = barFillColorOverT.Evaluate(num2);
			}
			else
			{
				barFill.fillAmount = 0f;
				lossBarFill.fillAmount = 0f;
				durabilityText.text = "-";
			}
		}

		private void OnRepairButtonClicked()
		{
			Item selectedItem = ItemUIUtilities.SelectedItem;
			if (!(selectedItem == null) && selectedItem.UseDurability)
			{
				Repair(selectedItem);
				RefreshSelectedItemInfo();
			}
		}

		private void Repair(Item item, bool prepaied = false)
		{
			float repairAmount;
			float lostAmount;
			float lostPercentage;
			int num = CalculateRepairPrice(item, out repairAmount, out lostAmount, out lostPercentage);
			if (prepaied || EconomyManager.Pay(new Cost(num)))
			{
				item.DurabilityLoss += lostPercentage;
				item.Durability = item.MaxDurability * (1f - item.DurabilityLoss);
				ItemRepairView.OnRepaireOptionDone?.Invoke();
			}
		}

		private int CalculateRepairPrice(Item item, out float repairAmount, out float lostAmount, out float lostPercentage)
		{
			repairAmount = 0f;
			lostAmount = 0f;
			lostPercentage = 0f;
			if (item == null)
			{
				return 0;
			}
			if (!item.UseDurability)
			{
				return 0;
			}
			float maxDurability = item.MaxDurability;
			float durabilityLoss = item.DurabilityLoss;
			float num = maxDurability * (1f - durabilityLoss);
			float durability = item.Durability;
			repairAmount = num - durability;
			float repairLossRatio = item.GetRepairLossRatio();
			lostAmount = repairAmount * repairLossRatio;
			repairAmount -= lostAmount;
			if (repairAmount <= 0f)
			{
				return 0;
			}
			lostPercentage = lostAmount / maxDurability;
			float num2 = repairAmount / maxDurability;
			return Mathf.CeilToInt((float)item.Value * num2 * 0.5f);
		}

		public List<Item> GetAllEquippedItems()
		{
			CharacterMainControl main = CharacterMainControl.Main;
			if (main == null)
			{
				return null;
			}
			Item characterItem = main.CharacterItem;
			if (characterItem == null)
			{
				return null;
			}
			SlotCollection slots = characterItem.Slots;
			if (slots == null)
			{
				return null;
			}
			List<Item> list = new List<Item>();
			foreach (Slot item in slots)
			{
				if (item != null)
				{
					Item content = item.Content;
					if (!(content == null))
					{
						list.Add(content);
					}
				}
			}
			return list;
		}

		public int CalculateRepairPrice(List<Item> itemsToRepair)
		{
			int num = 0;
			foreach (Item item in itemsToRepair)
			{
				num += CalculateRepairPrice(item, out var _, out var _, out var _);
			}
			return num;
		}

		public void RepairItems(List<Item> itemsToRepair)
		{
			if (!EconomyManager.Pay(new Cost(CalculateRepairPrice(itemsToRepair))))
			{
				return;
			}
			foreach (Item item in itemsToRepair)
			{
				Repair(item, prepaied: true);
			}
		}
	}
	public class LootView : View
	{
		[SerializeField]
		private ItemSlotCollectionDisplay characterSlotCollectionDisplay;

		[SerializeField]
		private InventoryDisplay characterInventoryDisplay;

		[SerializeField]
		private InventoryDisplay petInventoryDisplay;

		[SerializeField]
		private InventoryDisplay lootTargetInventoryDisplay;

		[SerializeField]
		private InventoryFilterDisplay lootTargetFilterDisplay;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private UnityEngine.UI.Button pickAllButton;

		[SerializeField]
		private TextMeshProUGUI lootTargetDisplayName;

		[SerializeField]
		private TextMeshProUGUI lootTargetCapacityText;

		[SerializeField]
		private string lootTargetCapacityTextFormat = "({itemCount}/{capacity})";

		[SerializeField]
		private UnityEngine.UI.Button storeAllButton;

		[SerializeField]
		private FadeGroup lootTargetFadeGroup;

		[SerializeField]
		private ItemDetailsDisplay detailsDisplay;

		[SerializeField]
		private FadeGroup detailsFadeGroup;

		[SerializeField]
		private InteractableLootbox targetLootBox;

		private Inventory targetInventory;

		private HashSet<Inventory> lootedInventories = new HashSet<Inventory>();

		public static LootView Instance => View.GetViewInstance<LootView>();

		private CharacterMainControl Character => LevelManager.Instance.MainCharacter;

		private Item CharacterItem
		{
			get
			{
				if (Character == null)
				{
					return null;
				}
				return Character.CharacterItem;
			}
		}

		public Inventory TargetInventory
		{
			get
			{
				if (targetLootBox != null)
				{
					return targetLootBox.Inventory;
				}
				if ((bool)targetInventory)
				{
					return targetInventory;
				}
				return null;
			}
		}

		public static bool HasInventoryEverBeenLooted(Inventory inventory)
		{
			if (Instance == null)
			{
				return false;
			}
			if (Instance.lootedInventories == null)
			{
				return false;
			}
			if (inventory == null)
			{
				return false;
			}
			return Instance.lootedInventories.Contains(inventory);
		}

		protected override void Awake()
		{
			base.Awake();
			InteractableLootbox.OnStartLoot += OnStartLoot;
			pickAllButton.onClick.AddListener(OnPickAllButtonClicked);
			CharacterMainControl.OnMainCharacterStartUseItem += OnMainCharacterStartUseItem;
			LevelManager.OnMainCharacterDead += OnMainCharacterDead;
			storeAllButton.onClick.AddListener(OnStoreAllButtonClicked);
		}

		private void OnStoreAllButtonClicked()
		{
			if (TargetInventory == null || TargetInventory != PlayerStorage.Inventory || CharacterItem == null)
			{
				return;
			}
			Inventory inventory = CharacterItem.Inventory;
			if (inventory == null)
			{
				return;
			}
			int lastItemPosition = inventory.GetLastItemPosition();
			for (int i = 0; i <= lastItemPosition; i++)
			{
				if (inventory.lockedIndexes.Contains(i))
				{
					continue;
				}
				Item itemAt = inventory.GetItemAt(i);
				if (!(itemAt == null))
				{
					if (!TargetInventory.AddAndMerge(itemAt))
					{
						break;
					}
					if (i == 0)
					{
						AudioManager.PlayPutItemSFX(itemAt);
					}
				}
			}
		}

		protected override void OnDestroy()
		{
			UnregisterEvents();
			InteractableLootbox.OnStartLoot -= OnStartLoot;
			LevelManager.OnMainCharacterDead -= OnMainCharacterDead;
			base.OnDestroy();
		}

		private void OnMainCharacterStartUseItem(Item _item)
		{
			if (base.open)
			{
				Close();
			}
		}

		private void OnMainCharacterDead(DamageInfo dmgInfo)
		{
			if (base.open)
			{
				Close();
			}
		}

		private void OnEnable()
		{
			RegisterEvents();
		}

		private void OnDisable()
		{
			UnregisterEvents();
			targetLootBox?.StopInteract();
			targetLootBox = null;
		}

		public void Show()
		{
			Open();
		}

		private void OnStartLoot(InteractableLootbox lootbox)
		{
			targetLootBox = lootbox;
			if (targetLootBox == null || targetLootBox.Inventory == null)
			{
				UnityEngine.Debug.LogError("Target loot box could not be found");
				return;
			}
			Open();
			if (TargetInventory != null)
			{
				lootedInventories.Add(TargetInventory);
			}
		}

		private void OnStopLoot(InteractableLootbox lootbox)
		{
			if (lootbox == targetLootBox)
			{
				targetLootBox = null;
				Close();
			}
		}

		public static void LootItem(Item item)
		{
			if (!(item == null) && !(Instance == null))
			{
				Instance.targetInventory = item.Inventory;
				Instance.Open();
			}
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			UnregisterEvents();
			base.gameObject.SetActive(value: true);
			characterSlotCollectionDisplay.Setup(CharacterItem, movable: true);
			if ((bool)PetProxy.PetInventory)
			{
				petInventoryDisplay.gameObject.SetActive(value: true);
				petInventoryDisplay.Setup(PetProxy.PetInventory);
			}
			else
			{
				petInventoryDisplay.gameObject.SetActive(value: false);
			}
			characterInventoryDisplay.Setup(CharacterItem.Inventory, null, null, movable: true);
			if (targetLootBox != null)
			{
				lootTargetInventoryDisplay.ShowSortButton = targetLootBox.ShowSortButton;
				lootTargetInventoryDisplay.Setup(TargetInventory, null, null, movable: true);
				lootTargetDisplayName.text = TargetInventory.DisplayName;
				if ((bool)TargetInventory.GetComponent<InventoryFilterProvider>())
				{
					lootTargetFilterDisplay.gameObject.SetActive(value: true);
					lootTargetFilterDisplay.Setup(lootTargetInventoryDisplay);
					lootTargetFilterDisplay.Select(0);
				}
				else
				{
					lootTargetFilterDisplay.gameObject.SetActive(value: false);
				}
				lootTargetFadeGroup.Show();
			}
			else if (targetInventory != null)
			{
				lootTargetInventoryDisplay.ShowSortButton = false;
				lootTargetInventoryDisplay.Setup(TargetInventory, null, null, movable: true);
				lootTargetFadeGroup.Show();
				lootTargetFilterDisplay.gameObject.SetActive(value: false);
			}
			else
			{
				lootTargetFadeGroup.SkipHide();
			}
			bool active = TargetInventory != null && TargetInventory == PlayerStorage.Inventory;
			storeAllButton.gameObject.SetActive(active);
			fadeGroup.Show();
			RefreshDetails();
			RefreshPickAllButton();
			RegisterEvents();
			RefreshCapacityText();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
			detailsFadeGroup.Hide();
			targetLootBox?.StopInteract();
			targetLootBox = null;
			targetInventory = null;
			if ((bool)SplitDialogue.Instance && SplitDialogue.Instance.isActiveAndEnabled)
			{
				SplitDialogue.Instance.Cancel();
			}
			UnregisterEvents();
		}

		private void OnTargetInventoryContentChanged(Inventory inventory, int arg2)
		{
			RefreshPickAllButton();
			RefreshCapacityText();
		}

		private void RefreshCapacityText()
		{
			if (targetLootBox != null)
			{
				lootTargetCapacityText.text = lootTargetCapacityTextFormat.Format(new
				{
					itemCount = TargetInventory.GetItemCount(),
					capacity = TargetInventory.Capacity
				});
			}
		}

		private void RegisterEvents()
		{
			UnregisterEvents();
			ItemUIUtilities.OnSelectionChanged += OnSelectionChanged;
			lootTargetInventoryDisplay.onDisplayDoubleClicked += OnLootTargetItemDoubleClicked;
			characterInventoryDisplay.onDisplayDoubleClicked += OnCharacterInventoryItemDoubleClicked;
			petInventoryDisplay.onDisplayDoubleClicked += OnCharacterInventoryItemDoubleClicked;
			characterSlotCollectionDisplay.onElementDoubleClicked += OnCharacterSlotItemDoubleClicked;
			if ((bool)TargetInventory)
			{
				TargetInventory.onContentChanged += OnTargetInventoryContentChanged;
			}
			UIInputManager.OnNextPage += OnNextPage;
			UIInputManager.OnPreviousPage += OnPreviousPage;
		}

		private void OnPreviousPage(UIInputEventData data)
		{
			if (!(TargetInventory == null) && lootTargetInventoryDisplay.UsePages)
			{
				lootTargetInventoryDisplay.PreviousPage();
			}
		}

		private void OnNextPage(UIInputEventData data)
		{
			if (!(TargetInventory == null) && lootTargetInventoryDisplay.UsePages)
			{
				lootTargetInventoryDisplay.NextPage();
			}
		}

		private void UnregisterEvents()
		{
			ItemUIUtilities.OnSelectionChanged -= OnSelectionChanged;
			if ((bool)lootTargetInventoryDisplay)
			{
				lootTargetInventoryDisplay.onDisplayDoubleClicked -= OnLootTargetItemDoubleClicked;
			}
			if ((bool)characterInventoryDisplay)
			{
				characterInventoryDisplay.onDisplayDoubleClicked -= OnCharacterInventoryItemDoubleClicked;
			}
			if ((bool)petInventoryDisplay)
			{
				petInventoryDisplay.onDisplayDoubleClicked -= OnCharacterInventoryItemDoubleClicked;
			}
			if ((bool)characterSlotCollectionDisplay)
			{
				characterSlotCollectionDisplay.onElementDoubleClicked -= OnCharacterSlotItemDoubleClicked;
			}
			if ((bool)TargetInventory)
			{
				TargetInventory.onContentChanged -= OnTargetInventoryContentChanged;
			}
			UIInputManager.OnNextPage -= OnNextPage;
			UIInputManager.OnPreviousPage -= OnPreviousPage;
		}

		private void OnCharacterSlotItemDoubleClicked(ItemSlotCollectionDisplay collectionDisplay, SlotDisplay slotDisplay)
		{
			if (slotDisplay == null)
			{
				return;
			}
			Slot target = slotDisplay.Target;
			if (target == null)
			{
				return;
			}
			Item content = target.Content;
			if (content == null || TargetInventory == null || (content.Sticky && !TargetInventory.AcceptSticky))
			{
				return;
			}
			AudioManager.PlayPutItemSFX(content);
			content.Detach();
			if (TargetInventory.AddAndMerge(content))
			{
				RefreshDetails();
				return;
			}
			if (!target.Plug(content, out var unpluggedItem))
			{
				UnityEngine.Debug.LogError("Failed plugging back!");
			}
			if (unpluggedItem != null)
			{
				UnityEngine.Debug.Log("Unplugged item should be null!");
			}
			RefreshDetails();
		}

		private void OnCharacterInventoryItemDoubleClicked(InventoryDisplay display, InventoryEntry entry, PointerEventData data)
		{
			Item content = entry.Content;
			if (content == null)
			{
				return;
			}
			Inventory inInventory = content.InInventory;
			if (TargetInventory == null || (content.Sticky && !TargetInventory.AcceptSticky))
			{
				return;
			}
			AudioManager.PlayPutItemSFX(content);
			content.Detach();
			if (TargetInventory.AddAndMerge(content))
			{
				RefreshDetails();
				return;
			}
			if (!inInventory.AddAndMerge(content))
			{
				UnityEngine.Debug.LogError("Failed sending back item");
			}
			RefreshDetails();
		}

		private void OnSelectionChanged()
		{
			RefreshDetails();
		}

		private void RefreshDetails()
		{
			if (ItemUIUtilities.SelectedItem != null)
			{
				detailsFadeGroup.Show();
				detailsDisplay.Setup(ItemUIUtilities.SelectedItem);
			}
			else
			{
				detailsFadeGroup.Hide();
			}
		}

		private void OnLootTargetItemDoubleClicked(InventoryDisplay display, InventoryEntry entry, PointerEventData data)
		{
			Item item = entry.Item;
			if (item == null || item.IsInPlayerCharacter())
			{
				return;
			}
			if (targetLootBox != null && targetLootBox.needInspect && !item.Inspected)
			{
				data.Use();
				return;
			}
			data.Use();
			bool flag = false;
			bool? flag2 = LevelManager.Instance?.MainCharacter?.CharacterItem?.TryPlug(item, emptyOnly: true);
			flag |= flag2.Value;
			if (!flag2.HasValue || !flag2.Value)
			{
				flag |= ItemUtilities.SendToPlayerCharacterInventory(item);
			}
			if (flag)
			{
				AudioManager.PlayPutItemSFX(item);
				RefreshDetails();
			}
		}

		private void RefreshPickAllButton()
		{
			if (!(TargetInventory == null))
			{
				pickAllButton.gameObject.SetActive(value: false);
				bool interactable = TargetInventory.GetItemCount() > 0;
				pickAllButton.interactable = interactable;
			}
		}

		private void OnPickAllButtonClicked()
		{
			if (TargetInventory == null)
			{
				return;
			}
			List<Item> list = new List<Item>();
			list.AddRange(TargetInventory);
			foreach (Item item in list)
			{
				if (!(item == null) && (!targetLootBox.needInspect || item.Inspected))
				{
					bool? flag = LevelManager.Instance?.MainCharacter?.CharacterItem?.TryPlug(item, emptyOnly: true);
					if (!flag.HasValue || !flag.Value)
					{
						ItemUtilities.SendToPlayerCharacterInventory(item);
					}
				}
			}
			AudioManager.Post("UI/confirm");
		}
	}
	public class MapSelectionEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private MapSelectionView master;

		[SerializeField]
		private TextMeshProUGUI displayNameText;

		[SerializeField]
		private CostDisplay costDisplay;

		[SerializeField]
		private GameObject lockedIndicator;

		[SerializeField]
		private Condition[] conditions;

		[SerializeField]
		private Cost cost;

		[SerializeField]
		[SceneID]
		private string sceneID;

		[SerializeField]
		private int beaconIndex;

		[SerializeField]
		private Sprite fullScreenImage;

		public Cost Cost => cost;

		public bool ConditionsSatisfied
		{
			get
			{
				if (conditions == null)
				{
					return true;
				}
				return conditions.Satisfied();
			}
		}

		public string SceneID => sceneID;

		public int BeaconIndex => beaconIndex;

		public Sprite FullScreenImage => fullScreenImage;

		public void Setup(MapSelectionView master)
		{
			this.master = master;
			Refresh();
		}

		private void OnEnable()
		{
			Refresh();
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (ConditionsSatisfied)
			{
				master.NotifyEntryClicked(this, eventData);
			}
		}

		private void Refresh()
		{
			SceneInfoEntry sceneInfo = SceneInfoCollection.GetSceneInfo(sceneID);
			displayNameText.text = sceneInfo.DisplayName;
			lockedIndicator.gameObject.SetActive(!ConditionsSatisfied);
			costDisplay.Setup(cost);
			costDisplay.gameObject.SetActive(!cost.IsFree);
		}
	}
	public class MapSelectionView : View
	{
		[SerializeField]
		private FadeGroup mainFadeGroup;

		[SerializeField]
		private FadeGroup confirmIndicatorFadeGroup;

		[SerializeField]
		private TextMeshProUGUI destinationDisplayNameText;

		[SerializeField]
		private CostDisplay confirmCostDisplay;

		private string sfx_EntryClicked = "UI/confirm";

		private string sfx_ShowDestination = "UI/destination_show";

		private string sfx_ConfirmDestination = "UI/destination_confirm";

		[SerializeField]
		private ColorPunch confirmColorPunch;

		[SerializeField]
		private UnityEngine.UI.Button btnConfirm;

		[SerializeField]
		private UnityEngine.UI.Button btnCancel;

		[SerializeField]
		private SceneReference overrideLoadingScreen;

		private bool loading;

		private bool confirmButtonClicked;

		private bool cancelButtonClicked;

		public static MapSelectionView Instance => View.GetViewInstance<MapSelectionView>();

		protected override void Awake()
		{
			base.Awake();
			btnConfirm.onClick.AddListener(delegate
			{
				confirmButtonClicked = true;
			});
			btnCancel.onClick.AddListener(delegate
			{
				cancelButtonClicked = true;
			});
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			confirmIndicatorFadeGroup.SkipHide();
			mainFadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			mainFadeGroup.Hide();
		}

		internal void NotifyEntryClicked(MapSelectionEntry mapSelectionEntry, PointerEventData eventData)
		{
			if (mapSelectionEntry.Cost.Enough)
			{
				AudioManager.Post(sfx_EntryClicked);
				string sceneID = mapSelectionEntry.SceneID;
				LevelManager.loadLevelBeaconIndex = mapSelectionEntry.BeaconIndex;
				loading = true;
				LoadTask(sceneID, mapSelectionEntry.Cost).Forget();
			}
		}

		private async UniTask LoadTask(string sceneID, Cost cost)
		{
			btnCancel.gameObject.SetActive(value: true);
			btnConfirm.gameObject.SetActive(value: false);
			SceneInfoEntry sceneInfo = SceneInfoCollection.GetSceneInfo(sceneID);
			SetupSceneInfo(sceneInfo);
			confirmCostDisplay.Setup(cost);
			confirmCostDisplay.gameObject.SetActive(!cost.IsFree);
			AudioManager.Post(sfx_ShowDestination);
			await confirmIndicatorFadeGroup.ShowAndReturnTask();
			btnConfirm.gameObject.SetActive(value: true);
			bool num = await WaitForConfirm();
			btnCancel.gameObject.SetActive(value: false);
			btnConfirm.gameObject.SetActive(value: false);
			if (num && cost.Enough)
			{
				cost.Pay();
				confirmColorPunch.Punch();
				AudioManager.Post(sfx_ConfirmDestination);
				await UniTask.WaitForSeconds(0.5f, ignoreTimeScale: true);
				SceneLoader.Instance.LoadScene(sceneID, overrideLoadingScreen, clickToConinue: true).Forget();
			}
			else
			{
				confirmIndicatorFadeGroup.Hide();
			}
			loading = false;
		}

		private async UniTask<bool> WaitForConfirm()
		{
			confirmButtonClicked = false;
			cancelButtonClicked = false;
			while (true)
			{
				if (cancelButtonClicked)
				{
					return false;
				}
				if (confirmButtonClicked)
				{
					break;
				}
				await UniTask.Yield();
			}
			return true;
		}

		private void SetupSceneInfo(SceneInfoEntry info)
		{
			if (info != null)
			{
				string displayName = info.DisplayName;
				destinationDisplayNameText.text = displayName;
				destinationDisplayNameText.color = Color.white;
			}
		}

		internal override void TryQuit()
		{
			if (!loading)
			{
				Close();
			}
		}
	}
	public class PerkDetails : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup content;

		[SerializeField]
		private FadeGroup placeHolder;

		[SerializeField]
		private TextMeshProUGUI text_Name;

		[SerializeField]
		private TextMeshProUGUI text_Description;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TrueShadow iconShadow;

		[SerializeField]
		private GameObject unlockedIndicator;

		[SerializeField]
		private GameObject activationInfoParent;

		[SerializeField]
		private TextMeshProUGUI text_RequireLevel;

		[SerializeField]
		private CostDisplay costDisplay;

		[SerializeField]
		private Color normalTextColor = Color.white;

		[SerializeField]
		private Color unsatisfiedTextColor = Color.red;

		[SerializeField]
		private UnityEngine.UI.Button activateButton;

		[SerializeField]
		private UnityEngine.UI.Button beginButton;

		[SerializeField]
		private GameObject buttonUnsatisfiedPlaceHolder;

		[SerializeField]
		private GameObject buttonUnavaliablePlaceHolder;

		[SerializeField]
		private GameObject inProgressPlaceHolder;

		[SerializeField]
		private UnityEngine.UI.Image progressFillImage;

		[SerializeField]
		private TextMeshProUGUI countDownText;

		private Perk showingPerk;

		private bool editable;

		[SerializeField]
		private string RequireLevelFormatKey => "UI_Perk_RequireLevel";

		[SerializeField]
		private string RequireLevelFormat => RequireLevelFormatKey.ToPlainText();

		private void Awake()
		{
			beginButton.onClick.AddListener(OnBeginButtonClicked);
			activateButton.onClick.AddListener(OnActivateButtonClicked);
		}

		private void OnActivateButtonClicked()
		{
			showingPerk.ConfirmUnlock();
		}

		private void OnBeginButtonClicked()
		{
			showingPerk.SubmitItemsAndBeginUnlocking();
		}

		private void OnEnable()
		{
			Refresh();
		}

		public void Setup(Perk perk, bool editable = false)
		{
			UnregisterEvents();
			showingPerk = perk;
			this.editable = editable;
			Refresh();
			RegisterEvents();
		}

		private void RegisterEvents()
		{
			if ((bool)showingPerk)
			{
				showingPerk.onUnlockStateChanged += OnTargetStateChanged;
			}
		}

		private void OnTargetStateChanged(Perk perk, bool arg2)
		{
			Refresh();
		}

		private void UnregisterEvents()
		{
			if ((bool)showingPerk)
			{
				showingPerk.onUnlockStateChanged -= OnTargetStateChanged;
			}
		}

		private void Refresh()
		{
			if (showingPerk == null)
			{
				content.Hide();
				placeHolder.Show();
				return;
			}
			text_Name.text = showingPerk.DisplayName;
			text_Description.text = showingPerk.Description;
			icon.sprite = showingPerk.Icon;
			(float, Color, bool) shadowOffsetAndColorOfQuality = GameplayDataSettings.UIStyle.GetShadowOffsetAndColorOfQuality(showingPerk.DisplayQuality);
			iconShadow.IgnoreCasterColor = true;
			iconShadow.Color = shadowOffsetAndColorOfQuality.Item2;
			iconShadow.Inset = shadowOffsetAndColorOfQuality.Item3;
			iconShadow.OffsetDistance = shadowOffsetAndColorOfQuality.Item1;
			bool flag = !showingPerk.Unlocked && editable;
			bool flag2 = showingPerk.AreAllParentsUnlocked();
			bool flag3 = false;
			if (flag2)
			{
				flag3 = showingPerk.Requirement.AreSatisfied();
			}
			activateButton.gameObject.SetActive(value: false);
			beginButton.gameObject.SetActive(value: false);
			buttonUnavaliablePlaceHolder.SetActive(value: false);
			buttonUnsatisfiedPlaceHolder.SetActive(value: false);
			inProgressPlaceHolder.SetActive(value: false);
			unlockedIndicator.SetActive(showingPerk.Unlocked);
			if (!showingPerk.Unlocked)
			{
				if (showingPerk.Unlocking)
				{
					if (showingPerk.GetRemainingTime() <= TimeSpan.Zero)
					{
						activateButton.gameObject.SetActive(value: true);
					}
					else
					{
						inProgressPlaceHolder.SetActive(value: true);
					}
				}
				else if (flag2)
				{
					if (flag3)
					{
						beginButton.gameObject.SetActive(value: true);
					}
					else
					{
						buttonUnsatisfiedPlaceHolder.SetActive(value: true);
					}
				}
				else
				{
					buttonUnavaliablePlaceHolder.SetActive(value: true);
				}
			}
			if (flag)
			{
				SetupActivationInfo();
			}
			activationInfoParent.SetActive(flag);
			content.Show();
			placeHolder.Hide();
		}

		private void SetupActivationInfo()
		{
			if ((bool)showingPerk)
			{
				int level = showingPerk.Requirement.level;
				if (level > 0)
				{
					bool flag = EXPManager.Level >= level;
					string text = "#" + (flag ? normalTextColor.ToHexString() : unsatisfiedTextColor.ToHexString());
					text_RequireLevel.gameObject.SetActive(value: true);
					int level2 = showingPerk.Requirement.level;
					string color = text;
					text_RequireLevel.text = RequireLevelFormat.Format(new
					{
						level = level2,
						color = color
					});
				}
				else
				{
					text_RequireLevel.gameObject.SetActive(value: false);
				}
				costDisplay.Setup(showingPerk.Requirement.cost);
			}
		}

		private void Update()
		{
			if ((bool)showingPerk && showingPerk.Unlocking && inProgressPlaceHolder.activeSelf)
			{
				UpdateCountDown();
			}
		}

		private void UpdateCountDown()
		{
			TimeSpan remainingTime = showingPerk.GetRemainingTime();
			if (remainingTime <= TimeSpan.Zero)
			{
				Refresh();
				return;
			}
			progressFillImage.fillAmount = showingPerk.GetProgress01();
			countDownText.text = $"{remainingTime.Days} {remainingTime.Hours:00}:{remainingTime.Minutes:00}:{remainingTime.Seconds:00}.{remainingTime.Milliseconds:000}";
		}
	}
	public class PerkEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler, Duckov.Utilities.IPoolable
	{
		[Serializable]
		public struct Look
		{
			public Color iconColor;

			public Material material;

			public Color frameColor;

			public Color frameGlowColor;

			public Color backgroundColor;
		}

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TrueShadow iconShadow;

		[SerializeField]
		private GameObject selectionIndicator;

		[SerializeField]
		private UnityEngine.UI.Image frame;

		[SerializeField]
		private TrueShadow frameGlow;

		[SerializeField]
		private UnityEngine.UI.Image background;

		[SerializeField]
		private TextMeshProUGUI displayNameText;

		[SerializeField]
		private PunchReceiver punchReceiver;

		[SerializeField]
		private GameObject inProgressIndicator;

		[SerializeField]
		private GameObject timeUpIndicator;

		[SerializeField]
		private GameObject avaliableForResearchIndicator;

		[SerializeField]
		private Look activeLook;

		[SerializeField]
		private Look avaliableLook;

		[SerializeField]
		private Look unavaliableLook;

		private RectTransform _rectTransform;

		private PerkTreeView master;

		private Perk target;

		public RectTransform RectTransform
		{
			get
			{
				if (_rectTransform == null)
				{
					_rectTransform = GetComponent<RectTransform>();
				}
				return _rectTransform;
			}
		}

		public Perk Target => target;

		private void SwitchToActiveLook()
		{
			ApplyLook(activeLook);
		}

		private void SwitchToAvaliableLook()
		{
			ApplyLook(avaliableLook);
		}

		private void SwitchToUnavaliableLook()
		{
			ApplyLook(unavaliableLook);
		}

		public void Setup(PerkTreeView master, Perk target)
		{
			UnregisterEvents();
			this.master = master;
			this.target = target;
			icon.sprite = target.Icon;
			(float, Color, bool) shadowOffsetAndColorOfQuality = GameplayDataSettings.UIStyle.GetShadowOffsetAndColorOfQuality(target.DisplayQuality);
			iconShadow.IgnoreCasterColor = true;
			iconShadow.Color = shadowOffsetAndColorOfQuality.Item2;
			iconShadow.OffsetDistance = shadowOffsetAndColorOfQuality.Item1;
			iconShadow.Inset = shadowOffsetAndColorOfQuality.Item3;
			displayNameText.text = target.DisplayName;
			Refresh();
			RegisterEvents();
		}

		private void Refresh()
		{
			if (!(target == null))
			{
				bool unlocked = target.Unlocked;
				bool flag = target.AreAllParentsUnlocked();
				if (unlocked)
				{
					SwitchToActiveLook();
				}
				else if (flag)
				{
					SwitchToAvaliableLook();
				}
				else
				{
					SwitchToUnavaliableLook();
				}
				bool unlocking = target.Unlocking;
				bool flag2 = target.GetRemainingTime() <= TimeSpan.Zero;
				avaliableForResearchIndicator.SetActive(!unlocked && !unlocking && target.AreAllParentsUnlocked() && target.Requirement.AreSatisfied());
				inProgressIndicator.SetActive(!unlocked && unlocking && !flag2);
				timeUpIndicator.SetActive(!unlocked && unlocking && flag2);
				if (!(master == null))
				{
					selectionIndicator.SetActive(master.GetSelection() == this);
				}
			}
		}

		private void OnMasterSelectionChanged(PerkEntry entry)
		{
			Refresh();
		}

		private void RegisterEvents()
		{
			if ((bool)master)
			{
				master.onSelectionChanged += OnMasterSelectionChanged;
			}
			if ((bool)target)
			{
				target.onUnlockStateChanged += OnTargetStateChanged;
			}
		}

		private void OnTargetStateChanged(Perk perk, bool state)
		{
			punchReceiver?.Punch();
			Refresh();
		}

		private void UnregisterEvents()
		{
			if ((bool)master)
			{
				master.onSelectionChanged -= OnMasterSelectionChanged;
			}
			if ((bool)target)
			{
				target.onUnlockStateChanged -= OnTargetStateChanged;
			}
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (!(master == null))
			{
				punchReceiver?.Punch();
				master.SetSelection(this);
			}
		}

		internal Vector2 GetLayoutPosition()
		{
			if (target == null)
			{
				return Vector2.zero;
			}
			return target.GetLayoutPosition();
		}

		private void ApplyLook(Look look)
		{
			icon.material = look.material;
			icon.color = look.iconColor;
			frame.color = look.frameColor;
			frameGlow.enabled = look.frameGlowColor.a > 0f;
			frameGlow.Color = look.frameGlowColor;
			background.color = look.backgroundColor;
		}

		private void FixedUpdate()
		{
			if (inProgressIndicator.activeSelf && target.GetRemainingTime() <= TimeSpan.Zero)
			{
				Refresh();
			}
		}
	}
	public class PerkLineEntry : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI label;

		private RectTransform _rectTransform;

		private PerkLevelLineNode target;

		public RectTransform RectTransform
		{
			get
			{
				if (_rectTransform == null)
				{
					_rectTransform = GetComponent<RectTransform>();
				}
				return _rectTransform;
			}
		}

		internal void Setup(PerkTreeView perkTreeView, PerkLevelLineNode cur)
		{
			target = cur;
			label.text = target.DisplayName;
		}

		internal Vector2 GetLayoutPosition()
		{
			if (target == null)
			{
				return Vector2.zero;
			}
			return target.cachedPosition;
		}
	}
	public class RequireItemEntry : MonoBehaviour, Duckov.Utilities.IPoolable
	{
		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private string textFormat = "{0} x{1}";

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
		}

		public void Setup(PerkRequirement.RequireItemEntry target)
		{
			int id = target.id;
			ItemMetaData metaData = ItemAssetsCollection.GetMetaData(id);
			icon.sprite = metaData.icon;
			string displayName = metaData.DisplayName;
			int itemCount = ItemUtilities.GetItemCount(id);
			text.text = string.Format(textFormat, displayName, target.amount, itemCount);
		}
	}
	public class PerkTreeView : View, ISingleSelectionMenu<PerkEntry>
	{
		[SerializeField]
		private TextMeshProUGUI title;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private RectTransform contentParent;

		[SerializeField]
		private PerkDetails details;

		[SerializeField]
		private PerkEntry perkEntryPrefab;

		[SerializeField]
		private PerkLineEntry perkLinePrefab;

		[SerializeField]
		private UISplineRenderer activeConnectionsRenderer;

		[SerializeField]
		private UISplineRenderer inactiveConnectionsRenderer;

		[SerializeField]
		private float splineTangent = 100f;

		[SerializeField]
		private PerkTree target;

		private PrefabPool<PerkEntry> _perkEntryPool;

		private PrefabPool<PerkLineEntry> _perkLinePool;

		private PerkEntry selectedPerkEntry;

		[SerializeField]
		private float layoutFactor = 10f;

		[SerializeField]
		private Vector2 padding = Vector2.one;

		public static PerkTreeView Instance => View.GetViewInstance<PerkTreeView>();

		private PrefabPool<PerkEntry> PerkEntryPool
		{
			get
			{
				if (_perkEntryPool == null)
				{
					_perkEntryPool = new PrefabPool<PerkEntry>(perkEntryPrefab, contentParent);
				}
				return _perkEntryPool;
			}
		}

		private PrefabPool<PerkLineEntry> PerkLinePool
		{
			get
			{
				if (_perkLinePool == null)
				{
					_perkLinePool = new PrefabPool<PerkLineEntry>(perkLinePrefab, contentParent);
				}
				return _perkLinePool;
			}
		}

		protected override bool ShowOpenCloseButtons => false;

		internal event Action<PerkEntry> onSelectionChanged;

		private void PopulatePerks()
		{
			contentParent.ForceUpdateRectTransforms();
			PerkEntryPool.ReleaseAll();
			PerkLinePool.ReleaseAll();
			bool isDemo = GameMetaData.Instance.IsDemo;
			foreach (Perk perk in target.Perks)
			{
				if ((!isDemo || !perk.LockInDemo) && target.RelationGraphOwner.GetRelatedNode(perk) != null)
				{
					PerkEntryPool.Get(contentParent).Setup(this, perk);
				}
			}
			foreach (PerkLevelLineNode item in target.RelationGraphOwner.graph.GetAllNodesOfType<PerkLevelLineNode>())
			{
				PerkLinePool.Get(contentParent).Setup(this, item);
			}
			FitChildren();
			RefreshConnections();
		}

		private void RefreshConnections()
		{
			bool isDemo = GameMetaData.Instance.IsDemo;
			activeConnectionsRenderer.enabled = false;
			inactiveConnectionsRenderer.enabled = false;
			SplineContainer splineContainer = activeConnectionsRenderer.splineContainer;
			SplineContainer splineContainer2 = inactiveConnectionsRenderer.splineContainer;
			ClearSplines(splineContainer);
			ClearSplines(splineContainer2);
			bool horizontal = target.Horizontal;
			Vector3 splineTangentVector = (horizontal ? Vector3.left : Vector3.up) * splineTangent;
			foreach (Perk perk in target.Perks)
			{
				if (isDemo && perk.LockInDemo)
				{
					continue;
				}
				PerkRelationNode relatedNode = target.RelationGraphOwner.GetRelatedNode(perk);
				PerkEntry perkEntry = GetPerkEntry(perk);
				if (perkEntry == null || relatedNode == null)
				{
					continue;
				}
				SplineContainer container = (perk.Unlocked ? splineContainer : splineContainer2);
				foreach (NodeCanvas.Framework.Connection outConnection in relatedNode.outConnections)
				{
					PerkRelationNode perkRelationNode = outConnection.targetNode as PerkRelationNode;
					Perk relatedNode2 = perkRelationNode.relatedNode;
					if (relatedNode2 == null)
					{
						UnityEngine.Debug.Log("Target Perk is Null (Connection from " + relatedNode.name + " to " + perkRelationNode.name + ")");
					}
					else if (!isDemo || !relatedNode2.LockInDemo)
					{
						PerkEntry perkEntry2 = GetPerkEntry(relatedNode2);
						if (perkEntry2 == null)
						{
							UnityEngine.Debug.Log("Target Perk Entry is Null (Connection from " + relatedNode.name + " to " + perkRelationNode.name + ")");
						}
						else
						{
							AddConnection(container, perkEntry.transform.localPosition, perkEntry2.transform.localPosition);
						}
					}
				}
			}
			activeConnectionsRenderer.enabled = true;
			inactiveConnectionsRenderer.enabled = true;
			void AddConnection(SplineContainer container2, Vector2 from, Vector2 to)
			{
				if (horizontal)
				{
					container2.AddSpline(new Spline(new BezierKnot[4]
					{
						new BezierKnot((Vector3)from, splineTangentVector, -splineTangentVector),
						new BezierKnot((Vector3)from - splineTangentVector, splineTangentVector, -splineTangentVector),
						new BezierKnot(new Vector3(from.x, to.y) - 2f * splineTangentVector, splineTangentVector, -splineTangentVector),
						new BezierKnot((Vector3)to, splineTangentVector, -splineTangentVector)
					}));
				}
				else
				{
					container2.AddSpline(new Spline(new BezierKnot[4]
					{
						new BezierKnot((Vector3)from, splineTangentVector, -splineTangentVector),
						new BezierKnot((Vector3)from - splineTangentVector, splineTangentVector, -splineTangentVector),
						new BezierKnot(new Vector3(to.x, from.y) - 2f * splineTangentVector, splineTangentVector, -splineTangentVector),
						new BezierKnot((Vector3)to, splineTangentVector, -splineTangentVector)
					}));
				}
			}
			static void ClearSplines(SplineContainer splineContainer3)
			{
				while (splineContainer3.Splines.Count > 0)
				{
					splineContainer3.RemoveSplineAt(0);
				}
			}
		}

		private PerkEntry GetPerkEntry(Perk ofPerk)
		{
			return PerkEntryPool.ActiveEntries.FirstOrDefault((PerkEntry e) => e != null && e.Target == ofPerk);
		}

		private void FitChildren()
		{
			contentParent.ForceUpdateRectTransforms();
			ReadOnlyCollection<PerkEntry> activeEntries = PerkEntryPool.ActiveEntries;
			float num2;
			float num = (num2 = float.MaxValue);
			float num4;
			float num3 = (num4 = float.MinValue);
			foreach (PerkEntry item in activeEntries)
			{
				RectTransform rectTransform = item.RectTransform;
				rectTransform.anchorMin = Vector2.zero;
				rectTransform.anchorMax = Vector2.zero;
				Vector2 layoutPosition = item.GetLayoutPosition();
				layoutPosition.y *= -1f;
				Vector2 vector = (rectTransform.anchoredPosition = layoutPosition * layoutFactor);
				if (vector.x < num)
				{
					num = vector.x;
				}
				if (vector.y < num2)
				{
					num2 = vector.y;
				}
				if (vector.x > num3)
				{
					num3 = vector.x;
				}
				if (vector.y > num4)
				{
					num4 = vector.y;
				}
			}
			float num5 = num3 - num;
			float num6 = num4 - num2;
			Vector2 vector3 = -new Vector2(num, num2);
			RectTransform rectTransform2 = contentParent;
			Vector2 sizeDelta = rectTransform2.sizeDelta;
			sizeDelta.y = num6 + padding.y * 2f;
			rectTransform2.sizeDelta = sizeDelta;
			foreach (PerkEntry item2 in activeEntries)
			{
				RectTransform rectTransform3 = item2.RectTransform;
				Vector2 anchoredPosition = rectTransform3.anchoredPosition + vector3;
				if (num5 == 0f)
				{
					anchoredPosition.x = (rectTransform2.rect.width - padding.x * 2f) / 2f;
				}
				else
				{
					float num7 = (rectTransform2.rect.width - padding.x * 2f) / num5;
					anchoredPosition.x *= num7;
				}
				anchoredPosition += padding;
				rectTransform3.anchoredPosition = anchoredPosition;
			}
			foreach (PerkLineEntry activeEntry in PerkLinePool.ActiveEntries)
			{
				RectTransform rectTransform4 = activeEntry.RectTransform;
				Vector2 layoutPosition2 = activeEntry.GetLayoutPosition();
				layoutPosition2.y *= -1f;
				Vector2 anchoredPosition2 = layoutPosition2 * layoutFactor;
				anchoredPosition2 += padding;
				anchoredPosition2.x = rectTransform4.anchoredPosition.x;
				rectTransform4.anchoredPosition = anchoredPosition2;
				rectTransform4.SetAsFirstSibling();
			}
			contentParent.anchoredPosition = Vector2.zero;
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		public PerkEntry GetSelection()
		{
			return selectedPerkEntry;
		}

		public bool SetSelection(PerkEntry selection)
		{
			selectedPerkEntry = selection;
			OnSelectionChanged();
			return true;
		}

		private void OnSelectionChanged()
		{
			this.onSelectionChanged?.Invoke(selectedPerkEntry);
			RefreshDetails();
		}

		private void RefreshDetails()
		{
			details.Setup(selectedPerkEntry?.Target, editable: true);
		}

		private void Show_Local(PerkTree target)
		{
			UnregisterEvents();
			SetSelection(null);
			this.target = target;
			title.text = target.DisplayName;
			ShowTask().Forget();
			RegisterEvents();
		}

		public static void Show(PerkTree target)
		{
			if (!(Instance == null))
			{
				Instance.Show_Local(target);
			}
		}

		private void RegisterEvents()
		{
			if (target != null)
			{
				target.onPerkTreeStatusChanged += Refresh;
			}
		}

		private void UnregisterEvents()
		{
			if (target != null)
			{
				target.onPerkTreeStatusChanged -= Refresh;
			}
		}

		private void Refresh(PerkTree tree)
		{
			RefreshConnections();
		}

		private async UniTask ShowTask()
		{
			if (target == null)
			{
				Close();
				return;
			}
			Open();
			await UniTask.WaitForEndOfFrame(this);
			await UniTask.WaitForEndOfFrame(this);
			await UniTask.WaitForEndOfFrame(this);
			PopulatePerks();
		}

		public void Hide()
		{
			Close();
		}

		protected override void Awake()
		{
			base.Awake();
		}
	}
	public class PlayerStatsView : View
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		public static PlayerStatsView Instance => View.GetViewInstance<PlayerStatsView>();

		protected override void Awake()
		{
			base.Awake();
		}

		protected override void OnOpen()
		{
			base.OnOpen();
			fadeGroup.Show();
		}

		protected override void OnClose()
		{
			base.OnClose();
			fadeGroup.Hide();
		}

		private void OnEnable()
		{
			RegisterEvents();
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		private void RegisterEvents()
		{
		}

		private void UnregisterEvents()
		{
		}
	}
	public class CloseViewOnPointerClick : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		private const bool FunctionEnabled = false;

		[SerializeField]
		private View view;

		[SerializeField]
		private Graphic graphic;

		private void OnValidate()
		{
			if (view == null)
			{
				view = GetComponent<View>();
			}
			if (graphic == null)
			{
				graphic = GetComponent<Graphic>();
			}
		}

		private void Awake()
		{
			if (view == null)
			{
				view = GetComponent<View>();
			}
			if (graphic == null)
			{
				graphic = GetComponent<Graphic>();
			}
			ManagedUIElement.onOpen += OnViewOpen;
			ManagedUIElement.onClose += OnViewClose;
		}

		private void OnDestroy()
		{
			ManagedUIElement.onOpen -= OnViewOpen;
			ManagedUIElement.onClose -= OnViewClose;
		}

		private void OnViewClose(ManagedUIElement element)
		{
			if (!(element != view) && !(graphic == null))
			{
				graphic.enabled = false;
			}
		}

		private void OnViewOpen(ManagedUIElement element)
		{
			if (!(element != view) && !(graphic == null))
			{
				graphic.enabled = true;
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
		}
	}
	public abstract class View : ManagedUIElement
	{
		[HideInInspector]
		private static View _activeView;

		[SerializeField]
		private ViewTabs viewTabs;

		[SerializeField]
		private UnityEngine.UI.Button exitButton;

		[SerializeField]
		private string sfx_Open;

		[SerializeField]
		private string sfx_Close;

		private bool autoClose = true;

		public static View ActiveView
		{
			get
			{
				return _activeView;
			}
			private set
			{
				View activeView = _activeView;
				_activeView = value;
				if (activeView != _activeView)
				{
					View.OnActiveViewChanged?.Invoke();
				}
			}
		}

		public static event Action OnActiveViewChanged;

		protected override void Awake()
		{
			base.Awake();
			if (exitButton != null)
			{
				exitButton.onClick.AddListener(base.Close);
			}
			UIInputManager.OnNavigate += OnNavigate;
			UIInputManager.OnConfirm += OnConfirm;
			UIInputManager.OnCancel += OnCancel;
			viewTabs = base.transform.parent.parent.GetComponent<ViewTabs>();
			if (autoClose)
			{
				Close();
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			UIInputManager.OnNavigate -= OnNavigate;
			UIInputManager.OnConfirm -= OnConfirm;
			UIInputManager.OnCancel -= OnCancel;
		}

		protected override void OnOpen()
		{
			autoClose = false;
			if (ActiveView != null && ActiveView != this)
			{
				ActiveView.Close();
			}
			ActiveView = this;
			ItemUIUtilities.Select(null);
			if (viewTabs != null)
			{
				viewTabs.Show();
			}
			if (base.gameObject == null)
			{
				UnityEngine.Debug.LogError("GameObject不存在", base.gameObject);
			}
			InputManager.DisableInput(base.gameObject);
			AudioManager.Post(sfx_Open);
		}

		protected override void OnClose()
		{
			if (ActiveView == this)
			{
				ActiveView = null;
			}
			InputManager.ActiveInput(base.gameObject);
			AudioManager.Post(sfx_Close);
		}

		internal virtual void TryQuit()
		{
			Close();
		}

		public void OnNavigate(UIInputEventData eventData)
		{
			if (!eventData.Used && !(ActiveView != this))
			{
				OnNavigate(eventData.vector);
			}
		}

		public void OnConfirm(UIInputEventData eventData)
		{
			if (!eventData.Used && !(ActiveView != this))
			{
				OnConfirm();
			}
		}

		public void OnCancel(UIInputEventData eventData)
		{
			if (!eventData.Used && !(ActiveView == null) && !(ActiveView != this))
			{
				OnCancel();
				if (!eventData.Used)
				{
					TryQuit();
					eventData.Use();
				}
			}
		}

		protected virtual void OnNavigate(Vector2 vector)
		{
		}

		protected virtual void OnConfirm()
		{
		}

		protected virtual void OnCancel()
		{
		}

		protected static T GetViewInstance<T>() where T : View
		{
			return GameplayUIManager.GetViewInstance<T>();
		}
	}
	public class WeightBarComplex : MonoBehaviour
	{
		[SerializeField]
		private CharacterMainControl target;

		[SerializeField]
		private RectTransform barArea;

		[SerializeField]
		private RectTransform mainBar;

		[SerializeField]
		private Graphic mainBarGraphic;

		[SerializeField]
		private RectTransform positiveBar;

		[SerializeField]
		private RectTransform negativeBar;

		[SerializeField]
		private RectTransform lightMark;

		[SerializeField]
		private RectTransform superHeavyMark;

		[SerializeField]
		private ToggleAnimation lightMarkToggle;

		[SerializeField]
		private ToggleAnimation superHeavyMarkToggle;

		[SerializeField]
		private Color superLightColor;

		[SerializeField]
		private Color lightColor;

		[SerializeField]
		private Color superHeavyColor;

		[SerializeField]
		private Color overweightColor;

		[SerializeField]
		private float animateDuration = 0.1f;

		[SerializeField]
		private AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		private float targetRealBarTop;

		private int currentToken;

		private CharacterMainControl Target
		{
			get
			{
				if (!target)
				{
					target = LevelManager.Instance?.MainCharacter;
				}
				return target;
			}
		}

		private float LightPercentage => 0.25f;

		private float SuperHeavyPercentage => 0.75f;

		private float MaxWeight
		{
			get
			{
				if (Target == null)
				{
					return 0f;
				}
				return Target.MaxWeight;
			}
		}

		private float BarWidth
		{
			get
			{
				if (barArea == null)
				{
					return 0f;
				}
				return barArea.rect.width;
			}
		}

		private void OnEnable()
		{
			ItemUIUtilities.OnSelectionChanged += OnItemSelectionChanged;
			if ((bool)Target)
			{
				Target.CharacterItem.onChildChanged += OnTargetChildChanged;
			}
			RefreshMarkPositions();
			ResetMainBar();
			Animate().Forget();
		}

		private void OnDisable()
		{
			ItemUIUtilities.OnSelectionChanged -= OnItemSelectionChanged;
			if ((bool)Target)
			{
				Target.CharacterItem.onChildChanged -= OnTargetChildChanged;
			}
		}

		private void RefreshMarkPositions()
		{
			if (!(lightMark == null) && !(superHeavyMark == null))
			{
				float num = BarWidth * LightPercentage;
				float num2 = BarWidth * SuperHeavyPercentage;
				lightMark.anchoredPosition = Vector2.right * num;
				superHeavyMark.anchoredPosition = Vector2.right * num2;
			}
		}

		private void RefreshMarkStatus()
		{
			float num = 0f;
			if (MaxWeight > 0f)
			{
				num = Target.CharacterItem.TotalWeight / MaxWeight;
			}
			lightMarkToggle.SetToggle(num > LightPercentage);
			superHeavyMarkToggle.SetToggle(num > SuperHeavyPercentage);
		}

		private void OnTargetChildChanged(Item item)
		{
			Animate().Forget();
		}

		private void OnItemSelectionChanged()
		{
			Animate().Forget();
		}

		private async UniTask Animate()
		{
			RefreshMarkPositions();
			RefreshMarkStatus();
			ResetChangeBars();
			int token = (currentToken = UnityEngine.Random.Range(int.MinValue, int.MaxValue));
			await AnimateMainBar(token);
			RefreshMarkPositions();
			if (token == currentToken)
			{
				UniTask uniTask = AnimatePositiveBar(token);
				UniTask uniTask2 = AnimateNegativeBar(token);
				RefreshMarkPositions();
				await UniTask.WhenAll(uniTask, uniTask2);
				RefreshMarkPositions();
			}
		}

		private void ResetChangeBars()
		{
			positiveBar.DOKill();
			negativeBar.DOKill();
			positiveBar.sizeDelta = new Vector2(positiveBar.sizeDelta.x, 0f);
			negativeBar.sizeDelta = new Vector2(negativeBar.sizeDelta.x, 0f);
		}

		private void ResetMainBar()
		{
			mainBar.DOKill();
			mainBar.sizeDelta = new Vector2(mainBar.sizeDelta.x, 0f);
		}

		private async UniTask AnimateMainBar(int token)
		{
			if (Target == null)
			{
				SetupInvalid();
				return;
			}
			await UniTask.NextFrame();
			if (token != currentToken)
			{
				return;
			}
			mainBar.DOKill();
			if (!(Target == null))
			{
				float totalWeight = Target.CharacterItem.TotalWeight;
				float x = WeightToRectHeight(totalWeight);
				_ = superLightColor;
				float num = 1f;
				if (MaxWeight > 0f)
				{
					num = totalWeight / MaxWeight;
				}
				TweenerCore<Color, Color, ColorOptions> tween = DOTweenModuleUI.DOColor(endValue: (num > 1f) ? overweightColor : ((num > SuperHeavyPercentage) ? superHeavyColor : ((!(num > LightPercentage)) ? superLightColor : lightColor)), target: mainBarGraphic, duration: animateDuration);
				TweenerCore<Vector2, Vector2, VectorOptions> tween2 = mainBar.DOSizeDelta(new Vector2(x, mainBar.sizeDelta.y), animateDuration).SetEase(animationCurve);
				await UniTask.WhenAll(tween.ToUniTask(), tween2.ToUniTask());
			}
		}

		private async UniTask AnimatePositiveBar(int token)
		{
			if (token == currentToken)
			{
				Item selectedItem = ItemUIUtilities.SelectedItem;
				float x = 0f;
				if (selectedItem != null && !selectedItem.IsInPlayerCharacter())
				{
					x = WeightToRectHeight(selectedItem.TotalWeight);
				}
				positiveBar.DOKill();
				await positiveBar.DOSizeDelta(new Vector2(x, positiveBar.sizeDelta.y), animateDuration).SetEase(animationCurve);
			}
		}

		private async UniTask AnimateNegativeBar(int token)
		{
			if (token == currentToken)
			{
				Item selectedItem = ItemUIUtilities.SelectedItem;
				float x = 0f;
				if (selectedItem != null && selectedItem.IsInPlayerCharacter())
				{
					x = WeightToRectHeight(selectedItem.TotalWeight);
				}
				negativeBar.DOKill();
				await negativeBar.DOSizeDelta(new Vector2(x, negativeBar.sizeDelta.y), animateDuration).SetEase(animationCurve);
			}
		}

		private void SetupInvalid()
		{
			SetSizeDeltaY(mainBar, 0f);
			SetSizeDeltaY(positiveBar, 0f);
			SetSizeDeltaY(negativeBar, 0f);
		}

		private static void SetSizeDeltaY(RectTransform rectTransform, float sizeDelta)
		{
			Vector2 sizeDelta2 = rectTransform.sizeDelta;
			sizeDelta2.y = sizeDelta;
			rectTransform.sizeDelta = sizeDelta2;
		}

		private static float GetSizeDeltaY(RectTransform rectTransform)
		{
			return rectTransform.sizeDelta.y;
		}

		private float WeightToRectHeight(float weight)
		{
			if (MaxWeight <= 0f)
			{
				return 0f;
			}
			float num = weight / MaxWeight;
			return BarWidth * num;
		}
	}
	public class FollowCursor : MonoBehaviour
	{
		private RectTransform parentRectTransform;

		private RectTransform rectTransform;

		private void Awake()
		{
			parentRectTransform = base.transform.parent as RectTransform;
			rectTransform = base.transform as RectTransform;
		}

		private void Update()
		{
			Vector2 value = Mouse.current.position.value;
			RectTransformUtility.ScreenPointToLocalPointInRectangle(parentRectTransform, value, null, out var localPoint);
			rectTransform.localPosition = localPoint;
		}
	}
	[ExecuteInEditMode]
	public class RectTransformChangeEventEmitter : UIBehaviour
	{
		public event Action<RectTransform> OnRectTransformChange;

		private void SetDirty()
		{
			this.OnRectTransformChange?.Invoke(base.transform as RectTransform);
		}

		protected override void OnRectTransformDimensionsChange()
		{
			SetDirty();
		}

		protected override void OnEnable()
		{
			SetDirty();
		}
	}
	public class ScrollViewBorderFrame : MonoBehaviour
	{
		[SerializeField]
		private ScrollRect scrollRect;

		[Range(0f, 1f)]
		[SerializeField]
		private float maxAlpha = 1f;

		[SerializeField]
		private float extendThreshold = 10f;

		[SerializeField]
		private float extendOffset;

		[SerializeField]
		private Graphic upGraphic;

		[SerializeField]
		private Graphic downGraphic;

		[SerializeField]
		private Graphic leftGraphic;

		[SerializeField]
		private Graphic rightGraphic;

		private void OnEnable()
		{
			scrollRect.onValueChanged.AddListener(Refresh);
			UniTask.Void(async delegate
			{
				await UniTask.Yield();
				await UniTask.Yield();
				await UniTask.Yield();
				Refresh();
			});
		}

		private void OnDisable()
		{
			scrollRect.onValueChanged.RemoveListener(Refresh);
		}

		private void Start()
		{
			Refresh();
		}

		private void Refresh(Vector2 scrollPos)
		{
			RectTransform viewport = scrollRect.viewport;
			RectTransform content = scrollRect.content;
			Rect rect = viewport.rect;
			Bounds bounds = RectTransformUtility.CalculateRelativeRectTransformBounds(viewport, content);
			float num = bounds.max.y - rect.max.y + extendOffset;
			float num2 = rect.min.y - bounds.min.y + extendOffset;
			float num3 = rect.min.x - bounds.min.x + extendOffset;
			float num4 = bounds.max.x - rect.max.x + extendOffset;
			float alpha = Mathf.Lerp(0f, maxAlpha, num / extendThreshold);
			float alpha2 = Mathf.Lerp(0f, maxAlpha, num2 / extendThreshold);
			float alpha3 = Mathf.Lerp(0f, maxAlpha, num3 / extendThreshold);
			float alpha4 = Mathf.Lerp(0f, maxAlpha, num4 / extendThreshold);
			SetAlpha(upGraphic, alpha);
			SetAlpha(downGraphic, alpha2);
			SetAlpha(leftGraphic, alpha3);
			SetAlpha(rightGraphic, alpha4);
			static void SetAlpha(Graphic graphic, float a)
			{
				if (!(graphic == null))
				{
					Color color = graphic.color;
					color.a = a;
					graphic.color = color;
				}
			}
		}

		private void Refresh()
		{
			if (!(scrollRect == null))
			{
				Refresh(scrollRect.normalizedPosition);
			}
		}
	}
	[RequireComponent(typeof(ScrollRect))]
	[ExecuteInEditMode]
	public class ScrollViewMaxHeight : UIBehaviour, ILayoutElement
	{
		[SerializeField]
		private ScrollRect scrollRect;

		[SerializeField]
		private RectTransformChangeEventEmitter contentRectChangeEventEmitter;

		[SerializeField]
		private int m_layoutPriority = 1;

		[SerializeField]
		private bool useTargetParentSize;

		[SerializeField]
		private float targetParentHeight = 935f;

		[SerializeField]
		private List<RectTransform> siblings = new List<RectTransform>();

		[SerializeField]
		private float parentLayoutMargin = 16f;

		[SerializeField]
		private float maxHeight = 100f;

		private RectTransform _rectTransform;

		public float preferredHeight
		{
			get
			{
				float y = scrollRect.content.sizeDelta.y;
				float num = maxHeight;
				if (useTargetParentSize)
				{
					float num2 = 0f;
					foreach (RectTransform sibling in siblings)
					{
						num2 += sibling.rect.height;
					}
					num = targetParentHeight - num2 - parentLayoutMargin;
				}
				if (y > num)
				{
					return num;
				}
				return y;
			}
		}

		public virtual float minWidth => -1f;

		public virtual float minHeight => -1f;

		public virtual float preferredWidth => -1f;

		public virtual float flexibleWidth => -1f;

		public virtual float flexibleHeight => -1f;

		public virtual int layoutPriority => m_layoutPriority;

		private RectTransform rectTransform
		{
			get
			{
				if (_rectTransform == null)
				{
					_rectTransform = base.transform as RectTransform;
				}
				return _rectTransform;
			}
		}

		public virtual void CalculateLayoutInputHorizontal()
		{
		}

		public virtual void CalculateLayoutInputVertical()
		{
		}

		private void OnContentRectChange(RectTransform rectTransform)
		{
			SetDirty();
		}

		protected override void OnEnable()
		{
			if (scrollRect == null)
			{
				scrollRect = GetComponent<ScrollRect>();
			}
			if (contentRectChangeEventEmitter == null)
			{
				contentRectChangeEventEmitter = scrollRect.content.GetComponent<RectTransformChangeEventEmitter>();
			}
			if (contentRectChangeEventEmitter == null)
			{
				contentRectChangeEventEmitter = scrollRect.content.gameObject.AddComponent<RectTransformChangeEventEmitter>();
			}
			base.OnEnable();
			contentRectChangeEventEmitter.OnRectTransformChange += OnContentRectChange;
			SetDirty();
		}

		protected override void OnDisable()
		{
			contentRectChangeEventEmitter.OnRectTransformChange -= OnContentRectChange;
			SetDirty();
			base.OnDisable();
		}

		private void Update()
		{
			if (preferredHeight != rectTransform.rect.height)
			{
				SetDirty();
			}
		}

		protected void SetDirty()
		{
			if (IsActive())
			{
				LayoutRebuilder.MarkLayoutForRebuild(base.transform as RectTransform);
			}
		}
	}
	public class KontextMenu : MonoBehaviour
	{
		private static KontextMenu instance;

		private RectTransform rectTransform;

		[SerializeField]
		private KontextMenuEntry entryPrefab;

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private float positionMoveCloseThreshold = 10f;

		private object target;

		private bool isWatchingRectTransform;

		private RectTransform watchRectTransform;

		private Vector3 cachedTransformPosition;

		private PrefabPool<KontextMenuEntry> _entryPool;

		private Transform ContentRoot => base.transform;

		private PrefabPool<KontextMenuEntry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<KontextMenuEntry>(entryPrefab, ContentRoot);
				}
				return _entryPool;
			}
		}

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			rectTransform = base.transform as RectTransform;
		}

		private void OnDestroy()
		{
		}

		private void Update()
		{
			if ((bool)watchRectTransform)
			{
				if ((cachedTransformPosition - watchRectTransform.position).magnitude > positionMoveCloseThreshold)
				{
					Hide(null);
				}
			}
			else if (isWatchingRectTransform)
			{
				Hide(null);
			}
		}

		public void InstanceShow(object target, RectTransform targetRectTransform, params KontextMenuDataEntry[] entries)
		{
			this.target = target;
			watchRectTransform = targetRectTransform;
			isWatchingRectTransform = true;
			cachedTransformPosition = watchRectTransform.position;
			Vector3[] array = new Vector3[4];
			targetRectTransform.GetWorldCorners(array);
			float num = Mathf.Min(array[0].x, array[1].x, array[2].x, array[3].x);
			float num2 = Mathf.Max(array[0].x, array[1].x, array[2].x, array[3].x);
			float num3 = Mathf.Min(array[0].y, array[1].y, array[2].y, array[3].y);
			float num4 = Mathf.Max(array[0].y, array[1].y, array[2].y, array[3].y);
			float num5 = num;
			float num6 = (float)Screen.width - num2;
			float num7 = (float)Screen.height - num4;
			float x = ((num5 > num6) ? num : num2);
			float y = ((num3 > num7) ? num3 : num4);
			Vector2 vector = new Vector2(x, y);
			if (entries.Length < 1)
			{
				InstanceHide();
				return;
			}
			Vector2 vector2 = new Vector2(vector.x / (float)Screen.width, vector.y / (float)Screen.height);
			float x2 = ((!(vector2.x < 0.5f)) ? 1 : 0);
			float y2 = ((!(vector2.y < 0.5f)) ? 1 : 0);
			rectTransform.pivot = new Vector2(x2, y2);
			base.gameObject.SetActive(value: true);
			fadeGroup.SkipHide();
			Setup(entries);
			fadeGroup.Show();
			base.transform.position = vector;
		}

		public void InstanceShow(object target, Vector2 screenPoint, params KontextMenuDataEntry[] entries)
		{
			this.target = target;
			watchRectTransform = null;
			isWatchingRectTransform = false;
			if (entries.Length < 1)
			{
				InstanceHide();
				return;
			}
			Vector2 vector = new Vector2(screenPoint.x / (float)Screen.width, screenPoint.y / (float)Screen.height);
			float x = ((!(vector.x < 0.5f)) ? 1 : 0);
			float y = ((!(vector.y < 0.5f)) ? 1 : 0);
			rectTransform.pivot = new Vector2(x, y);
			base.gameObject.SetActive(value: true);
			fadeGroup.SkipHide();
			Setup(entries);
			fadeGroup.Show();
			base.transform.position = screenPoint;
		}

		private void Clear()
		{
			EntryPool.ReleaseAll();
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < ContentRoot.childCount; i++)
			{
				Transform child = ContentRoot.GetChild(i);
				if (child.gameObject.activeSelf)
				{
					list.Add(child.gameObject);
				}
			}
			foreach (GameObject item in list)
			{
				UnityEngine.Object.Destroy(item);
			}
		}

		private void Setup(IEnumerable<KontextMenuDataEntry> entries)
		{
			Clear();
			int num = 0;
			foreach (KontextMenuDataEntry entry in entries)
			{
				if (entry != null)
				{
					KontextMenuEntry kontextMenuEntry = EntryPool.Get(ContentRoot);
					num++;
					kontextMenuEntry.Setup(this, num, entry);
					kontextMenuEntry.transform.SetAsLastSibling();
				}
			}
		}

		public void InstanceHide()
		{
			target = null;
			watchRectTransform = null;
			fadeGroup.Hide();
		}

		public static void Show(object target, RectTransform watchRectTransform, params KontextMenuDataEntry[] entries)
		{
			if (!(instance == null))
			{
				instance.InstanceShow(target, watchRectTransform, entries);
			}
		}

		public static void Show(object target, Vector2 position, params KontextMenuDataEntry[] entries)
		{
			if (!(instance == null))
			{
				instance.InstanceShow(target, position, entries);
			}
		}

		public static void Hide(object target)
		{
			if (!(instance == null) && (target == null || target == instance.target) && !instance.fadeGroup.IsHidingInProgress)
			{
				instance.InstanceHide();
			}
		}
	}
	public class KontextMenuDataEntry
	{
		public Sprite icon;

		public string text;

		public Action action;

		public void Invoke()
		{
			action?.Invoke();
		}
	}
	public class KontextMenuEntry : MonoBehaviour, Duckov.Utilities.IPoolable, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private float delayByIndex = 0.1f;

		[SerializeField]
		private List<FadeElement> fadeInElements;

		private KontextMenu menu;

		private KontextMenuDataEntry target;

		public void NotifyPooled()
		{
		}

		public void NotifyReleased()
		{
			target = null;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			if (menu != null)
			{
				menu.InstanceHide();
			}
			if (target != null)
			{
				target.action?.Invoke();
			}
		}

		public void Setup(KontextMenu menu, int index, KontextMenuDataEntry data)
		{
			this.menu = menu;
			target = data;
			if ((bool)icon)
			{
				if ((bool)data.icon)
				{
					icon.sprite = data.icon;
					icon.gameObject.SetActive(value: true);
				}
				else
				{
					icon.gameObject.SetActive(value: false);
				}
			}
			if ((bool)text)
			{
				if (!string.IsNullOrEmpty(target.text))
				{
					text.text = target.text;
					text.gameObject.SetActive(value: true);
				}
				else
				{
					text.gameObject.SetActive(value: false);
				}
			}
			foreach (FadeElement fadeInElement in fadeInElements)
			{
				fadeInElement.SkipHide();
				fadeInElement.Show(delayByIndex * (float)index).Forget();
			}
		}
	}
}
namespace Duckov.UI.Inventories
{
	public class PagesControl : MonoBehaviour
	{
		[SerializeField]
		private InventoryDisplay target;

		[SerializeField]
		private PagesControl_Entry template;

		[SerializeField]
		private GameObject inputIndicators;

		private PrefabPool<PagesControl_Entry> _pool;

		private PrefabPool<PagesControl_Entry> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<PagesControl_Entry>(template);
				}
				return _pool;
			}
		}

		private void Start()
		{
			if (target != null)
			{
				Setup(target);
			}
		}

		public void Setup(InventoryDisplay target)
		{
			UnregisterEvents();
			this.target = target;
			RegisterEvents();
			Refresh();
		}

		private void RegisterEvents()
		{
			UnregisterEvents();
			if (!(target == null))
			{
				target.onPageInfoRefreshed += OnPageInfoRefreshed;
			}
		}

		private void UnregisterEvents()
		{
			if (!(target == null))
			{
				target.onPageInfoRefreshed -= OnPageInfoRefreshed;
			}
		}

		private void OnPageInfoRefreshed()
		{
			Refresh();
		}

		private void Refresh()
		{
			Pool.ReleaseAll();
			if ((bool)inputIndicators)
			{
				inputIndicators?.SetActive(value: false);
			}
			if (!(target == null) && target.UsePages && target.MaxPage > 1)
			{
				for (int i = 0; i < target.MaxPage; i++)
				{
					Pool.Get().Setup(this, i, target.SelectedPage == i);
				}
				if ((bool)inputIndicators)
				{
					inputIndicators?.SetActive(value: true);
				}
			}
		}

		internal void NotifySelect(int i)
		{
			if (!(target == null))
			{
				target.SetPage(i);
			}
		}
	}
	public class PagesControl_Entry : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private GameObject selectedIndicator;

		[SerializeField]
		private UnityEngine.UI.Button button;

		private PagesControl master;

		private int index;

		private bool selected;

		private void Awake()
		{
			button.onClick.AddListener(OnButtonClicked);
		}

		private void OnButtonClicked()
		{
			master.NotifySelect(index);
		}

		internal void Setup(PagesControl master, int i, bool selected)
		{
			this.master = master;
			index = i;
			this.selected = selected;
			text.text = $"{index}";
			selectedIndicator.SetActive(this.selected);
		}
	}
}
namespace Duckov.UI.PlayerStats
{
	public class MainCharacterStatValueDisplay : MonoBehaviour
	{
		[SerializeField]
		private string statKey;

		[SerializeField]
		private TextMeshProUGUI displayNameText;

		[SerializeField]
		private TextMeshProUGUI valueText;

		[SerializeField]
		private string format = "{0:0.0}";

		private Stat target;

		private void OnEnable()
		{
			if (target == null)
			{
				target = CharacterMainControl.Main?.CharacterItem?.GetStat(statKey.GetHashCode());
			}
			Refresh();
			RegisterEvents();
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		private void AutoRename()
		{
			base.gameObject.name = "StatDisplay_" + statKey;
		}

		private void RegisterEvents()
		{
			if (target != null)
			{
				target.OnSetDirty += OnTargetDirty;
			}
		}

		private void UnregisterEvents()
		{
			if (target != null)
			{
				target.OnSetDirty -= OnTargetDirty;
			}
		}

		private void OnTargetDirty(Stat stat)
		{
			Refresh();
		}

		private void Refresh()
		{
			if (target != null)
			{
				displayNameText.text = target.DisplayName;
				float value = target.Value;
				valueText.text = string.Format(format, value);
			}
		}
	}
}
namespace Duckov.UI.BarDisplays
{
	public class BarDisplayController : MonoBehaviour
	{
		[SerializeField]
		private BarDisplay bar;

		protected virtual float Current => 0f;

		protected virtual float Max => 0f;

		protected void Refresh()
		{
			float current = Current;
			float max = Max;
			bar.SetValue(current, max);
		}
	}
	public class BarDisplayController_HP : BarDisplayController
	{
		private CharacterMainControl _target;

		protected override float Current
		{
			get
			{
				if (Target == null)
				{
					return 0f;
				}
				return Target.Health.CurrentHealth;
			}
		}

		protected override float Max
		{
			get
			{
				if (Target == null)
				{
					return 0f;
				}
				return Target.Health.MaxHealth;
			}
		}

		private CharacterMainControl Target
		{
			get
			{
				if (_target == null)
				{
					_target = CharacterMainControl.Main;
				}
				return _target;
			}
		}

		private void OnEnable()
		{
			Refresh();
			RegisterEvents();
		}

		private void OnDisable()
		{
			UnregisterEvents();
		}

		private void RegisterEvents()
		{
			if (!(Target == null))
			{
				Target.Health.OnHealthChange.AddListener(OnHealthChange);
			}
		}

		private void UnregisterEvents()
		{
			if (!(Target == null))
			{
				Target.Health.OnHealthChange.RemoveListener(OnHealthChange);
			}
		}

		private void OnHealthChange(Health health)
		{
			Refresh();
		}
	}
	public class BarDisplayController_Hunger : BarDisplayController
	{
		private CharacterMainControl _target;

		private float displayingCurrent = -1f;

		private float displayingMax = -1f;

		private CharacterMainControl Target
		{
			get
			{
				if (_target == null)
				{
					_target = CharacterMainControl.Main;
				}
				return _target;
			}
		}

		protected override float Current
		{
			get
			{
				if (Target == null)
				{
					return base.Current;
				}
				return Target.CurrentEnergy;
			}
		}

		protected override float Max
		{
			get
			{
				if (Target == null)
				{
					return base.Max;
				}
				return Target.MaxEnergy;
			}
		}

		private void Update()
		{
			float current = Current;
			float max = Max;
			if (displayingCurrent != current || displayingMax != max)
			{
				Refresh();
				displayingCurrent = current;
				displayingMax = max;
			}
		}
	}
	public class BarDisplayController_Stemina : BarDisplayController
	{
		private CharacterMainControl _target;

		private float displayingStemina = -1f;

		private float displayingMaxStemina = -1f;

		private CharacterMainControl Target
		{
			get
			{
				if (_target == null)
				{
					_target = CharacterMainControl.Main;
				}
				return _target;
			}
		}

		protected override float Current
		{
			get
			{
				if (Target == null)
				{
					return base.Current;
				}
				return Target.CurrentStamina;
			}
		}

		protected override float Max
		{
			get
			{
				if (Target == null)
				{
					return base.Max;
				}
				return Target.MaxStamina;
			}
		}

		private void Update()
		{
			float current = Current;
			float max = Max;
			if (displayingStemina != current || displayingMaxStemina != max)
			{
				Refresh();
				displayingStemina = current;
				displayingMaxStemina = max;
			}
		}
	}
	public class BarDisplayController_Thurst : BarDisplayController
	{
		private CharacterMainControl _target;

		private float displayingCurrent = -1f;

		private float displayingMax = -1f;

		private CharacterMainControl Target
		{
			get
			{
				if (_target == null)
				{
					_target = CharacterMainControl.Main;
				}
				return _target;
			}
		}

		protected override float Current
		{
			get
			{
				if (Target == null)
				{
					return base.Current;
				}
				return Target.CurrentWater;
			}
		}

		protected override float Max
		{
			get
			{
				if (Target == null)
				{
					return base.Max;
				}
				return Target.MaxWater;
			}
		}

		private void Update()
		{
			float current = Current;
			float max = Max;
			if (displayingCurrent != current || displayingMax != max)
			{
				Refresh();
				displayingCurrent = current;
				displayingMax = max;
			}
		}
	}
}
namespace Duckov.UI.Animations
{
	[RequireComponent(typeof(UnityEngine.CanvasGroup))]
	public class CanvasGroupFade : FadeElement
	{
		[SerializeField]
		private UnityEngine.CanvasGroup canvasGroup;

		[SerializeField]
		private AnimationCurve showingCurve;

		[SerializeField]
		private AnimationCurve hidingCurve;

		[SerializeField]
		private float fadeDuration = 0.2f;

		[SerializeField]
		private bool manageBlockRaycast;

		private bool awaked;

		private float ShowingDuration => fadeDuration;

		private float HidingDuration => fadeDuration;

		private void Awake()
		{
			if (canvasGroup == null || canvasGroup.gameObject != base.gameObject)
			{
				canvasGroup = GetComponent<UnityEngine.CanvasGroup>();
			}
			awaked = true;
		}

		private void OnValidate()
		{
			if (canvasGroup == null || canvasGroup.gameObject != base.gameObject)
			{
				canvasGroup = GetComponent<UnityEngine.CanvasGroup>();
			}
		}

		protected override UniTask ShowTask(int taskToken)
		{
			if (canvasGroup == null)
			{
				return default(UniTask);
			}
			if (!awaked)
			{
				canvasGroup.alpha = 0f;
			}
			if (manageBlockRaycast)
			{
				canvasGroup.blocksRaycasts = true;
			}
			return FadeTask(taskToken, base.IsFading ? canvasGroup.alpha : 0f, 1f, showingCurve, ShowingDuration);
		}

		protected override UniTask HideTask(int taskToken)
		{
			if (canvasGroup == null)
			{
				return default(UniTask);
			}
			if (manageBlockRaycast)
			{
				canvasGroup.blocksRaycasts = false;
			}
			return FadeTask(taskToken, base.IsFading ? canvasGroup.alpha : 1f, 0f, hidingCurve, HidingDuration);
		}

		private async UniTask FadeTask(int token, float beginAlpha, float targetAlpha, AnimationCurve animationCurve, float duration)
		{
			float time = 0f;
			while (time < duration)
			{
				if (!CheckTaskValid())
				{
					return;
				}
				time += Time.unscaledDeltaTime;
				float time2 = time / duration;
				float t = animationCurve.Evaluate(time2);
				float alpha = Mathf.Lerp(beginAlpha, targetAlpha, t);
				canvasGroup.alpha = alpha;
				await UniTask.NextFrame();
			}
			if (CheckTaskValid())
			{
				canvasGroup.alpha = targetAlpha;
			}
			bool CheckTaskValid()
			{
				if (canvasGroup != null)
				{
					return token == base.ActiveTaskToken;
				}
				return false;
			}
		}

		protected override void OnSkipHide()
		{
			if (canvasGroup != null)
			{
				canvasGroup.alpha = 0f;
			}
			if (manageBlockRaycast)
			{
				canvasGroup.blocksRaycasts = false;
			}
		}

		protected override void OnSkipShow()
		{
			if (canvasGroup != null)
			{
				canvasGroup.alpha = 1f;
			}
			if (manageBlockRaycast)
			{
				canvasGroup.blocksRaycasts = true;
			}
		}
	}
	public class MaterialPropertyFade : FadeElement
	{
		[SerializeField]
		private UnityEngine.UI.Image renderer;

		[SerializeField]
		private string propertyName = "t";

		[SerializeField]
		private Vector2 propertyRange = new Vector2(0f, 1f);

		[SerializeField]
		private float duration = 0.5f;

		[SerializeField]
		private AnimationCurve showCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		[SerializeField]
		private AnimationCurve hideCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		private Material _material;

		public AnimationCurve ShowCurve
		{
			get
			{
				return showCurve;
			}
			set
			{
				showCurve = value;
			}
		}

		public AnimationCurve HideCurve
		{
			get
			{
				return hideCurve;
			}
			set
			{
				hideCurve = value;
			}
		}

		private Material Material
		{
			get
			{
				if (_material == null && renderer != null)
				{
					_material = UnityEngine.Object.Instantiate(renderer.material);
					renderer.material = _material;
				}
				return _material;
			}
		}

		public float Duration
		{
			get
			{
				return duration;
			}
			internal set
			{
				duration = value;
			}
		}

		private void Awake()
		{
			if (renderer == null)
			{
				renderer = GetComponent<UnityEngine.UI.Image>();
			}
		}

		private void OnDestroy()
		{
			if ((bool)_material)
			{
				UnityEngine.Object.Destroy(_material);
			}
		}

		protected override async UniTask HideTask(int token)
		{
			if (Material == null)
			{
				return;
			}
			if (duration <= 0f)
			{
				Material.SetFloat(propertyName, propertyRange.x);
				return;
			}
			float timeWhenFadeBegun = Time.unscaledTime;
			float startingValue = Material.GetFloat(propertyName);
			while (TimeSinceFadeBegun() < duration)
			{
				if (token != base.ActiveTaskToken || Material == null)
				{
					return;
				}
				float time = TimeSinceFadeBegun() / duration;
				Material.SetFloat(propertyName, Mathf.Lerp(startingValue, propertyRange.x, hideCurve.Evaluate(time)));
				await UniTask.NextFrame();
			}
			Material?.SetFloat(propertyName, propertyRange.x);
			float TimeSinceFadeBegun()
			{
				return Time.unscaledTime - timeWhenFadeBegun;
			}
		}

		protected override void OnSkipHide()
		{
			if (!(Material == null))
			{
				Material.SetFloat(propertyName, propertyRange.x);
			}
		}

		protected override void OnSkipShow()
		{
			if (!(Material == null))
			{
				Material.SetFloat(propertyName, propertyRange.y);
			}
		}

		protected override async UniTask ShowTask(int token)
		{
			if (Material == null)
			{
				return;
			}
			if (duration <= 0f)
			{
				Material.SetFloat(propertyName, propertyRange.y);
				return;
			}
			float timeWhenFadeBegun = Time.unscaledTime;
			float startingValue = Material.GetFloat(propertyName);
			while (TimeSinceFadeBegun() < duration)
			{
				if (token != base.ActiveTaskToken || Material == null)
				{
					return;
				}
				float time = TimeSinceFadeBegun() / duration;
				Material.SetFloat(propertyName, Mathf.Lerp(startingValue, propertyRange.y, showCurve.Evaluate(time)));
				await UniTask.NextFrame();
			}
			Material?.SetFloat(propertyName, propertyRange.y);
			float TimeSinceFadeBegun()
			{
				return Time.unscaledTime - timeWhenFadeBegun;
			}
		}
	}
	public class RectTransformFade : FadeElement
	{
		[SerializeField]
		private bool debug;

		[SerializeField]
		private RectTransform rectTransform;

		[SerializeField]
		private float duration = 0.4f;

		[SerializeField]
		private Vector2 offset = Vector2.left * 10f;

		[SerializeField]
		[Range(-1f, 1f)]
		private float uniformScale;

		[SerializeField]
		[Range(-180f, 180f)]
		private float rotateZ;

		[SerializeField]
		private AnimationCurve showingAnimationCurve;

		[SerializeField]
		private AnimationCurve hidingAnimationCurve;

		private Vector2 cachedAnchordPosition = Vector2.zero;

		private Vector3 cachedScale = Vector3.one;

		private Vector3 cachedRotation = Vector3.zero;

		private bool initialized;

		private Vector2 TargetAnchoredPosition => cachedAnchordPosition + offset;

		private Vector3 TargetScale => cachedScale + Vector3.one * uniformScale;

		private Vector3 TargetRotation => cachedRotation + Vector3.forward * rotateZ;

		private void Initialize()
		{
			if (initialized)
			{
				UnityEngine.Debug.LogError("Object Initialized Twice, aborting");
				return;
			}
			CachePose();
			initialized = true;
		}

		private void CachePose()
		{
			if (!(rectTransform == null))
			{
				cachedAnchordPosition = rectTransform.anchoredPosition;
				cachedScale = rectTransform.localScale;
				cachedRotation = rectTransform.localRotation.eulerAngles;
			}
		}

		private void Awake()
		{
			if (rectTransform == null || rectTransform.gameObject != base.gameObject)
			{
				rectTransform = GetComponent<RectTransform>();
			}
			if (!initialized)
			{
				Initialize();
			}
		}

		private void OnValidate()
		{
			if (rectTransform == null || rectTransform.gameObject != base.gameObject)
			{
				rectTransform = GetComponent<RectTransform>();
			}
		}

		protected override async UniTask HideTask(int token)
		{
			if (!initialized)
			{
				Initialize();
			}
			UniTask uniTask = rectTransform.DOAnchorPos(TargetAnchoredPosition, duration).SetEase(hidingAnimationCurve).OnComplete(delegate
			{
				rectTransform.anchoredPosition = TargetAnchoredPosition;
			})
				.ToUniTask();
			UniTask uniTask2 = rectTransform.DOScale(TargetScale, duration).SetEase(showingAnimationCurve).OnComplete(delegate
			{
				rectTransform.localScale = TargetScale;
			})
				.ToUniTask();
			UniTask uniTask3 = rectTransform.DOLocalRotate(TargetRotation, duration).SetEase(showingAnimationCurve).OnComplete(delegate
			{
				rectTransform.localRotation = Quaternion.Euler(TargetRotation);
			})
				.ToUniTask();
			await UniTask.WhenAll(uniTask, uniTask2, uniTask3);
		}

		protected override async UniTask ShowTask(int token)
		{
			if (!initialized)
			{
				Initialize();
			}
			UniTask uniTask = rectTransform.DOAnchorPos(cachedAnchordPosition, duration).SetEase(showingAnimationCurve).OnComplete(delegate
			{
				rectTransform.anchoredPosition = cachedAnchordPosition;
				if (debug)
				{
					UnityEngine.Debug.Log($"Move Complete {base.gameObject.activeInHierarchy}");
				}
			})
				.ToUniTask();
			UniTask uniTask2 = rectTransform.DOScale(cachedScale, duration).SetEase(showingAnimationCurve).OnComplete(delegate
			{
				rectTransform.localScale = cachedScale;
			})
				.ToUniTask();
			UniTask uniTask3 = rectTransform.DOLocalRotate(cachedRotation, duration).SetEase(showingAnimationCurve).OnComplete(delegate
			{
				rectTransform.localRotation = Quaternion.Euler(cachedRotation);
			})
				.ToUniTask();
			await UniTask.WhenAll(uniTask, uniTask2, uniTask3);
			if (debug)
			{
				UnityEngine.Debug.Log("Ending Show Task");
			}
		}

		protected override void OnSkipHide()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("OnSkipHide");
			}
			if (!initialized)
			{
				Initialize();
			}
			rectTransform.anchoredPosition = TargetAnchoredPosition;
			rectTransform.localScale = TargetScale;
			rectTransform.localRotation = Quaternion.Euler(TargetRotation);
		}

		private void OnDestroy()
		{
			rectTransform?.DOKill();
		}

		protected override void OnSkipShow()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("OnSkipShow");
			}
			if (!initialized)
			{
				Initialize();
			}
			rectTransform.anchoredPosition = cachedAnchordPosition;
			rectTransform.localScale = cachedScale;
			rectTransform.localRotation = Quaternion.Euler(cachedRotation);
		}
	}
	public class ScaleFade : FadeElement
	{
		[SerializeField]
		private float duration = 0.1f;

		[SerializeField]
		private Vector3 scale = Vector3.zero;

		[SerializeField]
		[Range(-1f, 1f)]
		private float uniformScale;

		[SerializeField]
		private AnimationCurve showCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		[SerializeField]
		private AnimationCurve hideCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		private Vector3 cachedScale = Vector3.one;

		private bool initialized;

		private Vector3 HiddenScale => Vector3.one + Vector3.one * uniformScale + scale;

		private void CachePose()
		{
			cachedScale = base.transform.localScale;
		}

		private void RestorePose()
		{
			base.transform.localScale = cachedScale;
		}

		private void Initialize()
		{
			if (!initialized)
			{
				initialized = true;
				CachePose();
			}
		}

		protected override UniTask HideTask(int token)
		{
			if (!initialized)
			{
				Initialize();
			}
			if (!base.transform)
			{
				return UniTask.CompletedTask;
			}
			return base.transform.DOScale(HiddenScale, duration).SetEase(hideCurve).ToUniTask();
		}

		protected override void OnSkipHide()
		{
			if (!initialized)
			{
				Initialize();
			}
			base.transform.localScale = HiddenScale;
		}

		protected override void OnSkipShow()
		{
			if (!initialized)
			{
				Initialize();
			}
			RestorePose();
		}

		protected override UniTask ShowTask(int token)
		{
			if (!initialized)
			{
				Initialize();
			}
			return base.transform.DOScale(cachedScale, duration).SetEase(showCurve).OnComplete(RestorePose)
				.ToUniTask();
		}
	}
	public abstract class FadeElement : MonoBehaviour
	{
		protected UniTask activeTask;

		private int activeTaskToken;

		[SerializeField]
		private bool manageGameObjectActive;

		[SerializeField]
		private float delay;

		[SerializeField]
		private string sfx_Show;

		[SerializeField]
		private string sfx_Hide;

		private bool isShown;

		public UniTask ActiveTask => activeTask;

		protected int ActiveTaskToken => activeTaskToken;

		protected bool ManageGameObjectActive => manageGameObjectActive;

		public bool IsFading { get; private set; }

		private void CacheNewTaskToken()
		{
			activeTaskToken = UnityEngine.Random.Range(1, int.MaxValue);
		}

		public async UniTask Show(float delay = 0f)
		{
			CacheNewTaskToken();
			activeTask = WrapShowTask(ActiveTaskToken, delay);
			await activeTask;
			isShown = true;
		}

		public async UniTask Hide()
		{
			CacheNewTaskToken();
			activeTask = WrapHideTask(ActiveTaskToken, delay);
			isShown = false;
			await activeTask;
		}

		private async UniTask WrapShowTask(int token, float delay = 0f)
		{
			await UniTask.WaitForSeconds(this.delay + delay, ignoreTimeScale: true);
			if (!(this == null))
			{
				if (ActiveTaskToken == token && manageGameObjectActive)
				{
					base.gameObject.SetActive(value: true);
				}
				IsFading = true;
				if (!string.IsNullOrWhiteSpace(sfx_Show))
				{
					AudioManager.Post(sfx_Show);
				}
				await UniTask.NextFrame();
				await ShowTask(token);
				if (ActiveTaskToken == token)
				{
					IsFading = false;
				}
			}
		}

		private async UniTask WrapHideTask(int token, float delay = 0f)
		{
			if (!string.IsNullOrWhiteSpace(sfx_Hide) && isShown)
			{
				AudioManager.Post(sfx_Hide);
			}
			IsFading = true;
			await UniTask.WaitForSeconds(this.delay + delay, ignoreTimeScale: true);
			await HideTask(token);
			if (!(this == null))
			{
				if (ActiveTaskToken == token && manageGameObjectActive)
				{
					base.gameObject?.SetActive(value: false);
				}
				if (ActiveTaskToken == token)
				{
					IsFading = false;
				}
			}
		}

		protected abstract UniTask ShowTask(int token);

		protected abstract UniTask HideTask(int token);

		protected abstract void OnSkipHide();

		protected abstract void OnSkipShow();

		public void SkipHide()
		{
			activeTaskToken = 0;
			OnSkipHide();
			if (ManageGameObjectActive)
			{
				base.gameObject.SetActive(value: false);
			}
		}

		internal void SkipShow()
		{
			activeTaskToken = 0;
			OnSkipShow();
			if (ManageGameObjectActive)
			{
				base.gameObject.SetActive(value: true);
			}
		}
	}
	public class FadeGroup : MonoBehaviour
	{
		[SerializeField]
		private List<FadeElement> fadeElements = new List<FadeElement>();

		[SerializeField]
		private bool skipHideOnStart = true;

		[SerializeField]
		private bool showOnEnable;

		[SerializeField]
		private bool skipHideBeforeShow = true;

		public bool manageGameObjectActive;

		private bool isHidingInProgress;

		private bool isShowingInProgress;

		private bool isShown;

		public bool debug;

		private int activeTaskToken;

		public bool IsHidingInProgress => isHidingInProgress;

		public bool IsShowingInProgress => isShowingInProgress;

		public bool IsShown => isShown;

		public bool IsHidden => !isShown;

		public bool IsFading => fadeElements.Any((FadeElement e) => e != null && e.IsFading);

		public event Action<FadeGroup> OnFadeComplete;

		public event Action<FadeGroup> OnShowComplete;

		public event Action<FadeGroup> OnHideComplete;

		private void Start()
		{
			if (skipHideOnStart)
			{
				SkipHide();
			}
		}

		private void OnEnable()
		{
			if (showOnEnable)
			{
				Show();
			}
		}

		[ContextMenu("Show")]
		public void Show()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("Fadegroup SHOW " + base.name);
			}
			skipHideOnStart = false;
			if (manageGameObjectActive)
			{
				base.gameObject.SetActive(value: true);
			}
			ShowTask().Forget();
		}

		[ContextMenu("Hide")]
		public void Hide()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("Fadegroup HIDE " + base.name, base.gameObject);
			}
			HideTask().Forget();
		}

		public void Toggle()
		{
			if (IsShown)
			{
				Hide();
			}
			else if (IsHidden)
			{
				Show();
			}
		}

		public UniTask ShowAndReturnTask()
		{
			if (skipHideBeforeShow)
			{
				SkipHide();
			}
			if (manageGameObjectActive)
			{
				base.gameObject.SetActive(value: true);
			}
			return ShowTask();
		}

		public UniTask HideAndReturnTask()
		{
			return HideTask();
		}

		private int CacheNewTaskToken()
		{
			activeTaskToken = UnityEngine.Random.Range(0, int.MaxValue);
			return activeTaskToken;
		}

		public async UniTask ShowTask()
		{
			isHidingInProgress = false;
			isShowingInProgress = true;
			isShown = true;
			int token = CacheNewTaskToken();
			List<UniTask> list = new List<UniTask>();
			foreach (FadeElement fadeElement in fadeElements)
			{
				if (fadeElement == null)
				{
					UnityEngine.Debug.LogWarning("Element in fade group " + base.name + " is null");
				}
				else
				{
					list.Add(fadeElement.Show());
				}
			}
			await UniTask.WhenAll(list);
			if (token == activeTaskToken)
			{
				ShowComplete();
			}
		}

		public async UniTask HideTask()
		{
			isShowingInProgress = false;
			isHidingInProgress = true;
			isShown = false;
			int token = CacheNewTaskToken();
			List<UniTask> list = new List<UniTask>();
			foreach (FadeElement fadeElement in fadeElements)
			{
				if (!(fadeElement == null))
				{
					list.Add(fadeElement.Hide());
				}
			}
			await UniTask.WhenAll(list);
			if (token == activeTaskToken)
			{
				HideComplete();
			}
		}

		private void ShowComplete()
		{
			isShowingInProgress = false;
			this.OnFadeComplete?.Invoke(this);
			this.OnShowComplete?.Invoke(this);
		}

		private void HideComplete()
		{
			isHidingInProgress = false;
			this.OnFadeComplete?.Invoke(this);
			this.OnHideComplete?.Invoke(this);
			if (!(this == null) && manageGameObjectActive)
			{
				base.gameObject.SetActive(value: false);
			}
		}

		public void SkipHide()
		{
			foreach (FadeElement fadeElement in fadeElements)
			{
				if (fadeElement == null)
				{
					UnityEngine.Debug.LogWarning("Element in fade group " + base.name + " is null");
				}
				else
				{
					fadeElement.SkipHide();
				}
			}
			if (manageGameObjectActive)
			{
				base.gameObject.SetActive(value: false);
			}
		}

		internal void SkipShow()
		{
			foreach (FadeElement fadeElement in fadeElements)
			{
				if (fadeElement == null)
				{
					UnityEngine.Debug.LogWarning("Element in fade group " + base.name + " is null");
				}
				else
				{
					fadeElement.SkipShow();
				}
			}
			if (manageGameObjectActive)
			{
				base.gameObject.SetActive(value: true);
			}
		}
	}
	public class AnchoredPositionLooper : LooperElement
	{
		[SerializeField]
		private Vector2 anchoredPositionA;

		[SerializeField]
		private Vector2 anchoredPositionB;

		[SerializeField]
		private AnimationCurve curve;

		private RectTransform rectTransform;

		private void Awake()
		{
			rectTransform = base.transform as RectTransform;
		}

		protected override void OnTick(LooperClock clock, float t)
		{
			if (!(rectTransform == null))
			{
				Vector2 anchoredPosition = Vector2.Lerp(anchoredPositionA, anchoredPositionB, curve.Evaluate(t));
				rectTransform.anchoredPosition = anchoredPosition;
			}
		}
	}
	public class ImageColorLooper : LooperElement
	{
		[SerializeField]
		private UnityEngine.UI.Image image;

		[GradientUsage(true)]
		[SerializeField]
		private Gradient colorOverT;

		[SerializeField]
		private AnimationCurve alphaOverT;

		protected override void OnTick(LooperClock clock, float t)
		{
			Color color = colorOverT.Evaluate(t);
			float num = alphaOverT.Evaluate(t);
			color.a *= num;
			image.color = color;
		}
	}
	public class LocalPositionLooper : LooperElement
	{
		[SerializeField]
		private Vector3 localPositionA;

		[SerializeField]
		private Vector3 localPositionB;

		[SerializeField]
		private AnimationCurve curve;

		protected override void OnTick(LooperClock clock, float t)
		{
			if (!(base.transform == null))
			{
				Vector2 vector = Vector2.Lerp(localPositionA, localPositionB, curve.Evaluate(t));
				base.transform.localPosition = vector;
			}
		}
	}
	public class LooperClock : MonoBehaviour
	{
		[SerializeField]
		private float duration = 1f;

		private float time;

		public float t
		{
			get
			{
				if (duration > 0f)
				{
					return time / duration;
				}
				return 1f;
			}
		}

		public event Action<LooperClock, float> onTick;

		private void Update()
		{
			if (duration > 0f)
			{
				time += Time.unscaledDeltaTime;
				time %= duration;
				Tick();
			}
		}

		private void Tick()
		{
			this.onTick?.Invoke(this, t);
		}
	}
	public abstract class LooperElement : MonoBehaviour
	{
		[SerializeField]
		private LooperClock clock;

		protected virtual void OnEnable()
		{
			clock.onTick += OnTick;
			OnTick(clock, clock.t);
		}

		protected virtual void OnDisable()
		{
			if (clock != null)
			{
				clock.onTick -= OnTick;
			}
		}

		protected abstract void OnTick(LooperClock clock, float t);
	}
	public class RotationLooper : LooperElement
	{
		[SerializeField]
		private Vector3 eulerRotationA;

		[SerializeField]
		private Vector3 eulerRotationB;

		[SerializeField]
		private AnimationCurve curve;

		protected override void OnTick(LooperClock clock, float t)
		{
			if (!(base.transform == null))
			{
				Vector3 euler = Vector3.Lerp(eulerRotationA, eulerRotationB, curve.Evaluate(t));
				base.transform.localRotation = Quaternion.Euler(euler);
			}
		}
	}
	public class ScaleLooper : LooperElement
	{
		[SerializeField]
		private AnimationCurve uniformScaleOverT = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[SerializeField]
		private AnimationCurve xOverT = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[SerializeField]
		private AnimationCurve yOverT = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[SerializeField]
		private AnimationCurve zOverT = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		protected override void OnTick(LooperClock clock, float t)
		{
			float num = xOverT.Evaluate(t);
			float num2 = yOverT.Evaluate(t);
			float num3 = zOverT.Evaluate(t);
			float num4 = uniformScaleOverT.Evaluate(t);
			num *= num4;
			num2 *= num4;
			num3 *= num4;
			base.transform.localScale = new Vector3(num, num2, num3);
		}
	}
	public class Revolver : MonoBehaviour
	{
		public Vector3 pivot;

		public Vector3 axis = Vector3.forward;

		public float rPM;

		private void Update()
		{
			Quaternion quaternion = Quaternion.AngleAxis(Time.deltaTime * rPM / 60f * 360f, axis);
			Vector3 vector = base.transform.localPosition - pivot;
			Vector3 vector2 = quaternion * vector;
			Vector3 localPosition = pivot + vector2;
			base.transform.localPosition = localPosition;
		}

		private void OnDrawGizmosSelected()
		{
			if (base.transform.parent != null)
			{
				Gizmos.matrix = base.transform.parent.localToWorldMatrix;
			}
			Gizmos.DrawLine(pivot, base.transform.localPosition);
			Gizmos.color = Color.red;
			Gizmos.DrawWireSphere(pivot, 1f);
		}
	}
	public class ButtonAnimation : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler
	{
		[SerializeField]
		private GameObject hoveringIndicator;

		[SerializeField]
		private List<ToggleAnimation> toggles = new List<ToggleAnimation>();

		[SerializeField]
		private bool mute;

		private void Awake()
		{
			SetAll(value: false);
			if ((bool)hoveringIndicator)
			{
				hoveringIndicator.SetActive(value: false);
			}
		}

		private void OnEnable()
		{
			SetAll(value: false);
		}

		private void OnDisable()
		{
			if ((bool)hoveringIndicator)
			{
				hoveringIndicator.SetActive(value: false);
			}
		}

		private void SetAll(bool value)
		{
			foreach (ToggleAnimation toggle in toggles)
			{
				if (!(toggle == null))
				{
					toggle.SetToggle(value);
				}
			}
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			SetAll(value: true);
			if (!mute)
			{
				AudioManager.Post("UI/click");
			}
		}

		public void OnPointerUp(PointerEventData eventData)
		{
			SetAll(value: false);
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if ((bool)hoveringIndicator)
			{
				hoveringIndicator.SetActive(value: true);
			}
			if (!mute)
			{
				AudioManager.Post("UI/hover");
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if ((bool)hoveringIndicator)
			{
				hoveringIndicator.SetActive(value: false);
			}
		}
	}
	public class ChangeGraphicsColorToggle : ToggleComponent
	{
		[SerializeField]
		private UnityEngine.UI.Image image;

		[SerializeField]
		private Color trueColor;

		[SerializeField]
		private Color falseColor;

		[SerializeField]
		private float duration = 0.1f;

		protected override void OnSetToggle(ToggleAnimation master, bool value)
		{
			image.DOKill();
			image.DOColor(value ? trueColor : falseColor, duration);
		}
	}
	public class ScaleToggle : ToggleAnimation
	{
		public float idleScale = 1f;

		public float activeScale = 0.9f;

		public float duration = 0.1f;

		public AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		private Vector3 cachedScale = Vector3.one;

		private RectTransform rectTransform;

		private void CachePose()
		{
			cachedScale = rectTransform.localScale;
		}

		private void Awake()
		{
			rectTransform = base.transform as RectTransform;
			CachePose();
		}

		protected override void OnSetToggle(bool status)
		{
			float num = (status ? activeScale : idleScale);
			_ = num * cachedScale;
			rectTransform.DOKill();
			rectTransform.DOScale(cachedScale * num, duration).SetEase(animationCurve);
		}
	}
	public class SizeDeltaToggle : ToggleAnimation
	{
		public Vector2 idleSizeDelta = Vector2.zero;

		public Vector2 activeSizeDelta = Vector2.one * 12f;

		public float duration = 0.1f;

		public AnimationCurve animationCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		private Vector2 cachedSizeDelta = Vector3.one;

		private RectTransform _rectTransform;

		private RectTransform RectTransform
		{
			get
			{
				if (_rectTransform == null)
				{
					_rectTransform = GetComponent<RectTransform>();
				}
				return _rectTransform;
			}
		}

		private void CachePose()
		{
			cachedSizeDelta = RectTransform.sizeDelta;
		}

		private void Awake()
		{
			CachePose();
		}

		protected override void OnSetToggle(bool status)
		{
			if (base.gameObject.activeInHierarchy)
			{
				Vector2 endValue = (status ? activeSizeDelta : idleSizeDelta);
				RectTransform.DOKill();
				RectTransform.DOSizeDelta(endValue, duration).SetEase(animationCurve);
			}
		}
	}
	public class ToggleAnimation : MonoBehaviour
	{
		[SerializeField]
		[HideInInspector]
		private bool status;

		public bool Status
		{
			get
			{
				return status;
			}
			protected set
			{
				SetToggle(value);
			}
		}

		public event Action<ToggleAnimation, bool> onSetToggle;

		public void SetToggle(bool value)
		{
			status = value;
			if (Application.isPlaying)
			{
				OnSetToggle(Status);
				this.onSetToggle?.Invoke(this, value);
			}
		}

		protected virtual void OnSetToggle(bool value)
		{
		}
	}
	public class ToggleComponent : MonoBehaviour
	{
		[SerializeField]
		private ToggleAnimation master;

		private bool Status
		{
			get
			{
				if (!master)
				{
					return false;
				}
				return master.Status;
			}
		}

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponent<ToggleAnimation>();
			}
			master.onSetToggle += OnSetToggle;
		}

		private void OnDestroy()
		{
			if (!(master == null))
			{
				master.onSetToggle -= OnSetToggle;
			}
		}

		protected virtual void OnSetToggle(ToggleAnimation master, bool value)
		{
		}
	}
}
namespace Duckov.UI.DialogueBubbles
{
	public class DialogueBubble : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private float defaultSpeed = 10f;

		[SerializeField]
		private float sustainDuration = 2f;

		[SerializeField]
		private float defaultYOffset = 2f;

		[SerializeField]
		private GameObject interactIndicator;

		private bool interacted;

		private bool animating;

		private int taskToken;

		private Transform target;

		private float _yOffset;

		private float screenYOffset = 0.06f;

		private UniTask task;

		public Transform Target => target;

		private float YOffset
		{
			get
			{
				if (!(_yOffset >= 0f))
				{
					return defaultYOffset;
				}
				return _yOffset;
			}
		}

		private void LateUpdate()
		{
			UpdatePosition();
		}

		private void UpdatePosition()
		{
			if (!(target == null))
			{
				Vector2 screenPoint = RectTransformUtility.WorldToScreenPoint(Camera.main, target.position + Vector3.up * YOffset);
				screenPoint.y += screenYOffset * (float)Screen.height;
				if (RectTransformUtility.ScreenPointToLocalPointInRectangle(base.transform.parent as RectTransform, screenPoint, null, out var localPoint))
				{
					base.transform.localPosition = localPoint;
				}
			}
		}

		public UniTask Show(string text, Transform target, float yOffset = -1f, bool needInteraction = false, bool skippable = false, float speed = -1f, float duration = 2f)
		{
			task = ShowTask(text, target, yOffset, needInteraction, skippable, speed, duration);
			return task;
		}

		public async UniTask ShowTask(string text, Transform target, float yOffset = -1f, bool needInteraction = false, bool skippable = false, float speed = -1f, float duration = 2f)
		{
			_yOffset = yOffset;
			this.target = target;
			sustainDuration = duration;
			interactIndicator.gameObject.SetActive(value: false);
			int currentToken = (taskToken = UnityEngine.Random.Range(1, int.MaxValue));
			TMP_TextInfo textInfo = this.text.GetTextInfo(text);
			if (textInfo.characterCount < 1)
			{
				animating = false;
				await Hide();
				return;
			}
			animating = true;
			this.text.text = text;
			this.text.maxVisibleCharacters = 0;
			await fadeGroup.ShowAndReturnTask();
			if (taskToken != currentToken)
			{
				return;
			}
			int characterCount = textInfo.characterCount;
			if (speed <= 0f)
			{
				speed = defaultSpeed;
			}
			interacted = false;
			for (int i = 0; i <= characterCount; i++)
			{
				this.text.maxVisibleCharacters = i;
				await UniTask.WaitForSeconds(1f / speed, ignoreTimeScale: true);
				if (taskToken != currentToken)
				{
					return;
				}
				if (target == null)
				{
					Hide().Forget();
					return;
				}
				if (!target.gameObject.activeInHierarchy)
				{
					Hide().Forget();
					return;
				}
				if (skippable && interacted)
				{
					break;
				}
			}
			this.text.maxVisibleCharacters = characterCount;
			animating = false;
			if (needInteraction)
			{
				interactIndicator.gameObject.SetActive(value: true);
				await WaitForInteraction(currentToken);
			}
			else
			{
				float startTime = Time.unscaledTime;
				float num;
				do
				{
					await UniTask.NextFrame();
					num = Time.unscaledTime - startTime;
					if (taskToken != currentToken)
					{
						return;
					}
				}
				while ((bool)target && target.gameObject.activeInHierarchy && !(num >= sustainDuration));
			}
			if (taskToken == currentToken)
			{
				Hide().Forget();
			}
		}

		private async UniTask WaitForInteraction(int currentToken)
		{
			interacted = false;
			do
			{
				await UniTask.NextFrame();
			}
			while (currentToken == taskToken && !interacted && target.gameObject.activeInHierarchy);
		}

		public void Interact()
		{
			interacted = true;
		}

		private async UniTask Hide()
		{
			animating = false;
			await fadeGroup.HideAndReturnTask();
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Interact();
		}

		private void Awake()
		{
			DialogueBubblesManager.onPointerClick += OnPointerClick;
		}
	}
	public class DialogueBubblesManager : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private DialogueBubble prefab;

		[SerializeField]
		private Graphic raycastReceiver;

		private List<DialogueBubble> bubbles = new List<DialogueBubble>();

		public static DialogueBubblesManager Instance { get; private set; }

		public static event Action<PointerEventData> onPointerClick;

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			prefab.gameObject.SetActive(value: false);
			raycastReceiver.enabled = false;
		}

		public static async UniTask Show(string text, Transform target, float yOffset = -1f, bool needInteraction = false, bool skippable = false, float speed = -1f, float duration = 2f)
		{
			if (Instance == null)
			{
				return;
			}
			DialogueBubble dialogueBubble = Instance.bubbles.FirstOrDefault((DialogueBubble e) => e != null && e.Target == target);
			if (dialogueBubble == null)
			{
				dialogueBubble = Instance.bubbles.FirstOrDefault((DialogueBubble e) => e != null && !e.gameObject.activeSelf);
			}
			if (dialogueBubble == null)
			{
				if (Instance.prefab == null)
				{
					return;
				}
				dialogueBubble = UnityEngine.Object.Instantiate(Instance.prefab, Instance.transform);
				Instance.bubbles.Add(dialogueBubble);
			}
			Instance.raycastReceiver.enabled = needInteraction;
			await dialogueBubble.Show(text, target, yOffset, needInteraction, skippable, speed, duration);
			if ((bool)Instance && (bool)Instance.raycastReceiver)
			{
				Instance.raycastReceiver.enabled = false;
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			DialogueBubblesManager.onPointerClick?.Invoke(eventData);
		}
	}
}
namespace Duckov.UI.RedDots
{
	public class QuestsButtonRedDot : MonoBehaviour
	{
		public GameObject dot;

		private void Awake()
		{
			Quest.onQuestNeedInspectionChanged += OnQuestNeedInspectionChanged;
		}

		private void OnDestroy()
		{
			Quest.onQuestNeedInspectionChanged -= OnQuestNeedInspectionChanged;
		}

		private void OnQuestNeedInspectionChanged(Quest quest)
		{
			Refresh();
		}

		private void Start()
		{
			Refresh();
		}

		private void Refresh()
		{
			dot.SetActive(QuestManager.AnyQuestNeedsInspection);
		}
	}
}
namespace Duckov.UI.SavesRestore
{
	public class SavesBackupRestorePanel : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private FadeGroup confirmFadeGroup;

		[SerializeField]
		private FadeGroup resultFadeGroup;

		[SerializeField]
		private TextMeshProUGUI[] slotIndexTexts;

		[SerializeField]
		private TextMeshProUGUI[] backupTimeTexts;

		[SerializeField]
		private SavesBackupRestorePanelEntry template;

		[SerializeField]
		private GameObject noBackupIndicator;

		private PrefabPool<SavesBackupRestorePanelEntry> _pool;

		private int slot;

		private bool recovering;

		private bool confirm;

		private bool cancel;

		private PrefabPool<SavesBackupRestorePanelEntry> Pool
		{
			get
			{
				if (_pool == null)
				{
					_pool = new PrefabPool<SavesBackupRestorePanelEntry>(template);
				}
				return _pool;
			}
		}

		private void Awake()
		{
		}

		public void Open(int savesSlot)
		{
			slot = savesSlot;
			Refresh();
			fadeGroup.Show();
		}

		public void Close()
		{
			fadeGroup.Hide();
		}

		public void Confirm()
		{
			confirm = true;
		}

		public void Cancel()
		{
			cancel = true;
		}

		private void Refresh()
		{
			Pool.ReleaseAll();
			List<SavesSystem.BackupInfo> list = SavesSystem.GetBackupList(slot).ToList();
			list.Sort((SavesSystem.BackupInfo a, SavesSystem.BackupInfo b) => (a.Time < b.Time) ? 1 : (-1));
			int num = 0;
			for (int num2 = 0; num2 < list.Count; num2++)
			{
				SavesSystem.BackupInfo info = list[num2];
				if (info.exists)
				{
					Pool.Get().Setup(this, info);
					num++;
				}
			}
			noBackupIndicator.SetActive(num <= 0);
		}

		internal void NotifyClicked(SavesBackupRestorePanelEntry button)
		{
			if (!recovering)
			{
				SavesSystem.BackupInfo info = button.Info;
				if (info.exists)
				{
					RecoverTask(info).Forget();
				}
			}
		}

		private async UniTask RecoverTask(SavesSystem.BackupInfo info)
		{
			recovering = true;
			confirm = false;
			cancel = false;
			TextMeshProUGUI[] array = slotIndexTexts;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].text = $"{info.slot}";
			}
			array = backupTimeTexts;
			foreach (TextMeshProUGUI textMeshProUGUI in array)
			{
				if (info.time_raw <= 0)
				{
					textMeshProUGUI.text = "???";
				}
				textMeshProUGUI.text = info.Time.ToLocalTime().ToString("yyyy/MM/dd HH:mm");
			}
			confirmFadeGroup.Show();
			while (!confirm && !cancel)
			{
				await UniTask.Yield();
			}
			if (cancel)
			{
				confirmFadeGroup.Hide();
				recovering = false;
				return;
			}
			SavesSystem.RestoreIndexedBackup(info.slot, info.index);
			confirmFadeGroup.Hide();
			confirm = false;
			resultFadeGroup.Show();
			while (!confirm)
			{
				await UniTask.Yield();
			}
			confirmFadeGroup.Hide();
			resultFadeGroup.Hide();
			recovering = false;
			Close();
		}
	}
	public class SavesBackupRestorePanelEntry : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		[SerializeField]
		private TextMeshProUGUI timeText;

		private SavesBackupRestorePanel master;

		private SavesSystem.BackupInfo info;

		public SavesSystem.BackupInfo Info => info;

		public void OnPointerClick(PointerEventData eventData)
		{
			master.NotifyClicked(this);
		}

		internal void Setup(SavesBackupRestorePanel master, SavesSystem.BackupInfo info)
		{
			this.master = master;
			this.info = info;
			if (info.time_raw <= 0)
			{
				timeText.text = "???";
			}
			else
			{
				timeText.text = info.Time.ToLocalTime().ToString("yyyy/MM/dd HH:mm:ss");
			}
		}
	}
}
namespace Duckov.UI.MainMenu
{
	public class ContinueButton : MonoBehaviour
	{
		[SerializeField]
		private UnityEngine.UI.Button button;

		[SerializeField]
		private TextMeshProUGUI text;

		[LocalizationKey("Default")]
		[SerializeField]
		private string text_NewGame = "新游戏";

		[LocalizationKey("Default")]
		[SerializeField]
		private string text_Continue = "继续";

		[SerializeField]
		private SceneReference overrideCurtainScene;

		[SerializeField]
		private string Text_NewGame => text_NewGame.ToPlainText();

		[SerializeField]
		private string Text_Continue => text_Continue.ToPlainText();

		private void Awake()
		{
			SavesSystem.OnSetFile += Refresh;
			SavesSystem.OnSaveDeleted += Refresh;
			button.onClick.AddListener(OnButtonClicked);
			LocalizationManager.OnSetLanguage += OnSetLanguage;
		}

		private void OnDestroy()
		{
			SavesSystem.OnSetFile -= Refresh;
			SavesSystem.OnSaveDeleted -= Refresh;
			LocalizationManager.OnSetLanguage -= OnSetLanguage;
		}

		private void OnSetLanguage(SystemLanguage language)
		{
			Refresh();
		}

		private void OnButtonClicked()
		{
			GameManager.newBoot = true;
			if (MultiSceneCore.GetVisited("Base"))
			{
				SceneLoader.Instance.LoadBaseScene().Forget();
				return;
			}
			SavesSystem.Save("CreatedWithVersion", GameMetaData.Instance.Version);
			SceneLoader.Instance.LoadScene(GameplayDataSettings.SceneManagement.PrologueScene, overrideCurtainScene).Forget();
		}

		private void Start()
		{
			Refresh();
		}

		private void Refresh()
		{
			bool flag = SavesSystem.IsOldGame();
			text.text = (flag ? Text_Continue : Text_NewGame);
		}
	}
	public class SavesButton : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup currentMenuFadeGroup;

		[SerializeField]
		private SaveSlotSelectionMenu selectionMenu;

		[SerializeField]
		private GameObject oldSaveIndicator;

		[SerializeField]
		private UnityEngine.UI.Button button;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		[LocalizationKey("Default")]
		private string textKey = "MainMenu_SaveSlot";

		[SerializeField]
		private string textFormat = "{text}: {slotNumber}";

		private bool executing;

		private void Awake()
		{
			button.onClick.AddListener(OnButtonClick);
			SavesSystem.OnSetFile += Refresh;
			LocalizationManager.OnSetLanguage += OnSetLanguage;
			SavesSystem.OnSaveDeleted += Refresh;
		}

		private void OnDestroy()
		{
			SavesSystem.OnSetFile -= Refresh;
			LocalizationManager.OnSetLanguage -= OnSetLanguage;
			SavesSystem.OnSaveDeleted -= Refresh;
		}

		private void OnSetLanguage(SystemLanguage language)
		{
			Refresh();
		}

		private void OnButtonClick()
		{
			if (!executing)
			{
				SavesSelectionTask().Forget();
			}
		}

		private async UniTask SavesSelectionTask()
		{
			executing = true;
			currentMenuFadeGroup.Hide();
			await selectionMenu.Execute();
			currentMenuFadeGroup.Show();
			executing = false;
		}

		private void Start()
		{
			Refresh();
		}

		private void Refresh()
		{
			bool num = SavesSystem.IsOldGame();
			string difficulty = (num ? GameRulesManager.Current.DisplayName : "");
			text.text = textFormat.Format(new
			{
				text = textKey.ToPlainText(),
				slotNumber = SavesSystem.CurrentSlot,
				difficulty = difficulty
			});
			bool active = num && SavesSystem.IsOldSave(SavesSystem.CurrentSlot);
			oldSaveIndicator.SetActive(active);
		}
	}
	public class SaveSlotSelectionButton : MonoBehaviour
	{
		[SerializeField]
		private SaveSlotSelectionMenu menu;

		[SerializeField]
		private UnityEngine.UI.Button button;

		[SerializeField]
		private TextMeshProUGUI text;

		[SerializeField]
		private TextMeshProUGUI difficultyText;

		[SerializeField]
		private TextMeshProUGUI playTimeText;

		[SerializeField]
		private TextMeshProUGUI saveTimeText;

		[SerializeField]
		private string slotTextKey = "MainMenu_SaveSelection_Slot";

		[SerializeField]
		private string format = "{slotText} {index}";

		[LocalizationKey("Default")]
		[SerializeField]
		private string newGameTextKey = "NewGame";

		[SerializeField]
		private GameObject activeIndicator;

		[SerializeField]
		private GameObject oldSlotIndicator;

		[Min(1f)]
		[SerializeField]
		private int index;

		private void Awake()
		{
			button.onClick.AddListener(OnButtonClick);
		}

		private void OnDestroy()
		{
		}

		private void OnEnable()
		{
			SavesSystem.OnSetFile += Refresh;
			Refresh();
		}

		private void OnDisable()
		{
			SavesSystem.OnSetFile -= Refresh;
		}

		private void OnButtonClick()
		{
			SavesSystem.SetFile(index);
			menu.Finish();
		}

		private void OnValidate()
		{
			if (button == null)
			{
				button = GetComponent<UnityEngine.UI.Button>();
			}
			if (text == null)
			{
				text = GetComponentInChildren<TextMeshProUGUI>();
			}
			Refresh();
		}

		private void Refresh()
		{
			new ES3Settings(SavesSystem.GetFilePath(index)).location = ES3.Location.File;
			this.text.text = format.Format(new
			{
				slotText = slotTextKey.ToPlainText(),
				index = index
			});
			bool active = SavesSystem.CurrentSlot == index;
			activeIndicator?.SetActive(active);
			if (SavesSystem.IsOldGame(index))
			{
				difficultyText.text = GameRulesManager.GetRuleIndexDisplayNameOfSlot(index) ?? "";
				playTimeText.gameObject.SetActive(value: true);
				TimeSpan realTimePlayedOfSaveSlot = GameClock.GetRealTimePlayedOfSaveSlot(index);
				playTimeText.text = $"{Mathf.FloorToInt((float)realTimePlayedOfSaveSlot.TotalHours):00}:{realTimePlayedOfSaveSlot.Minutes:00}";
				bool active2 = SavesSystem.IsOldSave(index);
				oldSlotIndicator.SetActive(active2);
				long num = SavesSystem.Load<long>("SaveTime", index);
				string text = ((num > 0) ? DateTime.FromBinary(num).ToLocalTime().ToString("yyyy/MM/dd HH:mm") : "???");
				saveTimeText.text = text;
			}
			else
			{
				difficultyText.text = newGameTextKey.ToPlainText();
				playTimeText.gameObject.SetActive(value: false);
				oldSlotIndicator.SetActive(value: false);
				saveTimeText.text = "----/--/-- --:--";
			}
		}
	}
	public class SaveSlotSelectionMenu : MonoBehaviour
	{
		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private GameObject oldSaveIndicator;

		internal bool finished;

		private void OnEnable()
		{
			UIInputManager.OnCancel += OnCancel;
		}

		private void OnDisable()
		{
			UIInputManager.OnCancel -= OnCancel;
		}

		private void OnCancel(UIInputEventData data)
		{
			data.Use();
			Finish();
		}

		internal async UniTask Execute()
		{
			finished = false;
			oldSaveIndicator.SetActive(SavesSystem.IsOldSave(SavesSystem.CurrentSlot));
			await UniTask.WaitForSeconds(0.25f, ignoreTimeScale: true);
			fadeGroup.Show();
			while (!finished)
			{
				await UniTask.NextFrame();
			}
			oldSaveIndicator.SetActive(SavesSystem.IsOldSave(SavesSystem.CurrentSlot));
			await UniTask.WaitForSeconds(0.05f, ignoreTimeScale: true);
			fadeGroup.Hide();
			await UniTask.WaitForSeconds(0.25f, ignoreTimeScale: true);
		}

		public void Finish()
		{
			finished = true;
		}
	}
}
namespace Duckov.Effects
{
	public class DamageAction : EffectAction
	{
		[SerializeField]
		private Buff buff;

		[SerializeField]
		private bool percentDamage;

		[SerializeField]
		private float damageValue = 1f;

		[SerializeField]
		private float percentDamageValue;

		[SerializeField]
		private DamageInfo damageInfo = new DamageInfo(null);

		[SerializeField]
		private GameObject fx;

		private CharacterMainControl MainControl => base.Master?.Item?.GetCharacterMainControl();

		protected override void OnTriggeredPositive()
		{
			if (!(MainControl == null) && !(MainControl.Health == null))
			{
				damageInfo.isFromBuffOrEffect = true;
				if (buff != null)
				{
					damageInfo.fromCharacter = buff.fromWho;
					damageInfo.fromWeaponItemID = buff.fromWeaponID;
				}
				damageInfo.damagePoint = MainControl.transform.position + Vector3.up * 0.8f;
				damageInfo.damageNormal = Vector3.up;
				if (percentDamage && MainControl.Health != null)
				{
					damageInfo.damageValue = percentDamageValue * MainControl.Health.MaxHealth * ((buff == null) ? 1f : ((float)buff.CurrentLayers));
				}
				else
				{
					damageInfo.damageValue = damageValue * ((buff == null) ? 1f : ((float)buff.CurrentLayers));
				}
				MainControl.Health.Hurt(damageInfo);
				if ((bool)fx)
				{
					UnityEngine.Object.Instantiate(fx, damageInfo.damagePoint, Quaternion.identity);
				}
			}
		}
	}
}
namespace Duckov.Rules
{
	public class GameRulesManager : MonoBehaviour
	{
		[Serializable]
		private struct RuleIndexFileEntry
		{
			public RuleIndex index;

			public RulesetFile file;
		}

		private const string SelectedRuleIndexSaveKey = "GameRulesManager_RuleIndex";

		private Ruleset customRuleSet;

		private const string CustomRuleSetKey = "Rule_Custom";

		[SerializeField]
		private RuleIndexFileEntry[] entries;

		public static GameRulesManager Instance => GameManager.DifficultyManager;

		public static Ruleset Current => Instance.mCurrent;

		private Ruleset mCurrent
		{
			get
			{
				if (SelectedRuleIndex == RuleIndex.Custom)
				{
					return CustomRuleSet;
				}
				RuleIndexFileEntry[] array = entries;
				for (int i = 0; i < array.Length; i++)
				{
					RuleIndexFileEntry ruleIndexFileEntry = array[i];
					if (ruleIndexFileEntry.index == SelectedRuleIndex)
					{
						return ruleIndexFileEntry.file.Data;
					}
				}
				return entries[0].file.Data;
			}
		}

		public static RuleIndex SelectedRuleIndex
		{
			get
			{
				if (SavesSystem.KeyExisits("GameRulesManager_RuleIndex"))
				{
					return SavesSystem.Load<RuleIndex>("GameRulesManager_RuleIndex");
				}
				return RuleIndex.Standard;
			}
			internal set
			{
				SavesSystem.Save("GameRulesManager_RuleIndex", value);
				NotifyRuleChanged();
			}
		}

		private Ruleset CustomRuleSet
		{
			get
			{
				if (customRuleSet == null)
				{
					ReloadCustomRuleSet();
				}
				return customRuleSet;
			}
		}

		public static event Action OnRuleChanged;

		public static void NotifyRuleChanged()
		{
			GameRulesManager.OnRuleChanged?.Invoke();
		}

		public static RuleIndex GetRuleIndexOfSaveSlot(int slot)
		{
			return SavesSystem.Load<RuleIndex>("GameRulesManager_RuleIndex", slot);
		}

		private void Awake()
		{
			SavesSystem.OnCollectSaveData += OnCollectSaveData;
			SavesSystem.OnSetFile += OnSetFile;
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= OnCollectSaveData;
			SavesSystem.OnSetFile -= OnSetFile;
		}

		private void OnSetFile()
		{
			ReloadCustomRuleSet();
		}

		private void ReloadCustomRuleSet()
		{
			if (SavesSystem.KeyExisits("Rule_Custom"))
			{
				customRuleSet = SavesSystem.Load<Ruleset>("Rule_Custom");
			}
			if (customRuleSet == null)
			{
				customRuleSet = new Ruleset();
				customRuleSet.displayNameKey = "Rule_Custom";
			}
		}

		private void OnCollectSaveData()
		{
			if (SelectedRuleIndex == RuleIndex.Custom && customRuleSet != null)
			{
				SavesSystem.Save("Rule_Custom", customRuleSet);
			}
		}

		internal static string GetRuleIndexDisplayNameOfSlot(int slotIndex)
		{
			RuleIndex ruleIndexOfSaveSlot = GetRuleIndexOfSaveSlot(slotIndex);
			return $"Rule_{ruleIndexOfSaveSlot}".ToPlainText();
		}
	}
	public enum RuleIndex
	{
		Standard = 0,
		StandardChallenge = 13,
		Custom = 1,
		Easy = 11,
		ExtraEasy = 12,
		Hard = 21,
		ExtraHard = 22,
		Rage = 23
	}
	[Serializable]
	public class Ruleset
	{
		[LocalizationKey("UIText")]
		[SerializeField]
		internal string displayNameKey;

		[SerializeField]
		private float damageFactor_ToPlayer = 1f;

		[SerializeField]
		private float enemyHealthFactor = 1f;

		[SerializeField]
		private bool spawnDeadBody = true;

		[SerializeField]
		private bool fogOfWar = true;

		[SerializeField]
		private bool advancedDebuffMode;

		[SerializeField]
		private int saveDeadbodyCount = 1;

		[Range(0f, 1f)]
		[SerializeField]
		private float recoilMultiplier = 1f;

		[SerializeField]
		internal float enemyReactionTimeFactor = 1f;

		[SerializeField]
		internal float enemyAttackTimeSpaceFactor = 1f;

		[SerializeField]
		internal float enemyAttackTimeFactor = 1f;

		[LocalizationKey("UIText")]
		internal string descriptionKey
		{
			get
			{
				return displayNameKey + "_Desc";
			}
			set
			{
			}
		}

		public string DisplayName => displayNameKey.ToPlainText();

		public string Description => descriptionKey.ToPlainText();

		public bool SpawnDeadBody => spawnDeadBody;

		public int SaveDeadbodyCount => saveDeadbodyCount;

		public bool FogOfWar => fogOfWar;

		public bool AdvancedDebuffMode => advancedDebuffMode;

		public float RecoilMultiplier => recoilMultiplier;

		public float DamageFactor_ToPlayer => damageFactor_ToPlayer;

		public float EnemyHealthFactor => enemyHealthFactor;

		public float EnemyReactionTimeFactor => enemyReactionTimeFactor;

		public float EnemyAttackTimeSpaceFactor => enemyAttackTimeSpaceFactor;

		public float EnemyAttackTimeFactor => enemyAttackTimeFactor;
	}
	[CreateAssetMenu(menuName = "Duckov/Ruleset")]
	public class RulesetFile : ScriptableObject
	{
		[SerializeField]
		private Ruleset data;

		public Ruleset Data => data;
	}
}
namespace Duckov.Rules.UI
{
	public class DifficultySelection : MonoBehaviour
	{
		[Serializable]
		public struct SettingEntry
		{
			public RuleIndex ruleIndex;

			public Sprite icon;

			public bool recommended;

			[LocalizationKey("Default")]
			private string TitleKey
			{
				get
				{
					return $"Rule_{ruleIndex}";
				}
				set
				{
				}
			}

			public string Title => TitleKey.ToPlainText();

			[LocalizationKey("Default")]
			private string DescriptionKey
			{
				get
				{
					return $"Rule_{ruleIndex}_Desc";
				}
				set
				{
				}
			}

			public string Description => DescriptionKey.ToPlainText();
		}

		[SerializeField]
		private FadeGroup fadeGroup;

		[SerializeField]
		private TextMeshProUGUI textDescription;

		[SerializeField]
		[LocalizationKey("Default")]
		private string description_PlaceHolderKey = "DifficultySelection_Desc_PlaceHolder";

		[SerializeField]
		private UnityEngine.UI.Button confirmButton;

		[SerializeField]
		private FadeGroup customPanel;

		[SerializeField]
		private DifficultySelection_Entry entryTemplate;

		[SerializeField]
		private GameObject achievementDisabledIndicator;

		[SerializeField]
		private GameObject selectedCustomDifficultyBefore;

		private PrefabPool<DifficultySelection_Entry> _entryPool;

		[SerializeField]
		private SettingEntry[] displaySettings;

		private bool confirmed;

		private PrefabPool<DifficultySelection_Entry> EntryPool
		{
			get
			{
				if (_entryPool == null)
				{
					_entryPool = new PrefabPool<DifficultySelection_Entry>(entryTemplate);
				}
				return _entryPool;
			}
		}

		public static bool CustomDifficultyMarker
		{
			get
			{
				return SavesSystem.Load<bool>("CustomDifficultyMarker");
			}
			set
			{
				SavesSystem.Save("CustomDifficultyMarker", value);
			}
		}

		public RuleIndex SelectedRuleIndex
		{
			get
			{
				if (SelectedEntry == null)
				{
					return RuleIndex.Standard;
				}
				return SelectedEntry.Setting.ruleIndex;
			}
		}

		public DifficultySelection_Entry SelectedEntry { get; private set; }

		public DifficultySelection_Entry HoveringEntry { get; private set; }

		private void Awake()
		{
			confirmButton.onClick.AddListener(OnConfirmButtonClicked);
		}

		private void OnConfirmButtonClicked()
		{
			confirmed = true;
		}

		public async UniTask Execute()
		{
			EntryPool.ReleaseAll();
			fadeGroup.Show();
			SettingEntry[] array = displaySettings;
			foreach (SettingEntry setting in array)
			{
				if (CheckShouldDisplay(setting))
				{
					DifficultySelection_Entry difficultySelection_Entry = EntryPool.Get();
					bool locked = !CheckUnlocked(setting);
					difficultySelection_Entry.Setup(this, setting, locked);
				}
			}
			foreach (DifficultySelection_Entry activeEntry in EntryPool.ActiveEntries)
			{
				if (activeEntry.Setting.ruleIndex == GameRulesManager.SelectedRuleIndex)
				{
					NotifySelected(activeEntry);
					break;
				}
			}
			if ((GameRulesManager.SelectedRuleIndex = await WaitForConfirmation()) == RuleIndex.Custom)
			{
				CustomDifficultyMarker = true;
			}
			await fadeGroup.HideAndReturnTask();
		}

		private bool CheckUnlocked(SettingEntry setting)
		{
			bool flag = !MultiSceneCore.GetVisited("Base");
			switch (setting.ruleIndex)
			{
			case RuleIndex.Standard:
			case RuleIndex.Easy:
			case RuleIndex.ExtraEasy:
			case RuleIndex.StandardChallenge:
			case RuleIndex.Hard:
			case RuleIndex.ExtraHard:
				if (flag)
				{
					return true;
				}
				if (GameRulesManager.SelectedRuleIndex == RuleIndex.Custom)
				{
					return false;
				}
				if (GameRulesManager.SelectedRuleIndex == RuleIndex.Rage)
				{
					return false;
				}
				return true;
			case RuleIndex.Rage:
				return GetRageUnlocked(flag);
			case RuleIndex.Custom:
				if (flag)
				{
					return true;
				}
				return GameRulesManager.SelectedRuleIndex == RuleIndex.Custom;
			default:
				return false;
			}
		}

		public static void UnlockRage()
		{
			SavesSystem.SaveGlobal("Difficulty/RageUnlocked", value: true);
		}

		public bool GetRageUnlocked(bool isFirstSelect)
		{
			if (!SavesSystem.LoadGlobal("Difficulty/RageUnlocked", defaultValue: false))
			{
				return false;
			}
			if (isFirstSelect)
			{
				return true;
			}
			if (GameRulesManager.SelectedRuleIndex == RuleIndex.Custom)
			{
				return false;
			}
			if (GameRulesManager.SelectedRuleIndex != RuleIndex.Rage)
			{
				return false;
			}
			return true;
		}

		private bool CheckShouldDisplay(SettingEntry setting)
		{
			return true;
		}

		private async UniTask<RuleIndex> WaitForConfirmation()
		{
			confirmed = false;
			while (!confirmed)
			{
				await UniTask.Yield();
			}
			return SelectedRuleIndex;
		}

		internal void NotifySelected(DifficultySelection_Entry entry)
		{
			SelectedEntry = entry;
			GameRulesManager.SelectedRuleIndex = SelectedRuleIndex;
			foreach (DifficultySelection_Entry activeEntry in EntryPool.ActiveEntries)
			{
				if (!(activeEntry == null))
				{
					activeEntry.Refresh();
				}
			}
			RefreshDescription();
			if (SelectedRuleIndex == RuleIndex.Custom)
			{
				ShowCustomRuleSetupPanel();
			}
			bool flag = SelectedRuleIndex == RuleIndex.Custom;
			achievementDisabledIndicator.SetActive(flag || CustomDifficultyMarker);
			selectedCustomDifficultyBefore.SetActive(CustomDifficultyMarker);
		}

		private void ShowCustomRuleSetupPanel()
		{
			customPanel?.Show();
		}

		internal void NotifyEntryPointerEnter(DifficultySelection_Entry entry)
		{
			HoveringEntry = entry;
			RefreshDescription();
		}

		internal void NotifyEntryPointerExit(DifficultySelection_Entry entry)
		{
			if (HoveringEntry == entry)
			{
				HoveringEntry = null;
				RefreshDescription();
			}
		}

		private void RefreshDescription()
		{
			string text = ((!(SelectedEntry != null)) ? description_PlaceHolderKey.ToPlainText() : SelectedEntry.Setting.Description);
			textDescription.text = text;
		}

		internal void SkipHide()
		{
			if (fadeGroup != null)
			{
				fadeGroup.SkipHide();
			}
		}
	}
	public class DifficultySelection_Entry : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler
	{
		[SerializeField]
		private TextMeshProUGUI title;

		[SerializeField]
		private UnityEngine.UI.Image icon;

		[SerializeField]
		private GameObject recommendationIndicator;

		[SerializeField]
		private GameObject selectedIndicator;

		[SerializeField]
		private GameObject lockedIndicator;

		internal Action<DifficultySelection_Entry> onPointerEnter;

		internal Action<DifficultySelection_Entry> onPointerExit;

		private bool locked;

		public DifficultySelection Master { get; private set; }

		public DifficultySelection.SettingEntry Setting { get; private set; }

		public void OnPointerClick(PointerEventData eventData)
		{
			if (!locked)
			{
				Master.NotifySelected(this);
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			Master?.NotifyEntryPointerEnter(this);
			onPointerEnter?.Invoke(this);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			Master?.NotifyEntryPointerExit(this);
			onPointerExit?.Invoke(this);
		}

		internal void Refresh()
		{
			if (!(Master == null))
			{
				selectedIndicator.SetActive(Master.SelectedRuleIndex == Setting.ruleIndex);
			}
		}

		internal void Setup(DifficultySelection master, DifficultySelection.SettingEntry setting, bool locked)
		{
			Master = master;
			Setting = setting;
			title.text = setting.Title;
			icon.sprite = setting.icon;
			recommendationIndicator.SetActive(setting.recommended);
			this.locked = locked;
			lockedIndicator.SetActive(locked);
			Refresh();
		}
	}
}
namespace Duckov.CustomerService
{
	public class QuestionairButton : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
	{
		private string addressCN = "rsmTLx1";

		private string addressJP = "mHE3yAa";

		private string addressEN = "YdoJpod";

		private string format = "https://usersurvey.biligame.com/vm/{address}.aspx?sojumpparm={id}|{difficulty}|{time}|{level}";

		public string GenerateQuestionair()
		{
			string address = LocalizationManager.CurrentLanguage switch
			{
				SystemLanguage.ChineseSimplified => addressCN, 
				SystemLanguage.Japanese => addressJP, 
				_ => addressEN, 
			};
			int currentSlot = SavesSystem.CurrentSlot;
			string id = $"{PlatformInfo.Platform}_{PlatformInfo.GetID()}";
			string time = $"{GameClock.GetRealTimePlayedOfSaveSlot(currentSlot).TotalMinutes:0}";
			string level = $"{EXPManager.Level}";
			RuleIndex ruleIndexOfSaveSlot = GameRulesManager.GetRuleIndexOfSaveSlot(currentSlot);
			int num = 0;
			switch (ruleIndexOfSaveSlot)
			{
			case RuleIndex.Custom:
				num = 0;
				break;
			case RuleIndex.ExtraEasy:
				num = 1;
				break;
			case RuleIndex.Easy:
				num = 2;
				break;
			case RuleIndex.Standard:
				num = 3;
				break;
			case RuleIndex.Hard:
				num = 4;
				break;
			case RuleIndex.ExtraHard:
				num = 5;
				break;
			}
			string difficulty = $"{num}";
			return format.Format(new { address, id, time, level, difficulty });
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			Application.OpenURL(GenerateQuestionair());
		}
	}
}
namespace Duckov.Utilities
{
	public class CommonVariables : MonoBehaviour
	{
		private static CommonVariables instance;

		[SerializeField]
		private CustomDataCollection data;

		private const string saves_prefix = "CommonVariables";

		private const string saves_key = "Data";

		public CustomDataCollection Data => data;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Debug.LogWarning("检测到多个Common Variables");
			}
			SavesSystem.OnCollectSaveData += OnCollectSaveData;
			SavesSystem.OnSetFile += OnSetSaveFile;
		}

		private void OnDestroy()
		{
			SavesSystem.OnCollectSaveData -= OnCollectSaveData;
			SavesSystem.OnSetFile -= OnSetSaveFile;
		}

		private void OnSetSaveFile()
		{
			Load();
		}

		private void OnCollectSaveData()
		{
			Save();
		}

		private void Start()
		{
			Load();
		}

		private void Save()
		{
			SavesSystem.Save("CommonVariables", "Data", data);
		}

		private void Load()
		{
			data = SavesSystem.Load<CustomDataCollection>("CommonVariables", "Data");
			if (data == null)
			{
				data = new CustomDataCollection();
			}
		}

		public static void SetFloat(string key, float value)
		{
			if ((bool)instance)
			{
				instance.Data.SetFloat(key, value);
			}
		}

		public static void SetInt(string key, int value)
		{
			if ((bool)instance)
			{
				instance.Data.SetInt(key, value);
			}
		}

		public static void SetBool(string key, bool value)
		{
			if ((bool)instance)
			{
				instance.Data.SetBool(key, value);
			}
		}

		public static void SetString(string key, string value)
		{
			if ((bool)instance)
			{
				instance.Data.SetString(key, value);
			}
		}

		public static float GetFloat(string key, float defaultValue = 0f)
		{
			if ((bool)instance)
			{
				return instance.Data.GetFloat(key, defaultValue);
			}
			return defaultValue;
		}

		public static int GetInt(string key, int defaultValue = 0)
		{
			if ((bool)instance)
			{
				return instance.Data.GetInt(key, defaultValue);
			}
			return defaultValue;
		}

		public static bool GetBool(string key, bool defaultValue = false)
		{
			if ((bool)instance)
			{
				return instance.Data.GetBool(key, defaultValue);
			}
			return defaultValue;
		}

		public static string GetString(string key, string defaultValue = "")
		{
			if ((bool)instance)
			{
				return instance.Data.GetString(key, defaultValue);
			}
			return defaultValue;
		}

		public static float GetFloat(int hash, float defaultValue = 0f)
		{
			if ((bool)instance)
			{
				return instance.Data.GetFloat(hash, defaultValue);
			}
			return defaultValue;
		}

		public static int GetInt(int hash, int defaultValue = 0)
		{
			if ((bool)instance)
			{
				return instance.Data.GetInt(hash, defaultValue);
			}
			return defaultValue;
		}

		public static bool GetBool(int hash, bool defaultValue = false)
		{
			if ((bool)instance)
			{
				return instance.Data.GetBool(hash, defaultValue);
			}
			return defaultValue;
		}

		public static string GetString(int hash, string defaultValue = "")
		{
			if ((bool)instance)
			{
				return instance.Data.GetString(hash, defaultValue);
			}
			return defaultValue;
		}
	}
	[CreateAssetMenu(menuName = "Settings/Gameplay Data Settings")]
	public class GameplayDataSettings : ScriptableObject
	{
		[Serializable]
		public class LootingData
		{
			public float[] inspectingTimes;

			public float MGetInspectingTime(Item item)
			{
				int num = item.Quality;
				if (num < 0)
				{
					num = 0;
				}
				if (num >= inspectingTimes.Length)
				{
					num = inspectingTimes.Length - 1;
				}
				return inspectingTimes[num];
			}

			public static float GetInspectingTime(Item item)
			{
				return Looting?.MGetInspectingTime(item) ?? 1f;
			}
		}

		[Serializable]
		public class TagsData
		{
			[SerializeField]
			private Tag character;

			[SerializeField]
			private Tag lockInDemoTag;

			[SerializeField]
			private Tag helmat;

			[SerializeField]
			private Tag armor;

			[SerializeField]
			private Tag backpack;

			[SerializeField]
			private Tag bullet;

			[SerializeField]
			private Tag bait;

			[SerializeField]
			private Tag advancedDebuffMode;

			[SerializeField]
			private Tag special;

			[SerializeField]
			private Tag destroyOnLootBox;

			[FormerlySerializedAs("dontDropOnDead")]
			[SerializeField]
			private Tag dontDropOnDeadInSlot;

			[SerializeField]
			private List<Tag> allTags = new List<Tag>();

			private ReadOnlyCollection<Tag> tagsReadOnly;

			private Tag gun;

			public Tag Character => character;

			public Tag LockInDemoTag => lockInDemoTag;

			public Tag Helmat => helmat;

			public Tag Armor => armor;

			public Tag Backpack => backpack;

			public Tag Bullet => bullet;

			public Tag Bait => bait;

			public Tag AdvancedDebuffMode => advancedDebuffMode;

			public Tag Special => special;

			public Tag DestroyOnLootBox => destroyOnLootBox;

			public Tag DontDropOnDeadInSlot => dontDropOnDeadInSlot;

			public ReadOnlyCollection<Tag> AllTags
			{
				get
				{
					if (tagsReadOnly == null)
					{
						tagsReadOnly = allTags.AsReadOnly();
					}
					return tagsReadOnly;
				}
			}

			public Tag Gun
			{
				get
				{
					if (gun == null)
					{
						gun = Get("Gun");
					}
					return gun;
				}
			}

			internal Tag Get(string name)
			{
				foreach (Tag allTag in AllTags)
				{
					if (allTag.name == name)
					{
						return allTag;
					}
				}
				return null;
			}
		}

		[Serializable]
		public class PrefabsData
		{
			[SerializeField]
			private LevelManager levelManagerPrefab;

			[SerializeField]
			private CharacterMainControl characterPrefab;

			[SerializeField]
			private GameObject bulletHitObsticleFx;

			[SerializeField]
			private GameObject questMarker;

			[SerializeField]
			private DuckovItemAgent pickupAgentPrefab;

			[SerializeField]
			private DuckovItemAgent pickupAgentNoRendererPrefab;

			[SerializeField]
			private DuckovItemAgent handheldAgentPrefab;

			[SerializeField]
			private InteractableLootbox lootBoxPrefab;

			[SerializeField]
			private InteractableLootbox lootBoxPrefab_Tomb;

			[SerializeField]
			private InteractMarker interactMarker;

			[SerializeField]
			private HeadCollider headCollider;

			[SerializeField]
			private Projectile defaultBullet;

			[SerializeField]
			private UIInputManager uiInputManagerPrefab;

			[SerializeField]
			private GameObject buildingBlockAreaMesh;

			[SerializeField]
			private GameObject alertFxPrefab;

			public LevelManager LevelManagerPrefab => levelManagerPrefab;

			public CharacterMainControl CharacterPrefab => characterPrefab;

			public GameObject BulletHitObsticleFx => bulletHitObsticleFx;

			public GameObject QuestMarker => questMarker;

			public DuckovItemAgent PickupAgentPrefab => pickupAgentPrefab;

			public DuckovItemAgent PickupAgentNoRendererPrefab => pickupAgentNoRendererPrefab;

			public DuckovItemAgent HandheldAgentPrefab => handheldAgentPrefab;

			public InteractableLootbox LootBoxPrefab => lootBoxPrefab;

			public InteractableLootbox LootBoxPrefab_Tomb => lootBoxPrefab_Tomb;

			public InteractMarker InteractMarker => interactMarker;

			public HeadCollider HeadCollider => headCollider;

			public Projectile DefaultBullet => defaultBullet;

			public GameObject BuildingBlockAreaMesh => buildingBlockAreaMesh;

			public GameObject AlertFxPrefab => alertFxPrefab;

			public UIInputManager UIInputManagerPrefab => uiInputManagerPrefab;
		}

		[Serializable]
		public class BuffsData
		{
			[SerializeField]
			private Buff bleedSBuff;

			[SerializeField]
			private Buff unlimitBleedBuff;

			[SerializeField]
			private Buff boneCrackBuff;

			[SerializeField]
			private Buff woundBuff;

			[SerializeField]
			private Buff weight_Light;

			[SerializeField]
			private Buff weight_Heavy;

			[SerializeField]
			private Buff weight_SuperHeavy;

			[SerializeField]
			private Buff weight_Overweight;

			[SerializeField]
			private Buff pain;

			[SerializeField]
			private Buff baseBuff;

			[SerializeField]
			private Buff starve;

			[SerializeField]
			private Buff thirsty;

			[SerializeField]
			private Buff burn;

			[SerializeField]
			private Buff poison;

			[SerializeField]
			private Buff electric;

			[SerializeField]
			private Buff space;

			[SerializeField]
			private List<Buff> allBuffs;

			public Buff BleedSBuff => bleedSBuff;

			public Buff UnlimitBleedBuff => unlimitBleedBuff;

			public Buff BoneCrackBuff => boneCrackBuff;

			public Buff WoundBuff => woundBuff;

			public Buff Weight_Light => weight_Light;

			public Buff Weight_Heavy => weight_Heavy;

			public Buff Weight_SuperHeavy => weight_SuperHeavy;

			public Buff Weight_Overweight => weight_Overweight;

			public Buff Pain => pain;

			public Buff BaseBuff => baseBuff;

			public Buff Starve => starve;

			public Buff Thirsty => thirsty;

			public Buff Burn => burn;

			public Buff Poison => poison;

			public Buff Electric => electric;

			public Buff Space => space;

			public string GetBuffDisplayName(int id)
			{
				Buff buff = allBuffs.Find((Buff e) => e != null && e.ID == id);
				if (buff == null)
				{
					return "?";
				}
				return buff.DisplayName;
			}
		}

		[Serializable]
		public class ItemAssetsData
		{
			[SerializeField]
			[ItemTypeID]
			private int defaultCharacterItemTypeID;

			[SerializeField]
			[ItemTypeID]
			private int cashItemTypeID;

			public int DefaultCharacterItemTypeID => defaultCharacterItemTypeID;

			public int CashItemTypeID => cashItemTypeID;
		}

		public class StringListsData
		{
			public static StringList StatKeys;

			public static StringList SlotTypes;

			public static StringList ItemAgentKeys;
		}

		[Serializable]
		public class LayersData
		{
			public LayerMask damageReceiverLayerMask;

			public LayerMask wallLayerMask;

			public LayerMask groundLayerMask;

			public LayerMask halfObsticleLayer;

			public LayerMask fowBlockLayers;

			public LayerMask fowBlockLayersWithThermal;

			public static bool IsLayerInLayerMask(int layer, LayerMask layerMask)
			{
				if (((1 << layer) & (int)layerMask) != 0)
				{
					return true;
				}
				return false;
			}
		}

		[Serializable]
		public class SceneManagementData
		{
			[SerializeField]
			private SceneInfoCollection sceneInfoCollection;

			[SerializeField]
			private SceneReference prologueScene;

			[SerializeField]
			private SceneReference mainMenuScene;

			[SerializeField]
			private SceneReference baseScene;

			[SerializeField]
			private SceneReference failLoadingScreenScene;

			[SerializeField]
			private SceneReference evacuateScreenScene;

			public SceneInfoCollection SceneInfoCollection => sceneInfoCollection;

			public SceneReference PrologueScene => prologueScene;

			public SceneReference MainMenuScene => mainMenuScene;

			public SceneReference BaseScene => baseScene;

			public SceneReference FailLoadingScreenScene => failLoadingScreenScene;

			public SceneReference EvacuateScreenScene => evacuateScreenScene;
		}

		[Serializable]
		public class QuestsData
		{
			[Serializable]
			public class QuestGiverInfo
			{
				public QuestGiverID id;

				[SerializeField]
				private string displayName;

				public string DisplayName => displayName;
			}

			[SerializeField]
			private QuestCollection questCollection;

			[SerializeField]
			private QuestRelationGraph questRelation;

			[SerializeField]
			private List<QuestGiverInfo> questGiverInfos;

			[SerializeField]
			private string defaultQuestGiverDisplayName = "佚名";

			private string DefaultQuestGiverDisplayName => defaultQuestGiverDisplayName;

			public QuestCollection QuestCollection => questCollection;

			public QuestRelationGraph QuestRelation => questRelation;

			public QuestGiverInfo GetInfo(QuestGiverID id)
			{
				return questGiverInfos.Find((QuestGiverInfo e) => e != null && e.id == id);
			}

			public string GetDisplayName(QuestGiverID id)
			{
				return $"Character_{id}".ToPlainText();
			}
		}

		[Serializable]
		public class EconomyData
		{
			[SerializeField]
			[ItemTypeID]
			private List<int> unlockItemByDefault = new List<int>();

			public ReadOnlyCollection<int> UnlockedItemByDefault => unlockItemByDefault.AsReadOnly();
		}

		[Serializable]
		public class UIStyleData
		{
			[Serializable]
			public class DisplayQualityLook
			{
				public DisplayQuality quality;

				public float shadowOffset;

				public Color shadowColor;

				public bool innerGlow;

				public void Apply(TrueShadow trueShadow)
				{
					trueShadow.OffsetDistance = shadowOffset;
					trueShadow.Color = shadowColor;
					trueShadow.Inset = innerGlow;
				}
			}

			[Serializable]
			public class DisplayElementDamagePopTextLook
			{
				public ElementTypes elementType;

				public float normalSize;

				public float critSize;

				public Color color;
			}

			[SerializeField]
			private List<DisplayQualityLook> displayQualityLooks = new List<DisplayQualityLook>();

			[SerializeField]
			private List<DisplayElementDamagePopTextLook> elementDamagePopTextLook = new List<DisplayElementDamagePopTextLook>();

			[SerializeField]
			private float defaultDisplayQualityShadowOffset = 8f;

			[SerializeField]
			private Color defaultDisplayQualityShadowColor = Color.black;

			[SerializeField]
			private bool defaultDIsplayQualityShadowInnerGlow;

			[SerializeField]
			private Sprite defaultTeleporterIcon;

			[SerializeField]
			private float teleporterIconScale = 0.5f;

			[SerializeField]
			private Sprite critPopSprite;

			[SerializeField]
			private Sprite fallbackItemIcon;

			[SerializeField]
			private Sprite eleteCharacterIcon;

			[SerializeField]
			private Sprite bossCharacterIcon;

			[SerializeField]
			private Sprite pmcCharacterIcon;

			[SerializeField]
			private Sprite merchantCharacterIcon;

			[SerializeField]
			private Sprite petCharacterIcon;

			[SerializeField]
			private TMP_Asset defaultFont;

			[SerializeField]
			private TextMeshProUGUI templateTextUGUI;

			public Sprite CritPopSprite => critPopSprite;

			public Sprite DefaultTeleporterIcon => defaultTeleporterIcon;

			public Sprite EleteCharacterIcon => eleteCharacterIcon;

			public Sprite BossCharacterIcon => bossCharacterIcon;

			public Sprite PmcCharacterIcon => pmcCharacterIcon;

			public Sprite MerchantCharacterIcon => merchantCharacterIcon;

			public Sprite PetCharacterIcon => petCharacterIcon;

			public float TeleporterIconScale => teleporterIconScale;

			public Sprite FallbackItemIcon => fallbackItemIcon;

			public TextMeshProUGUI TemplateTextUGUI => templateTextUGUI;

			[SerializeField]
			private TMP_Asset DefaultFont => defaultFont;

			public (float shadowOffset, Color color, bool innerGlow) GetShadowOffsetAndColorOfQuality(DisplayQuality displayQuality)
			{
				DisplayQualityLook displayQualityLook = displayQualityLooks.Find((DisplayQualityLook e) => e != null && e.quality == displayQuality);
				if (displayQualityLook == null)
				{
					return (shadowOffset: defaultDisplayQualityShadowOffset, color: defaultDisplayQualityShadowColor, innerGlow: defaultDIsplayQualityShadowInnerGlow);
				}
				return (shadowOffset: displayQualityLook.shadowOffset, color: displayQualityLook.shadowColor, innerGlow: displayQualityLook.innerGlow);
			}

			public void ApplyDisplayQualityShadow(DisplayQuality displayQuality, TrueShadow target)
			{
				(target.OffsetDistance, target.Color, target.Inset) = GetShadowOffsetAndColorOfQuality(displayQuality);
			}

			public DisplayQualityLook GetDisplayQualityLook(DisplayQuality q)
			{
				DisplayQualityLook displayQualityLook = displayQualityLooks.Find((DisplayQualityLook e) => e != null && e.quality == q);
				if (displayQualityLook == null)
				{
					return new DisplayQualityLook
					{
						quality = q,
						shadowOffset = defaultDisplayQualityShadowOffset,
						shadowColor = defaultDisplayQualityShadowColor,
						innerGlow = defaultDIsplayQualityShadowInnerGlow
					};
				}
				return displayQualityLook;
			}

			public DisplayElementDamagePopTextLook GetElementDamagePopTextLook(ElementTypes elementType)
			{
				DisplayElementDamagePopTextLook displayElementDamagePopTextLook = elementDamagePopTextLook.Find((DisplayElementDamagePopTextLook e) => e != null && e.elementType == elementType);
				if (displayElementDamagePopTextLook == null)
				{
					return new DisplayElementDamagePopTextLook
					{
						elementType = ElementTypes.physics,
						normalSize = 1f,
						critSize = 1.6f,
						color = Color.white
					};
				}
				return displayElementDamagePopTextLook;
			}
		}

		[Serializable]
		public class SpritesData
		{
			[Serializable]
			public struct Entry
			{
				public string key;

				public Sprite sprite;
			}

			public List<Entry> entries;

			public Sprite GetSprite(string key)
			{
				foreach (Entry entry in entries)
				{
					if (entry.key == key)
					{
						return entry.sprite;
					}
				}
				return null;
			}
		}

		private static GameplayDataSettings cachedDefault;

		[SerializeField]
		private TagsData tags;

		[SerializeField]
		private PrefabsData prefabs;

		[SerializeField]
		private UIPrefabsReference uiPrefabs;

		[SerializeField]
		private ItemAssetsData itemAssets;

		[SerializeField]
		private StringListsData stringLists;

		[SerializeField]
		private LayersData layers;

		[SerializeField]
		private SceneManagementData sceneManagement;

		[SerializeField]
		private BuffsData buffs;

		[SerializeField]
		private QuestsData quests;

		[SerializeField]
		private EconomyData economyData;

		[SerializeField]
		private UIStyleData uiStyleData;

		[SerializeField]
		private InputActionAsset inputActions;

		[SerializeField]
		private BuildingDataCollection buildingDataCollection;

		[SerializeField]
		private CustomFaceData customFaceData;

		[SerializeField]
		private CraftingFormulaCollection craftingFormulas;

		[SerializeField]
		private DecomposeDatabase decomposeDatabase;

		[SerializeField]
		private StatInfoDatabase statInfo;

		[SerializeField]
		private StockShopDatabase stockShopDatabase;

		[SerializeField]
		private LootingData looting;

		[SerializeField]
		private AchievementDatabase achivementDatabase;

		[SerializeField]
		private CropDatabase cropDatabase;

		[SerializeField]
		private SpritesData spriteData;

		private static GameplayDataSettings Default
		{
			get
			{
				if (cachedDefault == null)
				{
					cachedDefault = Resources.Load<GameplayDataSettings>("GameplayDataSettings");
				}
				return cachedDefault;
			}
		}

		public static InputActionAsset InputActions => Default.inputActions;

		public static CustomFaceData CustomFaceData => Default.customFaceData;

		public static TagsData Tags => Default.tags;

		public static PrefabsData Prefabs => Default.prefabs;

		public static UIPrefabsReference UIPrefabs => Default.uiPrefabs;

		public static ItemAssetsData ItemAssets => Default.itemAssets;

		public static StringListsData StringLists => Default.stringLists;

		public static LayersData Layers => Default.layers;

		public static SceneManagementData SceneManagement => Default.sceneManagement;

		public static BuffsData Buffs => Default.buffs;

		public static QuestsData Quests => Default.quests;

		public static QuestCollection QuestCollection => Default.quests.QuestCollection;

		public static QuestRelationGraph QuestRelation => Default.quests.QuestRelation;

		public static EconomyData Economy => Default.economyData;

		public static UIStyleData UIStyle => Default.uiStyleData;

		public static BuildingDataCollection BuildingDataCollection => Default.buildingDataCollection;

		public static CraftingFormulaCollection CraftingFormulas => Default.craftingFormulas;

		public static DecomposeDatabase DecomposeDatabase => Default.decomposeDatabase;

		public static StatInfoDatabase StatInfo => Default.statInfo;

		public static StockShopDatabase StockshopDatabase => Default.stockShopDatabase;

		public static LootingData Looting => Default.looting;

		public static AchievementDatabase AchievementDatabase => Default.achivementDatabase;

		public static CropDatabase CropDatabase => Default.cropDatabase;

		internal static Sprite GetSprite(string key)
		{
			return Default.spriteData.GetSprite(key);
		}
	}
	public class FishSpawner : MonoBehaviour
	{
		[Serializable]
		private struct SpecialPair
		{
			[ItemTypeID]
			public int baitID;

			[ItemTypeID]
			public int fishID;

			[Range(0f, 1f)]
			public float chance;
		}

		[SerializeField]
		private List<SpecialPair> specialPairs;

		[SerializeField]
		private RandomContainer<Tag> tags;

		[SerializeField]
		private List<Tag> excludeTags;

		[SerializeField]
		private RandomContainer<int> qualities;

		private List<Tag> excludeTagsReal;

		[SerializeField]
		private Tag Fish_OnlyDay;

		[SerializeField]
		private Tag Fish_OnlyNight;

		[SerializeField]
		private Tag Fish_OnlySunDay;

		[SerializeField]
		private Tag Fish_OnlyRainDay;

		[SerializeField]
		private Tag Fish_OnlyStorm;

		public void CalculateChances()
		{
			tags.RefreshPercent();
			qualities.RefreshPercent();
		}

		private void Awake()
		{
			excludeTagsReal = new List<Tag>();
		}

		private void Start()
		{
		}

		public async UniTask<Item> Spawn(int baitID, float luck)
		{
			int num = -1;
			bool atNight = TimeOfDayController.Instance.AtNight;
			Weather currentWeather = TimeOfDayController.Instance.CurrentWeather;
			foreach (SpecialPair specialPair in specialPairs)
			{
				if (baitID == specialPair.baitID && UnityEngine.Random.Range(0f, 1f) < specialPair.chance && CheckFishDayNightAndWeather(specialPair.fishID, atNight, currentWeather))
				{
					num = specialPair.fishID;
					break;
				}
			}
			if (num == -1)
			{
				luck = Mathf.Max(luck, 0.1f);
				float lowPercent = 1f - 1f / luck;
				Tag random = tags.GetRandom();
				int random2 = qualities.GetRandom(lowPercent);
				CalculateTags(atNight, currentWeather);
				int[] array = Search(new ItemFilter
				{
					requireTags = new Tag[1] { random },
					excludeTags = excludeTagsReal.ToArray(),
					minQuality = random2,
					maxQuality = random2
				});
				if (array.Length < 1)
				{
					UnityEngine.Debug.Log($"LootBox未找到任何合适的随机物品\n Tag:{random.DisplayName} Quality:{random2}");
					return null;
				}
				num = array.GetRandom();
			}
			return await ItemAssetsCollection.InstantiateAsync(num);
		}

		public static int[] Search(ItemFilter filter)
		{
			return ItemAssetsCollection.Search(filter);
		}

		private void CalculateTags(bool atNight, Weather weather)
		{
			excludeTagsReal.Clear();
			excludeTagsReal.AddRange(excludeTags);
			if (atNight)
			{
				excludeTagsReal.Add(Fish_OnlyDay);
			}
			else
			{
				excludeTagsReal.Add(Fish_OnlyNight);
			}
			excludeTagsReal.Add(Fish_OnlySunDay);
			excludeTagsReal.Add(Fish_OnlyRainDay);
			excludeTagsReal.Add(Fish_OnlyStorm);
			switch (weather)
			{
			case Weather.Sunny:
				excludeTagsReal.Remove(Fish_OnlySunDay);
				break;
			case Weather.Rainy:
				excludeTagsReal.Remove(Fish_OnlyRainDay);
				break;
			case Weather.Stormy_I:
				excludeTagsReal.Remove(Fish_OnlyStorm);
				break;
			case Weather.Stormy_II:
				excludeTagsReal.Remove(Fish_OnlyStorm);
				break;
			case Weather.Cloudy:
				break;
			}
		}

		private bool CheckFishDayNightAndWeather(int fishID, bool atNight, Weather currentWeather)
		{
			ItemMetaData metaData = ItemAssetsCollection.GetMetaData(fishID);
			if (metaData.tags.Contains(Fish_OnlyNight) && !atNight)
			{
				return false;
			}
			if (metaData.tags.Contains(Fish_OnlyDay) && atNight)
			{
				return false;
			}
			if (metaData.tags.Contains(Fish_OnlyRainDay) && currentWeather != Weather.Rainy)
			{
				return false;
			}
			if (metaData.tags.Contains(Fish_OnlySunDay) && currentWeather != Weather.Sunny)
			{
				return false;
			}
			if (metaData.tags.Contains(Fish_OnlyStorm) && currentWeather != Weather.Stormy_I && currentWeather != Weather.Stormy_II)
			{
				return false;
			}
			return true;
		}
	}
	[RequireComponent(typeof(Points))]
	public class LootSpawner : MonoBehaviour
	{
		[Serializable]
		private struct Entry
		{
			[ItemTypeID]
			[SerializeField]
			public int itemTypeID;
		}

		[Range(0f, 1f)]
		public float spawnChance = 1f;

		public bool randomGenrate = true;

		public bool randomFromPool;

		[SerializeField]
		private Vector2Int randomCount = new Vector2Int(1, 1);

		[SerializeField]
		private RandomContainer<Tag> tags;

		[SerializeField]
		private List<Tag> excludeTags;

		[SerializeField]
		private RandomContainer<int> qualities;

		[SerializeField]
		private RandomContainer<Entry> randomPool;

		[ItemTypeID]
		[SerializeField]
		private List<int> fixedItems;

		[SerializeField]
		private Points points;

		private bool loading;

		[SerializeField]
		[ItemTypeID]
		private List<int> typeIds;

		public bool RandomFromPool
		{
			get
			{
				if (randomGenrate)
				{
					return randomFromPool;
				}
				return false;
			}
		}

		public bool RandomButNotFromPool
		{
			get
			{
				if (randomGenrate)
				{
					return !randomFromPool;
				}
				return false;
			}
		}

		public void CalculateChances()
		{
			tags.RefreshPercent();
			qualities.RefreshPercent();
			randomPool.RefreshPercent();
		}

		private void Start()
		{
			if (points == null)
			{
				points = GetComponent<Points>();
			}
			bool flag = false;
			int key = GetKey();
			if (MultiSceneCore.Instance.inLevelData.TryGetValue(key, out var value) && value is bool flag2)
			{
				flag = flag2;
			}
			if (!flag)
			{
				if (UnityEngine.Random.Range(0f, 1f) <= spawnChance)
				{
					Setup().Forget();
				}
				flag = true;
				MultiSceneCore.Instance.inLevelData.Add(key, true);
			}
		}

		private int GetKey()
		{
			Transform parent = base.transform.parent;
			string arg = base.transform.GetSiblingIndex().ToString();
			while (parent != null)
			{
				arg = $"{parent.GetSiblingIndex()}/{arg}";
				parent = parent.parent;
			}
			arg = $"{base.gameObject.scene.buildIndex}/{arg}";
			return arg.GetHashCode();
		}

		public async UniTask Setup()
		{
			typeIds.Clear();
			if (randomGenrate && !randomFromPool)
			{
				int num = UnityEngine.Random.Range(randomCount.x, randomCount.y);
				if (!excludeTags.Contains(GameplayDataSettings.Tags.Special))
				{
					excludeTags.Add(GameplayDataSettings.Tags.Special);
				}
				if (!LevelManager.Rule.AdvancedDebuffMode && !excludeTags.Contains(GameplayDataSettings.Tags.AdvancedDebuffMode))
				{
					excludeTags.Add(GameplayDataSettings.Tags.AdvancedDebuffMode);
				}
				for (int i = 0; i < num; i++)
				{
					Tag random = tags.GetRandom();
					int random2 = qualities.GetRandom();
					int[] array = Search(new ItemFilter
					{
						requireTags = new Tag[1] { random },
						excludeTags = excludeTags.ToArray(),
						minQuality = random2,
						maxQuality = random2
					});
					if (array.Length >= 1)
					{
						int random3 = array.GetRandom();
						typeIds.Add(random3);
					}
				}
			}
			else if (randomGenrate && randomFromPool)
			{
				int num2 = UnityEngine.Random.Range(randomCount.x, randomCount.y);
				for (int j = 0; j < num2; j++)
				{
					Entry random4 = randomPool.GetRandom();
					typeIds.Add(random4.itemTypeID);
				}
			}
			else
			{
				typeIds.AddRange(fixedItems);
			}
			loading = true;
			int idCount = typeIds.Count;
			List<Vector3> spawnPoints = points.GetRandomPoints(idCount);
			for (int k = 0; k < idCount; k++)
			{
				(await ItemAssetsCollection.InstantiateAsync(typeIds[k])).Drop(spawnPoints[k] + Vector3.up * 0.5f, createRigidbody: false, Vector3.up, 360f);
			}
			loading = false;
		}

		public static int[] Search(ItemFilter filter)
		{
			return ItemAssetsCollection.Search(filter);
		}

		private void OnValidate()
		{
			if (points == null)
			{
				points = GetComponent<Points>();
			}
		}
	}
	public class SetActiveByPlayerDistance : MonoBehaviour
	{
		private static Dictionary<int, List<GameObject>> listsOfScenes = new Dictionary<int, List<GameObject>>();

		[SerializeField]
		private float distance = 100f;

		private Scene cachedActiveScene;

		private List<GameObject> cachedListRef;

		private Transform cachedPlayerTransform;

		public static SetActiveByPlayerDistance Instance { get; private set; }

		public float Distance => distance;

		private Transform PlayerTransform
		{
			get
			{
				if (!cachedPlayerTransform)
				{
					cachedPlayerTransform = CharacterMainControl.Main?.transform;
				}
				return cachedPlayerTransform;
			}
		}

		private static List<GameObject> GetListByScene(int sceneBuildIndex, bool createIfNotExist = true)
		{
			if (listsOfScenes.TryGetValue(sceneBuildIndex, out var value))
			{
				return value;
			}
			if (createIfNotExist)
			{
				List<GameObject> list = new List<GameObject>();
				listsOfScenes[sceneBuildIndex] = list;
				return list;
			}
			return null;
		}

		private static List<GameObject> GetListByScene(Scene scene, bool createIfNotExist = true)
		{
			return GetListByScene(scene.buildIndex, createIfNotExist);
		}

		public static void Register(GameObject gameObject, int sceneBuildIndex)
		{
			GetListByScene(sceneBuildIndex).Add(gameObject);
		}

		public static bool Unregister(GameObject gameObject, int sceneBuildIndex)
		{
			return GetListByScene(sceneBuildIndex, createIfNotExist: false)?.Remove(gameObject) ?? false;
		}

		public static void Register(GameObject gameObject, Scene scene)
		{
			Register(gameObject, scene.buildIndex);
		}

		public static void Unregister(GameObject gameObject, Scene scene)
		{
			Unregister(gameObject, scene.buildIndex);
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			CleanUp();
			SceneManager.activeSceneChanged += OnActiveSceneChanged;
			cachedActiveScene = SceneManager.GetActiveScene();
			RefreshCache();
		}

		private void CleanUp()
		{
			List<int> list = new List<int>();
			foreach (KeyValuePair<int, List<GameObject>> listsOfScene in listsOfScenes)
			{
				List<GameObject> value = listsOfScene.Value;
				value.RemoveAll((GameObject e) => e == null);
				if (value == null || value.Count < 1)
				{
					list.Add(listsOfScene.Key);
				}
			}
			foreach (int item in list)
			{
				listsOfScenes.Remove(item);
			}
		}

		private void OnActiveSceneChanged(Scene prev, Scene cur)
		{
			RefreshCache();
		}

		private void RefreshCache()
		{
			cachedActiveScene = SceneManager.GetActiveScene();
			cachedListRef = GetListByScene(cachedActiveScene);
		}

		private void FixedUpdate()
		{
			if (PlayerTransform == null || cachedListRef == null)
			{
				return;
			}
			foreach (GameObject item in cachedListRef)
			{
				if (!(item == null))
				{
					bool active = (PlayerTransform.position - item.transform.position).sqrMagnitude < distance * distance;
					item.gameObject.SetActive(active);
				}
			}
		}

		private void DebugRegister(GameObject go)
		{
			Register(go, go.gameObject.scene);
		}
	}
	public class LootBoxLoader : MonoBehaviour
	{
		[Serializable]
		private struct Entry
		{
			[ItemTypeID]
			[SerializeField]
			public int itemTypeID;
		}

		public bool autoSetup = true;

		public bool dropOnSpawnItem;

		[SerializeField]
		[Range(0f, 1f)]
		private float activeChance = 1f;

		[SerializeField]
		private int inventorySize = 8;

		[SerializeField]
		private Vector2Int randomCount = new Vector2Int(1, 1);

		public bool randomFromPool;

		[SerializeField]
		private RandomContainer<Tag> tags;

		[SerializeField]
		private List<Tag> excludeTags;

		[SerializeField]
		private RandomContainer<int> qualities;

		[SerializeField]
		private RandomContainer<Entry> randomPool;

		[Range(0f, 1f)]
		public float GenrateCashChance;

		public int maxRandomCash;

		[ItemTypeID]
		[SerializeField]
		private List<int> fixedItems;

		[Range(0f, 1f)]
		[SerializeField]
		private float fixedItemSpawnChance = 1f;

		[SerializeField]
		private InteractableLootbox _lootBox;

		public List<int> FixedItems => fixedItems;

		[SerializeField]
		private Inventory Inventory
		{
			get
			{
				if (_lootBox == null)
				{
					_lootBox = GetComponent<InteractableLootbox>();
					if (_lootBox == null)
					{
						return null;
					}
				}
				return _lootBox.Inventory;
			}
		}

		public void CalculateChances()
		{
			randomPool.RefreshPercent();
		}

		public static int[] Search(ItemFilter filter)
		{
			return ItemAssetsCollection.Search(filter);
		}

		private void Awake()
		{
			if (_lootBox == null)
			{
				_lootBox = GetComponent<InteractableLootbox>();
			}
			RandomActive();
		}

		private int GetKey()
		{
			Vector3 vector = base.transform.position * 10f;
			int x = Mathf.RoundToInt(vector.x);
			int y = Mathf.RoundToInt(vector.y);
			int z = Mathf.RoundToInt(vector.z);
			Vector3Int vector3Int = new Vector3Int(x, y, z);
			return $"LootBoxLoader_{vector3Int}".GetHashCode();
		}

		private void RandomActive()
		{
			bool flag = false;
			int key = GetKey();
			if (MultiSceneCore.Instance.inLevelData.TryGetValue(key, out var value))
			{
				if (value is bool flag2)
				{
					flag = flag2;
				}
			}
			else
			{
				flag = UnityEngine.Random.Range(0f, 1f) < activeChance;
				MultiSceneCore.Instance.inLevelData.Add(key, flag);
			}
			base.gameObject.SetActive(flag);
		}

		public void StartSetup()
		{
			Setup().Forget();
		}

		public async UniTask Setup()
		{
			if (Inventory == null)
			{
				return;
			}
			if (GameMetaData.Instance.IsDemo)
			{
				excludeTags.Add(GameplayDataSettings.Tags.LockInDemoTag);
			}
			if (!excludeTags.Contains(GameplayDataSettings.Tags.Special))
			{
				excludeTags.Add(GameplayDataSettings.Tags.Special);
			}
			if (!LevelManager.Rule.AdvancedDebuffMode && !excludeTags.Contains(GameplayDataSettings.Tags.AdvancedDebuffMode))
			{
				excludeTags.Add(GameplayDataSettings.Tags.AdvancedDebuffMode);
			}
			int num = Mathf.RoundToInt(UnityEngine.Random.Range((float)randomCount.x - 0.5f, (float)randomCount.y + 0.5f) * LevelConfig.Instance.LootboxItemCountMultiplier);
			if (randomCount.x <= 0 && randomCount.y <= 0)
			{
				num = 0;
			}
			List<int> list = new List<int>();
			if (UnityEngine.Random.Range(0f, 1f) < fixedItemSpawnChance && fixedItems.Count > 0)
			{
				list.AddRange(fixedItems);
			}
			if (randomFromPool)
			{
				for (int i = 0; i < num; i++)
				{
					list.Add(randomPool.GetRandom().itemTypeID);
				}
			}
			else
			{
				float lootBoxQualityLowPercent = LevelConfig.Instance.LootBoxQualityLowPercent;
				for (int j = 0; j < num; j++)
				{
					Tag random = tags.GetRandom();
					int random2 = qualities.GetRandom(lootBoxQualityLowPercent);
					int[] array = Search(new ItemFilter
					{
						requireTags = new Tag[1] { random },
						excludeTags = excludeTags.ToArray(),
						minQuality = random2,
						maxQuality = random2
					});
					if (array.Length >= 1)
					{
						int random3 = array.GetRandom();
						list.Add(random3);
					}
				}
			}
			if (inventorySize < list.Count)
			{
				inventorySize = list.Count;
			}
			Inventory.SetCapacity(inventorySize);
			Inventory.Loading = true;
			foreach (int item2 in list)
			{
				if (item2 > 0)
				{
					Item item = await ItemAssetsCollection.InstantiateAsync(item2);
					if (dropOnSpawnItem || !Inventory.AddItem(item))
					{
						item.Drop(base.transform.position + Vector3.up, createRigidbody: true, (UnityEngine.Random.insideUnitSphere + Vector3.up) * 2f, 45f);
					}
				}
			}
			await CreateCash();
			Inventory.Loading = false;
			_lootBox.CheckHideIfEmpty();
		}

		private async UniTask CreateCash()
		{
			if (!(UnityEngine.Random.Range(0f, 1f) > GenrateCashChance))
			{
				int cashCount = UnityEngine.Random.Range(1, maxRandomCash);
				int firstEmptyPosition = Inventory.GetFirstEmptyPosition();
				int capacity = Inventory.Capacity;
				if (firstEmptyPosition >= capacity)
				{
					Inventory.SetCapacity(capacity + 1);
				}
				Item item = await ItemAssetsCollection.InstantiateAsync(GameplayDataSettings.ItemAssets.CashItemTypeID);
				item.StackCount = cashCount;
				if (dropOnSpawnItem || !Inventory.AddItem(item))
				{
					item.Drop(base.transform.position + Vector3.up, createRigidbody: true, (UnityEngine.Random.insideUnitSphere + Vector3.up) * 2f, 45f);
				}
			}
		}

		private void OnValidate()
		{
			tags.RefreshPercent();
			qualities.RefreshPercent();
		}
	}
}
namespace Duckov.Buffs
{
	public class Buff : MonoBehaviour
	{
		public enum BuffExclusiveTags
		{
			NotExclusive,
			Bleeding,
			Starve,
			Thirsty,
			Weight,
			Poison,
			Pain,
			Electric,
			Burning,
			Space,
			StormProtection,
			Nauseous,
			Stun
		}

		[SerializeField]
		private int id;

		[SerializeField]
		private int maxLayers = 1;

		[SerializeField]
		private BuffExclusiveTags exclusiveTag;

		[Tooltip("优先级高的代替优先级低的。同优先级，选剩余时间长的。如果一方不限制时长，选后来的")]
		[SerializeField]
		private int exclusiveTagPriority;

		[LocalizationKey("Buffs")]
		[SerializeField]
		private string displayName;

		[LocalizationKey("Buffs")]
		[SerializeField]
		private string description;

		[SerializeField]
		private Sprite icon;

		[SerializeField]
		private bool limitedLifeTime;

		[SerializeField]
		private float totalLifeTime;

		[SerializeField]
		private List<Effect> effects = new List<Effect>();

		[SerializeField]
		private bool hide;

		[SerializeField]
		private int currentLayers = 1;

		private CharacterBuffManager master;

		public UnityEvent OnSetupEvent;

		[SerializeField]
		private GameObject buffFxPfb;

		private GameObject buffFxInstance;

		[HideInInspector]
		public CharacterMainControl fromWho;

		public int fromWeaponID;

		private float timeWhenStarted;

		public BuffExclusiveTags ExclusiveTag => exclusiveTag;

		public int ExclusiveTagPriority => exclusiveTagPriority;

		public bool Hide => hide;

		public CharacterMainControl Character => master?.Master;

		private Item CharacterItem => master?.Master?.CharacterItem;

		public int ID
		{
			get
			{
				return id;
			}
			set
			{
				id = value;
			}
		}

		public int CurrentLayers
		{
			get
			{
				return currentLayers;
			}
			set
			{
				currentLayers = value;
				this.OnLayerChangedEvent?.Invoke();
			}
		}

		public int MaxLayers => maxLayers;

		public string DisplayName => displayName.ToPlainText();

		public string DisplayNameKey => displayName;

		public string Description => description.ToPlainText();

		public Sprite Icon => icon;

		public bool LimitedLifeTime => limitedLifeTime;

		public float TotalLifeTime => totalLifeTime;

		public float CurrentLifeTime => Time.time - timeWhenStarted;

		public float RemainingTime
		{
			get
			{
				if (!limitedLifeTime)
				{
					return float.PositiveInfinity;
				}
				return totalLifeTime - CurrentLifeTime;
			}
		}

		public bool IsOutOfTime
		{
			get
			{
				if (!limitedLifeTime)
				{
					return false;
				}
				return CurrentLifeTime >= totalLifeTime;
			}
		}

		public event Action OnLayerChangedEvent;

		internal void Setup(CharacterBuffManager manager)
		{
			master = manager;
			timeWhenStarted = Time.time;
			base.transform.SetParent(CharacterItem.transform, worldPositionStays: false);
			if ((bool)buffFxInstance)
			{
				UnityEngine.Object.Destroy(buffFxInstance.gameObject);
			}
			if ((bool)buffFxPfb && (bool)manager.Master && (bool)manager.Master.characterModel)
			{
				buffFxInstance = UnityEngine.Object.Instantiate(buffFxPfb);
				Transform armorSocket = manager.Master.characterModel.ArmorSocket;
				if (armorSocket == null)
				{
					armorSocket = manager.Master.transform;
				}
				buffFxInstance.transform.SetParent(armorSocket);
				buffFxInstance.transform.position = armorSocket.position;
				buffFxInstance.transform.localRotation = Quaternion.identity;
			}
			foreach (Effect effect in effects)
			{
				effect.SetItem(CharacterItem);
			}
			OnSetup();
			OnSetupEvent?.Invoke();
		}

		internal void NotifyUpdate()
		{
			OnUpdate();
		}

		internal void NotifyOutOfTime()
		{
			OnNotifiedOutOfTime();
			UnityEngine.Object.Destroy(base.gameObject);
		}

		internal virtual void NotifyIncomingBuffWithSameID(Buff incomingPrefab)
		{
			timeWhenStarted = Time.time;
			if (CurrentLayers < maxLayers)
			{
				CurrentLayers += incomingPrefab.CurrentLayers;
			}
		}

		protected virtual void OnSetup()
		{
		}

		protected virtual void OnUpdate()
		{
		}

		protected virtual void OnNotifiedOutOfTime()
		{
		}

		private void OnDestroy()
		{
			if ((bool)buffFxInstance)
			{
				UnityEngine.Object.Destroy(buffFxInstance.gameObject);
			}
		}
	}
	public class CharacterBuffManager : MonoBehaviour
	{
		[SerializeField]
		private CharacterMainControl master;

		private List<Buff> buffs = new List<Buff>();

		private ReadOnlyCollection<Buff> _readOnlyBuffsCollection;

		private List<Buff> outOfTimeBuffsBuffer = new List<Buff>();

		public CharacterMainControl Master => master;

		public ReadOnlyCollection<Buff> Buffs
		{
			get
			{
				if (_readOnlyBuffsCollection == null)
				{
					_readOnlyBuffsCollection = new ReadOnlyCollection<Buff>(buffs);
				}
				return _readOnlyBuffsCollection;
			}
		}

		public event Action<CharacterBuffManager, Buff> onAddBuff;

		public event Action<CharacterBuffManager, Buff> onRemoveBuff;

		private void Awake()
		{
			if (master == null)
			{
				master = GetComponent<CharacterMainControl>();
			}
		}

		public void AddBuff(Buff buffPrefab, CharacterMainControl fromWho, int overrideWeaponID = 0)
		{
			if (buffPrefab == null)
			{
				return;
			}
			Buff buff = buffs.Find((Buff e) => e.ID == buffPrefab.ID);
			if ((bool)buff)
			{
				buff.NotifyIncomingBuffWithSameID(buffPrefab);
				return;
			}
			Buff buff2 = UnityEngine.Object.Instantiate(buffPrefab);
			buff2.Setup(this);
			buff2.fromWho = fromWho;
			if (overrideWeaponID > 0)
			{
				buff2.fromWeaponID = overrideWeaponID;
			}
			buffs.Add(buff2);
			this.onAddBuff?.Invoke(this, buff2);
		}

		public void RemoveBuff(int buffID, bool removeOneLayer)
		{
			Buff buff = buffs.Find((Buff e) => e.ID == buffID);
			if (buff != null)
			{
				RemoveBuff(buff, removeOneLayer);
			}
		}

		public void RemoveBuffsByTag(Buff.BuffExclusiveTags buffTag, bool removeOneLayer)
		{
			if (buffTag == Buff.BuffExclusiveTags.NotExclusive)
			{
				return;
			}
			foreach (Buff item in buffs.FindAll((Buff e) => e.ExclusiveTag == buffTag))
			{
				if (item != null)
				{
					RemoveBuff(item, removeOneLayer);
				}
			}
		}

		public bool HasBuff(int buffID)
		{
			return buffs.Find((Buff e) => e.ID == buffID) != null;
		}

		public Buff GetBuffByTag(Buff.BuffExclusiveTags tag)
		{
			if (tag == Buff.BuffExclusiveTags.NotExclusive)
			{
				return null;
			}
			return buffs.Find((Buff e) => e.ExclusiveTag == tag);
		}

		public void RemoveBuff(Buff toRemove, bool oneLayer)
		{
			if (oneLayer && toRemove.CurrentLayers > 1)
			{
				toRemove.CurrentLayers--;
				if (toRemove.CurrentLayers >= 1)
				{
					return;
				}
			}
			if (buffs.Remove(toRemove))
			{
				this.onRemoveBuff?.Invoke(this, toRemove);
				UnityEngine.Object.Destroy(toRemove.gameObject);
			}
		}

		private void Update()
		{
			bool flag = false;
			foreach (Buff buff in buffs)
			{
				if (buff == null)
				{
					flag = true;
				}
				else if (buff.IsOutOfTime)
				{
					buff.NotifyOutOfTime();
					outOfTimeBuffsBuffer.Add(buff);
				}
				else
				{
					buff.NotifyUpdate();
				}
			}
			if (outOfTimeBuffsBuffer.Count > 0)
			{
				foreach (Buff item in outOfTimeBuffsBuffer)
				{
					if (item != null)
					{
						RemoveBuff(item, oneLayer: false);
					}
				}
				outOfTimeBuffsBuffer.Clear();
			}
			if (flag)
			{
				buffs.RemoveAll((Buff e) => e == null);
			}
		}
	}
}
namespace NodeCanvas.DialogueTrees
{
	[ParadoxNotion.Design.Icon("List", false, "")]
	[Name("Multiple Choice Localized", 0)]
	[ParadoxNotion.Design.Category("Branch")]
	[ParadoxNotion.Design.Description("Prompt a Dialogue Multiple Choice. A choice will be available if the choice condition(s) are true or there is no choice conditions. The Actor selected is used for the condition checks and will also Say the selection if the option is checked.")]
	[Color("b3ff7f")]
	public class LocalizedMultipleChoiceNode : DTNode
	{
		[Serializable]
		public class Choice
		{
			public bool isUnfolded = true;

			public LocalizedStatement statement;

			public ConditionTask condition;

			public Choice()
			{
			}

			public Choice(LocalizedStatement statement)
			{
				this.statement = statement;
			}
		}

		[SliderField(0f, 10f)]
		public float availableTime;

		public bool saySelection;

		[SerializeField]
		[AutoSortWithChildrenConnections]
		private List<Choice> availableChoices = new List<Choice>();

		public override int maxOutConnections => availableChoices.Count;

		public override bool requireActorSelection => true;

		protected override Status OnExecute(UnityEngine.Component agent, IBlackboard bb)
		{
			if (base.outConnections.Count == 0)
			{
				return Error("There are no connections to the Multiple Choice Node!");
			}
			Dictionary<IStatement, int> dictionary = new Dictionary<IStatement, int>();
			for (int i = 0; i < availableChoices.Count; i++)
			{
				ConditionTask condition = availableChoices[i].condition;
				if (condition == null || condition.CheckOnce(base.finalActor.transform, bb))
				{
					LocalizedStatement statement = availableChoices[i].statement;
					dictionary[statement] = i;
				}
			}
			if (dictionary.Count == 0)
			{
				base.DLGTree.Stop(success: false);
				return Status.Failure;
			}
			DialogueTree.RequestMultipleChoices(new MultipleChoiceRequestInfo(base.finalActor, dictionary, availableTime, OnOptionSelected)
			{
				showLastStatement = true
			});
			return Status.Running;
		}

		private void OnOptionSelected(int index)
		{
			base.status = Status.Success;
			Action action = delegate
			{
				base.DLGTree.Continue(index);
			};
			if (saySelection)
			{
				LocalizedStatement statement = availableChoices[index].statement;
				DialogueTree.RequestSubtitles(new SubtitlesRequestInfo(base.finalActor, statement, action));
			}
			else
			{
				action();
			}
		}
	}
}
namespace NodeCanvas.Tasks.Conditions
{
	public class CheckCanReleaseSkill : ConditionTask<AICharacterController>
	{
		protected override bool OnCheck()
		{
			if (base.agent == null)
			{
				return false;
			}
			if (!base.agent.hasSkill)
			{
				return false;
			}
			if (!base.agent.skillInstance)
			{
				return false;
			}
			if (Time.time < base.agent.nextReleaseSkillTimeMarker)
			{
				return false;
			}
			if (!base.agent.CharacterMainControl.skillAction.IsSkillHasEnoughStaminaAndCD(base.agent.skillInstance))
			{
				return false;
			}
			if ((bool)base.agent.CharacterMainControl.CurrentAction && base.agent.CharacterMainControl.CurrentAction.Running)
			{
				return false;
			}
			base.agent.nextReleaseSkillTimeMarker = Time.time + UnityEngine.Random.Range(base.agent.skillCoolTimeRange.x, base.agent.skillCoolTimeRange.y);
			if (UnityEngine.Random.Range(0f, 1f) > base.agent.skillSuccessChance)
			{
				return false;
			}
			return true;
		}
	}
	public class CheckHeathLessThan : ConditionTask<AICharacterController>
	{
		public float percent;

		private float checkTimeMarker = -1f;

		public float checkTimeSpace = 1.5f;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnEnable()
		{
		}

		protected override void OnDisable()
		{
		}

		protected override bool OnCheck()
		{
			if (Time.time - checkTimeMarker < checkTimeSpace)
			{
				return false;
			}
			checkTimeMarker = Time.time;
			if (!base.agent || !base.agent.CharacterMainControl)
			{
				return false;
			}
			Health health = base.agent.CharacterMainControl.Health;
			if (!health)
			{
				return false;
			}
			return health.CurrentHealth / health.MaxHealth <= percent;
		}
	}
	public class CheckHoldGun : ConditionTask<AICharacterController>
	{
		protected override string OnInit()
		{
			return null;
		}

		protected override void OnEnable()
		{
		}

		protected override void OnDisable()
		{
		}

		protected override bool OnCheck()
		{
			return base.agent.CharacterMainControl.GetGun() != null;
		}
	}
	public class CheckHurt : ConditionTask<AICharacterController>
	{
		public float hurtTimeThreshold = 0.2f;

		public int damageThreshold = 3;

		public BBParameter<DamageReceiver> cacheFromCharacterDmgReceiver;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnEnable()
		{
		}

		protected override void OnDisable()
		{
		}

		protected override bool OnCheck()
		{
			if (base.agent == null || cacheFromCharacterDmgReceiver == null)
			{
				return false;
			}
			bool result = false;
			DamageInfo dmgInfo = default(DamageInfo);
			if (base.agent.IsHurt(hurtTimeThreshold, damageThreshold, ref dmgInfo))
			{
				cacheFromCharacterDmgReceiver.value = dmgInfo.fromCharacter.mainDamageReceiver;
				result = true;
			}
			return result;
		}
	}
	public class CheckNoticed : ConditionTask<AICharacterController>
	{
		public float noticedTimeThreshold = 0.2f;

		public bool resetNotice;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnEnable()
		{
		}

		protected override void OnDisable()
		{
		}

		protected override bool OnCheck()
		{
			bool result = base.agent.isNoticing(noticedTimeThreshold);
			if (resetNotice)
			{
				base.agent.noticed = false;
			}
			return result;
		}
	}
	public class CheckReloading : ConditionTask<AICharacterController>
	{
		protected override bool OnCheck()
		{
			if (base.agent == null)
			{
				return false;
			}
			if (base.agent.CharacterMainControl == null)
			{
				return false;
			}
			return base.agent.CharacterMainControl.reloadAction.Running;
		}
	}
	public class CheckTargetDistance : ConditionTask<AICharacterController>
	{
		public bool useTransform;

		[ParadoxNotion.Design.ShowIf("useTransform", 1)]
		public BBParameter<Transform> targetTransform;

		[ParadoxNotion.Design.ShowIf("useTransform", 0)]
		public BBParameter<Vector3> targetPoint;

		public bool useShootRange;

		[ParadoxNotion.Design.ShowIf("useShootRange", 1)]
		public BBParameter<float> shootRangeMultiplier = 1f;

		[ParadoxNotion.Design.ShowIf("useShootRange", 0)]
		public BBParameter<float> distance;

		protected override string info => "is target in range";

		protected override bool OnCheck()
		{
			if (useTransform && targetTransform.value == null)
			{
				return false;
			}
			Vector3 b = (useTransform ? targetTransform.value.position : targetPoint.value);
			float num = 0f;
			num = ((!useShootRange) ? distance.value : (base.agent.CharacterMainControl.GetAimRange() * shootRangeMultiplier.value));
			return Vector3.Distance(base.agent.transform.position, b) <= num;
		}
	}
	public class HasObsticleToTarget : ConditionTask<AICharacterController>
	{
		public float hurtTimeThreshold = 0.2f;

		public int damageThreshold = 3;

		public BBParameter<DamageReceiver> cacheFromCharacterDmgReceiver;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnEnable()
		{
		}

		protected override void OnDisable()
		{
		}

		protected override bool OnCheck()
		{
			return base.agent.hasObsticleToTarget;
		}
	}
}
namespace NodeCanvas.Tasks.Actions
{
	public class AimToPlayer : ActionTask<AICharacterController>
	{
		private CharacterMainControl target;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
		}

		protected override void OnUpdate()
		{
			if (!target)
			{
				target = CharacterMainControl.Main;
			}
			base.agent.CharacterMainControl.SetAimPoint(target.transform.position);
		}
	}
	public class Attack : ActionTask<AICharacterController>
	{
		protected override string info => $"Attack";

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			base.agent.CharacterMainControl.Attack();
			EndAction(success: true);
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class CheckObsticle : ActionTask<AICharacterController>
	{
		public bool useTransform;

		[ParadoxNotion.Design.ShowIf("useTransform", 1)]
		public BBParameter<Transform> targetTransform;

		[ParadoxNotion.Design.ShowIf("useTransform", 0)]
		public BBParameter<Vector3> targetPoint;

		public bool alwaysSuccess;

		private bool waitingResult;

		private bool isHurtSearch;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			isHurtSearch = false;
			DamageInfo dmgInfo = default(DamageInfo);
			if (base.agent.IsHurt(1.5f, 1, ref dmgInfo) && (bool)dmgInfo.fromCharacter && (bool)dmgInfo.fromCharacter.mainDamageReceiver)
			{
				isHurtSearch = true;
			}
		}

		private void Check()
		{
			waitingResult = true;
			Vector3 end = (useTransform ? targetTransform.value.position : targetPoint.value);
			end += Vector3.up * 0.4f;
			Vector3 start = base.agent.transform.position + Vector3.up * 0.4f;
			ItemAgent_Gun gun = base.agent.CharacterMainControl.GetGun();
			if ((bool)gun && (bool)gun.muzzle)
			{
				start = gun.muzzle.position - gun.muzzle.forward * 0.1f;
			}
			LevelManager.Instance.AIMainBrain.AddCheckObsticleTask(start, end, base.agent.CharacterMainControl.ThermalOn, isHurtSearch, OnCheckFinished);
		}

		private void OnCheckFinished(bool result)
		{
			if (!(base.agent.gameObject == null))
			{
				base.agent.hasObsticleToTarget = result;
				waitingResult = false;
				if (base.isRunning)
				{
					EndAction(alwaysSuccess || result);
				}
			}
		}

		protected override void OnUpdate()
		{
			if (!waitingResult)
			{
				Check();
			}
		}

		protected override void OnStop()
		{
			waitingResult = false;
		}

		protected override void OnPause()
		{
		}
	}
	public class Dash : ActionTask<AICharacterController>
	{
		public enum DashDirectionModes
		{
			random,
			targetTransform
		}

		public DashDirectionModes directionMode;

		[ParadoxNotion.Design.ShowIf("directionMode", 1)]
		public BBParameter<Transform> targetTransform;

		[ParadoxNotion.Design.ShowIf("directionMode", 1)]
		public bool verticle;

		public BBParameter<Vector2> dashTimeSpaceRange;

		private float dashTimeSpace;

		private float lastDashTime = -999f;

		protected override string info => $"Dash";

		protected override string OnInit()
		{
			dashTimeSpace = UnityEngine.Random.Range(dashTimeSpaceRange.value.x, dashTimeSpaceRange.value.y);
			return null;
		}

		protected override void OnExecute()
		{
			if (Time.time - lastDashTime < dashTimeSpace)
			{
				EndAction();
				return;
			}
			lastDashTime = Time.time;
			dashTimeSpace = UnityEngine.Random.Range(dashTimeSpaceRange.value.x, dashTimeSpaceRange.value.y);
			Vector3 vector = Vector3.forward;
			switch (directionMode)
			{
			case DashDirectionModes.random:
				vector = UnityEngine.Random.insideUnitCircle;
				vector.z = vector.y;
				vector.y = 0f;
				vector.Normalize();
				break;
			case DashDirectionModes.targetTransform:
				if (targetTransform.value == null)
				{
					EndAction();
					return;
				}
				vector = targetTransform.value.position - base.agent.transform.position;
				vector.y = 0f;
				vector.Normalize();
				if (verticle)
				{
					vector = Vector3.Cross(vector, Vector3.up) * ((UnityEngine.Random.Range(0f, 1f) > 0.5f) ? 1f : (-1f));
				}
				break;
			}
			base.agent.CharacterMainControl.SetMoveInput(vector);
			base.agent.CharacterMainControl.Dash();
			EndAction(success: true);
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class FindMainCharacter : ActionTask<AICharacterController>
	{
		public BBParameter<CharacterMainControl> mainCharacter;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			if (!(LevelManager.Instance == null))
			{
				mainCharacter.value = LevelManager.Instance.MainCharacter;
				if (mainCharacter.value != null)
				{
					EndAction(success: true);
				}
			}
		}

		protected override void OnUpdate()
		{
			if (!(LevelManager.Instance == null))
			{
				mainCharacter.value = LevelManager.Instance.MainCharacter;
				if (mainCharacter.value != null)
				{
					EndAction(success: true);
				}
			}
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class MoveToRandomPos : ActionTask<AICharacterController>
	{
		public bool useTransform;

		public bool setAimToPos;

		[ParadoxNotion.Design.ShowIf("setAimToPos", 1)]
		public BBParameter<Vector3> aimPos;

		[ParadoxNotion.Design.ShowIf("useTransform", 0)]
		public BBParameter<Vector3> centerPos;

		[ParadoxNotion.Design.ShowIf("useTransform", 1)]
		public BBParameter<Transform> centerTransform;

		public BBParameter<float> radius;

		public BBParameter<float> avoidRadius;

		public float randomAngle = 360f;

		public BBParameter<float> overTime = 8f;

		public bool overTimeReturnSuccess = true;

		private Vector3 targetPoint;

		public bool failIfNoPath;

		[ParadoxNotion.Design.ShowIf("failIfNoPath", 0)]
		public bool retryIfNotFound;

		public bool syncDirectionIfNoAimTarget = true;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			if (base.agent == null)
			{
				EndAction(success: false);
				return;
			}
			targetPoint = RandomPoint();
			base.agent.MoveToPos(targetPoint);
		}

		protected override void OnUpdate()
		{
			if (base.agent == null)
			{
				EndAction(success: false);
				return;
			}
			if (base.elapsedTime > overTime.value)
			{
				EndAction(overTimeReturnSuccess);
				return;
			}
			if (useTransform && centerTransform.value == null)
			{
				EndAction(success: false);
				return;
			}
			if (syncDirectionIfNoAimTarget && base.agent.aimTarget == null)
			{
				if (setAimToPos && aimPos.isDefined)
				{
					base.agent.CharacterMainControl.SetAimPoint(aimPos.value);
				}
				else
				{
					Vector3 currentMoveDirection = base.agent.CharacterMainControl.CurrentMoveDirection;
					if (currentMoveDirection.magnitude > 0f)
					{
						base.agent.CharacterMainControl.SetAimPoint(base.agent.CharacterMainControl.transform.position + currentMoveDirection * 1000f);
					}
				}
			}
			if (base.agent.WaitingForPathResult())
			{
				return;
			}
			if (base.agent.ReachedEndOfPath() || !base.agent.IsMoving())
			{
				EndAction(success: true);
			}
			else if (!base.agent.HasPath())
			{
				if (!failIfNoPath && retryIfNotFound)
				{
					targetPoint = RandomPoint();
					base.agent.MoveToPos(targetPoint);
				}
				else
				{
					EndAction(!failIfNoPath);
				}
			}
		}

		protected override void OnStop()
		{
			base.agent.StopMove();
		}

		protected override void OnPause()
		{
		}

		private Vector3 RandomPoint()
		{
			Vector3 vector = base.agent.CharacterMainControl.transform.position;
			if (useTransform)
			{
				if (centerTransform.isDefined)
				{
					vector = centerTransform.value.position;
				}
			}
			else
			{
				vector = centerPos.value;
			}
			Vector3 vector2 = vector - base.agent.transform.position;
			vector2.y = 0f;
			if (vector2.magnitude < 0.1f)
			{
				vector2 = UnityEngine.Random.insideUnitSphere;
				vector2.y = 0f;
			}
			vector2 = vector2.normalized;
			float y = UnityEngine.Random.Range(-0.5f * randomAngle, 0.5f * randomAngle);
			float num = UnityEngine.Random.Range(avoidRadius.value, radius.value);
			vector2 = Quaternion.Euler(0f, y, 0f) * -vector2;
			return vector + vector2 * num;
		}
	}
	public class PickupSearchedItem : ActionTask<AICharacterController>
	{
		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			if (base.agent == null || base.agent.CharacterMainControl == null || base.agent.searchedPickup == null)
			{
				EndAction(success: false);
			}
			else if (Vector3.Distance(base.agent.transform.position, base.agent.searchedPickup.transform.position) > 1.5f)
			{
				EndAction(success: false);
			}
			else if (base.agent.searchedPickup.ItemAgent != null)
			{
				base.agent.CharacterMainControl.PickupItem(base.agent.searchedPickup.ItemAgent.Item);
			}
		}

		protected override void OnUpdate()
		{
		}
	}
	public class PopText : ActionTask<AICharacterController>
	{
		public BBParameter<string> content;

		public bool checkHide;

		private string Key => content.value;

		private string DisplayText => Key.ToPlainText();

		protected override string info => $"Pop:'{DisplayText}'";

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			if (checkHide && base.agent.CharacterMainControl.Hidden)
			{
				EndAction(success: true);
				return;
			}
			if (!base.agent.canTalk)
			{
				EndAction(success: true);
				return;
			}
			base.agent.CharacterMainControl.PopText(DisplayText);
			EndAction(success: true);
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class PostSound : ActionTask<AICharacterController>
	{
		public enum VoiceSounds
		{
			normal,
			surprise,
			death
		}

		public VoiceSounds voiceSound;

		protected override string info => $"Post Sound: {voiceSound.ToString()} ";

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			if ((bool)base.agent && (bool)base.agent.CharacterMainControl)
			{
				if (!base.agent.canTalk)
				{
					EndAction(success: true);
					return;
				}
				GameObject gameObject = base.agent.CharacterMainControl.gameObject;
				switch (voiceSound)
				{
				case VoiceSounds.normal:
					AudioManager.PostQuak("normal", base.agent.CharacterMainControl.AudioVoiceType, gameObject);
					break;
				case VoiceSounds.surprise:
					AudioManager.PostQuak("surprise", base.agent.CharacterMainControl.AudioVoiceType, gameObject);
					break;
				case VoiceSounds.death:
					AudioManager.PostQuak("death", base.agent.CharacterMainControl.AudioVoiceType, gameObject);
					break;
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
			EndAction(success: true);
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class ReleaseItemSkillIfHas : ActionTask<AICharacterController>
	{
		public bool random = true;

		private float checkTimeMarker = -1f;

		private float readyTime;

		private ItemSetting_Skill skillRefrence;

		private float chance
		{
			get
			{
				if (!base.agent)
				{
					return 0f;
				}
				return base.agent.itemSkillChance;
			}
		}

		public float checkTimeSpace
		{
			get
			{
				if (!base.agent)
				{
					return 999f;
				}
				return base.agent.itemSkillCoolTime;
			}
		}

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			skillRefrence = null;
			if (Time.time - checkTimeMarker < checkTimeSpace)
			{
				EndAction(success: false);
				return;
			}
			checkTimeMarker = Time.time;
			if (UnityEngine.Random.Range(0f, 1f) > chance)
			{
				EndAction(success: false);
				return;
			}
			ItemSetting_Skill itemSkill = base.agent.GetItemSkill(random);
			if (!itemSkill)
			{
				EndAction(success: false);
				return;
			}
			if ((bool)base.agent.CharacterMainControl.CurrentAction && base.agent.CharacterMainControl.CurrentAction.Running)
			{
				EndAction(success: false);
				return;
			}
			skillRefrence = itemSkill;
			base.agent.CharacterMainControl.ChangeHoldItem(itemSkill.Item);
			base.agent.CharacterMainControl.SetSkill(SkillTypes.itemSkill, itemSkill.Skill, itemSkill.gameObject);
			if (!base.agent.CharacterMainControl.StartSkillAim(SkillTypes.itemSkill))
			{
				EndAction(success: false);
			}
			else
			{
				readyTime = itemSkill.Skill.SkillContext.skillReadyTime;
			}
		}

		protected override void OnUpdate()
		{
			if (!skillRefrence)
			{
				EndAction(success: false);
				return;
			}
			if ((bool)base.agent.searchedEnemy)
			{
				base.agent.CharacterMainControl.SetAimPoint(base.agent.searchedEnemy.transform.position);
			}
			if (base.elapsedTime > readyTime + 0.1f)
			{
				base.agent.CharacterMainControl.ReleaseSkill(SkillTypes.itemSkill);
				EndAction(success: true);
			}
		}

		protected override void OnStop()
		{
			base.agent.CharacterMainControl.CancleSkill();
			base.agent.CharacterMainControl.SwitchToFirstAvailableWeapon();
		}
	}
	public class ReleaseSkill : ActionTask<AICharacterController>
	{
		private float readyTime;

		private float tryReleaseSkillTimeMarker = -1f;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			base.agent.CharacterMainControl.SetSkill(SkillTypes.characterSkill, base.agent.skillInstance, base.agent.skillInstance.gameObject);
			if (!base.agent.CharacterMainControl.StartSkillAim(SkillTypes.characterSkill))
			{
				EndAction(success: false);
			}
			else
			{
				readyTime = base.agent.skillInstance.SkillContext.skillReadyTime;
			}
		}

		protected override void OnUpdate()
		{
			if ((bool)base.agent.searchedEnemy)
			{
				base.agent.CharacterMainControl.SetAimPoint(base.agent.searchedEnemy.transform.position);
			}
			if (base.elapsedTime > readyTime + 0.1f)
			{
				if (UnityEngine.Random.Range(0f, 1f) < base.agent.skillSuccessChance)
				{
					base.agent.CharacterMainControl.ReleaseSkill(SkillTypes.characterSkill);
					EndAction(success: true);
				}
				else
				{
					base.agent.CharacterMainControl.CancleSkill();
					EndAction(success: false);
				}
			}
		}

		protected override void OnStop()
		{
			base.agent.CharacterMainControl.CancleSkill();
			base.agent.CharacterMainControl.SwitchToFirstAvailableWeapon();
		}
	}
	public class RotateAim : ActionTask<AICharacterController>
	{
		private Vector3 startDir;

		public float angle;

		private float currentAngle;

		public BBParameter<Vector2> timeRange;

		private float time;

		public bool shoot;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			time = UnityEngine.Random.Range(timeRange.value.x, timeRange.value.y);
			startDir = base.agent.CharacterMainControl.CurrentAimDirection;
			base.agent.SetTarget(null);
			if (shoot)
			{
				base.agent.CharacterMainControl.Trigger(trigger: true, triggerThisFrame: true, releaseThisFrame: false);
			}
		}

		protected override void OnUpdate()
		{
			currentAngle = angle * base.elapsedTime / time;
			Vector3 vector = Quaternion.Euler(0f, currentAngle, 0f) * startDir;
			base.agent.CharacterMainControl.SetAimPoint(base.agent.CharacterMainControl.transform.position + vector * 100f);
			if (shoot)
			{
				base.agent.CharacterMainControl.Trigger(trigger: true, triggerThisFrame: true, releaseThisFrame: false);
			}
			if (base.elapsedTime > time)
			{
				EndAction(success: true);
			}
		}

		protected override void OnStop()
		{
			base.agent.CharacterMainControl.Trigger(trigger: false, triggerThisFrame: false, releaseThisFrame: false);
		}

		protected override void OnPause()
		{
			base.agent.CharacterMainControl.Trigger(trigger: false, triggerThisFrame: false, releaseThisFrame: false);
		}
	}
	public class SearchEnemyAround : ActionTask<AICharacterController>
	{
		public bool useSight;

		public bool affactByNightVisionAbility;

		[ParadoxNotion.Design.ShowIf("useSight", 0)]
		public BBParameter<float> searchAngle = 180f;

		[ParadoxNotion.Design.ShowIf("useSight", 0)]
		public BBParameter<float> searchDistance;

		[ParadoxNotion.Design.ShowIf("useSight", 1)]
		public BBParameter<float> sightDistanceMultiplier = 1f;

		[ParadoxNotion.Design.ShowIf("useSight", 0)]
		public bool checkObsticle = true;

		public BBParameter<DamageReceiver> result;

		public BBParameter<InteractablePickup> pickupResult;

		public bool searchPickup;

		public bool alwaysSuccess;

		public bool setNullIfNotFound;

		private bool waitingSearchResult;

		private float searchStartTimeMarker;

		private bool isHurtSearch;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			DamageInfo dmgInfo = default(DamageInfo);
			isHurtSearch = false;
			if (base.agent.IsHurt(1.5f, 1, ref dmgInfo) && (bool)dmgInfo.fromCharacter && (bool)dmgInfo.fromCharacter.mainDamageReceiver)
			{
				isHurtSearch = true;
			}
		}

		private void Search()
		{
			waitingSearchResult = true;
			float num = (useSight ? base.agent.sightAngle : searchAngle.value);
			float num2 = (useSight ? (base.agent.sightDistance * sightDistanceMultiplier.value) : searchDistance.value);
			if (isHurtSearch)
			{
				num2 *= 2f;
			}
			if (affactByNightVisionAbility && (bool)base.agent.CharacterMainControl)
			{
				float nightVisionAbility = base.agent.CharacterMainControl.NightVisionAbility;
				num *= Mathf.Lerp(TimeOfDayController.NightViewAngleFactor, 1f, nightVisionAbility);
			}
			bool flag = useSight || checkObsticle;
			searchStartTimeMarker = Time.time;
			bool thermalOn = base.agent.CharacterMainControl.ThermalOn;
			LevelManager.Instance.AIMainBrain.AddSearchTask(base.agent.transform.position + Vector3.up * 1.5f, base.agent.CharacterMainControl.CurrentAimDirection, num, num2, base.agent.CharacterMainControl.Team, flag, thermalOn, isHurtSearch, searchPickup ? base.agent.wantItem : (-1), OnSearchFinished);
		}

		private void OnSearchFinished(DamageReceiver dmgReceiver, InteractablePickup pickup)
		{
			if (!(base.agent.gameObject == null))
			{
				_ = Time.time;
				_ = searchStartTimeMarker;
				if (dmgReceiver != null)
				{
					result.value = dmgReceiver;
				}
				else if (setNullIfNotFound)
				{
					result.value = null;
				}
				if (pickup != null)
				{
					pickupResult.value = pickup;
				}
				waitingSearchResult = false;
				if (base.isRunning)
				{
					EndAction(alwaysSuccess || result.value != null || pickupResult != null);
				}
			}
		}

		protected override void OnUpdate()
		{
			if (!waitingSearchResult)
			{
				Search();
			}
		}

		protected override void OnStop()
		{
			waitingSearchResult = false;
		}

		protected override void OnPause()
		{
		}
	}
	public class SetAim : ActionTask<AICharacterController>
	{
		public bool useTransfom = true;

		[ParadoxNotion.Design.ShowIf("useTransfom", 1)]
		public BBParameter<Transform> aimTarget;

		[ParadoxNotion.Design.ShowIf("useTransfom", 0)]
		public BBParameter<Vector3> aimPos;

		private bool waitingSearchResult;

		protected override string info
		{
			get
			{
				if (useTransfom && string.IsNullOrEmpty(aimTarget.name))
				{
					return "Set aim to null";
				}
				if (!useTransfom)
				{
					return "Set aim to " + aimPos.name;
				}
				return "Set aim to " + aimTarget.name;
			}
		}

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			base.agent.SetTarget(aimTarget.value);
			if (!useTransfom || !(aimTarget.value != null))
			{
				if (!useTransfom)
				{
					base.agent.SetAimInput((aimPos.value - base.agent.transform.position).normalized, AimTypes.normalAim);
				}
				else
				{
					base.agent.SetAimInput(Vector3.zero, AimTypes.normalAim);
				}
			}
			EndAction(success: true);
		}

		protected override void OnUpdate()
		{
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class SetNoticedToTarget : ActionTask<AICharacterController>
	{
		public BBParameter<DamageReceiver> target;

		protected override string info => "set noticed to";

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			base.agent.SetNoticedToTarget(target.value);
			EndAction(success: true);
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class SetRun : ActionTask<AICharacterController>
	{
		public BBParameter<bool> run;

		protected override string info => $"SetRun:{run.value}";

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			base.agent.CharacterMainControl.SetRunInput(run.value);
			EndAction(success: true);
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class Shoot : ActionTask<AICharacterController>
	{
		public BBParameter<Vector2> shootTimeRange;

		private float shootTime;

		public float semiTimeSpace = 0.35f;

		private float semiTimer;

		protected override string info => $"Shoot {shootTimeRange.value.x}to{shootTimeRange.value.y} sec.";

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			semiTimer = semiTimeSpace;
			base.agent.CharacterMainControl.Trigger(trigger: true, triggerThisFrame: true, releaseThisFrame: false);
			if (!base.agent.shootCanMove)
			{
				base.agent.StopMove();
			}
			shootTime = UnityEngine.Random.Range(shootTimeRange.value.x, shootTimeRange.value.y);
			if (shootTime <= 0f)
			{
				EndAction(success: true);
			}
		}

		protected override void OnUpdate()
		{
			bool triggerThisFrame = false;
			semiTimer += Time.deltaTime;
			if (!base.agent.shootCanMove)
			{
				base.agent.StopMove();
			}
			if (semiTimer >= semiTimeSpace)
			{
				semiTimer = 0f;
				triggerThisFrame = true;
			}
			base.agent.CharacterMainControl.Trigger(trigger: true, triggerThisFrame, releaseThisFrame: false);
			if (base.elapsedTime >= shootTime)
			{
				EndAction(success: true);
			}
		}

		protected override void OnStop()
		{
			base.agent.CharacterMainControl.Trigger(trigger: false, triggerThisFrame: false, releaseThisFrame: false);
		}

		protected override void OnPause()
		{
			base.agent.CharacterMainControl.Trigger(trigger: false, triggerThisFrame: false, releaseThisFrame: false);
		}
	}
	public class SpawnAlertFx : ActionTask<AICharacterController>
	{
		public BBParameter<float> alertTime = 0.2f;

		protected override string info => $"AlertFx";

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			if (!base.agent || !base.agent.CharacterMainControl)
			{
				EndAction(success: true);
			}
			Transform rightHandSocket = base.agent.CharacterMainControl.RightHandSocket;
			if (!rightHandSocket)
			{
				EndAction(success: true);
			}
			UnityEngine.Object.Instantiate(GameplayDataSettings.Prefabs.AlertFxPrefab, rightHandSocket).transform.localPosition = Vector3.zero;
			if (alertTime.value <= 0f)
			{
				EndAction(success: true);
			}
		}

		protected override void OnUpdate()
		{
			if (base.elapsedTime >= alertTime.value)
			{
				EndAction(success: true);
			}
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class StopMoving : ActionTask<AICharacterController>
	{
		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			base.agent.StopMove();
			EndAction(success: true);
		}
	}
	public class TraceTarget : ActionTask<AICharacterController>
	{
		public bool traceTargetTransform = true;

		[ParadoxNotion.Design.ShowIf("traceTargetTransform", 0)]
		public BBParameter<Vector3> centerPosition;

		[ParadoxNotion.Design.ShowIf("traceTargetTransform", 1)]
		public BBParameter<Transform> centerTransform;

		public BBParameter<float> stopDistance;

		public BBParameter<float> overTime = 8f;

		public bool overTimeReturnSuccess = true;

		private Vector3 targetPoint;

		public bool failIfNoPath;

		[ParadoxNotion.Design.ShowIf("failIfNoPath", 0)]
		public bool retryIfNotFound;

		private float recalculatePathTimeSpace = 0.15f;

		private float recalculatePathTimer = 0.15f;

		public bool syncDirectionIfNoAimTarget = true;

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			if (base.agent == null || (traceTargetTransform && centerTransform.value == null))
			{
				EndAction(success: false);
				return;
			}
			Vector3 pos = (traceTargetTransform ? centerTransform.value.position : centerPosition.value);
			base.agent.MoveToPos(pos);
		}

		protected override void OnUpdate()
		{
			if (base.agent == null)
			{
				EndAction(success: false);
				return;
			}
			Vector3 vector = ((traceTargetTransform && centerTransform.value != null) ? centerTransform.value.position : centerPosition.value);
			if (base.elapsedTime > overTime.value)
			{
				EndAction(overTimeReturnSuccess);
				return;
			}
			if (Vector3.Distance(vector, base.agent.transform.position) < stopDistance.value)
			{
				EndAction(success: true);
				return;
			}
			recalculatePathTimer -= Time.deltaTime;
			if (recalculatePathTimer <= 0f)
			{
				recalculatePathTimer = recalculatePathTimeSpace;
				base.agent.MoveToPos(vector);
			}
			else if (!base.agent.WaitingForPathResult())
			{
				if (!base.agent.IsMoving() || base.agent.ReachedEndOfPath())
				{
					EndAction(success: true);
					return;
				}
				if (!base.agent.HasPath())
				{
					if (!failIfNoPath && retryIfNotFound)
					{
						base.agent.MoveToPos(vector);
					}
					else
					{
						EndAction(!failIfNoPath);
					}
					return;
				}
			}
			if (syncDirectionIfNoAimTarget && base.agent.aimTarget == null)
			{
				Vector3 currentMoveDirection = base.agent.CharacterMainControl.CurrentMoveDirection;
				if (currentMoveDirection.magnitude > 0f)
				{
					base.agent.CharacterMainControl.SetAimPoint(base.agent.CharacterMainControl.transform.position + currentMoveDirection * 1000f);
				}
			}
		}

		protected override void OnStop()
		{
			base.agent.StopMove();
		}

		protected override void OnPause()
		{
		}
	}
	public class TryToReloadIfEmpty : ActionTask<AICharacterController>
	{
		public string poptextWhileReloading = "PopText_Reloading";

		public bool postSound;

		private bool isFirstTime = true;

		public string SoundKey => "normal";

		private string Key => poptextWhileReloading;

		private string DisplayText => poptextWhileReloading.ToPlainText();

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			ItemAgent_Gun gun = base.agent.CharacterMainControl.GetGun();
			if (gun == null)
			{
				EndAction(success: true);
				return;
			}
			if (gun.BulletCount <= 0)
			{
				base.agent.CharacterMainControl.TryToReload();
				if (!isFirstTime)
				{
					if (!base.agent.CharacterMainControl.Health.Hidden && poptextWhileReloading != string.Empty && base.agent.canTalk)
					{
						base.agent.CharacterMainControl.PopText(poptextWhileReloading.ToPlainText());
					}
					if (postSound && SoundKey != string.Empty && (bool)base.agent && (bool)base.agent.CharacterMainControl)
					{
						AudioManager.PostQuak(SoundKey, base.agent.CharacterMainControl.AudioVoiceType, base.agent.CharacterMainControl.gameObject);
					}
				}
			}
			isFirstTime = false;
			EndAction(success: true);
		}

		protected override void OnUpdate()
		{
		}

		protected override void OnStop()
		{
		}

		protected override void OnPause()
		{
		}
	}
	public class UseDrug : ActionTask<AICharacterController>
	{
		public bool stopMove;

		protected override string info
		{
			get
			{
				if (!stopMove)
				{
					return "打药";
				}
				return "原地打药";
			}
		}

		protected override string OnInit()
		{
			return null;
		}

		protected override void OnExecute()
		{
			Item drugItem = base.agent.GetDrugItem();
			if (drugItem == null)
			{
				EndAction(success: false);
			}
			else
			{
				base.agent.CharacterMainControl.UseItem(drugItem);
			}
		}

		protected override void OnUpdate()
		{
			if (stopMove && base.agent.IsMoving())
			{
				base.agent.StopMove();
			}
			if (!base.agent || !base.agent.CharacterMainControl)
			{
				EndAction(success: false);
			}
			else if (!base.agent.CharacterMainControl.useItemAction.Running)
			{
				EndAction(success: true);
			}
		}

		protected override void OnStop()
		{
			base.agent.CharacterMainControl.SwitchToFirstAvailableWeapon();
		}
	}
}
namespace SodaCraft
{
	[Serializable]
	[VolumeComponentMenu("SodaCraft/SunFogTD")]
	public class SunFogTD : VolumeComponent, IPostProcessComponent
	{
		public BoolParameter enable = new BoolParameter(value: false);

		public ColorParameter fogColor = new ColorParameter(new Color(0.68718916f, 1.070217f, 1.3615336f, 0f), hdr: true, showAlpha: true, showEyeDropper: false);

		public ColorParameter sunColor = new ColorParameter(new Color(4.061477f, 2.5092788f, 1.7816858f, 0f), hdr: true, showAlpha: true, showEyeDropper: false);

		public FloatRangeParameter clipPlanes = new FloatRangeParameter(new Vector2(41f, 72f), 0.3f, 1000f);

		public Vector2Parameter sunPoint = new Vector2Parameter(new Vector2(-2.63f, 1.23f));

		public FloatParameter sunSize = new ClampedFloatParameter(1.85f, 0f, 10f);

		public ClampedFloatParameter sunPower = new ClampedFloatParameter(1f, 0.1f, 10f);

		public ClampedFloatParameter sunAlphaGain = new ClampedFloatParameter(0.001f, 0f, 0.25f);

		private int fogColorHash = Shader.PropertyToID("SunFogColor");

		private int sunColorHash = Shader.PropertyToID("SunFogSunColor");

		private int nearDistanceHash = Shader.PropertyToID("SunFogNearDistance");

		private int farDistanceHash = Shader.PropertyToID("SunFogFarDistance");

		private int sunPointHash = Shader.PropertyToID("SunFogSunPoint");

		private int sunSizeHash = Shader.PropertyToID("SunFogSunSize");

		private int sunPowerHash = Shader.PropertyToID("SunFogSunPower");

		private int sunAlphaGainHash = Shader.PropertyToID("SunFogSunAplhaGain");

		public bool IsActive()
		{
			return enable.value;
		}

		public bool IsTileCompatible()
		{
			return false;
		}

		public override void Override(VolumeComponent state, float interpFactor)
		{
			SunFogTD sunFogTD = state as SunFogTD;
			base.Override(state, interpFactor);
			Shader.SetGlobalColor(fogColorHash, sunFogTD.fogColor.value);
			Shader.SetGlobalColor(sunColorHash, sunFogTD.sunColor.value);
			Shader.SetGlobalFloat(nearDistanceHash, sunFogTD.clipPlanes.value.x);
			Shader.SetGlobalFloat(farDistanceHash, sunFogTD.clipPlanes.value.y);
			Shader.SetGlobalFloat(sunSizeHash, sunFogTD.sunSize.value);
			Shader.SetGlobalFloat(sunPowerHash, sunFogTD.sunPower.value);
			Shader.SetGlobalVector(sunPointHash, sunFogTD.sunPoint.value);
			Shader.SetGlobalFloat(sunAlphaGainHash, sunFogTD.sunAlphaGain.value);
		}
	}
	[Serializable]
	[VolumeComponentMenu("SodaCraft/CameraArmControl")]
	public class CameraArmControl : VolumeComponent
	{
		public BoolParameter enable = new BoolParameter(value: false);

		public MinFloatParameter pitch = new MinFloatParameter(55f, 0f);

		public FloatParameter yaw = new FloatParameter(-30f);

		public MinFloatParameter distance = new MinFloatParameter(45f, 2f);

		public bool IsActive()
		{
			return enable.value;
		}

		public override void Override(VolumeComponent state, float interpFactor)
		{
			CameraArmControl obj = state as CameraArmControl;
			base.Override(state, interpFactor);
			CameraArm.globalPitch = obj.pitch.value;
			CameraArm.globalYaw = obj.yaw.value;
			CameraArm.globalDistance = obj.distance.value;
		}
	}
	[Serializable]
	[VolumeComponentMenu("SodaCraft/EdgeLight")]
	public class EdgeLight : VolumeComponent, IPostProcessComponent
	{
		public BoolParameter enable = new BoolParameter(value: false);

		public Vector2Parameter direction = new Vector2Parameter(new Vector2(-1f, 1f));

		public ClampedFloatParameter edgeLightWidth = new ClampedFloatParameter(0.001f, 0f, 0.05f);

		public ClampedFloatParameter edgeLightFix = new ClampedFloatParameter(0.001f, 0f, 0.05f);

		public FloatParameter EdgeLightClampDistance = new ClampedFloatParameter(0.001f, 0.001f, 1f);

		public ColorParameter edgeLightColor = new ColorParameter(Color.white, hdr: true, showAlpha: false, showEyeDropper: false);

		public FloatParameter blendScreenColor = new ClampedFloatParameter(1f, 0f, 1f);

		private int edgeLightDirectionHash = Shader.PropertyToID("_EdgeLightDirection");

		private int widthHash = Shader.PropertyToID("_EdgeLightWidth");

		private int colorHash = Shader.PropertyToID("_EdgeLightColor");

		private int fixHash = Shader.PropertyToID("_EdgeLightFix");

		private int clampDistanceHash = Shader.PropertyToID("_EdgeLightClampDistance");

		private int edgeLightBlendScreenColorHash = Shader.PropertyToID("_EdgeLightBlendScreenColor");

		public bool IsActive()
		{
			return enable.value;
		}

		public bool IsTileCompatible()
		{
			return false;
		}

		public override void Override(VolumeComponent state, float interpFactor)
		{
			EdgeLight edgeLight = state as EdgeLight;
			base.Override(state, interpFactor);
			Shader.SetGlobalVector(edgeLightDirectionHash, edgeLight.direction.value);
			Shader.SetGlobalFloat(widthHash, edgeLight.edgeLightWidth.value);
			Shader.SetGlobalFloat(fixHash, edgeLight.edgeLightFix.value);
			Shader.SetGlobalFloat(clampDistanceHash, edgeLight.EdgeLightClampDistance.value);
			Shader.SetGlobalColor(colorHash, edgeLight.edgeLightColor.value);
			Shader.SetGlobalFloat(edgeLightBlendScreenColorHash, edgeLight.blendScreenColor.value);
		}
	}
	[Serializable]
	[VolumeComponentMenu("SodaCraft/LightControl")]
	public class LightControl : VolumeComponent, IPostProcessComponent
	{
		public BoolParameter enable = new BoolParameter(value: false);

		public ColorParameter skyColor = new ColorParameter(Color.black, hdr: true, showAlpha: true, showEyeDropper: false);

		public ColorParameter equatorColor = new ColorParameter(Color.black, hdr: true, showAlpha: true, showEyeDropper: false);

		public ColorParameter groundColor = new ColorParameter(Color.black, hdr: true, showAlpha: true, showEyeDropper: false);

		public ColorParameter sunColor = new ColorParameter(Color.white, hdr: true, showAlpha: true, showEyeDropper: false);

		public ColorParameter fowColor = new ColorParameter(Color.white, hdr: true, showAlpha: true, showEyeDropper: false);

		public MinFloatParameter sunIntensity = new MinFloatParameter(1f, 0f);

		public ClampedFloatParameter sunShadowHardness = new ClampedFloatParameter(0.96f, 0f, 1f);

		public Vector3Parameter sunRotation = new Vector3Parameter(new Vector3(59f, 168f, 0f));

		public ColorParameter SodaLightTint = new ColorParameter(Color.white, hdr: true, showAlpha: true, showEyeDropper: false);

		private int SodaPointLight_EnviromentTintID = Shader.PropertyToID("SodaPointLight_EnviromentTint");

		private int fowColorID = Shader.PropertyToID("_SodaUnknowColor");

		private static Light light;

		private static UmbraSoftShadows lightShadows;

		public bool IsActive()
		{
			return enable.value;
		}

		public bool IsTileCompatible()
		{
			return false;
		}

		public override void Override(VolumeComponent state, float interpFactor)
		{
			LightControl lightControl = state as LightControl;
			base.Override(state, interpFactor);
			RenderSettings.ambientSkyColor = lightControl.skyColor.value;
			RenderSettings.ambientEquatorColor = lightControl.equatorColor.value;
			RenderSettings.ambientGroundColor = lightControl.groundColor.value;
			Shader.SetGlobalColor(fowColorID, lightControl.fowColor.value);
			Shader.SetGlobalColor(SodaPointLight_EnviromentTintID, lightControl.SodaLightTint.value);
			if (!light)
			{
				light = RenderSettings.sun;
			}
			if ((bool)light)
			{
				light.color = lightControl.sunColor.value;
				light.intensity = lightControl.sunIntensity.value;
				light.transform.rotation = Quaternion.Euler(lightControl.sunRotation.value);
				if (!lightShadows)
				{
					lightShadows = light.GetComponent<UmbraSoftShadows>();
				}
				if ((bool)lightShadows)
				{
					float value = lightControl.sunShadowHardness.value;
					lightShadows.profile.contactStrength = value;
				}
			}
		}
	}
	[Serializable]
	[VolumeComponentMenu("SodaCraft/TimeOfDayPost")]
	public class TimeOfDayPost : VolumeComponent, IPostProcessComponent
	{
		public BoolParameter enable = new BoolParameter(value: false);

		public ClampedFloatParameter nightViewAngleFactor = new ClampedFloatParameter(0.2f, 0f, 1f);

		public ClampedFloatParameter nightViewDistanceFactor = new ClampedFloatParameter(0.2f, 0f, 1f);

		public ClampedFloatParameter nightSenseRangeFactor = new ClampedFloatParameter(0.2f, 0f, 1f);

		public bool IsActive()
		{
			return enable.value;
		}

		public bool IsTileCompatible()
		{
			return false;
		}

		public override void Override(VolumeComponent state, float interpFactor)
		{
			TimeOfDayPost timeOfDayPost = state as TimeOfDayPost;
			base.Override(state, interpFactor);
			if (!(timeOfDayPost == null))
			{
				TimeOfDayController.NightViewAngleFactor = timeOfDayPost.nightViewAngleFactor.value;
				TimeOfDayController.NightViewDistanceFactor = timeOfDayPost.nightViewDistanceFactor.value;
				TimeOfDayController.NightSenseRangeFactor = timeOfDayPost.nightSenseRangeFactor.value;
			}
		}
	}
}
